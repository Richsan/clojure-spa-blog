["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hastscript/lib/core.js"],"~:js","shadow$provide.module$node_modules$hastscript$lib$core=function(global,require,module,exports){function addChild(nodes,value){let index=-1;if(void 0!==value&&null!==value)if(\"string\"===typeof value||\"number\"===typeof value)nodes.push({type:\"text\",value:String(value)});else if(Array.isArray(value))for(;++index<value.length;)addChild(nodes,value[index]);else if(\"object\"===typeof value&&\"type\"in value)\"root\"===value.type?addChild(nodes,value.children):nodes.push(value);else throw Error(\"Expected node, nodes, or string, got `\"+\nvalue+\"`\");}function parsePrimitive(info,name,value){if(\"string\"===typeof value){if(info.number&&value&&!Number.isNaN(Number(value)))return Number(value);if((info.boolean||info.overloadedBoolean)&&(\"\"===value||(0,_propertyInformation.normalize)(value)===(0,_propertyInformation.normalize)(name)))return!0}return value}function createAdjustMap(values){const result={};let index=-1;for(;++index<values.length;)result[values[index].toLowerCase()]=values[index];return result}Object.defineProperty(exports,\n\"__esModule\",{value:!0});exports.core=function(schema,defaultTagName,caseSensitive){const adjust=caseSensitive&&createAdjustMap(caseSensitive);return function(selector,properties,...children){let index$jscomp$0=-1;if(void 0===selector||null===selector)selector={type:\"root\",children:[]},children.unshift(properties);else{selector=(0,_hastUtilParseSelector.parseSelector)(selector,defaultTagName);selector.tagName=selector.tagName.toLowerCase();adjust&&own.call(adjust,selector.tagName)&&(selector.tagName=\nadjust[selector.tagName]);var name=selector.tagName;if(null===properties||void 0===properties||\"object\"!==typeof properties||Array.isArray(properties)?0:\"input\"!==name&&properties.type&&\"string\"===typeof properties.type?\"children\"in properties&&Array.isArray(properties.children)?0:\"button\"===name?buttonTypes.has(properties.type.toLowerCase()):!(\"value\"in properties):1){let key;for(key in properties)if(own.call(properties,key))a:{var result$jscomp$0=void 0;name=selector.properties;var value=properties[key];\nconst info=(0,_propertyInformation.find)(schema,key);let index=-1;if(void 0!==value&&null!==value){if(\"number\"===typeof value){if(Number.isNaN(value))break a;result$jscomp$0=value}else if(\"boolean\"===typeof value)result$jscomp$0=value;else if(\"string\"===typeof value)result$jscomp$0=info.spaceSeparated?(0,_spaceSeparatedTokens.parse)(value):info.commaSeparated?(0,_commaSeparatedTokens.parse)(value):info.commaOrSpaceSeparated?(0,_spaceSeparatedTokens.parse)((0,_commaSeparatedTokens.parse)(value).join(\" \")):\nparsePrimitive(info,info.property,value);else if(Array.isArray(value))result$jscomp$0=value.concat();else if(\"style\"===info.property){result$jscomp$0=void 0;const result=[];for(result$jscomp$0 in value)own.call(value,result$jscomp$0)&&result.push([result$jscomp$0,value[result$jscomp$0]].join(\": \"));result$jscomp$0=result.join(\"; \")}else result$jscomp$0=String(value);if(Array.isArray(result$jscomp$0)){for(value=[];++index<result$jscomp$0.length;)value[index]=parsePrimitive(info,info.property,result$jscomp$0[index]);\nresult$jscomp$0=value}\"className\"===info.property&&Array.isArray(name.className)&&(result$jscomp$0=name.className.concat(result$jscomp$0));name[info.property]=result$jscomp$0}}}else children.unshift(properties)}for(;++index$jscomp$0<children.length;)addChild(selector.children,children[index$jscomp$0]);\"element\"===selector.type&&\"template\"===selector.tagName&&(selector.content={type:\"root\",children:selector.children},selector.children=[]);return selector}};var _propertyInformation=require(\"module$node_modules$property_information$index\"),\n_hastUtilParseSelector=require(\"module$node_modules$hast_util_parse_selector$index\"),_spaceSeparatedTokens=require(\"module$node_modules$space_separated_tokens$index\"),_commaSeparatedTokens=require(\"module$node_modules$comma_separated_tokens$index\");const buttonTypes=new Set([\"menu\",\"submit\",\"reset\",\"button\"]),own={}.hasOwnProperty}","~:source","shadow$provide[\"module$node_modules$hastscript$lib$core\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.core = core;\n\nvar _propertyInformation = require(\"property-information\");\n\nvar _hastUtilParseSelector = require(\"hast-util-parse-selector\");\n\nvar _spaceSeparatedTokens = require(\"space-separated-tokens\");\n\nvar _commaSeparatedTokens = require(\"comma-separated-tokens\");\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {Content | Root} Node\n *   Any concrete `hast` node.\n * @typedef {Root | Element} HResult\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {string | number} HStyleValue\n *   Value for a CSS style field.\n * @typedef {Record<string, HStyleValue>} HStyle\n *   Supported value of a `style` prop.\n * @typedef {string | number | boolean | null | undefined} HPrimitiveValue\n *   Primitive property value.\n * @typedef {Array<string | number>} HArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n * @typedef {HPrimitiveValue | HArrayValue} HPropertyValue\n *   Primitive value or list value.\n * @typedef {{[property: string]: HPropertyValue | HStyle}} HProperties\n *   Acceptable value for element properties.\n *\n * @typedef {string | number | null | undefined} HPrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<Node | HPrimitiveChild>} HArrayChild\n *   List of children.\n * @typedef {Node | HPrimitiveChild | HArrayChild} HChild\n *   Acceptable child value.\n */\nconst buttonTypes = new Set(['menu', 'submit', 'reset', 'button']);\nconst own = {}.hasOwnProperty;\n/**\n * @param {Schema} schema\n * @param {string} defaultTagName\n * @param {Array<string>} [caseSensitive]\n */\n\nfunction core(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive);\n\n  const h =\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @param {string | null} [selector]\n   * @param {HProperties | HChild} [properties]\n   * @param {Array<HChild>} children\n   * @returns {HResult}\n   */\n  function (selector, properties, ...children) {\n    let index = -1;\n    /** @type {HResult} */\n\n    let node;\n\n    if (selector === undefined || selector === null) {\n      node = {\n        type: 'root',\n        children: []\n      }; // @ts-expect-error Properties are not supported for roots.\n\n      children.unshift(properties);\n    } else {\n      node = (0, _hastUtilParseSelector.parseSelector)(selector, defaultTagName); // Normalize the name.\n\n      node.tagName = node.tagName.toLowerCase();\n\n      if (adjust && own.call(adjust, node.tagName)) {\n        node.tagName = adjust[node.tagName];\n      } // Handle props.\n\n\n      if (isProperties(properties, node.tagName)) {\n        /** @type {string} */\n        let key;\n\n        for (key in properties) {\n          if (own.call(properties, key)) {\n            // @ts-expect-error `node.properties` is set.\n            addProperty(schema, node.properties, key, properties[key]);\n          }\n        }\n      } else {\n        children.unshift(properties);\n      }\n    } // Handle children.\n\n\n    while (++index < children.length) {\n      addChild(node.children, children[index]);\n    }\n\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {\n        type: 'root',\n        children: node.children\n      };\n      node.children = [];\n    }\n\n    return node;\n  };\n\n  return h;\n}\n/**\n * @param {HProperties | HChild} value\n * @param {string} name\n * @returns {value is HProperties}\n */\n\n\nfunction isProperties(value, name) {\n  if (value === null || value === undefined || typeof value !== 'object' || Array.isArray(value)) {\n    return false;\n  }\n\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\n    return true;\n  }\n\n  if ('children' in value && Array.isArray(value.children)) {\n    return false;\n  }\n\n  if (name === 'button') {\n    return buttonTypes.has(value.type.toLowerCase());\n  }\n\n  return !('value' in value);\n}\n/**\n * @param {Schema} schema\n * @param {Properties} properties\n * @param {string} key\n * @param {HStyle | HPropertyValue} value\n * @returns {void}\n */\n\n\nfunction addProperty(schema, properties, key, value) {\n  const info = (0, _propertyInformation.find)(schema, key);\n  let index = -1;\n  /** @type {HPropertyValue} */\n\n  let result; // Ignore nullish and NaN values.\n\n  if (value === undefined || value === null) return;\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return;\n    result = value;\n  } // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value;\n  } // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = (0, _spaceSeparatedTokens.parse)(value);\n    } else if (info.commaSeparated) {\n      result = (0, _commaSeparatedTokens.parse)(value);\n    } else if (info.commaOrSpaceSeparated) {\n      result = (0, _spaceSeparatedTokens.parse)((0, _commaSeparatedTokens.parse)(value).join(' '));\n    } else {\n      result = parsePrimitive(info, info.property, value);\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat();\n  } else {\n    result = info.property === 'style' ? style(value) : String(value);\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<string | number>} */\n    const finalResult = [];\n\n    while (++index < result.length) {\n      // @ts-expect-error Assume no booleans in array.\n      finalResult[index] = parsePrimitive(info, info.property, result[index]);\n    }\n\n    result = finalResult;\n  } // Class names (which can be added both on the `selector` and here).\n\n\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // @ts-expect-error Assume no booleans in `className`.\n    result = properties.className.concat(result);\n  }\n\n  properties[info.property] = result;\n}\n/**\n * @param {Array<Content>} nodes\n * @param {HChild} value\n * @returns {void}\n */\n\n\nfunction addChild(nodes, value) {\n  let index = -1;\n\n  if (value === undefined || value === null) {// Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({\n      type: 'text',\n      value: String(value)\n    });\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index]);\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children);\n    } else {\n      nodes.push(value);\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`');\n  }\n}\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n * @param {string} name\n * @param {HPrimitiveValue} value\n * @returns {HPrimitiveValue}\n */\n\n\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value);\n    }\n\n    if ((info.boolean || info.overloadedBoolean) && (value === '' || (0, _propertyInformation.normalize)(value) === (0, _propertyInformation.normalize)(name))) {\n      return true;\n    }\n  }\n\n  return value;\n}\n/**\n * Serialize a `style` object as a string.\n *\n * @param {HStyle} value\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\n\n\nfunction style(value) {\n  /** @type {Array<string>} */\n  const result = [];\n  /** @type {string} */\n\n  let key;\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '));\n    }\n  }\n\n  return result.join('; ');\n}\n/**\n * Create a map to adjust casing.\n *\n * @param {Array<string>} values\n *   List of properly cased keys.\n * @returns {Record<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\n\n\nfunction createAdjustMap(values) {\n  /** @type {Record<string, string>} */\n  const result = {};\n  let index = -1;\n\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index];\n  }\n\n  return result;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$property_information$index","~$shadow.js","~$module$node_modules$hast_util_parse_selector$index","~$module$node_modules$space_separated_tokens$index","~$module$node_modules$comma_separated_tokens$index"]],"~:properties",["^5",["children","__esModule","value","content","type","tagName","core"]],"~:compiled-at",1676667638428,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hastscript$lib$core.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/hastscript/lib/core.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hastscript$lib$core\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.core = core;\\n\\nvar _propertyInformation = require(\\\"property-information\\\");\\n\\nvar _hastUtilParseSelector = require(\\\"hast-util-parse-selector\\\");\\n\\nvar _spaceSeparatedTokens = require(\\\"space-separated-tokens\\\");\\n\\nvar _commaSeparatedTokens = require(\\\"comma-separated-tokens\\\");\\n\\n/**\\n * @typedef {import('hast').Root} Root\\n * @typedef {import('hast').Content} Content\\n * @typedef {import('hast').Element} Element\\n * @typedef {import('hast').Properties} Properties\\n * @typedef {import('property-information').Info} Info\\n * @typedef {import('property-information').Schema} Schema\\n */\\n\\n/**\\n * @typedef {Content | Root} Node\\n *   Any concrete `hast` node.\\n * @typedef {Root | Element} HResult\\n *   Result from a `h` (or `s`) call.\\n *\\n * @typedef {string | number} HStyleValue\\n *   Value for a CSS style field.\\n * @typedef {Record<string, HStyleValue>} HStyle\\n *   Supported value of a `style` prop.\\n * @typedef {string | number | boolean | null | undefined} HPrimitiveValue\\n *   Primitive property value.\\n * @typedef {Array<string | number>} HArrayValue\\n *   List of property values for space- or comma separated values (such as `className`).\\n * @typedef {HPrimitiveValue | HArrayValue} HPropertyValue\\n *   Primitive value or list value.\\n * @typedef {{[property: string]: HPropertyValue | HStyle}} HProperties\\n *   Acceptable value for element properties.\\n *\\n * @typedef {string | number | null | undefined} HPrimitiveChild\\n *   Primitive children, either ignored (nullish), or turned into text nodes.\\n * @typedef {Array<Node | HPrimitiveChild>} HArrayChild\\n *   List of children.\\n * @typedef {Node | HPrimitiveChild | HArrayChild} HChild\\n *   Acceptable child value.\\n */\\nconst buttonTypes = new Set(['menu', 'submit', 'reset', 'button']);\\nconst own = {}.hasOwnProperty;\\n/**\\n * @param {Schema} schema\\n * @param {string} defaultTagName\\n * @param {Array<string>} [caseSensitive]\\n */\\n\\nfunction core(schema, defaultTagName, caseSensitive) {\\n  const adjust = caseSensitive && createAdjustMap(caseSensitive);\\n\\n  const h =\\n  /**\\n   * Hyperscript compatible DSL for creating virtual hast trees.\\n   *\\n   * @param {string | null} [selector]\\n   * @param {HProperties | HChild} [properties]\\n   * @param {Array<HChild>} children\\n   * @returns {HResult}\\n   */\\n  function (selector, properties, ...children) {\\n    let index = -1;\\n    /** @type {HResult} */\\n\\n    let node;\\n\\n    if (selector === undefined || selector === null) {\\n      node = {\\n        type: 'root',\\n        children: []\\n      }; // @ts-expect-error Properties are not supported for roots.\\n\\n      children.unshift(properties);\\n    } else {\\n      node = (0, _hastUtilParseSelector.parseSelector)(selector, defaultTagName); // Normalize the name.\\n\\n      node.tagName = node.tagName.toLowerCase();\\n\\n      if (adjust && own.call(adjust, node.tagName)) {\\n        node.tagName = adjust[node.tagName];\\n      } // Handle props.\\n\\n\\n      if (isProperties(properties, node.tagName)) {\\n        /** @type {string} */\\n        let key;\\n\\n        for (key in properties) {\\n          if (own.call(properties, key)) {\\n            // @ts-expect-error `node.properties` is set.\\n            addProperty(schema, node.properties, key, properties[key]);\\n          }\\n        }\\n      } else {\\n        children.unshift(properties);\\n      }\\n    } // Handle children.\\n\\n\\n    while (++index < children.length) {\\n      addChild(node.children, children[index]);\\n    }\\n\\n    if (node.type === 'element' && node.tagName === 'template') {\\n      node.content = {\\n        type: 'root',\\n        children: node.children\\n      };\\n      node.children = [];\\n    }\\n\\n    return node;\\n  };\\n\\n  return h;\\n}\\n/**\\n * @param {HProperties | HChild} value\\n * @param {string} name\\n * @returns {value is HProperties}\\n */\\n\\n\\nfunction isProperties(value, name) {\\n  if (value === null || value === undefined || typeof value !== 'object' || Array.isArray(value)) {\\n    return false;\\n  }\\n\\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\\n    return true;\\n  }\\n\\n  if ('children' in value && Array.isArray(value.children)) {\\n    return false;\\n  }\\n\\n  if (name === 'button') {\\n    return buttonTypes.has(value.type.toLowerCase());\\n  }\\n\\n  return !('value' in value);\\n}\\n/**\\n * @param {Schema} schema\\n * @param {Properties} properties\\n * @param {string} key\\n * @param {HStyle | HPropertyValue} value\\n * @returns {void}\\n */\\n\\n\\nfunction addProperty(schema, properties, key, value) {\\n  const info = (0, _propertyInformation.find)(schema, key);\\n  let index = -1;\\n  /** @type {HPropertyValue} */\\n\\n  let result; // Ignore nullish and NaN values.\\n\\n  if (value === undefined || value === null) return;\\n\\n  if (typeof value === 'number') {\\n    // Ignore NaN.\\n    if (Number.isNaN(value)) return;\\n    result = value;\\n  } // Booleans.\\n  else if (typeof value === 'boolean') {\\n    result = value;\\n  } // Handle list values.\\n  else if (typeof value === 'string') {\\n    if (info.spaceSeparated) {\\n      result = (0, _spaceSeparatedTokens.parse)(value);\\n    } else if (info.commaSeparated) {\\n      result = (0, _commaSeparatedTokens.parse)(value);\\n    } else if (info.commaOrSpaceSeparated) {\\n      result = (0, _spaceSeparatedTokens.parse)((0, _commaSeparatedTokens.parse)(value).join(' '));\\n    } else {\\n      result = parsePrimitive(info, info.property, value);\\n    }\\n  } else if (Array.isArray(value)) {\\n    result = value.concat();\\n  } else {\\n    result = info.property === 'style' ? style(value) : String(value);\\n  }\\n\\n  if (Array.isArray(result)) {\\n    /** @type {Array<string | number>} */\\n    const finalResult = [];\\n\\n    while (++index < result.length) {\\n      // @ts-expect-error Assume no booleans in array.\\n      finalResult[index] = parsePrimitive(info, info.property, result[index]);\\n    }\\n\\n    result = finalResult;\\n  } // Class names (which can be added both on the `selector` and here).\\n\\n\\n  if (info.property === 'className' && Array.isArray(properties.className)) {\\n    // @ts-expect-error Assume no booleans in `className`.\\n    result = properties.className.concat(result);\\n  }\\n\\n  properties[info.property] = result;\\n}\\n/**\\n * @param {Array<Content>} nodes\\n * @param {HChild} value\\n * @returns {void}\\n */\\n\\n\\nfunction addChild(nodes, value) {\\n  let index = -1;\\n\\n  if (value === undefined || value === null) {// Empty.\\n  } else if (typeof value === 'string' || typeof value === 'number') {\\n    nodes.push({\\n      type: 'text',\\n      value: String(value)\\n    });\\n  } else if (Array.isArray(value)) {\\n    while (++index < value.length) {\\n      addChild(nodes, value[index]);\\n    }\\n  } else if (typeof value === 'object' && 'type' in value) {\\n    if (value.type === 'root') {\\n      addChild(nodes, value.children);\\n    } else {\\n      nodes.push(value);\\n    }\\n  } else {\\n    throw new Error('Expected node, nodes, or string, got `' + value + '`');\\n  }\\n}\\n/**\\n * Parse a single primitives.\\n *\\n * @param {Info} info\\n * @param {string} name\\n * @param {HPrimitiveValue} value\\n * @returns {HPrimitiveValue}\\n */\\n\\n\\nfunction parsePrimitive(info, name, value) {\\n  if (typeof value === 'string') {\\n    if (info.number && value && !Number.isNaN(Number(value))) {\\n      return Number(value);\\n    }\\n\\n    if ((info.boolean || info.overloadedBoolean) && (value === '' || (0, _propertyInformation.normalize)(value) === (0, _propertyInformation.normalize)(name))) {\\n      return true;\\n    }\\n  }\\n\\n  return value;\\n}\\n/**\\n * Serialize a `style` object as a string.\\n *\\n * @param {HStyle} value\\n *   Style object.\\n * @returns {string}\\n *   CSS string.\\n */\\n\\n\\nfunction style(value) {\\n  /** @type {Array<string>} */\\n  const result = [];\\n  /** @type {string} */\\n\\n  let key;\\n\\n  for (key in value) {\\n    if (own.call(value, key)) {\\n      result.push([key, value[key]].join(': '));\\n    }\\n  }\\n\\n  return result.join('; ');\\n}\\n/**\\n * Create a map to adjust casing.\\n *\\n * @param {Array<string>} values\\n *   List of properly cased keys.\\n * @returns {Record<string, string>}\\n *   Map of lowercase keys to uppercase keys.\\n */\\n\\n\\nfunction createAdjustMap(values) {\\n  /** @type {Record<string, string>} */\\n  const result = {};\\n  let index = -1;\\n\\n  while (++index < values.length) {\\n    result[values[index].toLowerCase()] = values[index];\\n  }\\n\\n  return result;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"addChild\",\"nodes\",\"value\",\"index\",\"undefined\",\"push\",\"type\",\"String\",\"Array\",\"isArray\",\"length\",\"children\",\"Error\",\"parsePrimitive\",\"info\",\"name\",\"number\",\"Number\",\"isNaN\",\"boolean\",\"overloadedBoolean\",\"_propertyInformation\",\"normalize\",\"createAdjustMap\",\"values\",\"result\",\"toLowerCase\",\"Object\",\"defineProperty\",\"core\",\"schema\",\"defaultTagName\",\"caseSensitive\",\"adjust\",\"h\",\"selector\",\"properties\",\"node\",\"unshift\",\"_hastUtilParseSelector\",\"parseSelector\",\"tagName\",\"own\",\"call\",\"buttonTypes\",\"has\",\"key\",\"find\",\"join\",\"finalResult\",\"property\",\"className\",\"concat\",\"content\",\"_spaceSeparatedTokens\",\"_commaSeparatedTokens\",\"Set\",\"hasOwnProperty\"]\n}\n"]