["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/unist-util-filter/lib/index.js"],"~:js","shadow$provide.module$node_modules$unist_util_filter$lib$index=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.filter=void 0;var _unistUtilIs=require(\"module$node_modules$unist_util_is$index\");const own={}.hasOwnProperty;exports.filter=function(tree,options,test){function preorder(node,index,parent){const children=[];if(!is(node,index,parent))return null;if(node.children){for(index=-1;++index<node.children.length;)(parent=preorder(node.children[index],\nindex,node))&&children.push(parent);if(cascade&&0<node.children.length&&0===children.length)return null}index={};let key;for(key in node)own.call(node,key)&&(index[key]=\"children\"===key?children:node[key]);return index}const is=(0,_unistUtilIs.convert)(test||options);options=options&&\"object\"===typeof options&&\"cascade\"in options?options.cascade:void 0;const cascade=void 0===options||null===options?!0:options;return preorder(tree)}}","~:source","shadow$provide[\"module$node_modules$unist_util_filter$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.filter = void 0;\n\nvar _unistUtilIs = require(\"unist-util-is\");\n\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [cascade=true]\n *   Whether to drop parent nodes if they had children, but all their children\n *   were filtered out.\n */\nconst own = {}.hasOwnProperty;\n/**\n * Create a new `tree` of copies of all nodes that pass `test`.\n *\n * The tree is walked in *preorder* (NLR), visiting the node itself, then its\n * head, etc.\n *\n * @param tree\n *   Tree to filter.\n * @param options\n *   Configuration (optional).\n * @param test\n *   `unist-util-is` compatible test.\n * @returns\n *   New filtered tree.\n *\n *   `null` is returned if `tree` itself didnâ€™t pass the test, or is cascaded\n *   away.\n */\n\nconst filter =\n/**\n * @param {Node} tree\n * @param {Options | Test | null | undefined} [options]\n * @param {Test | null | undefined} [test]\n * @returns {Node | null}\n */\nfunction (tree, options, test) {\n  const is = (0, _unistUtilIs.convert)(test || options);\n  /** @type {boolean | null | undefined} */\n\n  const cascadeRaw = options && typeof options === 'object' && 'cascade' in options ? options.cascade : undefined;\n  const cascade = cascadeRaw === undefined || cascadeRaw === null ? true : cascadeRaw;\n  return preorder(tree);\n  /**\n   * @param {Node} node\n   *   Current node.\n   * @param {number | undefined} [index]\n   *   Index of `node` in `parent`.\n   * @param {Parent | undefined} [parent]\n   *   Parent node.\n   * @returns {Node | null}\n   *   Shallow copy of `node`.\n   */\n\n  function preorder(node, index, parent) {\n    /** @type {Array<Node>} */\n    const children = [];\n    if (!is(node, index, parent)) return null; // @ts-expect-error: Looks like a parent.\n\n    if (node.children) {\n      let childIndex = -1; // @ts-expect-error Looks like a parent.\n\n      while (++childIndex < node.children.length) {\n        // @ts-expect-error Looks like a parent.\n        const result = preorder(node.children[childIndex], childIndex, node);\n\n        if (result) {\n          children.push(result);\n        }\n      } // @ts-expect-error Looks like a parent.\n\n\n      if (cascade && node.children.length > 0 && children.length === 0) return null;\n    } // Create a shallow clone, using the new children.\n\n    /** @type {typeof node} */\n    // @ts-expect-error all the fields will be copied over.\n\n\n    const next = {};\n    /** @type {string} */\n\n    let key;\n\n    for (key in node) {\n      if (own.call(node, key)) {\n        // @ts-expect-error: Looks like a record.\n        next[key] = key === 'children' ? children : node[key];\n      }\n    }\n\n    return next;\n  }\n};\n\nexports.filter = filter;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$unist_util_is$index"]],"~:properties",["^5",["__esModule","value","filter"]],"~:compiled-at",1676841365354,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$unist_util_filter$lib$index.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,+CAAA,CAAoE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG5GC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,MAAR,CAAiB,IAAK,EAEtB,KAAIC,aAAeP,OAAA,CAAQ,yCAAR,CAanB,OAAMQ,IAAM,EAAGC,CAAAA,cAsFfP,QAAQI,CAAAA,MAAR,CA3DAA,QAAS,CAACI,IAAD,CAAOC,OAAP,CAAgBC,IAAhB,CAAsB,CAkB7BC,QAASA,SAAQ,CAACC,IAAD,CAAOC,KAAP,CAAcC,MAAd,CAAsB,CAErC,MAAMC,SAAW,EACjB,IAAI,CAACC,EAAA,CAAGJ,IAAH,CAASC,KAAT,CAAgBC,MAAhB,CAAL,CAA8B,MAAO,KAErC,IAAIF,IAAKG,CAAAA,QAAT,CAAmB,CAGjB,IAFIE,KAEJ,CAFiB,CAAC,CAElB,CAAO,EAAEA,KAAT,CAAsBL,IAAKG,CAAAA,QAASG,CAAAA,MAApC,CAAA,CAIE,CAFMC,MAEN,CAFeR,QAAA,CAASC,IAAKG,CAAAA,QAAL,CAAcE,KAAd,CAAT;AAAoCA,KAApC,CAAgDL,IAAhD,CAEf,GACEG,QAASK,CAAAA,IAAT,CAAcD,MAAd,CAKJ,IAAIE,OAAJ,EAAsC,CAAtC,CAAeT,IAAKG,CAAAA,QAASG,CAAAA,MAA7B,EAA+D,CAA/D,GAA2CH,QAASG,CAAAA,MAApD,CAAkE,MAAO,KAbxD,CAoBbI,KAAAA,CAAO,EAGb,KAAIC,GAEJ,KAAKA,GAAL,GAAYX,KAAZ,CACMN,GAAIkB,CAAAA,IAAJ,CAASZ,IAAT,CAAeW,GAAf,CAAJ,GAEED,KAAA,CAAKC,GAAL,CAFF,CAEsB,UAAR,GAAAA,GAAA,CAAqBR,QAArB,CAAgCH,IAAA,CAAKW,GAAL,CAF9C,CAMF,OAAOD,MArC8B,CAjBvC,MAAMN,GAAK,GAAIX,YAAaoB,CAAAA,OAAjB,EAA0Bf,IAA1B,EAAkCD,OAAlC,CAGLiB,QAAAA,CAAajB,OAAA,EAA8B,QAA9B,GAAW,MAAOA,QAAlB,EAA0C,SAA1C,EAAuDA,QAAvD,CAAiEA,OAAQY,CAAAA,OAAzE,CAAmFM,IAAAA,EACtG,OAAMN,QAAyBM,IAAAA,EAAf,GAAAD,OAAA,EAA2C,IAA3C,GAA4BA,OAA5B,CAAkD,CAAA,CAAlD,CAAyDA,OACzE,OAAOf,SAAA,CAASH,IAAT,CANsB,CAhD6E;\",\n\"sources\":[\"node_modules/unist-util-filter/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$unist_util_filter$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.filter = void 0;\\n\\nvar _unistUtilIs = require(\\\"unist-util-is\\\");\\n\\n/**\\n * @typedef {import('unist').Node} Node\\n * @typedef {import('unist').Parent} Parent\\n * @typedef {import('unist-util-is').Test} Test\\n *\\n * @typedef Options\\n *   Configuration (optional).\\n * @property {boolean | null | undefined} [cascade=true]\\n *   Whether to drop parent nodes if they had children, but all their children\\n *   were filtered out.\\n */\\nconst own = {}.hasOwnProperty;\\n/**\\n * Create a new `tree` of copies of all nodes that pass `test`.\\n *\\n * The tree is walked in *preorder* (NLR), visiting the node itself, then its\\n * head, etc.\\n *\\n * @param tree\\n *   Tree to filter.\\n * @param options\\n *   Configuration (optional).\\n * @param test\\n *   `unist-util-is` compatible test.\\n * @returns\\n *   New filtered tree.\\n *\\n *   `null` is returned if `tree` itself didn\\u2019t pass the test, or is cascaded\\n *   away.\\n */\\n\\nconst filter =\\n/**\\n * @param {Node} tree\\n * @param {Options | Test | null | undefined} [options]\\n * @param {Test | null | undefined} [test]\\n * @returns {Node | null}\\n */\\nfunction (tree, options, test) {\\n  const is = (0, _unistUtilIs.convert)(test || options);\\n  /** @type {boolean | null | undefined} */\\n\\n  const cascadeRaw = options && typeof options === 'object' && 'cascade' in options ? options.cascade : undefined;\\n  const cascade = cascadeRaw === undefined || cascadeRaw === null ? true : cascadeRaw;\\n  return preorder(tree);\\n  /**\\n   * @param {Node} node\\n   *   Current node.\\n   * @param {number | undefined} [index]\\n   *   Index of `node` in `parent`.\\n   * @param {Parent | undefined} [parent]\\n   *   Parent node.\\n   * @returns {Node | null}\\n   *   Shallow copy of `node`.\\n   */\\n\\n  function preorder(node, index, parent) {\\n    /** @type {Array<Node>} */\\n    const children = [];\\n    if (!is(node, index, parent)) return null; // @ts-expect-error: Looks like a parent.\\n\\n    if (node.children) {\\n      let childIndex = -1; // @ts-expect-error Looks like a parent.\\n\\n      while (++childIndex < node.children.length) {\\n        // @ts-expect-error Looks like a parent.\\n        const result = preorder(node.children[childIndex], childIndex, node);\\n\\n        if (result) {\\n          children.push(result);\\n        }\\n      } // @ts-expect-error Looks like a parent.\\n\\n\\n      if (cascade && node.children.length > 0 && children.length === 0) return null;\\n    } // Create a shallow clone, using the new children.\\n\\n    /** @type {typeof node} */\\n    // @ts-expect-error all the fields will be copied over.\\n\\n\\n    const next = {};\\n    /** @type {string} */\\n\\n    let key;\\n\\n    for (key in node) {\\n      if (own.call(node, key)) {\\n        // @ts-expect-error: Looks like a record.\\n        next[key] = key === 'children' ? children : node[key];\\n      }\\n    }\\n\\n    return next;\\n  }\\n};\\n\\nexports.filter = filter;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"filter\",\"_unistUtilIs\",\"own\",\"hasOwnProperty\",\"tree\",\"options\",\"test\",\"preorder\",\"node\",\"index\",\"parent\",\"children\",\"is\",\"childIndex\",\"length\",\"result\",\"push\",\"cascade\",\"next\",\"key\",\"call\",\"convert\",\"cascadeRaw\",\"undefined\"]\n}\n"]