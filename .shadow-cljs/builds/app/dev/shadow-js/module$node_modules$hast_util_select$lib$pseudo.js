["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hast-util-select/lib/pseudo.js"],"~:js","shadow$provide.module$node_modules$hast_util_select$lib$pseudo=function(global,require,module,exports){function pseudo(query,element,index,parent,state){query=query.pseudos;let offset=-1;for(;++offset<query.length;)if(!handle(query[offset],element,index,parent,state))return!1;return!0}function disabled(_,element){return(\"button\"===element.tagName||\"input\"===element.tagName||\"select\"===element.tagName||\"textarea\"===element.tagName||\"optgroup\"===element.tagName||\"option\"===element.tagName||\"menuitem\"===\nelement.tagName||\"fieldset\"===element.tagName)&&(0,_hastUtilHasProperty.hasProperty)(element,\"disabled\")}function matches(query,element,_,parent,state){query={...state,found:!1,shallow:!1,one:!0,scopeElements:[element],results:[],rootQuery:(0,_walk.queryToSelectors)(query.value)};(0,_walk.walk)(query,element);return query.results[0]===element}function readWrite(_,element,_1,_2,state){return\"input\"===element.tagName||\"textarea\"===element.tagName?!(0,_hastUtilHasProperty.hasProperty)(element,\"readOnly\")&&\n!(0,_hastUtilHasProperty.hasProperty)(element,\"disabled\"):!!state.editableOrEditingHost}function required(_,element){return(\"input\"===element.tagName||\"textarea\"===element.tagName||\"select\"===element.tagName)&&(0,_hastUtilHasProperty.hasProperty)(element,\"required\")}function someChildren(element,check){element=element.children;let index=-1;for(;++index<element.length;)if(check(element[index]))return!0;return!1}function assertDeep(state,query){if(state.shallow)throw Error(\"Cannot use `:\"+query.name+\n\"` without parent\");}function getCachedNthCheck(query){let fn=query._cachedFn;fn||(fn=nthCheck(query.value),query._cachedFn=fn);return fn}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.pseudo=pseudo;var _bcp47Match=require(\"module$node_modules$bcp_47_match$index\"),_commaSeparatedTokens=require(\"module$node_modules$comma_separated_tokens$index\"),_hastUtilHasProperty=require(\"module$node_modules$hast_util_has_property$index\"),_hastUtilWhitespace=require(\"module$node_modules$hast_util_whitespace$index\");\nglobal=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(require(\"module$node_modules$nth_check$lib$index\"));module=require(\"module$node_modules$zwitch$index\");var _walk=require(\"module$node_modules$hast_util_select$lib$walk\");const nthCheck=global.default.default||global.default,handle=(0,module.zwitch)(\"name\",{unknown:function(query){if(query.name)throw Error(\"Unknown pseudo-selector `\"+query.name+\"`\");throw Error(\"Unexpected pseudo-element or empty pseudo-class\");},invalid:function(){throw Error(\"Invalid pseudo-selector\");\n},handlers:{any:matches,\"any-link\":function(_,element){return(\"a\"===element.tagName||\"area\"===element.tagName||\"link\"===element.tagName)&&(0,_hastUtilHasProperty.hasProperty)(element,\"href\")},blank:function(_,element){return!someChildren(element,function(child){return\"element\"===child.type||\"text\"===child.type&&!(0,_hastUtilWhitespace.whitespace)(child)})},checked:function(_,element){return\"input\"===element.tagName||\"menuitem\"===element.tagName?!(!element.properties||\"checkbox\"!==element.properties.type&&\n\"radio\"!==element.properties.type||!(0,_hastUtilHasProperty.hasProperty)(element,\"checked\")):\"option\"===element.tagName?(0,_hastUtilHasProperty.hasProperty)(element,\"selected\"):!1},dir:function(query,_1,_2,_3,state){return state.direction===query.value},disabled,empty:function(_,element){return!someChildren(element,function(child){return\"element\"===child.type||\"text\"===child.type})},enabled:function(query,element){return!disabled(query,element)},\"first-child\":function(query,_1,_2,_3,state){assertDeep(state,\nquery);return 0===state.elementIndex},\"first-of-type\":function(query,_1,_2,_3,state){assertDeep(state,query);return 0===state.typeIndex},has:function(query,element,_1,_2,state){query={...state,found:!1,shallow:!1,one:!0,scopeElements:[element],results:[],rootQuery:(0,_walk.queryToSelectors)(query.value)};(0,_walk.walk)(query,{type:\"root\",children:element.children});return 0<query.results.length},lang:function(query,_1,_2,_3,state){return\"\"!==state.language&&void 0!==state.language&&0<(0,_bcp47Match.extendedFilter)(state.language,\n(0,_commaSeparatedTokens.parse)(query.value)).length},\"last-child\":function(query,_1,_2,_3,state){assertDeep(state,query);return!(!state.elementCount||state.elementIndex!==state.elementCount-1)},\"last-of-type\":function(query,_1,_2,_3,state){assertDeep(state,query);return\"number\"===typeof state.typeIndex&&\"number\"===typeof state.typeCount&&state.typeIndex===state.typeCount-1},matches,not:function(query,element,index,parent,state){return!matches(query,element,index,parent,state)},\"nth-child\":function(query,\n_1,_2,_3,state){_1=getCachedNthCheck(query);assertDeep(state,query);return\"number\"===typeof state.elementIndex&&_1(state.elementIndex)},\"nth-last-child\":function(query,_1,_2,_3,state){_1=getCachedNthCheck(query);assertDeep(state,query);return!(\"number\"!==typeof state.elementCount||\"number\"!==typeof state.elementIndex||!_1(state.elementCount-state.elementIndex-1))},\"nth-of-type\":function(query,_1,_2,_3,state){_1=getCachedNthCheck(query);assertDeep(state,query);return\"number\"===typeof state.typeIndex&&\n_1(state.typeIndex)},\"nth-last-of-type\":function(query,_1,_2,_3,state){_1=getCachedNthCheck(query);assertDeep(state,query);return\"number\"===typeof state.typeCount&&\"number\"===typeof state.typeIndex&&_1(state.typeCount-1-state.typeIndex)},\"only-child\":function(query,_1,_2,_3,state){assertDeep(state,query);return 1===state.elementCount},\"only-of-type\":function(query,_1,_2,_3,state){assertDeep(state,query);return 1===state.typeCount},optional:function(query,element){return!required(query,element)},\"read-only\":function(query,\nelement,index,parent,state){return!readWrite(query,element,index,parent,state)},\"read-write\":readWrite,required,root:function(_,element,_1,parent,state){return!(parent&&\"root\"!==parent.type||!state.schema||\"html\"!==state.schema.space&&\"svg\"!==state.schema.space||\"html\"!==element.tagName&&\"svg\"!==element.tagName)},scope:function(_,element,_1,_2,state){return state.scopeElements.includes(element)}}});pseudo.needsIndex=\"any first-child first-of-type last-child last-of-type matches not nth-child nth-last-child nth-of-type nth-last-of-type only-child only-of-type\".split(\" \")}","~:source","shadow$provide[\"module$node_modules$hast_util_select$lib$pseudo\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pseudo = pseudo;\n\nvar _bcp47Match = require(\"bcp-47-match\");\n\nvar _commaSeparatedTokens = require(\"comma-separated-tokens\");\n\nvar _hastUtilHasProperty = require(\"hast-util-has-property\");\n\nvar _hastUtilWhitespace = require(\"hast-util-whitespace\");\n\nvar _nthCheck = _interopRequireDefault(require(\"nth-check\"));\n\nvar _zwitch = require(\"zwitch\");\n\nvar _walk = require(\"./walk.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RulePseudo} RulePseudo\n * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').ElementChild} ElementChild\n */\n\n/** @type {import('nth-check').default} */\n// @ts-expect-error\nconst nthCheck = _nthCheck.default.default || _nthCheck.default;\n/** @type {(rule: Rule | RulePseudo, element: Element, index: number | undefined, parent: Parent | undefined, state: SelectState) => boolean} */\n\nconst handle = (0, _zwitch.zwitch)('name', {\n  unknown: unknownPseudo,\n  invalid: invalidPseudo,\n  handlers: {\n    any: matches,\n    'any-link': anyLink,\n    blank,\n    checked,\n    dir,\n    disabled,\n    empty,\n    enabled,\n    'first-child': firstChild,\n    'first-of-type': firstOfType,\n    has,\n    lang,\n    'last-child': lastChild,\n    'last-of-type': lastOfType,\n    matches,\n    not,\n    'nth-child': nthChild,\n    'nth-last-child': nthLastChild,\n    'nth-of-type': nthOfType,\n    'nth-last-of-type': nthLastOfType,\n    'only-child': onlyChild,\n    'only-of-type': onlyOfType,\n    optional,\n    'read-only': readOnly,\n    'read-write': readWrite,\n    required,\n    root,\n    scope\n  }\n});\npseudo.needsIndex = ['any', 'first-child', 'first-of-type', 'last-child', 'last-of-type', 'matches', 'not', 'nth-child', 'nth-last-child', 'nth-of-type', 'nth-last-of-type', 'only-child', 'only-of-type'];\n/**\n * Check whether an element matches pseudo selectors.\n *\n * @param {Rule} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\n\nfunction pseudo(query, element, index, parent, state) {\n  const pseudos = query.pseudos;\n  let offset = -1;\n\n  while (++offset < pseudos.length) {\n    if (!handle(pseudos[offset], element, index, parent, state)) return false;\n  }\n\n  return true;\n}\n/**\n * Check whether an element matches an `:any-link` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction anyLink(_, element) {\n  return (element.tagName === 'a' || element.tagName === 'area' || element.tagName === 'link') && (0, _hastUtilHasProperty.hasProperty)(element, 'href');\n}\n/**\n * Check whether an element matches a `:blank` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction blank(_, element) {\n  return !someChildren(element, check);\n  /**\n   * @param {ElementChild} child\n   * @returns {boolean}\n   */\n\n  function check(child) {\n    return child.type === 'element' || child.type === 'text' && !(0, _hastUtilWhitespace.whitespace)(child);\n  }\n}\n/**\n * Check whether an element matches a `:checked` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction checked(_, element) {\n  if (element.tagName === 'input' || element.tagName === 'menuitem') {\n    return Boolean(element.properties && (element.properties.type === 'checkbox' || element.properties.type === 'radio') && (0, _hastUtilHasProperty.hasProperty)(element, 'checked'));\n  }\n\n  if (element.tagName === 'option') {\n    return (0, _hastUtilHasProperty.hasProperty)(element, 'selected');\n  }\n\n  return false;\n}\n/**\n * Check whether an element matches a `:dir()` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction dir(query, _1, _2, _3, state) {\n  return state.direction === query.value;\n}\n/**\n * Check whether an element matches a `:disabled` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction disabled(_, element) {\n  return (element.tagName === 'button' || element.tagName === 'input' || element.tagName === 'select' || element.tagName === 'textarea' || element.tagName === 'optgroup' || element.tagName === 'option' || element.tagName === 'menuitem' || element.tagName === 'fieldset') && (0, _hastUtilHasProperty.hasProperty)(element, 'disabled');\n}\n/**\n * Check whether an element matches an `:empty` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction empty(_, element) {\n  return !someChildren(element, check);\n  /**\n   * @param {ElementChild} child\n   * @returns {boolean}\n   */\n\n  function check(child) {\n    return child.type === 'element' || child.type === 'text';\n  }\n}\n/**\n * Check whether an element matches an `:enabled` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction enabled(query, element) {\n  return !disabled(query, element);\n}\n/**\n * Check whether an element matches a `:first-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction firstChild(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.elementIndex === 0;\n}\n/**\n * Check whether an element matches a `:first-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction firstOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.typeIndex === 0;\n}\n/**\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction has(query, element, _1, _2, state) {\n  /** @type {SelectState} */\n  const childState = { ...state,\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeElements: [element],\n    results: [],\n    rootQuery: (0, _walk.queryToSelectors)(query.value)\n  };\n  (0, _walk.walk)(childState, {\n    type: 'root',\n    children: element.children\n  });\n  return childState.results.length > 0;\n}\n/**\n * Check whether an element matches a `:lang()` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction lang(query, _1, _2, _3, state) {\n  return state.language !== '' && state.language !== undefined && // @ts-expect-error never `selectors`.\n  (0, _bcp47Match.extendedFilter)(state.language, (0, _commaSeparatedTokens.parse)(query.value)).length > 0;\n}\n/**\n * Check whether an element matches a `:last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction lastChild(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return Boolean(state.elementCount && state.elementIndex === state.elementCount - 1);\n}\n/**\n * Check whether an element matches a `:last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction lastOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return typeof state.typeIndex === 'number' && typeof state.typeCount === 'number' && state.typeIndex === state.typeCount - 1;\n}\n/**\n * Check whether an element `:matches` further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} _\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction matches(query, element, _, parent, state) {\n  /** @type {SelectState} */\n  const childState = { ...state,\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeElements: [element],\n    results: [],\n    rootQuery: (0, _walk.queryToSelectors)(query.value)\n  };\n  (0, _walk.walk)(childState, element);\n  return childState.results[0] === element;\n}\n/**\n * Check whether an element does `:not` match further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction not(query, element, index, parent, state) {\n  return !matches(query, element, index, parent, state);\n}\n/**\n * Check whether an element matches an `:nth-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction nthChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return typeof state.elementIndex === 'number' && fn(state.elementIndex);\n}\n/**\n * Check whether an element matches an `:nth-last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction nthLastChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return Boolean(typeof state.elementCount === 'number' && typeof state.elementIndex === 'number' && fn(state.elementCount - state.elementIndex - 1));\n}\n/**\n * Check whether an element matches a `:nth-last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction nthLastOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return typeof state.typeCount === 'number' && typeof state.typeIndex === 'number' && fn(state.typeCount - 1 - state.typeIndex);\n}\n/**\n * Check whether an element matches an `:nth-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction nthOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return typeof state.typeIndex === 'number' && fn(state.typeIndex);\n}\n/**\n * Check whether an element matches an `:only-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction onlyChild(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.elementCount === 1;\n}\n/**\n * Check whether an element matches an `:only-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction onlyOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.typeCount === 1;\n}\n/**\n * Check whether an element matches an `:optional` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction optional(query, element) {\n  return !required(query, element);\n}\n/**\n * Check whether an element matches a `:read-only` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction readOnly(query, element, index, parent, state) {\n  return !readWrite(query, element, index, parent, state);\n}\n/**\n * Check whether an element matches a `:read-write` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction readWrite(_, element, _1, _2, state) {\n  return element.tagName === 'input' || element.tagName === 'textarea' ? !(0, _hastUtilHasProperty.hasProperty)(element, 'readOnly') && !(0, _hastUtilHasProperty.hasProperty)(element, 'disabled') : Boolean(state.editableOrEditingHost);\n}\n/**\n * Check whether an element matches a `:required` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction required(_, element) {\n  return (element.tagName === 'input' || element.tagName === 'textarea' || element.tagName === 'select') && (0, _hastUtilHasProperty.hasProperty)(element, 'required');\n}\n/**\n * Check whether an element matches a `:root` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction root(_, element, _1, parent, state) {\n  return Boolean((!parent || parent.type === 'root') && state.schema && (state.schema.space === 'html' || state.schema.space === 'svg') && (element.tagName === 'html' || element.tagName === 'svg'));\n}\n/**\n * Check whether an element matches a `:scope` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction scope(_, element, _1, _2, state) {\n  return state.scopeElements.includes(element);\n} // Shouldn’t be called, parser gives correct data.\n\n/* c8 ignore next 3 */\n\n\nfunction invalidPseudo() {\n  throw new Error('Invalid pseudo-selector');\n}\n/**\n * @param {unknown} query\n * @returns {never}\n */\n\n\nfunction unknownPseudo(query) {\n  // @ts-expect-error: indexable.\n  if (query.name) {\n    // @ts-expect-error: indexable.\n    throw new Error('Unknown pseudo-selector `' + query.name + '`');\n  }\n\n  throw new Error('Unexpected pseudo-element or empty pseudo-class');\n}\n/**\n * Check children.\n *\n * @param {Element} element\n * @param {(child: ElementChild) => boolean} check\n * @returns {boolean}\n */\n\n\nfunction someChildren(element, check) {\n  const children = element.children;\n  let index = -1;\n\n  while (++index < children.length) {\n    if (check(children[index])) return true;\n  }\n\n  return false;\n}\n/**\n * @param {SelectState} state\n * @param {RulePseudo} query\n */\n\n\nfunction assertDeep(state, query) {\n  if (state.shallow) {\n    throw new Error('Cannot use `:' + query.name + '` without parent');\n  }\n}\n/**\n * @param {RulePseudo} query\n * @returns {(value: number) => boolean}\n */\n\n\nfunction getCachedNthCheck(query) {\n  /** @type {(value: number) => boolean} */\n  // @ts-expect-error: cache.\n  let fn = query._cachedFn;\n\n  if (!fn) {\n    // @ts-expect-error: always string.\n    fn = nthCheck(query.value); // @ts-expect-error: cache.\n\n    query._cachedFn = fn;\n  }\n\n  return fn;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$nth_check$lib$index","~$module$node_modules$hast_util_whitespace$index","~$shadow.js","~$module$node_modules$bcp_47_match$index","~$module$node_modules$comma_separated_tokens$index","~$module$node_modules$zwitch$index","~$module$node_modules$hast_util_select$lib$walk","~$module$node_modules$hast_util_has_property$index"]],"~:properties",["^5",["blank","pseudo","lang","optional","rootQuery","not","handlers","found","children","__esModule","enabled","results","root","invalid","any","value","_cachedFn","scope","dir","empty","matches","required","unknown","type","one","scopeElements","needsIndex","has","disabled","default","checked","shallow"]],"~:compiled-at",1676841365497,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hast_util_select$lib$pseudo.js\",\n\"lineCount\":12,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/hast-util-select/lib/pseudo.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hast_util_select$lib$pseudo\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.pseudo = pseudo;\\n\\nvar _bcp47Match = require(\\\"bcp-47-match\\\");\\n\\nvar _commaSeparatedTokens = require(\\\"comma-separated-tokens\\\");\\n\\nvar _hastUtilHasProperty = require(\\\"hast-util-has-property\\\");\\n\\nvar _hastUtilWhitespace = require(\\\"hast-util-whitespace\\\");\\n\\nvar _nthCheck = _interopRequireDefault(require(\\\"nth-check\\\"));\\n\\nvar _zwitch = require(\\\"zwitch\\\");\\n\\nvar _walk = require(\\\"./walk.js\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n/**\\n * @typedef {import('./types.js').Rule} Rule\\n * @typedef {import('./types.js').RulePseudo} RulePseudo\\n * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector\\n * @typedef {import('./types.js').Parent} Parent\\n * @typedef {import('./types.js').SelectState} SelectState\\n * @typedef {import('./types.js').Element} Element\\n * @typedef {import('./types.js').ElementChild} ElementChild\\n */\\n\\n/** @type {import('nth-check').default} */\\n// @ts-expect-error\\nconst nthCheck = _nthCheck.default.default || _nthCheck.default;\\n/** @type {(rule: Rule | RulePseudo, element: Element, index: number | undefined, parent: Parent | undefined, state: SelectState) => boolean} */\\n\\nconst handle = (0, _zwitch.zwitch)('name', {\\n  unknown: unknownPseudo,\\n  invalid: invalidPseudo,\\n  handlers: {\\n    any: matches,\\n    'any-link': anyLink,\\n    blank,\\n    checked,\\n    dir,\\n    disabled,\\n    empty,\\n    enabled,\\n    'first-child': firstChild,\\n    'first-of-type': firstOfType,\\n    has,\\n    lang,\\n    'last-child': lastChild,\\n    'last-of-type': lastOfType,\\n    matches,\\n    not,\\n    'nth-child': nthChild,\\n    'nth-last-child': nthLastChild,\\n    'nth-of-type': nthOfType,\\n    'nth-last-of-type': nthLastOfType,\\n    'only-child': onlyChild,\\n    'only-of-type': onlyOfType,\\n    optional,\\n    'read-only': readOnly,\\n    'read-write': readWrite,\\n    required,\\n    root,\\n    scope\\n  }\\n});\\npseudo.needsIndex = ['any', 'first-child', 'first-of-type', 'last-child', 'last-of-type', 'matches', 'not', 'nth-child', 'nth-last-child', 'nth-of-type', 'nth-last-of-type', 'only-child', 'only-of-type'];\\n/**\\n * Check whether an element matches pseudo selectors.\\n *\\n * @param {Rule} query\\n * @param {Element} element\\n * @param {number | undefined} index\\n * @param {Parent | undefined} parent\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\nfunction pseudo(query, element, index, parent, state) {\\n  const pseudos = query.pseudos;\\n  let offset = -1;\\n\\n  while (++offset < pseudos.length) {\\n    if (!handle(pseudos[offset], element, index, parent, state)) return false;\\n  }\\n\\n  return true;\\n}\\n/**\\n * Check whether an element matches an `:any-link` pseudo.\\n *\\n * @param {RulePseudo} _\\n * @param {Element} element\\n * @returns {boolean}\\n */\\n\\n\\nfunction anyLink(_, element) {\\n  return (element.tagName === 'a' || element.tagName === 'area' || element.tagName === 'link') && (0, _hastUtilHasProperty.hasProperty)(element, 'href');\\n}\\n/**\\n * Check whether an element matches a `:blank` pseudo.\\n *\\n * @param {RulePseudo} _\\n * @param {Element} element\\n * @returns {boolean}\\n */\\n\\n\\nfunction blank(_, element) {\\n  return !someChildren(element, check);\\n  /**\\n   * @param {ElementChild} child\\n   * @returns {boolean}\\n   */\\n\\n  function check(child) {\\n    return child.type === 'element' || child.type === 'text' && !(0, _hastUtilWhitespace.whitespace)(child);\\n  }\\n}\\n/**\\n * Check whether an element matches a `:checked` pseudo.\\n *\\n * @param {RulePseudo} _\\n * @param {Element} element\\n * @returns {boolean}\\n */\\n\\n\\nfunction checked(_, element) {\\n  if (element.tagName === 'input' || element.tagName === 'menuitem') {\\n    return Boolean(element.properties && (element.properties.type === 'checkbox' || element.properties.type === 'radio') && (0, _hastUtilHasProperty.hasProperty)(element, 'checked'));\\n  }\\n\\n  if (element.tagName === 'option') {\\n    return (0, _hastUtilHasProperty.hasProperty)(element, 'selected');\\n  }\\n\\n  return false;\\n}\\n/**\\n * Check whether an element matches a `:dir()` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} _1\\n * @param {number | undefined} _2\\n * @param {Parent | undefined} _3\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction dir(query, _1, _2, _3, state) {\\n  return state.direction === query.value;\\n}\\n/**\\n * Check whether an element matches a `:disabled` pseudo.\\n *\\n * @param {RulePseudo} _\\n * @param {Element} element\\n * @returns {boolean}\\n */\\n\\n\\nfunction disabled(_, element) {\\n  return (element.tagName === 'button' || element.tagName === 'input' || element.tagName === 'select' || element.tagName === 'textarea' || element.tagName === 'optgroup' || element.tagName === 'option' || element.tagName === 'menuitem' || element.tagName === 'fieldset') && (0, _hastUtilHasProperty.hasProperty)(element, 'disabled');\\n}\\n/**\\n * Check whether an element matches an `:empty` pseudo.\\n *\\n * @param {RulePseudo} _\\n * @param {Element} element\\n * @returns {boolean}\\n */\\n\\n\\nfunction empty(_, element) {\\n  return !someChildren(element, check);\\n  /**\\n   * @param {ElementChild} child\\n   * @returns {boolean}\\n   */\\n\\n  function check(child) {\\n    return child.type === 'element' || child.type === 'text';\\n  }\\n}\\n/**\\n * Check whether an element matches an `:enabled` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} element\\n * @returns {boolean}\\n */\\n\\n\\nfunction enabled(query, element) {\\n  return !disabled(query, element);\\n}\\n/**\\n * Check whether an element matches a `:first-child` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} _1\\n * @param {number | undefined} _2\\n * @param {Parent | undefined} _3\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction firstChild(query, _1, _2, _3, state) {\\n  assertDeep(state, query);\\n  return state.elementIndex === 0;\\n}\\n/**\\n * Check whether an element matches a `:first-of-type` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} _1\\n * @param {number | undefined} _2\\n * @param {Parent | undefined} _3\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction firstOfType(query, _1, _2, _3, state) {\\n  assertDeep(state, query);\\n  return state.typeIndex === 0;\\n}\\n/**\\n * @param {RulePseudoSelector} query\\n * @param {Element} element\\n * @param {number | undefined} _1\\n * @param {Parent | undefined} _2\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction has(query, element, _1, _2, state) {\\n  /** @type {SelectState} */\\n  const childState = { ...state,\\n    // Not found yet.\\n    found: false,\\n    // Do walk deep.\\n    shallow: false,\\n    // One result is enough.\\n    one: true,\\n    scopeElements: [element],\\n    results: [],\\n    rootQuery: (0, _walk.queryToSelectors)(query.value)\\n  };\\n  (0, _walk.walk)(childState, {\\n    type: 'root',\\n    children: element.children\\n  });\\n  return childState.results.length > 0;\\n}\\n/**\\n * Check whether an element matches a `:lang()` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} _1\\n * @param {number | undefined} _2\\n * @param {Parent | undefined} _3\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction lang(query, _1, _2, _3, state) {\\n  return state.language !== '' && state.language !== undefined && // @ts-expect-error never `selectors`.\\n  (0, _bcp47Match.extendedFilter)(state.language, (0, _commaSeparatedTokens.parse)(query.value)).length > 0;\\n}\\n/**\\n * Check whether an element matches a `:last-child` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} _1\\n * @param {number | undefined} _2\\n * @param {Parent | undefined} _3\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction lastChild(query, _1, _2, _3, state) {\\n  assertDeep(state, query);\\n  return Boolean(state.elementCount && state.elementIndex === state.elementCount - 1);\\n}\\n/**\\n * Check whether an element matches a `:last-of-type` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} _1\\n * @param {number | undefined} _2\\n * @param {Parent | undefined} _3\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction lastOfType(query, _1, _2, _3, state) {\\n  assertDeep(state, query);\\n  return typeof state.typeIndex === 'number' && typeof state.typeCount === 'number' && state.typeIndex === state.typeCount - 1;\\n}\\n/**\\n * Check whether an element `:matches` further selectors.\\n *\\n * @param {RulePseudoSelector} query\\n * @param {Element} element\\n * @param {number | undefined} _\\n * @param {Parent | undefined} parent\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction matches(query, element, _, parent, state) {\\n  /** @type {SelectState} */\\n  const childState = { ...state,\\n    // Not found yet.\\n    found: false,\\n    // Do walk deep.\\n    shallow: false,\\n    // One result is enough.\\n    one: true,\\n    scopeElements: [element],\\n    results: [],\\n    rootQuery: (0, _walk.queryToSelectors)(query.value)\\n  };\\n  (0, _walk.walk)(childState, element);\\n  return childState.results[0] === element;\\n}\\n/**\\n * Check whether an element does `:not` match further selectors.\\n *\\n * @param {RulePseudoSelector} query\\n * @param {Element} element\\n * @param {number | undefined} index\\n * @param {Parent | undefined} parent\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction not(query, element, index, parent, state) {\\n  return !matches(query, element, index, parent, state);\\n}\\n/**\\n * Check whether an element matches an `:nth-child` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} _1\\n * @param {number | undefined} _2\\n * @param {Parent | undefined} _3\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction nthChild(query, _1, _2, _3, state) {\\n  const fn = getCachedNthCheck(query);\\n  assertDeep(state, query);\\n  return typeof state.elementIndex === 'number' && fn(state.elementIndex);\\n}\\n/**\\n * Check whether an element matches an `:nth-last-child` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} _1\\n * @param {number | undefined} _2\\n * @param {Parent | undefined} _3\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction nthLastChild(query, _1, _2, _3, state) {\\n  const fn = getCachedNthCheck(query);\\n  assertDeep(state, query);\\n  return Boolean(typeof state.elementCount === 'number' && typeof state.elementIndex === 'number' && fn(state.elementCount - state.elementIndex - 1));\\n}\\n/**\\n * Check whether an element matches a `:nth-last-of-type` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} _1\\n * @param {number | undefined} _2\\n * @param {Parent | undefined} _3\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction nthLastOfType(query, _1, _2, _3, state) {\\n  const fn = getCachedNthCheck(query);\\n  assertDeep(state, query);\\n  return typeof state.typeCount === 'number' && typeof state.typeIndex === 'number' && fn(state.typeCount - 1 - state.typeIndex);\\n}\\n/**\\n * Check whether an element matches an `:nth-of-type` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} _1\\n * @param {number | undefined} _2\\n * @param {Parent | undefined} _3\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction nthOfType(query, _1, _2, _3, state) {\\n  const fn = getCachedNthCheck(query);\\n  assertDeep(state, query);\\n  return typeof state.typeIndex === 'number' && fn(state.typeIndex);\\n}\\n/**\\n * Check whether an element matches an `:only-child` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} _1\\n * @param {number | undefined} _2\\n * @param {Parent | undefined} _3\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction onlyChild(query, _1, _2, _3, state) {\\n  assertDeep(state, query);\\n  return state.elementCount === 1;\\n}\\n/**\\n * Check whether an element matches an `:only-of-type` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} _1\\n * @param {number | undefined} _2\\n * @param {Parent | undefined} _3\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction onlyOfType(query, _1, _2, _3, state) {\\n  assertDeep(state, query);\\n  return state.typeCount === 1;\\n}\\n/**\\n * Check whether an element matches an `:optional` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} element\\n * @returns {boolean}\\n */\\n\\n\\nfunction optional(query, element) {\\n  return !required(query, element);\\n}\\n/**\\n * Check whether an element matches a `:read-only` pseudo.\\n *\\n * @param {RulePseudo} query\\n * @param {Element} element\\n * @param {number | undefined} index\\n * @param {Parent | undefined} parent\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction readOnly(query, element, index, parent, state) {\\n  return !readWrite(query, element, index, parent, state);\\n}\\n/**\\n * Check whether an element matches a `:read-write` pseudo.\\n *\\n * @param {RulePseudo} _\\n * @param {Element} element\\n * @param {number | undefined} _1\\n * @param {Parent | undefined} _2\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction readWrite(_, element, _1, _2, state) {\\n  return element.tagName === 'input' || element.tagName === 'textarea' ? !(0, _hastUtilHasProperty.hasProperty)(element, 'readOnly') && !(0, _hastUtilHasProperty.hasProperty)(element, 'disabled') : Boolean(state.editableOrEditingHost);\\n}\\n/**\\n * Check whether an element matches a `:required` pseudo.\\n *\\n * @param {RulePseudo} _\\n * @param {Element} element\\n * @returns {boolean}\\n */\\n\\n\\nfunction required(_, element) {\\n  return (element.tagName === 'input' || element.tagName === 'textarea' || element.tagName === 'select') && (0, _hastUtilHasProperty.hasProperty)(element, 'required');\\n}\\n/**\\n * Check whether an element matches a `:root` pseudo.\\n *\\n * @param {RulePseudo} _\\n * @param {Element} element\\n * @param {number | undefined} _1\\n * @param {Parent | undefined} parent\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction root(_, element, _1, parent, state) {\\n  return Boolean((!parent || parent.type === 'root') && state.schema && (state.schema.space === 'html' || state.schema.space === 'svg') && (element.tagName === 'html' || element.tagName === 'svg'));\\n}\\n/**\\n * Check whether an element matches a `:scope` pseudo.\\n *\\n * @param {RulePseudo} _\\n * @param {Element} element\\n * @param {number | undefined} _1\\n * @param {Parent | undefined} _2\\n * @param {SelectState} state\\n * @returns {boolean}\\n */\\n\\n\\nfunction scope(_, element, _1, _2, state) {\\n  return state.scopeElements.includes(element);\\n} // Shouldn\\u2019t be called, parser gives correct data.\\n\\n/* c8 ignore next 3 */\\n\\n\\nfunction invalidPseudo() {\\n  throw new Error('Invalid pseudo-selector');\\n}\\n/**\\n * @param {unknown} query\\n * @returns {never}\\n */\\n\\n\\nfunction unknownPseudo(query) {\\n  // @ts-expect-error: indexable.\\n  if (query.name) {\\n    // @ts-expect-error: indexable.\\n    throw new Error('Unknown pseudo-selector `' + query.name + '`');\\n  }\\n\\n  throw new Error('Unexpected pseudo-element or empty pseudo-class');\\n}\\n/**\\n * Check children.\\n *\\n * @param {Element} element\\n * @param {(child: ElementChild) => boolean} check\\n * @returns {boolean}\\n */\\n\\n\\nfunction someChildren(element, check) {\\n  const children = element.children;\\n  let index = -1;\\n\\n  while (++index < children.length) {\\n    if (check(children[index])) return true;\\n  }\\n\\n  return false;\\n}\\n/**\\n * @param {SelectState} state\\n * @param {RulePseudo} query\\n */\\n\\n\\nfunction assertDeep(state, query) {\\n  if (state.shallow) {\\n    throw new Error('Cannot use `:' + query.name + '` without parent');\\n  }\\n}\\n/**\\n * @param {RulePseudo} query\\n * @returns {(value: number) => boolean}\\n */\\n\\n\\nfunction getCachedNthCheck(query) {\\n  /** @type {(value: number) => boolean} */\\n  // @ts-expect-error: cache.\\n  let fn = query._cachedFn;\\n\\n  if (!fn) {\\n    // @ts-expect-error: always string.\\n    fn = nthCheck(query.value); // @ts-expect-error: cache.\\n\\n    query._cachedFn = fn;\\n  }\\n\\n  return fn;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"pseudo\",\"query\",\"element\",\"index\",\"parent\",\"state\",\"pseudos\",\"offset\",\"length\",\"handle\",\"disabled\",\"_\",\"tagName\",\"_hastUtilHasProperty\",\"hasProperty\",\"matches\",\"childState\",\"found\",\"shallow\",\"one\",\"scopeElements\",\"results\",\"rootQuery\",\"_walk\",\"queryToSelectors\",\"value\",\"walk\",\"readWrite\",\"_1\",\"_2\",\"editableOrEditingHost\",\"required\",\"someChildren\",\"check\",\"children\",\"assertDeep\",\"Error\",\"name\",\"getCachedNthCheck\",\"fn\",\"_cachedFn\",\"nthCheck\",\"Object\",\"defineProperty\",\"_bcp47Match\",\"_commaSeparatedTokens\",\"_hastUtilWhitespace\",\"_nthCheck\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"default\",\"_zwitch\",\"zwitch\",\"unknown\",\"unknownPseudo\",\"invalid\",\"invalidPseudo\",\"handlers\",\"any\",\"anyLink\",\"blank\",\"child\",\"type\",\"whitespace\",\"checked\",\"properties\",\"dir\",\"_3\",\"direction\",\"empty\",\"enabled\",\"firstChild\",\"elementIndex\",\"firstOfType\",\"typeIndex\",\"has\",\"lang\",\"language\",\"undefined\",\"extendedFilter\",\"parse\",\"lastChild\",\"elementCount\",\"lastOfType\",\"typeCount\",\"not\",\"nthChild\",\"nthLastChild\",\"nthOfType\",\"nthLastOfType\",\"onlyChild\",\"onlyOfType\",\"optional\",\"readOnly\",\"root\",\"schema\",\"space\",\"scope\",\"includes\",\"needsIndex\"]\n}\n"]