["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vfile/lib/minpath.browser.js"],"~:js","shadow$provide.module$node_modules$vfile$lib$minpath_browser=function(global,require,module,exports){function assertPath(path){if(\"string\"!==typeof path)throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(path));}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.path=void 0;exports.path={basename:function(path,ext){if(void 0!==ext&&\"string\"!==typeof ext)throw new TypeError('\"ext\" argument must be a string');assertPath(path);let start=0,end=-1,index=path.length,seenNonSlash;\nif(void 0===ext||0===ext.length||ext.length>path.length){for(;index--;)if(47===path.charCodeAt(index)){if(seenNonSlash){start=index+1;break}}else 0>end&&(seenNonSlash=!0,end=index+1);return 0>end?\"\":path.slice(start,end)}if(ext===path)return\"\";let firstNonSlashEnd=-1,extIndex=ext.length-1;for(;index--;)if(47===path.charCodeAt(index)){if(seenNonSlash){start=index+1;break}}else 0>firstNonSlashEnd&&(seenNonSlash=!0,firstNonSlashEnd=index+1),-1<extIndex&&(path.charCodeAt(index)===ext.charCodeAt(extIndex--)?\n0>extIndex&&(end=index):(extIndex=-1,end=firstNonSlashEnd));start===end?end=firstNonSlashEnd:0>end&&(end=path.length);return path.slice(start,end)},dirname:function(path){assertPath(path);if(0===path.length)return\".\";let end=-1,index=path.length,unmatchedSlash;for(;--index;)if(47===path.charCodeAt(index)){if(unmatchedSlash){end=index;break}}else unmatchedSlash||(unmatchedSlash=!0);return 0>end?47===path.charCodeAt(0)?\"/\":\".\":1===end&&47===path.charCodeAt(0)?\"//\":path.slice(0,end)},extname:function(path){assertPath(path);\nlet index=path.length,end=-1,startPart=0,startDot=-1,preDotState=0,unmatchedSlash;for(;index--;){const code=path.charCodeAt(index);if(47===code){if(unmatchedSlash){startPart=index+1;break}}else 0>end&&(unmatchedSlash=!0,end=index+1),46===code?0>startDot?startDot=index:1!==preDotState&&(preDotState=1):-1<startDot&&(preDotState=-1)}return 0>startDot||0>end||0===preDotState||1===preDotState&&startDot===end-1&&startDot===startPart+1?\"\":path.slice(startDot,end)},join:function(...segments){for(var index$jscomp$0=\n-1,joined;++index$jscomp$0<segments.length;)assertPath(segments[index$jscomp$0]),segments[index$jscomp$0]&&(joined=void 0===joined?segments[index$jscomp$0]:joined+\"/\"+segments[index$jscomp$0]);if(void 0===joined)var JSCompiler_temp=\".\";else{segments=joined;assertPath(segments);index$jscomp$0=47===segments.charCodeAt(0);joined=!index$jscomp$0;let result=\"\",lastSegmentLength=0;var lastSlash=-1;let dots=0,index=-1;for(;++index<=segments.length;){if(index<segments.length)JSCompiler_temp=segments.charCodeAt(index);\nelse if(47===JSCompiler_temp)break;else JSCompiler_temp=47;if(47===JSCompiler_temp){if(lastSlash!==index-1&&1!==dots)if(lastSlash!==index-1&&2===dots){if(2>result.length||2!==lastSegmentLength||46!==result.charCodeAt(result.length-1)||46!==result.charCodeAt(result.length-2))if(2<result.length){if(lastSlash=result.lastIndexOf(\"/\"),lastSlash!==result.length-1){0>lastSlash?(result=\"\",lastSegmentLength=0):(result=result.slice(0,lastSlash),lastSegmentLength=result.length-1-result.lastIndexOf(\"/\"));lastSlash=\nindex;dots=0;continue}}else if(0<result.length){result=\"\";lastSegmentLength=0;lastSlash=index;dots=0;continue}joined&&(result=0<result.length?result+\"/..\":\"..\",lastSegmentLength=2)}else result=0<result.length?result+(\"/\"+segments.slice(lastSlash+1,index)):segments.slice(lastSlash+1,index),lastSegmentLength=index-lastSlash-1;lastSlash=index;dots=0}else 46===JSCompiler_temp&&-1<dots?dots++:dots=-1}JSCompiler_temp=result;0!==JSCompiler_temp.length||index$jscomp$0||(JSCompiler_temp=\".\");0<JSCompiler_temp.length&&\n47===segments.charCodeAt(segments.length-1)&&(JSCompiler_temp+=\"/\");JSCompiler_temp=index$jscomp$0?\"/\"+JSCompiler_temp:JSCompiler_temp}return JSCompiler_temp},sep:\"/\"}}","~:source","shadow$provide[\"module$node_modules$vfile$lib$minpath_browser\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.path = void 0;\n// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Nodeâ€™s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nconst path = {\n  basename,\n  dirname,\n  extname,\n  join,\n  sep: '/'\n};\n/* eslint-disable max-depth, complexity */\n\n/**\n * Get the basename from a path.\n *\n * @param {string} path\n *   File path.\n * @param {string | undefined} [ext]\n *   Extension to strip.\n * @returns {string}\n *   Stem or basename.\n */\n\nexports.path = path;\n\nfunction basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string');\n  }\n\n  assertPath(path);\n  let start = 0;\n  let end = -1;\n  let index = path.length;\n  /** @type {boolean | undefined} */\n\n  let seenNonSlash;\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47\n      /* `/` */\n      ) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1;\n          break;\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true;\n        end = index + 1;\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end);\n  }\n\n  if (ext === path) {\n    return '';\n  }\n\n  let firstNonSlashEnd = -1;\n  let extIndex = ext.length - 1;\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47\n    /* `/` */\n    ) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1;\n        break;\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true;\n        firstNonSlashEnd = index + 1;\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index;\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1;\n          end = firstNonSlashEnd;\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd;\n  } else if (end < 0) {\n    end = path.length;\n  }\n\n  return path.slice(start, end);\n}\n/**\n * Get the dirname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\n\n\nfunction dirname(path) {\n  assertPath(path);\n\n  if (path.length === 0) {\n    return '.';\n  }\n\n  let end = -1;\n  let index = path.length;\n  /** @type {boolean | undefined} */\n\n  let unmatchedSlash; // Prefix `--` is important to not run on `0`.\n\n  while (--index) {\n    if (path.charCodeAt(index) === 47\n    /* `/` */\n    ) {\n      if (unmatchedSlash) {\n        end = index;\n        break;\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true;\n    }\n  }\n\n  return end < 0 ? path.charCodeAt(0) === 47\n  /* `/` */\n  ? '/' : '.' : end === 1 && path.charCodeAt(0) === 47\n  /* `/` */\n  ? '//' : path.slice(0, end);\n}\n/**\n * Get an extname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   Extname.\n */\n\n\nfunction extname(path) {\n  assertPath(path);\n  let index = path.length;\n  let end = -1;\n  let startPart = 0;\n  let startDot = -1; // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n\n  let preDotState = 0;\n  /** @type {boolean | undefined} */\n\n  let unmatchedSlash;\n\n  while (index--) {\n    const code = path.charCodeAt(index);\n\n    if (code === 47\n    /* `/` */\n    ) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1;\n        break;\n      }\n\n      continue;\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true;\n      end = index + 1;\n    }\n\n    if (code === 46\n    /* `.` */\n    ) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index;\n      } else if (preDotState !== 1) {\n        preDotState = 1;\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1;\n    }\n  }\n\n  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.\n  preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n\n  return path.slice(startDot, end);\n}\n/**\n * Join segments from a path.\n *\n * @param {Array<string>} segments\n *   Path segments.\n * @returns {string}\n *   File path.\n */\n\n\nfunction join(...segments) {\n  let index = -1;\n  /** @type {string | undefined} */\n\n  let joined;\n\n  while (++index < segments.length) {\n    assertPath(segments[index]);\n\n    if (segments[index]) {\n      joined = joined === undefined ? segments[index] : joined + '/' + segments[index];\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined);\n}\n/**\n * Normalize a basic file path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\n\n\nfunction normalize(path) {\n  assertPath(path);\n  const absolute = path.charCodeAt(0) === 47;\n  /* `/` */\n  // Normalize the path according to POSIX rules.\n\n  let value = normalizeString(path, !absolute);\n\n  if (value.length === 0 && !absolute) {\n    value = '.';\n  }\n\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47\n  /* / */\n  ) {\n    value += '/';\n  }\n\n  return absolute ? '/' + value : value;\n}\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n *   File path.\n * @param {boolean} allowAboveRoot\n *   Whether `..` can move above root.\n * @returns {string}\n *   File path.\n */\n\n\nfunction normalizeString(path, allowAboveRoot) {\n  let result = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let index = -1;\n  /** @type {number | undefined} */\n\n  let code;\n  /** @type {number} */\n\n  let lastSlashIndex;\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index);\n    } else if (code === 47\n    /* `/` */\n    ) {\n      break;\n    } else {\n      code = 47;\n      /* `/` */\n    }\n\n    if (code === 47\n    /* `/` */\n    ) {\n      if (lastSlash === index - 1 || dots === 1) {// Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46\n        /* `.` */\n        || result.charCodeAt(result.length - 2) !== 46\n        /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/');\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = '';\n                lastSegmentLength = 0;\n              } else {\n                result = result.slice(0, lastSlashIndex);\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/');\n              }\n\n              lastSlash = index;\n              dots = 0;\n              continue;\n            }\n          } else if (result.length > 0) {\n            result = '';\n            lastSegmentLength = 0;\n            lastSlash = index;\n            dots = 0;\n            continue;\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index);\n        } else {\n          result = path.slice(lastSlash + 1, index);\n        }\n\n        lastSegmentLength = index - lastSlash - 1;\n      }\n\n      lastSlash = index;\n      dots = 0;\n    } else if (code === 46\n    /* `.` */\n    && dots > -1) {\n      dots++;\n    } else {\n      dots = -1;\n    }\n  }\n\n  return result;\n}\n/**\n * Make sure `path` is a string.\n *\n * @param {string} path\n *   File path.\n * @returns {asserts path is string}\n *   Nothing.\n */\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n/* eslint-enable max-depth, complexity */\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["extname","sep","__esModule","path","basename","value","dirname","join"]],"~:compiled-at",1676665867239,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vfile$lib$minpath_browser.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vfile/lib/minpath.browser.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vfile$lib$minpath_browser\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.path = void 0;\\n// A derivative work based on:\\n// <https://github.com/browserify/path-browserify>.\\n// Which is licensed:\\n//\\n// MIT License\\n//\\n// Copyright (c) 2013 James Halliday\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\\n// this software and associated documentation files (the \\\"Software\\\"), to deal in\\n// the Software without restriction, including without limitation the rights to\\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\\n// the Software, and to permit persons to whom the Software is furnished to do so,\\n// subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n// A derivative work based on:\\n//\\n// Parts of that are extracted from Node\\u2019s internal `path` module:\\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\\n// Which is licensed:\\n//\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\nconst path = {\\n  basename,\\n  dirname,\\n  extname,\\n  join,\\n  sep: '/'\\n};\\n/* eslint-disable max-depth, complexity */\\n\\n/**\\n * Get the basename from a path.\\n *\\n * @param {string} path\\n *   File path.\\n * @param {string | undefined} [ext]\\n *   Extension to strip.\\n * @returns {string}\\n *   Stem or basename.\\n */\\n\\nexports.path = path;\\n\\nfunction basename(path, ext) {\\n  if (ext !== undefined && typeof ext !== 'string') {\\n    throw new TypeError('\\\"ext\\\" argument must be a string');\\n  }\\n\\n  assertPath(path);\\n  let start = 0;\\n  let end = -1;\\n  let index = path.length;\\n  /** @type {boolean | undefined} */\\n\\n  let seenNonSlash;\\n\\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\\n    while (index--) {\\n      if (path.charCodeAt(index) === 47\\n      /* `/` */\\n      ) {\\n        // If we reached a path separator that was not part of a set of path\\n        // separators at the end of the string, stop now.\\n        if (seenNonSlash) {\\n          start = index + 1;\\n          break;\\n        }\\n      } else if (end < 0) {\\n        // We saw the first non-path separator, mark this as the end of our\\n        // path component.\\n        seenNonSlash = true;\\n        end = index + 1;\\n      }\\n    }\\n\\n    return end < 0 ? '' : path.slice(start, end);\\n  }\\n\\n  if (ext === path) {\\n    return '';\\n  }\\n\\n  let firstNonSlashEnd = -1;\\n  let extIndex = ext.length - 1;\\n\\n  while (index--) {\\n    if (path.charCodeAt(index) === 47\\n    /* `/` */\\n    ) {\\n      // If we reached a path separator that was not part of a set of path\\n      // separators at the end of the string, stop now.\\n      if (seenNonSlash) {\\n        start = index + 1;\\n        break;\\n      }\\n    } else {\\n      if (firstNonSlashEnd < 0) {\\n        // We saw the first non-path separator, remember this index in case\\n        // we need it if the extension ends up not matching.\\n        seenNonSlash = true;\\n        firstNonSlashEnd = index + 1;\\n      }\\n\\n      if (extIndex > -1) {\\n        // Try to match the explicit extension.\\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\\n          if (extIndex < 0) {\\n            // We matched the extension, so mark this as the end of our path\\n            // component\\n            end = index;\\n          }\\n        } else {\\n          // Extension does not match, so our result is the entire path\\n          // component\\n          extIndex = -1;\\n          end = firstNonSlashEnd;\\n        }\\n      }\\n    }\\n  }\\n\\n  if (start === end) {\\n    end = firstNonSlashEnd;\\n  } else if (end < 0) {\\n    end = path.length;\\n  }\\n\\n  return path.slice(start, end);\\n}\\n/**\\n * Get the dirname from a path.\\n *\\n * @param {string} path\\n *   File path.\\n * @returns {string}\\n *   File path.\\n */\\n\\n\\nfunction dirname(path) {\\n  assertPath(path);\\n\\n  if (path.length === 0) {\\n    return '.';\\n  }\\n\\n  let end = -1;\\n  let index = path.length;\\n  /** @type {boolean | undefined} */\\n\\n  let unmatchedSlash; // Prefix `--` is important to not run on `0`.\\n\\n  while (--index) {\\n    if (path.charCodeAt(index) === 47\\n    /* `/` */\\n    ) {\\n      if (unmatchedSlash) {\\n        end = index;\\n        break;\\n      }\\n    } else if (!unmatchedSlash) {\\n      // We saw the first non-path separator\\n      unmatchedSlash = true;\\n    }\\n  }\\n\\n  return end < 0 ? path.charCodeAt(0) === 47\\n  /* `/` */\\n  ? '/' : '.' : end === 1 && path.charCodeAt(0) === 47\\n  /* `/` */\\n  ? '//' : path.slice(0, end);\\n}\\n/**\\n * Get an extname from a path.\\n *\\n * @param {string} path\\n *   File path.\\n * @returns {string}\\n *   Extname.\\n */\\n\\n\\nfunction extname(path) {\\n  assertPath(path);\\n  let index = path.length;\\n  let end = -1;\\n  let startPart = 0;\\n  let startDot = -1; // Track the state of characters (if any) we see before our first dot and\\n  // after any path separator we find.\\n\\n  let preDotState = 0;\\n  /** @type {boolean | undefined} */\\n\\n  let unmatchedSlash;\\n\\n  while (index--) {\\n    const code = path.charCodeAt(index);\\n\\n    if (code === 47\\n    /* `/` */\\n    ) {\\n      // If we reached a path separator that was not part of a set of path\\n      // separators at the end of the string, stop now.\\n      if (unmatchedSlash) {\\n        startPart = index + 1;\\n        break;\\n      }\\n\\n      continue;\\n    }\\n\\n    if (end < 0) {\\n      // We saw the first non-path separator, mark this as the end of our\\n      // extension.\\n      unmatchedSlash = true;\\n      end = index + 1;\\n    }\\n\\n    if (code === 46\\n    /* `.` */\\n    ) {\\n      // If this is our first dot, mark it as the start of our extension.\\n      if (startDot < 0) {\\n        startDot = index;\\n      } else if (preDotState !== 1) {\\n        preDotState = 1;\\n      }\\n    } else if (startDot > -1) {\\n      // We saw a non-dot and non-path separator before our dot, so we should\\n      // have a good chance at having a non-empty extension.\\n      preDotState = -1;\\n    }\\n  }\\n\\n  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.\\n  preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\\n    return '';\\n  }\\n\\n  return path.slice(startDot, end);\\n}\\n/**\\n * Join segments from a path.\\n *\\n * @param {Array<string>} segments\\n *   Path segments.\\n * @returns {string}\\n *   File path.\\n */\\n\\n\\nfunction join(...segments) {\\n  let index = -1;\\n  /** @type {string | undefined} */\\n\\n  let joined;\\n\\n  while (++index < segments.length) {\\n    assertPath(segments[index]);\\n\\n    if (segments[index]) {\\n      joined = joined === undefined ? segments[index] : joined + '/' + segments[index];\\n    }\\n  }\\n\\n  return joined === undefined ? '.' : normalize(joined);\\n}\\n/**\\n * Normalize a basic file path.\\n *\\n * @param {string} path\\n *   File path.\\n * @returns {string}\\n *   File path.\\n */\\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\\n// manually removed from it.\\n\\n\\nfunction normalize(path) {\\n  assertPath(path);\\n  const absolute = path.charCodeAt(0) === 47;\\n  /* `/` */\\n  // Normalize the path according to POSIX rules.\\n\\n  let value = normalizeString(path, !absolute);\\n\\n  if (value.length === 0 && !absolute) {\\n    value = '.';\\n  }\\n\\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47\\n  /* / */\\n  ) {\\n    value += '/';\\n  }\\n\\n  return absolute ? '/' + value : value;\\n}\\n/**\\n * Resolve `.` and `..` elements in a path with directory names.\\n *\\n * @param {string} path\\n *   File path.\\n * @param {boolean} allowAboveRoot\\n *   Whether `..` can move above root.\\n * @returns {string}\\n *   File path.\\n */\\n\\n\\nfunction normalizeString(path, allowAboveRoot) {\\n  let result = '';\\n  let lastSegmentLength = 0;\\n  let lastSlash = -1;\\n  let dots = 0;\\n  let index = -1;\\n  /** @type {number | undefined} */\\n\\n  let code;\\n  /** @type {number} */\\n\\n  let lastSlashIndex;\\n\\n  while (++index <= path.length) {\\n    if (index < path.length) {\\n      code = path.charCodeAt(index);\\n    } else if (code === 47\\n    /* `/` */\\n    ) {\\n      break;\\n    } else {\\n      code = 47;\\n      /* `/` */\\n    }\\n\\n    if (code === 47\\n    /* `/` */\\n    ) {\\n      if (lastSlash === index - 1 || dots === 1) {// Empty.\\n      } else if (lastSlash !== index - 1 && dots === 2) {\\n        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46\\n        /* `.` */\\n        || result.charCodeAt(result.length - 2) !== 46\\n        /* `.` */\\n        ) {\\n          if (result.length > 2) {\\n            lastSlashIndex = result.lastIndexOf('/');\\n\\n            if (lastSlashIndex !== result.length - 1) {\\n              if (lastSlashIndex < 0) {\\n                result = '';\\n                lastSegmentLength = 0;\\n              } else {\\n                result = result.slice(0, lastSlashIndex);\\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/');\\n              }\\n\\n              lastSlash = index;\\n              dots = 0;\\n              continue;\\n            }\\n          } else if (result.length > 0) {\\n            result = '';\\n            lastSegmentLength = 0;\\n            lastSlash = index;\\n            dots = 0;\\n            continue;\\n          }\\n        }\\n\\n        if (allowAboveRoot) {\\n          result = result.length > 0 ? result + '/..' : '..';\\n          lastSegmentLength = 2;\\n        }\\n      } else {\\n        if (result.length > 0) {\\n          result += '/' + path.slice(lastSlash + 1, index);\\n        } else {\\n          result = path.slice(lastSlash + 1, index);\\n        }\\n\\n        lastSegmentLength = index - lastSlash - 1;\\n      }\\n\\n      lastSlash = index;\\n      dots = 0;\\n    } else if (code === 46\\n    /* `.` */\\n    && dots > -1) {\\n      dots++;\\n    } else {\\n      dots = -1;\\n    }\\n  }\\n\\n  return result;\\n}\\n/**\\n * Make sure `path` is a string.\\n *\\n * @param {string} path\\n *   File path.\\n * @returns {asserts path is string}\\n *   Nothing.\\n */\\n\\n\\nfunction assertPath(path) {\\n  if (typeof path !== 'string') {\\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\\n  }\\n}\\n/* eslint-enable max-depth, complexity */\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"assertPath\",\"path\",\"TypeError\",\"JSON\",\"stringify\",\"Object\",\"defineProperty\",\"value\",\"basename\",\"ext\",\"undefined\",\"start\",\"end\",\"index\",\"length\",\"seenNonSlash\",\"charCodeAt\",\"slice\",\"firstNonSlashEnd\",\"extIndex\",\"dirname\",\"unmatchedSlash\",\"extname\",\"startPart\",\"startDot\",\"preDotState\",\"code\",\"join\",\"segments\",\"joined\",\"absolute\",\"result\",\"lastSegmentLength\",\"lastSlash\",\"dots\",\"lastSlashIndex\",\"lastIndexOf\",\"allowAboveRoot\",\"sep\"]\n}\n"]