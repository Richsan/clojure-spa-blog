["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/puppet.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$puppet=function(global,require,module,exports){function puppet(Prism){Prism.languages.puppet={heredoc:[{pattern:/(@\\(\"([^\"\\r\\n\\/):]+)\"(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r(?!\\n)))*?[ \\t]*(?:\\|[ \\t]*)?(?:-[ \\t]*)?\\2/,lookbehind:!0,alias:\"string\",inside:{punctuation:/(?=\\S).*\\S(?= *$)/}},{pattern:/(@\\(([^\"\\r\\n\\/):]+)(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r(?!\\n)))*?[ \\t]*(?:\\|[ \\t]*)?(?:-[ \\t]*)?\\2/,lookbehind:!0,greedy:!0,alias:\"string\",\ninside:{punctuation:/(?=\\S).*\\S(?= *$)/}},{pattern:/@\\(\"?(?:[^\"\\r\\n\\/):]+)\"?(?:\\/[nrts$uL]*)?\\)/,alias:\"string\",inside:{punctuation:{pattern:/(\\().+?(?=\\))/,lookbehind:!0}}}],\"multiline-comment\":{pattern:/(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,lookbehind:!0,greedy:!0,alias:\"comment\"},regex:{pattern:/((?:\\bnode\\s+|[~=\\(\\[\\{,]\\s*|[=+]>\\s*|^\\s*))\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/(?:[imx]+\\b|\\B)/,lookbehind:!0,greedy:!0,inside:{\"extended-regex\":{pattern:/^\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/[im]*x[im]*$/,inside:{comment:/#.*/}}}},comment:{pattern:/(^|[^\\\\])#.*/,\nlookbehind:!0,greedy:!0},string:{pattern:/([\"'])(?:\\$\\{(?:[^'\"}]|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}|\\$(?!\\{)|(?!\\1)[^\\\\$]|\\\\[\\s\\S])*\\1/,greedy:!0,inside:{\"double-quoted\":{pattern:/^\"[\\s\\S]*\"$/,inside:{}}}},variable:{pattern:/\\$(?:::)?\\w+(?:::\\w+)*/,inside:{punctuation:/::/}},\"attr-name\":/(?:\\b\\w+|\\*)(?=\\s*=>)/,function:[{pattern:/(\\.)(?!\\d)\\w+/,lookbehind:!0},/\\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\\b|\\b(?!\\d)\\w+(?=\\()/],number:/\\b(?:0x[a-f\\d]+|\\d+(?:\\.\\d+)?(?:e-?\\d+)?)\\b/i,\nboolean:/\\b(?:false|true)\\b/,keyword:/\\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\\b/,datatype:{pattern:/\\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\\b/,alias:\"symbol\"},operator:/=[=~>]?|![=~]?|<(?:<\\|?|[=~|-])?|>[>=]?|->?|~>|\\|>?>?|[*\\/%+?]|\\b(?:and|in|or)\\b/,\npunctuation:/[\\[\\]{}().,;]|:+/};var interpolation=[{pattern:/(^|[^\\\\])\\$\\{(?:[^'\"{}]|\\{[^}]*\\}|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}/,lookbehind:!0,inside:{\"short-variable\":{pattern:/(^\\$\\{)(?!\\w+\\()(?:::)?\\w+(?:::\\w+)*/,lookbehind:!0,alias:\"variable\",inside:{punctuation:/::/}},delimiter:{pattern:/^\\$/,alias:\"variable\"},rest:Prism.languages.puppet}},{pattern:/(^|[^\\\\])\\$(?:::)?\\w+(?:::\\w+)*/,lookbehind:!0,alias:\"variable\",inside:{punctuation:/::/}}];Prism.languages.puppet.heredoc[0].inside.interpolation=\ninterpolation;Prism.languages.puppet.string.inside[\"double-quoted\"].inside.interpolation=interpolation}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=puppet;puppet.displayName=\"puppet\";puppet.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$puppet\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = puppet;\n// @ts-nocheck\npuppet.displayName = 'puppet';\npuppet.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction puppet(Prism) {\n  ;\n\n  (function (Prism) {\n    Prism.languages.puppet = {\n      heredoc: [// Matches the content of a quoted heredoc string (subject to interpolation)\n      {\n        pattern: /(@\\(\"([^\"\\r\\n\\/):]+)\"(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r(?!\\n)))*?[ \\t]*(?:\\|[ \\t]*)?(?:-[ \\t]*)?\\2/,\n        lookbehind: true,\n        alias: 'string',\n        inside: {\n          // Matches the end tag\n          punctuation: /(?=\\S).*\\S(?= *$)/ // See interpolation below\n\n        }\n      }, // Matches the content of an unquoted heredoc string (no interpolation)\n      {\n        pattern: /(@\\(([^\"\\r\\n\\/):]+)(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r(?!\\n)))*?[ \\t]*(?:\\|[ \\t]*)?(?:-[ \\t]*)?\\2/,\n        lookbehind: true,\n        greedy: true,\n        alias: 'string',\n        inside: {\n          // Matches the end tag\n          punctuation: /(?=\\S).*\\S(?= *$)/\n        }\n      }, // Matches the start tag of heredoc strings\n      {\n        pattern: /@\\(\"?(?:[^\"\\r\\n\\/):]+)\"?(?:\\/[nrts$uL]*)?\\)/,\n        alias: 'string',\n        inside: {\n          punctuation: {\n            pattern: /(\\().+?(?=\\))/,\n            lookbehind: true\n          }\n        }\n      }],\n      'multiline-comment': {\n        pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,\n        lookbehind: true,\n        greedy: true,\n        alias: 'comment'\n      },\n      regex: {\n        // Must be prefixed with the keyword \"node\" or a non-word char\n        pattern: /((?:\\bnode\\s+|[~=\\(\\[\\{,]\\s*|[=+]>\\s*|^\\s*))\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/(?:[imx]+\\b|\\B)/,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          // Extended regexes must have the x flag. They can contain single-line comments.\n          'extended-regex': {\n            pattern: /^\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/[im]*x[im]*$/,\n            inside: {\n              comment: /#.*/\n            }\n          }\n        }\n      },\n      comment: {\n        pattern: /(^|[^\\\\])#.*/,\n        lookbehind: true,\n        greedy: true\n      },\n      string: {\n        // Allow for one nested level of double quotes inside interpolation\n        pattern: /([\"'])(?:\\$\\{(?:[^'\"}]|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}|\\$(?!\\{)|(?!\\1)[^\\\\$]|\\\\[\\s\\S])*\\1/,\n        greedy: true,\n        inside: {\n          'double-quoted': {\n            pattern: /^\"[\\s\\S]*\"$/,\n            inside: {// See interpolation below\n            }\n          }\n        }\n      },\n      variable: {\n        pattern: /\\$(?:::)?\\w+(?:::\\w+)*/,\n        inside: {\n          punctuation: /::/\n        }\n      },\n      'attr-name': /(?:\\b\\w+|\\*)(?=\\s*=>)/,\n      function: [{\n        pattern: /(\\.)(?!\\d)\\w+/,\n        lookbehind: true\n      }, /\\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\\b|\\b(?!\\d)\\w+(?=\\()/],\n      number: /\\b(?:0x[a-f\\d]+|\\d+(?:\\.\\d+)?(?:e-?\\d+)?)\\b/i,\n      boolean: /\\b(?:false|true)\\b/,\n      // Includes words reserved for future use\n      keyword: /\\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\\b/,\n      datatype: {\n        pattern: /\\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\\b/,\n        alias: 'symbol'\n      },\n      operator: /=[=~>]?|![=~]?|<(?:<\\|?|[=~|-])?|>[>=]?|->?|~>|\\|>?>?|[*\\/%+?]|\\b(?:and|in|or)\\b/,\n      punctuation: /[\\[\\]{}().,;]|:+/\n    };\n    var interpolation = [{\n      // Allow for one nested level of braces inside interpolation\n      pattern: /(^|[^\\\\])\\$\\{(?:[^'\"{}]|\\{[^}]*\\}|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}/,\n      lookbehind: true,\n      inside: {\n        'short-variable': {\n          // Negative look-ahead prevent wrong highlighting of functions\n          pattern: /(^\\$\\{)(?!\\w+\\()(?:::)?\\w+(?:::\\w+)*/,\n          lookbehind: true,\n          alias: 'variable',\n          inside: {\n            punctuation: /::/\n          }\n        },\n        delimiter: {\n          pattern: /^\\$/,\n          alias: 'variable'\n        },\n        rest: Prism.languages.puppet\n      }\n    }, {\n      pattern: /(^|[^\\\\])\\$(?:::)?\\w+(?:::\\w+)*/,\n      lookbehind: true,\n      alias: 'variable',\n      inside: {\n        punctuation: /::/\n      }\n    }];\n    Prism.languages.puppet['heredoc'][0].inside.interpolation = interpolation;\n    Prism.languages.puppet['string'].inside['double-quoted'].inside.interpolation = interpolation;\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["boolean","punctuation","string","aliases","operator","displayName","__esModule","regex","rest","lookbehind","value","delimiter","variable","keyword","number","greedy","function","puppet","pattern","inside","datatype","alias","comment","heredoc","interpolation","default"]],"~:compiled-at",1676841365450,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$puppet.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lang/puppet.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$puppet\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = puppet;\\n// @ts-nocheck\\npuppet.displayName = 'puppet';\\npuppet.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction puppet(Prism) {\\n  ;\\n\\n  (function (Prism) {\\n    Prism.languages.puppet = {\\n      heredoc: [// Matches the content of a quoted heredoc string (subject to interpolation)\\n      {\\n        pattern: /(@\\\\(\\\"([^\\\"\\\\r\\\\n\\\\/):]+)\\\"(?:\\\\/[nrts$uL]*)?\\\\).*(?:\\\\r?\\\\n|\\\\r))(?:.*(?:\\\\r?\\\\n|\\\\r(?!\\\\n)))*?[ \\\\t]*(?:\\\\|[ \\\\t]*)?(?:-[ \\\\t]*)?\\\\2/,\\n        lookbehind: true,\\n        alias: 'string',\\n        inside: {\\n          // Matches the end tag\\n          punctuation: /(?=\\\\S).*\\\\S(?= *$)/ // See interpolation below\\n\\n        }\\n      }, // Matches the content of an unquoted heredoc string (no interpolation)\\n      {\\n        pattern: /(@\\\\(([^\\\"\\\\r\\\\n\\\\/):]+)(?:\\\\/[nrts$uL]*)?\\\\).*(?:\\\\r?\\\\n|\\\\r))(?:.*(?:\\\\r?\\\\n|\\\\r(?!\\\\n)))*?[ \\\\t]*(?:\\\\|[ \\\\t]*)?(?:-[ \\\\t]*)?\\\\2/,\\n        lookbehind: true,\\n        greedy: true,\\n        alias: 'string',\\n        inside: {\\n          // Matches the end tag\\n          punctuation: /(?=\\\\S).*\\\\S(?= *$)/\\n        }\\n      }, // Matches the start tag of heredoc strings\\n      {\\n        pattern: /@\\\\(\\\"?(?:[^\\\"\\\\r\\\\n\\\\/):]+)\\\"?(?:\\\\/[nrts$uL]*)?\\\\)/,\\n        alias: 'string',\\n        inside: {\\n          punctuation: {\\n            pattern: /(\\\\().+?(?=\\\\))/,\\n            lookbehind: true\\n          }\\n        }\\n      }],\\n      'multiline-comment': {\\n        pattern: /(^|[^\\\\\\\\])\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\//,\\n        lookbehind: true,\\n        greedy: true,\\n        alias: 'comment'\\n      },\\n      regex: {\\n        // Must be prefixed with the keyword \\\"node\\\" or a non-word char\\n        pattern: /((?:\\\\bnode\\\\s+|[~=\\\\(\\\\[\\\\{,]\\\\s*|[=+]>\\\\s*|^\\\\s*))\\\\/(?:[^\\\\/\\\\\\\\]|\\\\\\\\[\\\\s\\\\S])+\\\\/(?:[imx]+\\\\b|\\\\B)/,\\n        lookbehind: true,\\n        greedy: true,\\n        inside: {\\n          // Extended regexes must have the x flag. They can contain single-line comments.\\n          'extended-regex': {\\n            pattern: /^\\\\/(?:[^\\\\/\\\\\\\\]|\\\\\\\\[\\\\s\\\\S])+\\\\/[im]*x[im]*$/,\\n            inside: {\\n              comment: /#.*/\\n            }\\n          }\\n        }\\n      },\\n      comment: {\\n        pattern: /(^|[^\\\\\\\\])#.*/,\\n        lookbehind: true,\\n        greedy: true\\n      },\\n      string: {\\n        // Allow for one nested level of double quotes inside interpolation\\n        pattern: /([\\\"'])(?:\\\\$\\\\{(?:[^'\\\"}]|([\\\"'])(?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\[\\\\s\\\\S])*\\\\2)+\\\\}|\\\\$(?!\\\\{)|(?!\\\\1)[^\\\\\\\\$]|\\\\\\\\[\\\\s\\\\S])*\\\\1/,\\n        greedy: true,\\n        inside: {\\n          'double-quoted': {\\n            pattern: /^\\\"[\\\\s\\\\S]*\\\"$/,\\n            inside: {// See interpolation below\\n            }\\n          }\\n        }\\n      },\\n      variable: {\\n        pattern: /\\\\$(?:::)?\\\\w+(?:::\\\\w+)*/,\\n        inside: {\\n          punctuation: /::/\\n        }\\n      },\\n      'attr-name': /(?:\\\\b\\\\w+|\\\\*)(?=\\\\s*=>)/,\\n      function: [{\\n        pattern: /(\\\\.)(?!\\\\d)\\\\w+/,\\n        lookbehind: true\\n      }, /\\\\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\\\\b|\\\\b(?!\\\\d)\\\\w+(?=\\\\()/],\\n      number: /\\\\b(?:0x[a-f\\\\d]+|\\\\d+(?:\\\\.\\\\d+)?(?:e-?\\\\d+)?)\\\\b/i,\\n      boolean: /\\\\b(?:false|true)\\\\b/,\\n      // Includes words reserved for future use\\n      keyword: /\\\\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\\\\b/,\\n      datatype: {\\n        pattern: /\\\\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\\\\b/,\\n        alias: 'symbol'\\n      },\\n      operator: /=[=~>]?|![=~]?|<(?:<\\\\|?|[=~|-])?|>[>=]?|->?|~>|\\\\|>?>?|[*\\\\/%+?]|\\\\b(?:and|in|or)\\\\b/,\\n      punctuation: /[\\\\[\\\\]{}().,;]|:+/\\n    };\\n    var interpolation = [{\\n      // Allow for one nested level of braces inside interpolation\\n      pattern: /(^|[^\\\\\\\\])\\\\$\\\\{(?:[^'\\\"{}]|\\\\{[^}]*\\\\}|([\\\"'])(?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\[\\\\s\\\\S])*\\\\2)+\\\\}/,\\n      lookbehind: true,\\n      inside: {\\n        'short-variable': {\\n          // Negative look-ahead prevent wrong highlighting of functions\\n          pattern: /(^\\\\$\\\\{)(?!\\\\w+\\\\()(?:::)?\\\\w+(?:::\\\\w+)*/,\\n          lookbehind: true,\\n          alias: 'variable',\\n          inside: {\\n            punctuation: /::/\\n          }\\n        },\\n        delimiter: {\\n          pattern: /^\\\\$/,\\n          alias: 'variable'\\n        },\\n        rest: Prism.languages.puppet\\n      }\\n    }, {\\n      pattern: /(^|[^\\\\\\\\])\\\\$(?:::)?\\\\w+(?:::\\\\w+)*/,\\n      lookbehind: true,\\n      alias: 'variable',\\n      inside: {\\n        punctuation: /::/\\n      }\\n    }];\\n    Prism.languages.puppet['heredoc'][0].inside.interpolation = interpolation;\\n    Prism.languages.puppet['string'].inside['double-quoted'].inside.interpolation = interpolation;\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"puppet\",\"Prism\",\"languages\",\"heredoc\",\"pattern\",\"lookbehind\",\"alias\",\"inside\",\"punctuation\",\"greedy\",\"regex\",\"comment\",\"string\",\"variable\",\"function\",\"number\",\"boolean\",\"keyword\",\"datatype\",\"operator\",\"interpolation\",\"delimiter\",\"rest\",\"Object\",\"defineProperty\",\"value\",\"default\",\"displayName\",\"aliases\"]\n}\n"]