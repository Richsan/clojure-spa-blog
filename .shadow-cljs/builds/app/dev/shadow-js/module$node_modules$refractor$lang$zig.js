["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/zig.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$zig=function(global,require,module,exports){function zig(Prism$jscomp$0){(function(Prism){function literal(str){return function(){return str}}var keyword=/\\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/,\nIDENTIFIER=\"\\\\b(?!\"+keyword.source+\")(?!\\\\d)\\\\w+\\\\b\",ALIGN=/align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source,PREFIX_TYPE_OP=/(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(/<ALIGN>/g,literal(ALIGN));IDENTIFIER=/(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(/<ID>/g,literal(IDENTIFIER));PREFIX_TYPE_OP=\"(?!\\\\s)(?:!?\\\\s*(?:\"+PREFIX_TYPE_OP+\"\\\\s*)*\"+IDENTIFIER+\")+\";Prism.languages.zig={comment:[{pattern:/\\/\\/[/!].*/,\nalias:\"doc-comment\"},/\\/{2}.*/],string:[{pattern:/(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,lookbehind:!0,greedy:!0},{pattern:/([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,lookbehind:!0,greedy:!0}],char:{pattern:/(^|[^\\\\])'(?:[^'\\\\\\r\\n]|[\\uD800-\\uDFFF]{2}|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,lookbehind:!0,greedy:!0},builtin:/\\B@(?!\\d)\\w+(?=\\s*\\()/,label:{pattern:/(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,lookbehind:!0},\"class-name\":[/\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/,\n{pattern:RegExp(/(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source.replace(/<TYPE>/g,literal(PREFIX_TYPE_OP)).replace(/<ALIGN>/g,literal(ALIGN))),lookbehind:!0,inside:null},{pattern:RegExp(/(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source.replace(/<TYPE>/g,literal(PREFIX_TYPE_OP)).replace(/<ALIGN>/g,literal(ALIGN))),lookbehind:!0,inside:null}],\"builtin-type\":{pattern:/\\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\\b/,\nalias:\"keyword\"},keyword,function:/\\b(?!\\d)\\w+(?=\\s*\\()/,number:/\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+(?:\\.[a-fA-F\\d]*)?(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\b/,boolean:/\\b(?:false|true)\\b/,operator:/\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,punctuation:/[.:,;(){}[\\]]/};Prism.languages.zig[\"class-name\"].forEach(function(obj){null===obj.inside&&(obj.inside=Prism.languages.zig)})})(Prism$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});\nexports.default=zig;zig.displayName=\"zig\";zig.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$zig\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = zig;\n// @ts-nocheck\nzig.displayName = 'zig';\nzig.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction zig(Prism) {\n  ;\n\n  (function (Prism) {\n    function literal(str) {\n      return function () {\n        return str;\n      };\n    }\n\n    var keyword = /\\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/;\n    var IDENTIFIER = '\\\\b(?!' + keyword.source + ')(?!\\\\d)\\\\w+\\\\b';\n    var ALIGN = /align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source;\n    var PREFIX_TYPE_OP = /(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(/<ALIGN>/g, literal(ALIGN));\n    var SUFFIX_EXPR = /(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(/<ID>/g, literal(IDENTIFIER));\n    var TYPE = '(?!\\\\s)(?:!?\\\\s*(?:' + PREFIX_TYPE_OP + '\\\\s*)*' + SUFFIX_EXPR + ')+';\n    /*\n     * A simplified grammar for Zig compile time type literals:\n     *\n     * TypeExpr = ( \"!\"? PREFIX_TYPE_OP* SUFFIX_EXPR )+\n     *\n     * SUFFIX_EXPR = ( \\b \"promise\" \\b | ( \\b \"error\" \".\" )? IDENTIFIER ( \".\" IDENTIFIER )* (?! \\s+ IDENTIFIER ) )\n     *\n     * PREFIX_TYPE_OP = \"?\"\n     *                | \\b \"promise\" \"->\"\n     *                | ( \"[\" [^\\[\\]]* \"]\" | \"*\" | \"**\" ) ( ALIGN | \"const\" \\b | \"volatile\" \\b | \"allowzero\" \\b )*\n     *\n     * ALIGN = \"align\" \"(\" ( [^()] | \"(\" [^()]* \")\" )* \")\"\n     *\n     * IDENTIFIER = \\b (?! KEYWORD ) [a-zA-Z_] \\w* \\b\n     *\n     */\n\n    Prism.languages.zig = {\n      comment: [{\n        pattern: /\\/\\/[/!].*/,\n        alias: 'doc-comment'\n      }, /\\/{2}.*/],\n      string: [{\n        // \"string\" and c\"string\"\n        pattern: /(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n        lookbehind: true,\n        greedy: true\n      }, {\n        // multiline strings and c-strings\n        pattern: /([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,\n        lookbehind: true,\n        greedy: true\n      }],\n      char: {\n        // characters 'a', '\\n', '\\xFF', '\\u{10FFFF}'\n        pattern: /(^|[^\\\\])'(?:[^'\\\\\\r\\n]|[\\uD800-\\uDFFF]{2}|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,\n        lookbehind: true,\n        greedy: true\n      },\n      builtin: /\\B@(?!\\d)\\w+(?=\\s*\\()/,\n      label: {\n        pattern: /(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,\n        lookbehind: true\n      },\n      'class-name': [// const Foo = struct {};\n      /\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/, {\n        // const x: i32 = 9;\n        // var x: Bar;\n        // fn foo(x: bool, y: f32) void {}\n        pattern: RegExp(/(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n        lookbehind: true,\n        inside: null // see below\n\n      }, {\n        // extern fn foo(x: f64) f64; (optional alignment)\n        pattern: RegExp(/(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n        lookbehind: true,\n        inside: null // see below\n\n      }],\n      'builtin-type': {\n        pattern: /\\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\\b/,\n        alias: 'keyword'\n      },\n      keyword: keyword,\n      function: /\\b(?!\\d)\\w+(?=\\s*\\()/,\n      number: /\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+(?:\\.[a-fA-F\\d]*)?(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\b/,\n      boolean: /\\b(?:false|true)\\b/,\n      operator: /\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,\n      punctuation: /[.:,;(){}[\\]]/\n    };\n    Prism.languages.zig['class-name'].forEach(function (obj) {\n      if (obj.inside === null) {\n        obj.inside = Prism.languages.zig;\n      }\n    });\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["boolean","punctuation","string","aliases","zig","operator","displayName","label","__esModule","lookbehind","value","char","keyword","number","greedy","function","pattern","inside","alias","comment","builtin","default"]],"~:compiled-at",1676841365478,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$zig.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lang/zig.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$zig\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = zig;\\n// @ts-nocheck\\nzig.displayName = 'zig';\\nzig.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction zig(Prism) {\\n  ;\\n\\n  (function (Prism) {\\n    function literal(str) {\\n      return function () {\\n        return str;\\n      };\\n    }\\n\\n    var keyword = /\\\\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\\\b/;\\n    var IDENTIFIER = '\\\\\\\\b(?!' + keyword.source + ')(?!\\\\\\\\d)\\\\\\\\w+\\\\\\\\b';\\n    var ALIGN = /align\\\\s*\\\\((?:[^()]|\\\\([^()]*\\\\))*\\\\)/.source;\\n    var PREFIX_TYPE_OP = /(?:\\\\?|\\\\bpromise->|(?:\\\\[[^[\\\\]]*\\\\]|\\\\*(?!\\\\*)|\\\\*\\\\*)(?:\\\\s*<ALIGN>|\\\\s*const\\\\b|\\\\s*volatile\\\\b|\\\\s*allowzero\\\\b)*)/.source.replace(/<ALIGN>/g, literal(ALIGN));\\n    var SUFFIX_EXPR = /(?:\\\\bpromise\\\\b|(?:\\\\berror\\\\.)?<ID>(?:\\\\.<ID>)*(?!\\\\s+<ID>))/.source.replace(/<ID>/g, literal(IDENTIFIER));\\n    var TYPE = '(?!\\\\\\\\s)(?:!?\\\\\\\\s*(?:' + PREFIX_TYPE_OP + '\\\\\\\\s*)*' + SUFFIX_EXPR + ')+';\\n    /*\\n     * A simplified grammar for Zig compile time type literals:\\n     *\\n     * TypeExpr = ( \\\"!\\\"? PREFIX_TYPE_OP* SUFFIX_EXPR )+\\n     *\\n     * SUFFIX_EXPR = ( \\\\b \\\"promise\\\" \\\\b | ( \\\\b \\\"error\\\" \\\".\\\" )? IDENTIFIER ( \\\".\\\" IDENTIFIER )* (?! \\\\s+ IDENTIFIER ) )\\n     *\\n     * PREFIX_TYPE_OP = \\\"?\\\"\\n     *                | \\\\b \\\"promise\\\" \\\"->\\\"\\n     *                | ( \\\"[\\\" [^\\\\[\\\\]]* \\\"]\\\" | \\\"*\\\" | \\\"**\\\" ) ( ALIGN | \\\"const\\\" \\\\b | \\\"volatile\\\" \\\\b | \\\"allowzero\\\" \\\\b )*\\n     *\\n     * ALIGN = \\\"align\\\" \\\"(\\\" ( [^()] | \\\"(\\\" [^()]* \\\")\\\" )* \\\")\\\"\\n     *\\n     * IDENTIFIER = \\\\b (?! KEYWORD ) [a-zA-Z_] \\\\w* \\\\b\\n     *\\n     */\\n\\n    Prism.languages.zig = {\\n      comment: [{\\n        pattern: /\\\\/\\\\/[/!].*/,\\n        alias: 'doc-comment'\\n      }, /\\\\/{2}.*/],\\n      string: [{\\n        // \\\"string\\\" and c\\\"string\\\"\\n        pattern: /(^|[^\\\\\\\\@])c?\\\"(?:[^\\\"\\\\\\\\\\\\r\\\\n]|\\\\\\\\.)*\\\"/,\\n        lookbehind: true,\\n        greedy: true\\n      }, {\\n        // multiline strings and c-strings\\n        pattern: /([\\\\r\\\\n])([ \\\\t]+c?\\\\\\\\{2}).*(?:(?:\\\\r\\\\n?|\\\\n)\\\\2.*)*/,\\n        lookbehind: true,\\n        greedy: true\\n      }],\\n      char: {\\n        // characters 'a', '\\\\n', '\\\\xFF', '\\\\u{10FFFF}'\\n        pattern: /(^|[^\\\\\\\\])'(?:[^'\\\\\\\\\\\\r\\\\n]|[\\\\uD800-\\\\uDFFF]{2}|\\\\\\\\(?:.|x[a-fA-F\\\\d]{2}|u\\\\{[a-fA-F\\\\d]{1,6}\\\\}))'/,\\n        lookbehind: true,\\n        greedy: true\\n      },\\n      builtin: /\\\\B@(?!\\\\d)\\\\w+(?=\\\\s*\\\\()/,\\n      label: {\\n        pattern: /(\\\\b(?:break|continue)\\\\s*:\\\\s*)\\\\w+\\\\b|\\\\b(?!\\\\d)\\\\w+\\\\b(?=\\\\s*:\\\\s*(?:\\\\{|while\\\\b))/,\\n        lookbehind: true\\n      },\\n      'class-name': [// const Foo = struct {};\\n      /\\\\b(?!\\\\d)\\\\w+(?=\\\\s*=\\\\s*(?:(?:extern|packed)\\\\s+)?(?:enum|struct|union)\\\\s*[({])/, {\\n        // const x: i32 = 9;\\n        // var x: Bar;\\n        // fn foo(x: bool, y: f32) void {}\\n        pattern: RegExp(/(:\\\\s*)<TYPE>(?=\\\\s*(?:<ALIGN>\\\\s*)?[=;,)])|<TYPE>(?=\\\\s*(?:<ALIGN>\\\\s*)?\\\\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\\n        lookbehind: true,\\n        inside: null // see below\\n\\n      }, {\\n        // extern fn foo(x: f64) f64; (optional alignment)\\n        pattern: RegExp(/(\\\\)\\\\s*)<TYPE>(?=\\\\s*(?:<ALIGN>\\\\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\\n        lookbehind: true,\\n        inside: null // see below\\n\\n      }],\\n      'builtin-type': {\\n        pattern: /\\\\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\\\\b/,\\n        alias: 'keyword'\\n      },\\n      keyword: keyword,\\n      function: /\\\\b(?!\\\\d)\\\\w+(?=\\\\s*\\\\()/,\\n      number: /\\\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\\\d]+(?:\\\\.[a-fA-F\\\\d]*)?(?:[pP][+-]?[a-fA-F\\\\d]+)?|\\\\d+(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)\\\\b/,\\n      boolean: /\\\\b(?:false|true)\\\\b/,\\n      operator: /\\\\.[*?]|\\\\.{2,3}|[-=]>|\\\\*\\\\*|\\\\+\\\\+|\\\\|\\\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,\\n      punctuation: /[.:,;(){}[\\\\]]/\\n    };\\n    Prism.languages.zig['class-name'].forEach(function (obj) {\\n      if (obj.inside === null) {\\n        obj.inside = Prism.languages.zig;\\n      }\\n    });\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"zig\",\"Prism\",\"literal\",\"str\",\"keyword\",\"IDENTIFIER\",\"source\",\"ALIGN\",\"PREFIX_TYPE_OP\",\"replace\",\"SUFFIX_EXPR\",\"TYPE\",\"languages\",\"comment\",\"pattern\",\"alias\",\"string\",\"lookbehind\",\"greedy\",\"char\",\"builtin\",\"label\",\"RegExp\",\"inside\",\"function\",\"number\",\"boolean\",\"operator\",\"punctuation\",\"forEach\",\"obj\",\"Object\",\"defineProperty\",\"value\",\"default\",\"displayName\",\"aliases\"]\n}\n"]