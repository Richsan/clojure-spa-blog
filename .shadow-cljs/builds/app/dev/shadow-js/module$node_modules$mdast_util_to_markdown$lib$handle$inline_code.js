["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mdast-util-to-markdown/lib/handle/inline-code.js"],"~:js","shadow$provide.module$node_modules$mdast_util_to_markdown$lib$handle$inline_code=function(global,require,module,exports){function inlineCode(node,_,state){node=node.value||\"\";_=\"`\";let index=-1;for(;(new RegExp(\"(^|[^`])\"+_+\"([^`]|$)\")).test(node);)_+=\"`\";for(/[^ \\r\\n]/.test(node)&&(/^[ \\r\\n]/.test(node)&&/[ \\r\\n]$/.test(node)||/^`|`$/.test(node))&&(node=\" \"+node+\" \");++index<state.unsafe.length;){var pattern=state.unsafe[index];const expression=(0,_patternCompile.patternCompile)(pattern);if(pattern.atBreak)for(;pattern=\nexpression.exec(node);){let position=pattern.index;10===node.charCodeAt(position)&&13===node.charCodeAt(position-1)&&position--;node=node.slice(0,position)+\" \"+node.slice(pattern.index+1)}}return _+node+_}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.inlineCode=inlineCode;var _patternCompile=require(\"module$node_modules$mdast_util_to_markdown$lib$util$pattern_compile\");inlineCode.peek=function(){return\"`\"}}","~:source","shadow$provide[\"module$node_modules$mdast_util_to_markdown$lib$handle$inline_code\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inlineCode = inlineCode;\n\nvar _patternCompile = require(\"../util/pattern-compile.js\");\n\n/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\ninlineCode.peek = inlineCodePeek;\n/**\n * @param {InlineCode} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\n\nfunction inlineCode(node, _, state) {\n  let value = node.value || '';\n  let sequence = '`';\n  let index = -1; // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`';\n  } // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n\n\n  if (/[^ \\r\\n]/.test(value) && (/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) || /^`|`$/.test(value))) {\n    value = ' ' + value + ' ';\n  } // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index];\n    const expression = (0, _patternCompile.patternCompile)(pattern);\n    /** @type {RegExpExecArray | null} */\n\n    let match; // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n\n    if (!pattern.atBreak) continue;\n\n    while (match = expression.exec(value)) {\n      let position = match.index; // Support CRLF (patterns only look for one of the characters).\n\n      if (value.charCodeAt(position) === 10\n      /* `\\n` */\n      && value.charCodeAt(position - 1) === 13\n      /* `\\r` */\n      ) {\n        position--;\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\n    }\n  }\n\n  return sequence + value + sequence;\n}\n/**\n * @returns {string}\n */\n\n\nfunction inlineCodePeek() {\n  return '`';\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mdast_util_to_markdown$lib$util$pattern_compile"]],"~:properties",["^5",["peek","inlineCode","__esModule","value"]],"~:compiled-at",1676841365340,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mdast_util_to_markdown$lib$handle$inline_code.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,iEAAA,CAAsF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAuB9HC,QAASA,WAAU,CAACC,IAAD,CAAOC,CAAP,CAAUC,KAAV,CAAiB,CAC9BC,IAAAA,CAAQH,IAAKG,CAAAA,KAAbA,EAAsB,EACtBC,EAAAA,CAAW,GACf,KAAIC,MAAQ,CAAC,CAIb,KAAA,CAAsDC,CAA/C,IAAIC,MAAJ,CAAW,UAAX,CAAwBH,CAAxB,CAAmC,UAAnC,CAA+CE,EAAAA,IAA/C,CAAoDH,IAApD,CAAP,CAAA,CACEC,CAAA,EAAY,GAgBd,KAXI,UAAWE,CAAAA,IAAX,CAAgBH,IAAhB,CAWJ,GAX+B,UAAWG,CAAAA,IAAX,CAAgBH,IAAhB,CAW/B,EAXyD,UAAWG,CAAAA,IAAX,CAAgBH,IAAhB,CAWzD,EAXmF,OAAQG,CAAAA,IAAR,CAAaH,IAAb,CAWnF,IAVEA,IAUF,CAVU,GAUV,CAVgBA,IAUhB,CAVwB,GAUxB,EAAO,EAAEE,KAAT,CAAiBH,KAAMM,CAAAA,MAAOC,CAAAA,MAA9B,CAAA,CAAsC,CACpC,IAAMC,QAAUR,KAAMM,CAAAA,MAAN,CAAaH,KAAb,CAChB,OAAMM,WAAa,GAAIC,eAAgBC,CAAAA,cAApB,EAAoCH,OAApC,CAOnB,IAAKA,OAAQI,CAAAA,OAAb,CAEA,IAAA,CAAOC,OAAP;AAAeJ,UAAWK,CAAAA,IAAX,CAAgBb,IAAhB,CAAf,CAAA,CAAuC,CACrC,IAAIc,SAAWF,OAAMV,CAAAA,KAEc,GAAnC,GAAIF,IAAMe,CAAAA,UAAN,CAAiBD,QAAjB,CAAJ,EAEsC,EAFtC,GAEGd,IAAMe,CAAAA,UAAN,CAAiBD,QAAjB,CAA4B,CAA5B,CAFH,EAKEA,QAAA,EAGFd,KAAA,CAAQA,IAAMgB,CAAAA,KAAN,CAAY,CAAZ,CAAeF,QAAf,CAAR,CAAmC,GAAnC,CAAyCd,IAAMgB,CAAAA,KAAN,CAAYJ,OAAMV,CAAAA,KAAlB,CAA0B,CAA1B,CAXJ,CAXH,CA0BtC,MAAOD,EAAP,CAAkBD,IAAlB,CAA0BC,CAlDQ,CApBpCgB,MAAOC,CAAAA,cAAP,CAAsBvB,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CK,MAAO,CAAA,CADoC,CAA7C,CAGAL,QAAQC,CAAAA,UAAR,CAAqBA,UAErB,KAAIa,gBAAkBhB,OAAA,CAAQ,qEAAR,CAOtBG,WAAWuB,CAAAA,IAAX,CAiEAC,QAAuB,EAAG,CACxB,MAAO,GADiB,CAhFoG;\",\n\"sources\":[\"node_modules/mdast-util-to-markdown/lib/handle/inline-code.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mdast_util_to_markdown$lib$handle$inline_code\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.inlineCode = inlineCode;\\n\\nvar _patternCompile = require(\\\"../util/pattern-compile.js\\\");\\n\\n/**\\n * @typedef {import('mdast').InlineCode} InlineCode\\n * @typedef {import('../types.js').Parent} Parent\\n * @typedef {import('../types.js').State} State\\n */\\ninlineCode.peek = inlineCodePeek;\\n/**\\n * @param {InlineCode} node\\n * @param {Parent | undefined} _\\n * @param {State} state\\n * @returns {string}\\n */\\n\\nfunction inlineCode(node, _, state) {\\n  let value = node.value || '';\\n  let sequence = '`';\\n  let index = -1; // If there is a single grave accent on its own in the code, use a fence of\\n  // two.\\n  // If there are two in a row, use one.\\n\\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\\n    sequence += '`';\\n  } // If this is not just spaces or eols (tabs don\\u2019t count), and either the\\n  // first or last character are a space, eol, or tick, then pad with spaces.\\n\\n\\n  if (/[^ \\\\r\\\\n]/.test(value) && (/^[ \\\\r\\\\n]/.test(value) && /[ \\\\r\\\\n]$/.test(value) || /^`|`$/.test(value))) {\\n    value = ' ' + value + ' ';\\n  } // We have a potential problem: certain characters after eols could result in\\n  // blocks being seen.\\n  // For example, if someone injected the string `'\\\\n# b'`, then that would\\n  // result in an ATX heading.\\n  // We can\\u2019t escape characters in `inlineCode`, but because eols are\\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\\n  // them out.\\n\\n\\n  while (++index < state.unsafe.length) {\\n    const pattern = state.unsafe[index];\\n    const expression = (0, _patternCompile.patternCompile)(pattern);\\n    /** @type {RegExpExecArray | null} */\\n\\n    let match; // Only look for `atBreak`s.\\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\\n    // CR.\\n\\n    if (!pattern.atBreak) continue;\\n\\n    while (match = expression.exec(value)) {\\n      let position = match.index; // Support CRLF (patterns only look for one of the characters).\\n\\n      if (value.charCodeAt(position) === 10\\n      /* `\\\\n` */\\n      && value.charCodeAt(position - 1) === 13\\n      /* `\\\\r` */\\n      ) {\\n        position--;\\n      }\\n\\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\\n    }\\n  }\\n\\n  return sequence + value + sequence;\\n}\\n/**\\n * @returns {string}\\n */\\n\\n\\nfunction inlineCodePeek() {\\n  return '`';\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"inlineCode\",\"node\",\"_\",\"state\",\"value\",\"sequence\",\"index\",\"test\",\"RegExp\",\"unsafe\",\"length\",\"pattern\",\"expression\",\"_patternCompile\",\"patternCompile\",\"atBreak\",\"match\",\"exec\",\"position\",\"charCodeAt\",\"slice\",\"Object\",\"defineProperty\",\"peek\",\"inlineCodePeek\"]\n}\n"]