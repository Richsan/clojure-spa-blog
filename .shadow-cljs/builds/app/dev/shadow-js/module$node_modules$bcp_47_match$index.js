["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/bcp-47-match/index.js"],"~:js","shadow$provide.module$node_modules$bcp_47_match$index=function(global,require,module,exports){function factory(check,filter){return function(tags,ranges){tags=cast(tags,\"tag\");ranges=cast(null===ranges||void 0===ranges?\"*\":ranges,\"range\");const matches=[];let rightIndex=-1;for(;++rightIndex<ranges.length;){const range=ranges[rightIndex].toLowerCase();if(!filter&&\"*\"===range)continue;let leftIndex=-1;const next=[];for(;++leftIndex<tags.length;)if(check(tags[leftIndex].toLowerCase(),range)){if(!filter)return tags[leftIndex];\nmatches.push(tags[leftIndex])}else next.push(tags[leftIndex]);tags=next}return filter?matches:void 0}}function cast(values,name){values=values&&\"string\"===typeof values?[values]:values;if(!(values&&\"object\"===typeof values&&\"length\"in values))throw Error(\"Invalid \"+name+\" `\"+values+\"`, expected non-empty string\");return values}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.lookup=exports.extendedFilter=exports.basicFilter=void 0;global=factory(function(tag,range){return\"*\"===range||\ntag===range||tag.includes(range+\"-\")},!0);exports.basicFilter=global;global=factory(function(tag,range){tag=tag.split(\"-\");range=range.split(\"-\");let leftIndex=0,rightIndex=0;if(\"*\"!==range[rightIndex]&&tag[leftIndex]!==range[rightIndex])return!1;leftIndex++;for(rightIndex++;rightIndex<range.length;)if(\"*\"===range[rightIndex])rightIndex++;else{if(!tag[leftIndex])return!1;if(tag[leftIndex]===range[rightIndex])leftIndex++,rightIndex++;else{if(1===tag[leftIndex].length)return!1;leftIndex++}}return!0},\n!0);exports.extendedFilter=global;global=factory(function(tag,range){for(;;){if(\"*\"===range||tag===range)return!0;let index=range.lastIndexOf(\"-\");if(0>index)return!1;\"-\"===range.charAt(index-2)&&(index-=2);range=range.slice(0,index)}},!1);exports.lookup=global}","~:source","shadow$provide[\"module$node_modules$bcp_47_match$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lookup = exports.extendedFilter = exports.basicFilter = void 0;\n\n/**\n * See <https://tools.ietf.org/html/rfc4647#section-3.1>\n * for more info on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n *   BCP-47 tag.\n * @typedef {Array<Tag>} Tags\n *   List of BCP-47 tags.\n * @typedef {string} Range\n *   RFC 4647 range.\n * @typedef {Array<Range>} Ranges\n *   List of RFC 4647 range.\n *\n * @callback Check\n *   An internal check.\n * @param {Tag} tag\n *   BCP-47 tag.\n * @param {Range} range\n *   RFC 4647 range.\n * @returns {boolean}\n *   Whether the range matches the tag.\n *\n * @typedef {FilterOrLookup<true>} Filter\n *   Filter: yields all tags that match a range.\n * @typedef {FilterOrLookup<false>} Lookup\n *   Lookup: yields the best tag that matches a range.\n */\n\n/**\n * @template {boolean} IsFilter\n *   Whether to filter or perform a lookup.\n * @callback FilterOrLookup\n *   A check.\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {IsFilter extends true ? Tags : Tag|undefined}\n *   Result.\n */\n\n/**\n * Factory to perform a filter or a lookup.\n *\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.\n * That way, earlier ranges matching any tag have precedence over later ranges.\n *\n * @template {boolean} IsFilter\n * @param {Check} check\n *   A check.\n * @param {IsFilter} filter\n *   Whether to filter or perform a lookup.\n * @returns {FilterOrLookup<IsFilter>}\n *   Filter or lookup.\n */\nfunction factory(check, filter) {\n  /**\n   * @param {Tag|Tags} tags\n   *   One or more BCP-47 tags.\n   * @param {Range|Ranges|undefined} [ranges='*']\n   *   One or more RFC 4647 ranges.\n   * @returns {IsFilter extends true ? Tags : Tag|undefined}\n   *   Result.\n   */\n  return function (tags, ranges) {\n    let left = cast(tags, 'tag');\n    const right = cast(ranges === null || ranges === undefined ? '*' : ranges, 'range');\n    /** @type {Tags} */\n\n    const matches = [];\n    let rightIndex = -1;\n\n    while (++rightIndex < right.length) {\n      const range = right[rightIndex].toLowerCase(); // Ignore wildcards in lookup mode.\n\n      if (!filter && range === '*') continue;\n      let leftIndex = -1;\n      /** @type {Tags} */\n\n      const next = [];\n\n      while (++leftIndex < left.length) {\n        if (check(left[leftIndex].toLowerCase(), range)) {\n          // Exit if this is a lookup and we have a match.\n          if (!filter) {\n            return left[leftIndex];\n          }\n\n          matches.push(left[leftIndex]);\n        } else {\n          next.push(left[leftIndex]);\n        }\n      }\n\n      left = next;\n    } // If this is a filter, return the list.  If it’s a lookup, we didn’t find\n    // a match, so return `undefined`.\n\n\n    return filter ? matches : undefined;\n  };\n}\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tags}\n *   List of BCP-47 tags.\n */\n\n\nconst basicFilter = factory(function (tag, range) {\n  return range === '*' || tag === range || tag.includes(range + '-');\n}, true);\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tags}\n *   List of BCP-47 tags.\n */\n\nexports.basicFilter = basicFilter;\nconst extendedFilter = factory(function (tag, range) {\n  // 3.3.2.1\n  const left = tag.split('-');\n  const right = range.split('-');\n  let leftIndex = 0;\n  let rightIndex = 0; // 3.3.2.2\n\n  if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n    return false;\n  }\n\n  leftIndex++;\n  rightIndex++; // 3.3.2.3\n\n  while (rightIndex < right.length) {\n    // 3.3.2.3.A\n    if (right[rightIndex] === '*') {\n      rightIndex++;\n      continue;\n    } // 3.3.2.3.B\n\n\n    if (!left[leftIndex]) return false; // 3.3.2.3.C\n\n    if (left[leftIndex] === right[rightIndex]) {\n      leftIndex++;\n      rightIndex++;\n      continue;\n    } // 3.3.2.3.D\n\n\n    if (left[leftIndex].length === 1) return false; // 3.3.2.3.E\n\n    leftIndex++;\n  } // 3.3.2.4\n\n\n  return true;\n}, true);\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tag|undefined}\n *   BCP-47 tag.\n */\n\nexports.extendedFilter = extendedFilter;\nconst lookup = factory(function (tag, range) {\n  let right = range;\n  /* eslint-disable-next-line no-constant-condition */\n\n  while (true) {\n    if (right === '*' || tag === right) return true;\n    let index = right.lastIndexOf('-');\n    if (index < 0) return false;\n    if (right.charAt(index - 2) === '-') index -= 2;\n    right = right.slice(0, index);\n  }\n}, false);\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array<string>} values\n * @param {string} name\n * @returns {Array<string>}\n */\n\nexports.lookup = lookup;\n\nfunction cast(values, name) {\n  const value = values && typeof values === 'string' ? [values] : values;\n\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error('Invalid ' + name + ' `' + value + '`, expected non-empty string');\n  }\n\n  return value;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["__esModule","basicFilter","lookup","value","extendedFilter"]],"~:compiled-at",1676841365494,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$bcp_47_match$index.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/bcp-47-match/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$bcp_47_match$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.lookup = exports.extendedFilter = exports.basicFilter = void 0;\\n\\n/**\\n * See <https://tools.ietf.org/html/rfc4647#section-3.1>\\n * for more info on the algorithms.\\n */\\n\\n/**\\n * @typedef {string} Tag\\n *   BCP-47 tag.\\n * @typedef {Array<Tag>} Tags\\n *   List of BCP-47 tags.\\n * @typedef {string} Range\\n *   RFC 4647 range.\\n * @typedef {Array<Range>} Ranges\\n *   List of RFC 4647 range.\\n *\\n * @callback Check\\n *   An internal check.\\n * @param {Tag} tag\\n *   BCP-47 tag.\\n * @param {Range} range\\n *   RFC 4647 range.\\n * @returns {boolean}\\n *   Whether the range matches the tag.\\n *\\n * @typedef {FilterOrLookup<true>} Filter\\n *   Filter: yields all tags that match a range.\\n * @typedef {FilterOrLookup<false>} Lookup\\n *   Lookup: yields the best tag that matches a range.\\n */\\n\\n/**\\n * @template {boolean} IsFilter\\n *   Whether to filter or perform a lookup.\\n * @callback FilterOrLookup\\n *   A check.\\n * @param {Tag|Tags} tags\\n *   One or more BCP-47 tags.\\n * @param {Range|Ranges|undefined} [ranges='*']\\n *   One or more RFC 4647 ranges.\\n * @returns {IsFilter extends true ? Tags : Tag|undefined}\\n *   Result.\\n */\\n\\n/**\\n * Factory to perform a filter or a lookup.\\n *\\n * This factory creates a function that accepts a list of tags and a list of\\n * ranges, and contains logic to exit early for lookups.\\n * `check` just has to deal with one tag and one range.\\n * This match function iterates over ranges, and for each range,\\n * iterates over tags.\\n * That way, earlier ranges matching any tag have precedence over later ranges.\\n *\\n * @template {boolean} IsFilter\\n * @param {Check} check\\n *   A check.\\n * @param {IsFilter} filter\\n *   Whether to filter or perform a lookup.\\n * @returns {FilterOrLookup<IsFilter>}\\n *   Filter or lookup.\\n */\\nfunction factory(check, filter) {\\n  /**\\n   * @param {Tag|Tags} tags\\n   *   One or more BCP-47 tags.\\n   * @param {Range|Ranges|undefined} [ranges='*']\\n   *   One or more RFC 4647 ranges.\\n   * @returns {IsFilter extends true ? Tags : Tag|undefined}\\n   *   Result.\\n   */\\n  return function (tags, ranges) {\\n    let left = cast(tags, 'tag');\\n    const right = cast(ranges === null || ranges === undefined ? '*' : ranges, 'range');\\n    /** @type {Tags} */\\n\\n    const matches = [];\\n    let rightIndex = -1;\\n\\n    while (++rightIndex < right.length) {\\n      const range = right[rightIndex].toLowerCase(); // Ignore wildcards in lookup mode.\\n\\n      if (!filter && range === '*') continue;\\n      let leftIndex = -1;\\n      /** @type {Tags} */\\n\\n      const next = [];\\n\\n      while (++leftIndex < left.length) {\\n        if (check(left[leftIndex].toLowerCase(), range)) {\\n          // Exit if this is a lookup and we have a match.\\n          if (!filter) {\\n            return left[leftIndex];\\n          }\\n\\n          matches.push(left[leftIndex]);\\n        } else {\\n          next.push(left[leftIndex]);\\n        }\\n      }\\n\\n      left = next;\\n    } // If this is a filter, return the list.  If it\\u2019s a lookup, we didn\\u2019t find\\n    // a match, so return `undefined`.\\n\\n\\n    return filter ? matches : undefined;\\n  };\\n}\\n/**\\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\\n * of basic language ranges (Section 2.1) to sets of language tags.\\n *\\n * @param {Tag|Tags} tags\\n *   One or more BCP-47 tags.\\n * @param {Range|Ranges|undefined} [ranges='*']\\n *   One or more RFC 4647 ranges.\\n * @returns {Tags}\\n *   List of BCP-47 tags.\\n */\\n\\n\\nconst basicFilter = factory(function (tag, range) {\\n  return range === '*' || tag === range || tag.includes(range + '-');\\n}, true);\\n/**\\n * Extended Filtering (Section 3.3.2) matches a language priority list\\n * consisting of extended language ranges (Section 2.2) to sets of language\\n * tags.\\n *\\n * @param {Tag|Tags} tags\\n *   One or more BCP-47 tags.\\n * @param {Range|Ranges|undefined} [ranges='*']\\n *   One or more RFC 4647 ranges.\\n * @returns {Tags}\\n *   List of BCP-47 tags.\\n */\\n\\nexports.basicFilter = basicFilter;\\nconst extendedFilter = factory(function (tag, range) {\\n  // 3.3.2.1\\n  const left = tag.split('-');\\n  const right = range.split('-');\\n  let leftIndex = 0;\\n  let rightIndex = 0; // 3.3.2.2\\n\\n  if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\\n    return false;\\n  }\\n\\n  leftIndex++;\\n  rightIndex++; // 3.3.2.3\\n\\n  while (rightIndex < right.length) {\\n    // 3.3.2.3.A\\n    if (right[rightIndex] === '*') {\\n      rightIndex++;\\n      continue;\\n    } // 3.3.2.3.B\\n\\n\\n    if (!left[leftIndex]) return false; // 3.3.2.3.C\\n\\n    if (left[leftIndex] === right[rightIndex]) {\\n      leftIndex++;\\n      rightIndex++;\\n      continue;\\n    } // 3.3.2.3.D\\n\\n\\n    if (left[leftIndex].length === 1) return false; // 3.3.2.3.E\\n\\n    leftIndex++;\\n  } // 3.3.2.4\\n\\n\\n  return true;\\n}, true);\\n/**\\n * Lookup (Section 3.4) matches a language priority list consisting of basic\\n * language ranges to sets of language tags to find the one exact language tag\\n * that best matches the range.\\n *\\n * @param {Tag|Tags} tags\\n *   One or more BCP-47 tags.\\n * @param {Range|Ranges|undefined} [ranges='*']\\n *   One or more RFC 4647 ranges.\\n * @returns {Tag|undefined}\\n *   BCP-47 tag.\\n */\\n\\nexports.extendedFilter = extendedFilter;\\nconst lookup = factory(function (tag, range) {\\n  let right = range;\\n  /* eslint-disable-next-line no-constant-condition */\\n\\n  while (true) {\\n    if (right === '*' || tag === right) return true;\\n    let index = right.lastIndexOf('-');\\n    if (index < 0) return false;\\n    if (right.charAt(index - 2) === '-') index -= 2;\\n    right = right.slice(0, index);\\n  }\\n}, false);\\n/**\\n * Validate tags or ranges, and cast them to arrays.\\n *\\n * @param {string|Array<string>} values\\n * @param {string} name\\n * @returns {Array<string>}\\n */\\n\\nexports.lookup = lookup;\\n\\nfunction cast(values, name) {\\n  const value = values && typeof values === 'string' ? [values] : values;\\n\\n  if (!value || typeof value !== 'object' || !('length' in value)) {\\n    throw new Error('Invalid ' + name + ' `' + value + '`, expected non-empty string');\\n  }\\n\\n  return value;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"check\",\"filter\",\"tags\",\"ranges\",\"left\",\"cast\",\"right\",\"undefined\",\"matches\",\"rightIndex\",\"length\",\"range\",\"toLowerCase\",\"leftIndex\",\"next\",\"push\",\"values\",\"name\",\"value\",\"Error\",\"Object\",\"defineProperty\",\"lookup\",\"extendedFilter\",\"basicFilter\",\"tag\",\"includes\",\"split\",\"index\",\"lastIndexOf\",\"charAt\",\"slice\"]\n}\n"]