["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-extension-math/lib/math-flow.js"],"~:js","shadow$provide.module$node_modules$micromark_extension_math$lib$math_flow=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.mathFlow=void 0;var _micromarkFactorySpace=require(\"module$node_modules$micromark_factory_space$index\"),_micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\");exports.mathFlow={tokenize:function(effects,ok,nok){function sequenceOpen(code){if(36===code)return effects.consume(code),sizeOpen++,sequenceOpen;\neffects.exit(\"mathFlowFenceSequence\");return 2>sizeOpen?nok(code):(0,_micromarkFactorySpace.factorySpace)(effects,metaOpen,\"whitespace\")(code)}function metaOpen(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return openAfter(code);effects.enter(\"mathFlowFenceMeta\");effects.enter(\"chunkString\",{contentType:\"string\"});return meta(code)}function meta(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.exit(\"chunkString\"),effects.exit(\"mathFlowFenceMeta\"),\nopenAfter(code);if(36===code)return nok(code);effects.consume(code);return meta}function openAfter(code){effects.exit(\"mathFlowFence\");return self.interrupt?ok(code):contentStart(code)}function contentStart(code){if(null===code)return after(code);if((0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.attempt(nonLazyLine,effects.attempt({tokenize:tokenizeClosingFence,partial:!0},after,initialSize?(0,_micromarkFactorySpace.factorySpace)(effects,contentStart,\"linePrefix\",initialSize+\n1):contentStart),after)(code);effects.enter(\"mathFlowValue\");return contentContinue(code)}function contentContinue(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.exit(\"mathFlowValue\"),contentStart(code);effects.consume(code);return contentContinue}function after(code){effects.exit(\"mathFlow\");return ok(code)}function tokenizeClosingFence(effects,ok,nok){function closingSequence(code){if(36===code)return effects.consume(code),size++,closingSequence;if(size<\nsizeOpen)return nok(code);effects.exit(\"mathFlowFenceSequence\");return(0,_micromarkFactorySpace.factorySpace)(effects,closingSequenceEnd,\"whitespace\")(code)}function closingSequenceEnd(code){return null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code)?(effects.exit(\"mathFlowFence\"),ok(code)):nok(code)}let size=0;return(0,_micromarkFactorySpace.factorySpace)(effects,function(code){effects.enter(\"mathFlowFence\");effects.enter(\"mathFlowFenceSequence\");return closingSequence(code)},\"linePrefix\",\n4)}const self=this,tail=self.events[self.events.length-1],initialSize=tail&&\"linePrefix\"===tail[1].type?tail[2].sliceSerialize(tail[1],!0).length:0;let sizeOpen=0;return function(code){effects.enter(\"mathFlow\");effects.enter(\"mathFlowFence\");effects.enter(\"mathFlowFenceSequence\");return sequenceOpen(code)}},concrete:!0};const nonLazyLine={tokenize:function(effects,ok,nok){function lineStart(code){return self.parser.lazy[self.now().line]?nok(code):ok(code)}const self=this;return function(code){effects.enter(\"lineEnding\");\neffects.consume(code);effects.exit(\"lineEnding\");return lineStart}},partial:!0}}","~:source","shadow$provide[\"module$node_modules$micromark_extension_math$lib$math_flow\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mathFlow = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\n\n/** @type {Construct} */\nconst mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n};\n/** @type {Construct} */\n\nexports.mathFlow = mathFlow;\nconst nonLazyLine = {\n  tokenize: tokenizeNonLazyLine,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  const initialSize = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('mathFlow');\n    effects.enter('mathFlowFence');\n    effects.enter('mathFlowFenceSequence');\n    return sequenceOpen(code);\n  }\n  /** @type {State} */\n\n\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n\n    effects.exit('mathFlowFenceSequence');\n    return sizeOpen < 2 ? nok(code) : (0, _micromarkFactorySpace.factorySpace)(effects, metaOpen, 'whitespace')(code);\n  }\n  /** @type {State} */\n\n\n  function metaOpen(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return openAfter(code);\n    }\n\n    effects.enter('mathFlowFenceMeta');\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return meta(code);\n  }\n  /** @type {State} */\n\n\n  function meta(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('chunkString');\n      effects.exit('mathFlowFenceMeta');\n      return openAfter(code);\n    }\n\n    if (code === 36) return nok(code);\n    effects.consume(code);\n    return meta;\n  }\n  /** @type {State} */\n\n\n  function openAfter(code) {\n    effects.exit('mathFlowFence');\n    return self.interrupt ? ok(code) : contentStart(code);\n  }\n  /** @type {State} */\n\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return effects.attempt(nonLazyLine, effects.attempt({\n        tokenize: tokenizeClosingFence,\n        partial: true\n      }, after, initialSize ? (0, _micromarkFactorySpace.factorySpace)(effects, contentStart, 'linePrefix', initialSize + 1) : contentStart), after)(code);\n    }\n\n    effects.enter('mathFlowValue');\n    return contentContinue(code);\n  }\n  /** @type {State} */\n\n\n  function contentContinue(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('mathFlowValue');\n      return contentStart(code);\n    }\n\n    effects.consume(code);\n    return contentContinue;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    effects.exit('mathFlow');\n    return ok(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    return (0, _micromarkFactorySpace.factorySpace)(effects, closingPrefixAfter, 'linePrefix', 4);\n    /** @type {State} */\n\n    function closingPrefixAfter(code) {\n      effects.enter('mathFlowFence');\n      effects.enter('mathFlowFenceSequence');\n      return closingSequence(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequence(code) {\n      if (code === 36) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      }\n\n      if (size < sizeOpen) return nok(code);\n      effects.exit('mathFlowFenceSequence');\n      return (0, _micromarkFactorySpace.factorySpace)(effects, closingSequenceEnd, 'whitespace')(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequenceEnd(code) {\n      if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n        effects.exit('mathFlowFence');\n        return ok(code);\n      }\n\n      return nok(code);\n    }\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNonLazyLine(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    return lineStart;\n  }\n  /** @type {State} */\n\n\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js","~$module$node_modules$micromark_factory_space$index"]],"~:properties",["^5",["partial","mathFlow","tokenize","concrete","__esModule","value","contentType"]],"~:compiled-at",1676667584429,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_extension_math$lib$math_flow.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-extension-math/lib/math-flow.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_extension_math$lib$math_flow\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.mathFlow = void 0;\\n\\nvar _micromarkFactorySpace = require(\\\"micromark-factory-space\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').State} State\\n */\\n\\n/** @type {Construct} */\\nconst mathFlow = {\\n  tokenize: tokenizeMathFenced,\\n  concrete: true\\n};\\n/** @type {Construct} */\\n\\nexports.mathFlow = mathFlow;\\nconst nonLazyLine = {\\n  tokenize: tokenizeNonLazyLine,\\n  partial: true\\n};\\n/** @type {Tokenizer} */\\n\\nfunction tokenizeMathFenced(effects, ok, nok) {\\n  const self = this;\\n  const tail = self.events[self.events.length - 1];\\n  const initialSize = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\\n  let sizeOpen = 0;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('mathFlow');\\n    effects.enter('mathFlowFence');\\n    effects.enter('mathFlowFenceSequence');\\n    return sequenceOpen(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function sequenceOpen(code) {\\n    if (code === 36) {\\n      effects.consume(code);\\n      sizeOpen++;\\n      return sequenceOpen;\\n    }\\n\\n    effects.exit('mathFlowFenceSequence');\\n    return sizeOpen < 2 ? nok(code) : (0, _micromarkFactorySpace.factorySpace)(effects, metaOpen, 'whitespace')(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function metaOpen(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      return openAfter(code);\\n    }\\n\\n    effects.enter('mathFlowFenceMeta');\\n    effects.enter('chunkString', {\\n      contentType: 'string'\\n    });\\n    return meta(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function meta(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.exit('chunkString');\\n      effects.exit('mathFlowFenceMeta');\\n      return openAfter(code);\\n    }\\n\\n    if (code === 36) return nok(code);\\n    effects.consume(code);\\n    return meta;\\n  }\\n  /** @type {State} */\\n\\n\\n  function openAfter(code) {\\n    effects.exit('mathFlowFence');\\n    return self.interrupt ? ok(code) : contentStart(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function contentStart(code) {\\n    if (code === null) {\\n      return after(code);\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      return effects.attempt(nonLazyLine, effects.attempt({\\n        tokenize: tokenizeClosingFence,\\n        partial: true\\n      }, after, initialSize ? (0, _micromarkFactorySpace.factorySpace)(effects, contentStart, 'linePrefix', initialSize + 1) : contentStart), after)(code);\\n    }\\n\\n    effects.enter('mathFlowValue');\\n    return contentContinue(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function contentContinue(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.exit('mathFlowValue');\\n      return contentStart(code);\\n    }\\n\\n    effects.consume(code);\\n    return contentContinue;\\n  }\\n  /** @type {State} */\\n\\n\\n  function after(code) {\\n    effects.exit('mathFlow');\\n    return ok(code);\\n  }\\n  /** @type {Tokenizer} */\\n\\n\\n  function tokenizeClosingFence(effects, ok, nok) {\\n    let size = 0;\\n    return (0, _micromarkFactorySpace.factorySpace)(effects, closingPrefixAfter, 'linePrefix', 4);\\n    /** @type {State} */\\n\\n    function closingPrefixAfter(code) {\\n      effects.enter('mathFlowFence');\\n      effects.enter('mathFlowFenceSequence');\\n      return closingSequence(code);\\n    }\\n    /** @type {State} */\\n\\n\\n    function closingSequence(code) {\\n      if (code === 36) {\\n        effects.consume(code);\\n        size++;\\n        return closingSequence;\\n      }\\n\\n      if (size < sizeOpen) return nok(code);\\n      effects.exit('mathFlowFenceSequence');\\n      return (0, _micromarkFactorySpace.factorySpace)(effects, closingSequenceEnd, 'whitespace')(code);\\n    }\\n    /** @type {State} */\\n\\n\\n    function closingSequenceEnd(code) {\\n      if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n        effects.exit('mathFlowFence');\\n        return ok(code);\\n      }\\n\\n      return nok(code);\\n    }\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeNonLazyLine(effects, ok, nok) {\\n  const self = this;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('lineEnding');\\n    effects.consume(code);\\n    effects.exit('lineEnding');\\n    return lineStart;\\n  }\\n  /** @type {State} */\\n\\n\\n  function lineStart(code) {\\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"mathFlow\",\"_micromarkFactorySpace\",\"_micromarkUtilCharacter\",\"tokenize\",\"tokenizeMathFenced\",\"effects\",\"ok\",\"nok\",\"sequenceOpen\",\"code\",\"consume\",\"sizeOpen\",\"exit\",\"factorySpace\",\"metaOpen\",\"markdownLineEnding\",\"openAfter\",\"enter\",\"contentType\",\"meta\",\"self\",\"interrupt\",\"contentStart\",\"after\",\"attempt\",\"nonLazyLine\",\"tokenizeClosingFence\",\"partial\",\"initialSize\",\"contentContinue\",\"closingSequence\",\"size\",\"closingSequenceEnd\",\"closingPrefixAfter\",\"tail\",\"events\",\"length\",\"type\",\"sliceSerialize\",\"start\",\"concrete\",\"tokenizeNonLazyLine\",\"lineStart\",\"parser\",\"lazy\",\"now\",\"line\"]\n}\n"]