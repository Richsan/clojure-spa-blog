["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-extension-gfm-footnote/lib/syntax.js"],"~:js","shadow$provide.module$node_modules$micromark_extension_gfm_footnote$lib$syntax=function(global,require,module,exports){function tokenizePotentialGfmFootnoteCall(effects,ok,nok){const self=this;let index=self.events.length;const defined=self.parser.gfmFootnotes||(self.parser.gfmFootnotes=[]);let labelStart;for(;index--;){const token=self.events[index][1];if(\"labelImage\"===token.type){labelStart=token;break}if(\"gfmFootnoteCall\"===token.type||\"labelLink\"===token.type||\"label\"===token.type||\"image\"===\ntoken.type||\"link\"===token.type)break}return function(code){if(!labelStart||!labelStart._balanced)return nok(code);const id=(0,_micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize({start:labelStart.end,end:self.now()}));if(94!==id.charCodeAt(0)||!defined.includes(id.slice(1)))return nok(code);effects.enter(\"gfmFootnoteCallLabelMarker\");effects.consume(code);effects.exit(\"gfmFootnoteCallLabelMarker\");return ok(code)}}function resolveToPotentialGfmFootnoteCall(events,context){let index=\nevents.length;for(;index--&&(\"labelImage\"!==events[index][1].type||\"enter\"!==events[index][0]););events[index+1][1].type=\"data\";events[index+3][1].type=\"gfmFootnoteCallLabelMarker\";const call={type:\"gfmFootnoteCall\",start:Object.assign({},events[index+3][1].start),end:Object.assign({},events[events.length-1][1].end)},marker={type:\"gfmFootnoteCallMarker\",start:Object.assign({},events[index+3][1].end),end:Object.assign({},events[index+3][1].end)};marker.end.column++;marker.end.offset++;marker.end._bufferIndex++;\nconst string={type:\"gfmFootnoteCallString\",start:Object.assign({},marker.end),end:Object.assign({},events[events.length-1][1].start)},chunk={type:\"chunkString\",contentType:\"string\",start:Object.assign({},string.start),end:Object.assign({},string.end)};events.splice(index,events.length-index+1,...[events[index+1],events[index+2],[\"enter\",call,context],events[index+3],events[index+4],[\"enter\",marker,context],[\"exit\",marker,context],[\"enter\",string,context],[\"enter\",chunk,context],[\"exit\",chunk,context],\n[\"exit\",string,context],events[events.length-2],events[events.length-1],[\"exit\",call,context]]);return events}function tokenizeGfmFootnoteCall(effects,ok,nok){function callStart(code){if(94!==code)return nok(code);effects.enter(\"gfmFootnoteCallMarker\");effects.consume(code);effects.exit(\"gfmFootnoteCallMarker\");effects.enter(\"gfmFootnoteCallString\");effects.enter(\"chunkString\").contentType=\"string\";return callData}function callData(code){let token;if(null===code||91===code||999<size++)return nok(code);\nif(93===code){if(!data)return nok(code);effects.exit(\"chunkString\");token=effects.exit(\"gfmFootnoteCallString\");defined.includes((0,_micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(token)))?(effects.enter(\"gfmFootnoteCallLabelMarker\"),effects.consume(code),effects.exit(\"gfmFootnoteCallLabelMarker\"),effects.exit(\"gfmFootnoteCall\"),code=ok):code=nok(code);return code}effects.consume(code);(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code)||(data=!0);return 92===code?\ncallEscape:callData}function callEscape(code){return 91===code||92===code||93===code?(effects.consume(code),size++,callData):callData(code)}const self=this,defined=self.parser.gfmFootnotes||(self.parser.gfmFootnotes=[]);let size=0,data;return function(code){effects.enter(\"gfmFootnoteCall\");effects.enter(\"gfmFootnoteCallLabelMarker\");effects.consume(code);effects.exit(\"gfmFootnoteCallLabelMarker\");return callStart}}function tokenizeDefinitionStart(effects,ok,nok){function labelStart(code){return 94===\ncode?(effects.enter(\"gfmFootnoteDefinitionMarker\"),effects.consume(code),effects.exit(\"gfmFootnoteDefinitionMarker\"),effects.enter(\"gfmFootnoteDefinitionLabelString\"),atBreak):nok(code)}function atBreak(code){let token;if(null===code||91===code||999<size)return nok(code);if(93===code){if(!data)return nok(code);token=effects.exit(\"gfmFootnoteDefinitionLabelString\");identifier=(0,_micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(token));effects.enter(\"gfmFootnoteDefinitionLabelMarker\");\neffects.consume(code);effects.exit(\"gfmFootnoteDefinitionLabelMarker\");effects.exit(\"gfmFootnoteDefinitionLabel\");return labelAfter}if((0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.enter(\"lineEnding\"),effects.consume(code),effects.exit(\"lineEnding\"),size++,atBreak;effects.enter(\"chunkString\").contentType=\"string\";return label(code)}function label(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code)||91===code||93===code||999<size)return effects.exit(\"chunkString\"),\natBreak(code);(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code)||(data=!0);size++;effects.consume(code);return 92===code?labelEscape:label}function labelEscape(code){return 91===code||92===code||93===code?(effects.consume(code),size++,label):label(code)}function labelAfter(code){return 58===code?(effects.enter(\"definitionMarker\"),effects.consume(code),effects.exit(\"definitionMarker\"),(0,_micromarkFactorySpace.factorySpace)(effects,done,\"gfmFootnoteDefinitionWhitespace\")):nok(code)}function done(code){defined.includes(identifier)||\ndefined.push(identifier);return ok(code)}const self=this,defined=self.parser.gfmFootnotes||(self.parser.gfmFootnotes=[]);let identifier,size=0,data;return function(code){effects.enter(\"gfmFootnoteDefinition\")._container=!0;effects.enter(\"gfmFootnoteDefinitionLabel\");effects.enter(\"gfmFootnoteDefinitionLabelMarker\");effects.consume(code);effects.exit(\"gfmFootnoteDefinitionLabelMarker\");return labelStart}}function tokenizeDefinitionContinuation(effects,ok,nok){return effects.check(_micromarkCoreCommonmark.blankLine,\nok,effects.attempt(indent,ok,nok))}function gfmFootnoteDefinitionEnd(effects){effects.exit(\"gfmFootnoteDefinition\")}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.gfmFootnote=function(){return{document:{[91]:{tokenize:tokenizeDefinitionStart,continuation:{tokenize:tokenizeDefinitionContinuation},exit:gfmFootnoteDefinitionEnd}},text:{[91]:{tokenize:tokenizeGfmFootnoteCall},[93]:{add:\"after\",tokenize:tokenizePotentialGfmFootnoteCall,resolveTo:resolveToPotentialGfmFootnoteCall}}}};var _micromarkCoreCommonmark=\nrequire(\"module$node_modules$micromark_core_commonmark$index\"),_micromarkFactorySpace=require(\"module$node_modules$micromark_factory_space$index\"),_micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\"),_micromarkUtilNormalizeIdentifier=require(\"module$node_modules$micromark_util_normalize_identifier$index\");const indent={tokenize:function(effects,ok,nok){const self=this;return(0,_micromarkFactorySpace.factorySpace)(effects,function(code){const tail=self.events[self.events.length-\n1];return tail&&\"gfmFootnoteDefinitionIndent\"===tail[1].type&&4===tail[2].sliceSerialize(tail[1],!0).length?ok(code):nok(code)},\"gfmFootnoteDefinitionIndent\",5)},partial:!0}}","~:source","shadow$provide[\"module$node_modules$micromark_extension_gfm_footnote$lib$syntax\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gfmFootnote = gfmFootnote;\n\nvar _micromarkCoreCommonmark = require(\"micromark-core-commonmark\");\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilNormalizeIdentifier = require(\"micromark-util-normalize-identifier\");\n\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n */\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\n/**\n * @returns {Extension}\n */\n\nfunction gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [91]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [91]: {\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [93]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  };\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {Token} */\n\n  let labelStart; // Find an opening.\n\n  while (index--) {\n    const token = self.events[index][1];\n\n    if (token.type === 'labelImage') {\n      labelStart = token;\n      break;\n    } // Exit if we’ve walked far enough.\n\n\n    if (token.type === 'gfmFootnoteCall' || token.type === 'labelLink' || token.type === 'label' || token.type === 'image' || token.type === 'link') {\n      break;\n    }\n  }\n\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code);\n    }\n\n    const id = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    }));\n\n    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code);\n    }\n\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return ok(code);\n  }\n}\n/** @type {Resolver} */\n\n\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length;\n  /** @type {Token|undefined} */\n\n  let labelStart; // Find an opening.\n\n  while (index--) {\n    if (events[index][1].type === 'labelImage' && events[index][0] === 'enter') {\n      labelStart = events[index][1];\n      break;\n    }\n  } // Change the `labelImageMarker` to a `data`.\n\n\n  events[index + 1][1].type = 'data';\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'; // The whole (without `!`):\n\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }; // The `^` marker\n\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }; // Increment the end 1 character.\n\n  marker.end.column++;\n  marker.end.offset++;\n  marker.end._bufferIndex++;\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  };\n  const chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  };\n  /** @type {Array<Event>} */\n\n  const replacement = [// Take the `labelImageMarker` (now `data`, the `!`)\n  events[index + 1], events[index + 2], ['enter', call, context], // The `[`\n  events[index + 3], events[index + 4], // The `^`.\n  ['enter', marker, context], ['exit', marker, context], // Everything in between.\n  ['enter', string, context], ['enter', chunk, context], ['exit', chunk, context], ['exit', string, context], // The ending (`]`, properly parsed and labelled).\n  events[events.length - 2], events[events.length - 1], ['exit', call, context]];\n  events.splice(index, events.length - index + 1, ...replacement);\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this;\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  let size = 0;\n  /** @type {boolean} */\n\n  let data;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('gfmFootnoteCall');\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return callStart;\n  }\n  /** @type {State} */\n\n\n  function callStart(code) {\n    if (code !== 94) return nok(code);\n    effects.enter('gfmFootnoteCallMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallMarker');\n    effects.enter('gfmFootnoteCallString');\n    effects.enter('chunkString').contentType = 'string';\n    return callData;\n  }\n  /** @type {State} */\n\n\n  function callData(code) {\n    /** @type {Token} */\n    let token;\n\n    if (code === null || code === 91 || size++ > 999) {\n      return nok(code);\n    }\n\n    if (code === 93) {\n      if (!data) {\n        return nok(code);\n      }\n\n      effects.exit('chunkString');\n      token = effects.exit('gfmFootnoteCallString');\n      return defined.includes((0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(token))) ? end(code) : nok(code);\n    }\n\n    effects.consume(code);\n\n    if (!(0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      data = true;\n    }\n\n    return code === 92 ? callEscape : callData;\n  }\n  /** @type {State} */\n\n\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return callData;\n    }\n\n    return callData(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    effects.exit('gfmFootnoteCall');\n    return ok;\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this;\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {string} */\n\n  let identifier;\n  let size = 0;\n  /** @type {boolean|undefined} */\n\n  let data;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true;\n    effects.enter('gfmFootnoteDefinitionLabel');\n    effects.enter('gfmFootnoteDefinitionLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteDefinitionLabelMarker');\n    return labelStart;\n  }\n  /** @type {State} */\n\n\n  function labelStart(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionMarker');\n      effects.enter('gfmFootnoteDefinitionLabelString');\n      return atBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function atBreak(code) {\n    /** @type {Token} */\n    let token;\n\n    if (code === null || code === 91 || size > 999) {\n      return nok(code);\n    }\n\n    if (code === 93) {\n      if (!data) {\n        return nok(code);\n      }\n\n      token = effects.exit('gfmFootnoteDefinitionLabelString');\n      identifier = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(token));\n      effects.enter('gfmFootnoteDefinitionLabelMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionLabelMarker');\n      effects.exit('gfmFootnoteDefinitionLabel');\n      return labelAfter;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      size++;\n      return atBreak;\n    }\n\n    effects.enter('chunkString').contentType = 'string';\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function label(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code) || code === 91 || code === 93 || size > 999) {\n      effects.exit('chunkString');\n      return atBreak(code);\n    }\n\n    if (!(0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      data = true;\n    }\n\n    size++;\n    effects.consume(code);\n    return code === 92 ? labelEscape : label;\n  }\n  /** @type {State} */\n\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return label;\n    }\n\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker');\n      effects.consume(code);\n      effects.exit('definitionMarker'); // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n\n      return (0, _micromarkFactorySpace.factorySpace)(effects, done, 'gfmFootnoteDefinitionWhitespace');\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    if (!defined.includes(identifier)) {\n      defined.push(identifier);\n    }\n\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(_micromarkCoreCommonmark.blankLine, ok, effects.attempt(indent, ok, nok));\n}\n/** @type {Exiter} */\n\n\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition');\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this;\n  return (0, _micromarkFactorySpace.factorySpace)(effects, afterPrefix, 'gfmFootnoteDefinitionIndent', 4 + 1);\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'gfmFootnoteDefinitionIndent' && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok(code) : nok(code);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_normalize_identifier$index","~$module$node_modules$micromark_util_character$index","~$shadow.js","~$module$node_modules$micromark_factory_space$index","~$module$node_modules$micromark_core_commonmark$index"]],"~:properties",["^5",["partial","resolveTo","tokenize","continuation","gfmFootnotes","__esModule","document","gfmFootnote","value","start","text","type","_container","exit","contentType","add","end"]],"~:compiled-at",1676841365314,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_extension_gfm_footnote$lib$syntax.js\",\n\"lineCount\":14,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-extension-gfm-footnote/lib/syntax.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_extension_gfm_footnote$lib$syntax\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.gfmFootnote = gfmFootnote;\\n\\nvar _micromarkCoreCommonmark = require(\\\"micromark-core-commonmark\\\");\\n\\nvar _micromarkFactorySpace = require(\\\"micromark-factory-space\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\nvar _micromarkUtilNormalizeIdentifier = require(\\\"micromark-util-normalize-identifier\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Extension} Extension\\n * @typedef {import('micromark-util-types').Resolver} Resolver\\n * @typedef {import('micromark-util-types').Token} Token\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').Exiter} Exiter\\n * @typedef {import('micromark-util-types').State} State\\n * @typedef {import('micromark-util-types').Event} Event\\n */\\nconst indent = {\\n  tokenize: tokenizeIndent,\\n  partial: true\\n};\\n/**\\n * @returns {Extension}\\n */\\n\\nfunction gfmFootnote() {\\n  /** @type {Extension} */\\n  return {\\n    document: {\\n      [91]: {\\n        tokenize: tokenizeDefinitionStart,\\n        continuation: {\\n          tokenize: tokenizeDefinitionContinuation\\n        },\\n        exit: gfmFootnoteDefinitionEnd\\n      }\\n    },\\n    text: {\\n      [91]: {\\n        tokenize: tokenizeGfmFootnoteCall\\n      },\\n      [93]: {\\n        add: 'after',\\n        tokenize: tokenizePotentialGfmFootnoteCall,\\n        resolveTo: resolveToPotentialGfmFootnoteCall\\n      }\\n    }\\n  };\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\\n  const self = this;\\n  let index = self.events.length;\\n  /** @type {Array<string>} */\\n  // @ts-expect-error It\\u2019s fine!\\n\\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\\n  /** @type {Token} */\\n\\n  let labelStart; // Find an opening.\\n\\n  while (index--) {\\n    const token = self.events[index][1];\\n\\n    if (token.type === 'labelImage') {\\n      labelStart = token;\\n      break;\\n    } // Exit if we\\u2019ve walked far enough.\\n\\n\\n    if (token.type === 'gfmFootnoteCall' || token.type === 'labelLink' || token.type === 'label' || token.type === 'image' || token.type === 'link') {\\n      break;\\n    }\\n  }\\n\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    if (!labelStart || !labelStart._balanced) {\\n      return nok(code);\\n    }\\n\\n    const id = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize({\\n      start: labelStart.end,\\n      end: self.now()\\n    }));\\n\\n    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {\\n      return nok(code);\\n    }\\n\\n    effects.enter('gfmFootnoteCallLabelMarker');\\n    effects.consume(code);\\n    effects.exit('gfmFootnoteCallLabelMarker');\\n    return ok(code);\\n  }\\n}\\n/** @type {Resolver} */\\n\\n\\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\\n  let index = events.length;\\n  /** @type {Token|undefined} */\\n\\n  let labelStart; // Find an opening.\\n\\n  while (index--) {\\n    if (events[index][1].type === 'labelImage' && events[index][0] === 'enter') {\\n      labelStart = events[index][1];\\n      break;\\n    }\\n  } // Change the `labelImageMarker` to a `data`.\\n\\n\\n  events[index + 1][1].type = 'data';\\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'; // The whole (without `!`):\\n\\n  const call = {\\n    type: 'gfmFootnoteCall',\\n    start: Object.assign({}, events[index + 3][1].start),\\n    end: Object.assign({}, events[events.length - 1][1].end)\\n  }; // The `^` marker\\n\\n  const marker = {\\n    type: 'gfmFootnoteCallMarker',\\n    start: Object.assign({}, events[index + 3][1].end),\\n    end: Object.assign({}, events[index + 3][1].end)\\n  }; // Increment the end 1 character.\\n\\n  marker.end.column++;\\n  marker.end.offset++;\\n  marker.end._bufferIndex++;\\n  const string = {\\n    type: 'gfmFootnoteCallString',\\n    start: Object.assign({}, marker.end),\\n    end: Object.assign({}, events[events.length - 1][1].start)\\n  };\\n  const chunk = {\\n    type: 'chunkString',\\n    contentType: 'string',\\n    start: Object.assign({}, string.start),\\n    end: Object.assign({}, string.end)\\n  };\\n  /** @type {Array<Event>} */\\n\\n  const replacement = [// Take the `labelImageMarker` (now `data`, the `!`)\\n  events[index + 1], events[index + 2], ['enter', call, context], // The `[`\\n  events[index + 3], events[index + 4], // The `^`.\\n  ['enter', marker, context], ['exit', marker, context], // Everything in between.\\n  ['enter', string, context], ['enter', chunk, context], ['exit', chunk, context], ['exit', string, context], // The ending (`]`, properly parsed and labelled).\\n  events[events.length - 2], events[events.length - 1], ['exit', call, context]];\\n  events.splice(index, events.length - index + 1, ...replacement);\\n  return events;\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\\n  const self = this;\\n  /** @type {Array<string>} */\\n  // @ts-expect-error It\\u2019s fine!\\n\\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\\n  let size = 0;\\n  /** @type {boolean} */\\n\\n  let data;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('gfmFootnoteCall');\\n    effects.enter('gfmFootnoteCallLabelMarker');\\n    effects.consume(code);\\n    effects.exit('gfmFootnoteCallLabelMarker');\\n    return callStart;\\n  }\\n  /** @type {State} */\\n\\n\\n  function callStart(code) {\\n    if (code !== 94) return nok(code);\\n    effects.enter('gfmFootnoteCallMarker');\\n    effects.consume(code);\\n    effects.exit('gfmFootnoteCallMarker');\\n    effects.enter('gfmFootnoteCallString');\\n    effects.enter('chunkString').contentType = 'string';\\n    return callData;\\n  }\\n  /** @type {State} */\\n\\n\\n  function callData(code) {\\n    /** @type {Token} */\\n    let token;\\n\\n    if (code === null || code === 91 || size++ > 999) {\\n      return nok(code);\\n    }\\n\\n    if (code === 93) {\\n      if (!data) {\\n        return nok(code);\\n      }\\n\\n      effects.exit('chunkString');\\n      token = effects.exit('gfmFootnoteCallString');\\n      return defined.includes((0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(token))) ? end(code) : nok(code);\\n    }\\n\\n    effects.consume(code);\\n\\n    if (!(0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\\n      data = true;\\n    }\\n\\n    return code === 92 ? callEscape : callData;\\n  }\\n  /** @type {State} */\\n\\n\\n  function callEscape(code) {\\n    if (code === 91 || code === 92 || code === 93) {\\n      effects.consume(code);\\n      size++;\\n      return callData;\\n    }\\n\\n    return callData(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function end(code) {\\n    effects.enter('gfmFootnoteCallLabelMarker');\\n    effects.consume(code);\\n    effects.exit('gfmFootnoteCallLabelMarker');\\n    effects.exit('gfmFootnoteCall');\\n    return ok;\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeDefinitionStart(effects, ok, nok) {\\n  const self = this;\\n  /** @type {Array<string>} */\\n  // @ts-expect-error It\\u2019s fine!\\n\\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\\n  /** @type {string} */\\n\\n  let identifier;\\n  let size = 0;\\n  /** @type {boolean|undefined} */\\n\\n  let data;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('gfmFootnoteDefinition')._container = true;\\n    effects.enter('gfmFootnoteDefinitionLabel');\\n    effects.enter('gfmFootnoteDefinitionLabelMarker');\\n    effects.consume(code);\\n    effects.exit('gfmFootnoteDefinitionLabelMarker');\\n    return labelStart;\\n  }\\n  /** @type {State} */\\n\\n\\n  function labelStart(code) {\\n    if (code === 94) {\\n      effects.enter('gfmFootnoteDefinitionMarker');\\n      effects.consume(code);\\n      effects.exit('gfmFootnoteDefinitionMarker');\\n      effects.enter('gfmFootnoteDefinitionLabelString');\\n      return atBreak;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function atBreak(code) {\\n    /** @type {Token} */\\n    let token;\\n\\n    if (code === null || code === 91 || size > 999) {\\n      return nok(code);\\n    }\\n\\n    if (code === 93) {\\n      if (!data) {\\n        return nok(code);\\n      }\\n\\n      token = effects.exit('gfmFootnoteDefinitionLabelString');\\n      identifier = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(token));\\n      effects.enter('gfmFootnoteDefinitionLabelMarker');\\n      effects.consume(code);\\n      effects.exit('gfmFootnoteDefinitionLabelMarker');\\n      effects.exit('gfmFootnoteDefinitionLabel');\\n      return labelAfter;\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.enter('lineEnding');\\n      effects.consume(code);\\n      effects.exit('lineEnding');\\n      size++;\\n      return atBreak;\\n    }\\n\\n    effects.enter('chunkString').contentType = 'string';\\n    return label(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function label(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code) || code === 91 || code === 93 || size > 999) {\\n      effects.exit('chunkString');\\n      return atBreak(code);\\n    }\\n\\n    if (!(0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\\n      data = true;\\n    }\\n\\n    size++;\\n    effects.consume(code);\\n    return code === 92 ? labelEscape : label;\\n  }\\n  /** @type {State} */\\n\\n\\n  function labelEscape(code) {\\n    if (code === 91 || code === 92 || code === 93) {\\n      effects.consume(code);\\n      size++;\\n      return label;\\n    }\\n\\n    return label(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function labelAfter(code) {\\n    if (code === 58) {\\n      effects.enter('definitionMarker');\\n      effects.consume(code);\\n      effects.exit('definitionMarker'); // Any whitespace after the marker is eaten, forming indented code\\n      // is not possible.\\n      // No space is also fine, just like a block quote marker.\\n\\n      return (0, _micromarkFactorySpace.factorySpace)(effects, done, 'gfmFootnoteDefinitionWhitespace');\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function done(code) {\\n    if (!defined.includes(identifier)) {\\n      defined.push(identifier);\\n    }\\n\\n    return ok(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\\n  // Either a blank line, which is okay, or an indented thing.\\n  return effects.check(_micromarkCoreCommonmark.blankLine, ok, effects.attempt(indent, ok, nok));\\n}\\n/** @type {Exiter} */\\n\\n\\nfunction gfmFootnoteDefinitionEnd(effects) {\\n  effects.exit('gfmFootnoteDefinition');\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeIndent(effects, ok, nok) {\\n  const self = this;\\n  return (0, _micromarkFactorySpace.factorySpace)(effects, afterPrefix, 'gfmFootnoteDefinitionIndent', 4 + 1);\\n  /** @type {State} */\\n\\n  function afterPrefix(code) {\\n    const tail = self.events[self.events.length - 1];\\n    return tail && tail[1].type === 'gfmFootnoteDefinitionIndent' && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok(code) : nok(code);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"tokenizePotentialGfmFootnoteCall\",\"effects\",\"ok\",\"nok\",\"self\",\"index\",\"events\",\"length\",\"defined\",\"parser\",\"gfmFootnotes\",\"labelStart\",\"token\",\"type\",\"start\",\"code\",\"_balanced\",\"id\",\"_micromarkUtilNormalizeIdentifier\",\"normalizeIdentifier\",\"sliceSerialize\",\"end\",\"now\",\"charCodeAt\",\"includes\",\"slice\",\"enter\",\"consume\",\"exit\",\"resolveToPotentialGfmFootnoteCall\",\"context\",\"call\",\"Object\",\"assign\",\"marker\",\"column\",\"offset\",\"_bufferIndex\",\"string\",\"chunk\",\"contentType\",\"splice\",\"replacement\",\"tokenizeGfmFootnoteCall\",\"callStart\",\"callData\",\"size\",\"data\",\"_micromarkUtilCharacter\",\"markdownLineEndingOrSpace\",\"callEscape\",\"tokenizeDefinitionStart\",\"atBreak\",\"identifier\",\"labelAfter\",\"markdownLineEnding\",\"label\",\"labelEscape\",\"_micromarkFactorySpace\",\"factorySpace\",\"done\",\"push\",\"_container\",\"tokenizeDefinitionContinuation\",\"check\",\"_micromarkCoreCommonmark\",\"blankLine\",\"attempt\",\"indent\",\"gfmFootnoteDefinitionEnd\",\"defineProperty\",\"value\",\"gfmFootnote\",\"document\",\"tokenize\",\"continuation\",\"text\",\"add\",\"resolveTo\",\"tokenizeIndent\",\"afterPrefix\",\"tail\",\"partial\"]\n}\n"]