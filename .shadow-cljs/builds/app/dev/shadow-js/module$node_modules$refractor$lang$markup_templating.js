["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/markup-templating.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$markup_templating=function(global,require,module,exports){function markupTemplating(Prism$jscomp$0){Prism$jscomp$0.register(_markup.default);(function(Prism){function getPlaceholder(language,index){return\"___\"+language.toUpperCase()+index+\"___\"}Object.defineProperties(Prism.languages[\"markup-templating\"]={},{buildPlaceholders:{value:function(env,language,placeholderPattern,replaceFilter){if(env.language===language){var tokenStack=env.tokenStack=[];\nenv.code=env.code.replace(placeholderPattern,function(match){if(\"function\"===typeof replaceFilter&&!replaceFilter(match))return match;for(var i=tokenStack.length,placeholder;-1!==env.code.indexOf(placeholder=getPlaceholder(language,i));)++i;tokenStack[i]=match;return placeholder});env.grammar=Prism.languages.markup}}},tokenizePlaceholders:{value:function(env,language){function walkTokens(tokens){for(var i=0;i<tokens.length&&!(j>=keys.length);i++){var token=tokens[i];if(\"string\"===typeof token||token.content&&\n\"string\"===typeof token.content){var k=keys[j],t=env.tokenStack[k],s=\"string\"===typeof token?token:token.content,placeholder=getPlaceholder(language,k),index=s.indexOf(placeholder);-1<index&&(++j,k=s.substring(0,index),t=new Prism.Token(language,Prism.tokenize(t,env.grammar),\"language-\"+language,t),s=s.substring(index+placeholder.length),placeholder=[],k&&placeholder.push.apply(placeholder,walkTokens([k])),placeholder.push(t),s&&placeholder.push.apply(placeholder,walkTokens([s])),\"string\"===typeof token?\ntokens.splice.apply(tokens,[i,1].concat(placeholder)):token.content=placeholder)}else token.content&&walkTokens(token.content)}return tokens}if(env.language===language&&env.tokenStack){env.grammar=Prism.languages[language];var j=0,keys=Object.keys(env.tokenStack);walkTokens(env.tokens)}}}})})(Prism$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=markupTemplating;var _markup=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(require(\"module$node_modules$refractor$lang$markup\"));\nmarkupTemplating.displayName=\"markup-templating\";markupTemplating.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$markup_templating\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = markupTemplating;\n\nvar _markup = _interopRequireDefault(require(\"./markup.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// @ts-nocheck\nmarkupTemplating.displayName = 'markup-templating';\nmarkupTemplating.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction markupTemplating(Prism) {\n  Prism.register(_markup.default);\n\n  (function (Prism) {\n    /**\n     * Returns the placeholder for the given language id and index.\n     *\n     * @param {string} language\n     * @param {string|number} index\n     * @returns {string}\n     */\n    function getPlaceholder(language, index) {\n      return '___' + language.toUpperCase() + index + '___';\n    }\n\n    Object.defineProperties(Prism.languages['markup-templating'] = {}, {\n      buildPlaceholders: {\n        /**\n         * Tokenize all inline templating expressions matching `placeholderPattern`.\n         *\n         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n         * `true` will be replaced.\n         *\n         * @param {object} env The environment of the `before-tokenize` hook.\n         * @param {string} language The language id.\n         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n         * @param {(match: string) => boolean} [replaceFilter]\n         */\n        value: function (env, language, placeholderPattern, replaceFilter) {\n          if (env.language !== language) {\n            return;\n          }\n\n          var tokenStack = env.tokenStack = [];\n          env.code = env.code.replace(placeholderPattern, function (match) {\n            if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n              return match;\n            }\n\n            var i = tokenStack.length;\n            var placeholder; // Check for existing strings\n\n            while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n              ++i;\n            } // Create a sparse array\n\n\n            tokenStack[i] = match;\n            return placeholder;\n          }); // Switch the grammar to markup\n\n          env.grammar = Prism.languages.markup;\n        }\n      },\n      tokenizePlaceholders: {\n        /**\n         * Replace placeholders with proper tokens after tokenizing.\n         *\n         * @param {object} env The environment of the `after-tokenize` hook.\n         * @param {string} language The language id.\n         */\n        value: function (env, language) {\n          if (env.language !== language || !env.tokenStack) {\n            return;\n          } // Switch the grammar back\n\n\n          env.grammar = Prism.languages[language];\n          var j = 0;\n          var keys = Object.keys(env.tokenStack);\n\n          function walkTokens(tokens) {\n            for (var i = 0; i < tokens.length; i++) {\n              // all placeholders are replaced already\n              if (j >= keys.length) {\n                break;\n              }\n\n              var token = tokens[i];\n\n              if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n                var k = keys[j];\n                var t = env.tokenStack[k];\n                var s = typeof token === 'string' ? token : token.content;\n                var placeholder = getPlaceholder(language, k);\n                var index = s.indexOf(placeholder);\n\n                if (index > -1) {\n                  ++j;\n                  var before = s.substring(0, index);\n                  var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n                  var after = s.substring(index + placeholder.length);\n                  var replacement = [];\n\n                  if (before) {\n                    replacement.push.apply(replacement, walkTokens([before]));\n                  }\n\n                  replacement.push(middle);\n\n                  if (after) {\n                    replacement.push.apply(replacement, walkTokens([after]));\n                  }\n\n                  if (typeof token === 'string') {\n                    tokens.splice.apply(tokens, [i, 1].concat(replacement));\n                  } else {\n                    token.content = replacement;\n                  }\n                }\n              } else if (token.content\n              /* && typeof token.content !== 'string' */\n              ) {\n                walkTokens(token.content);\n              }\n            }\n\n            return tokens;\n          }\n\n          walkTokens(env.tokens);\n        }\n      }\n    });\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$refractor$lang$markup","~$shadow.js"]],"~:properties",["^5",["grammar","aliases","displayName","__esModule","value","content","tokenizePlaceholders","buildPlaceholders","default","code","tokenStack"]],"~:compiled-at",1676841365372,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$markup_templating.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lang/markup-templating.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$markup_templating\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = markupTemplating;\\n\\nvar _markup = _interopRequireDefault(require(\\\"./markup.js\\\"));\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n// @ts-nocheck\\nmarkupTemplating.displayName = 'markup-templating';\\nmarkupTemplating.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction markupTemplating(Prism) {\\n  Prism.register(_markup.default);\\n\\n  (function (Prism) {\\n    /**\\n     * Returns the placeholder for the given language id and index.\\n     *\\n     * @param {string} language\\n     * @param {string|number} index\\n     * @returns {string}\\n     */\\n    function getPlaceholder(language, index) {\\n      return '___' + language.toUpperCase() + index + '___';\\n    }\\n\\n    Object.defineProperties(Prism.languages['markup-templating'] = {}, {\\n      buildPlaceholders: {\\n        /**\\n         * Tokenize all inline templating expressions matching `placeholderPattern`.\\n         *\\n         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\\n         * `true` will be replaced.\\n         *\\n         * @param {object} env The environment of the `before-tokenize` hook.\\n         * @param {string} language The language id.\\n         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\\n         * @param {(match: string) => boolean} [replaceFilter]\\n         */\\n        value: function (env, language, placeholderPattern, replaceFilter) {\\n          if (env.language !== language) {\\n            return;\\n          }\\n\\n          var tokenStack = env.tokenStack = [];\\n          env.code = env.code.replace(placeholderPattern, function (match) {\\n            if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\\n              return match;\\n            }\\n\\n            var i = tokenStack.length;\\n            var placeholder; // Check for existing strings\\n\\n            while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\\n              ++i;\\n            } // Create a sparse array\\n\\n\\n            tokenStack[i] = match;\\n            return placeholder;\\n          }); // Switch the grammar to markup\\n\\n          env.grammar = Prism.languages.markup;\\n        }\\n      },\\n      tokenizePlaceholders: {\\n        /**\\n         * Replace placeholders with proper tokens after tokenizing.\\n         *\\n         * @param {object} env The environment of the `after-tokenize` hook.\\n         * @param {string} language The language id.\\n         */\\n        value: function (env, language) {\\n          if (env.language !== language || !env.tokenStack) {\\n            return;\\n          } // Switch the grammar back\\n\\n\\n          env.grammar = Prism.languages[language];\\n          var j = 0;\\n          var keys = Object.keys(env.tokenStack);\\n\\n          function walkTokens(tokens) {\\n            for (var i = 0; i < tokens.length; i++) {\\n              // all placeholders are replaced already\\n              if (j >= keys.length) {\\n                break;\\n              }\\n\\n              var token = tokens[i];\\n\\n              if (typeof token === 'string' || token.content && typeof token.content === 'string') {\\n                var k = keys[j];\\n                var t = env.tokenStack[k];\\n                var s = typeof token === 'string' ? token : token.content;\\n                var placeholder = getPlaceholder(language, k);\\n                var index = s.indexOf(placeholder);\\n\\n                if (index > -1) {\\n                  ++j;\\n                  var before = s.substring(0, index);\\n                  var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\\n                  var after = s.substring(index + placeholder.length);\\n                  var replacement = [];\\n\\n                  if (before) {\\n                    replacement.push.apply(replacement, walkTokens([before]));\\n                  }\\n\\n                  replacement.push(middle);\\n\\n                  if (after) {\\n                    replacement.push.apply(replacement, walkTokens([after]));\\n                  }\\n\\n                  if (typeof token === 'string') {\\n                    tokens.splice.apply(tokens, [i, 1].concat(replacement));\\n                  } else {\\n                    token.content = replacement;\\n                  }\\n                }\\n              } else if (token.content\\n              /* && typeof token.content !== 'string' */\\n              ) {\\n                walkTokens(token.content);\\n              }\\n            }\\n\\n            return tokens;\\n          }\\n\\n          walkTokens(env.tokens);\\n        }\\n      }\\n    });\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"markupTemplating\",\"Prism\",\"register\",\"_markup\",\"default\",\"getPlaceholder\",\"language\",\"index\",\"toUpperCase\",\"Object\",\"defineProperties\",\"languages\",\"buildPlaceholders\",\"value\",\"env\",\"placeholderPattern\",\"replaceFilter\",\"tokenStack\",\"code\",\"replace\",\"match\",\"i\",\"length\",\"placeholder\",\"indexOf\",\"grammar\",\"markup\",\"tokenizePlaceholders\",\"walkTokens\",\"tokens\",\"j\",\"keys\",\"token\",\"content\",\"k\",\"t\",\"s\",\"before\",\"substring\",\"middle\",\"Token\",\"tokenize\",\"after\",\"replacement\",\"push\",\"apply\",\"splice\",\"concat\",\"defineProperty\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"displayName\",\"aliases\"]\n}\n"]