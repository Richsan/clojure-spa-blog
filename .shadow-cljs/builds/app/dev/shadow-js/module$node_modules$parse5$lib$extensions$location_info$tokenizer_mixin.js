["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js"],"~:js","shadow$provide.module$node_modules$parse5$lib$extensions$location_info$tokenizer_mixin=function(global,require,module,exports){const Mixin=require(\"module$node_modules$parse5$lib$utils$mixin\"),Tokenizer=require(\"module$node_modules$parse5$lib$tokenizer$index\"),PositionTrackingPreprocessorMixin=require(\"module$node_modules$parse5$lib$extensions$position_tracking$preprocessor_mixin\");class LocationInfoTokenizerMixin extends Mixin{constructor(tokenizer){super(tokenizer);this.tokenizer=tokenizer;this.posTracker=\nMixin.install(tokenizer.preprocessor,PositionTrackingPreprocessorMixin);this.ctLoc=this.currentAttrLocation=null}_getCurrentLocation(){return{startLine:this.posTracker.line,startCol:this.posTracker.col,startOffset:this.posTracker.offset,endLine:-1,endCol:-1,endOffset:-1}}_attachCurrentAttrLocationInfo(){this.currentAttrLocation.endLine=this.posTracker.line;this.currentAttrLocation.endCol=this.posTracker.col;this.currentAttrLocation.endOffset=this.posTracker.offset;const currentToken=this.tokenizer.currentToken,\ncurrentAttr=this.tokenizer.currentAttr;currentToken.location.attrs||(currentToken.location.attrs=Object.create(null));currentToken.location.attrs[currentAttr.name]=this.currentAttrLocation}_getOverriddenMethods(mxn,orig){const methods={_createStartTagToken(){orig._createStartTagToken.call(this);this.currentToken.location=mxn.ctLoc},_createEndTagToken(){orig._createEndTagToken.call(this);this.currentToken.location=mxn.ctLoc},_createCommentToken(){orig._createCommentToken.call(this);this.currentToken.location=\nmxn.ctLoc},_createDoctypeToken(initialName){orig._createDoctypeToken.call(this,initialName);this.currentToken.location=mxn.ctLoc},_createCharacterToken(type,ch){orig._createCharacterToken.call(this,type,ch);this.currentCharacterToken.location=mxn.ctLoc},_createEOFToken(){orig._createEOFToken.call(this);this.currentToken.location=mxn._getCurrentLocation()},_createAttr(attrNameFirstCh){orig._createAttr.call(this,attrNameFirstCh);mxn.currentAttrLocation=mxn._getCurrentLocation()},_leaveAttrName(toState){orig._leaveAttrName.call(this,\ntoState);mxn._attachCurrentAttrLocationInfo()},_leaveAttrValue(toState){orig._leaveAttrValue.call(this,toState);mxn._attachCurrentAttrLocationInfo()},_emitCurrentToken(){const ctLoc=this.currentToken.location;this.currentCharacterToken&&(this.currentCharacterToken.location.endLine=ctLoc.startLine,this.currentCharacterToken.location.endCol=ctLoc.startCol,this.currentCharacterToken.location.endOffset=ctLoc.startOffset);this.currentToken.type===Tokenizer.EOF_TOKEN?(ctLoc.endLine=ctLoc.startLine,ctLoc.endCol=\nctLoc.startCol,ctLoc.endOffset=ctLoc.startOffset):(ctLoc.endLine=mxn.posTracker.line,ctLoc.endCol=mxn.posTracker.col+1,ctLoc.endOffset=mxn.posTracker.offset+1);orig._emitCurrentToken.call(this)},_emitCurrentCharacterToken(){const ctLoc=this.currentCharacterToken&&this.currentCharacterToken.location;ctLoc&&-1===ctLoc.endOffset&&(ctLoc.endLine=mxn.posTracker.line,ctLoc.endCol=mxn.posTracker.col,ctLoc.endOffset=mxn.posTracker.offset);orig._emitCurrentCharacterToken.call(this)}};Object.keys(Tokenizer.MODE).forEach(modeName=>\n{const state=Tokenizer.MODE[modeName];methods[state]=function(cp){mxn.ctLoc=mxn._getCurrentLocation();orig[state].call(this,cp)}});return methods}}module.exports=LocationInfoTokenizerMixin}","~:source","shadow$provide[\"module$node_modules$parse5$lib$extensions$location_info$tokenizer_mixin\"] = function(global,require,module,exports) {\n'use strict';\n\nconst Mixin = require('../../utils/mixin');\nconst Tokenizer = require('../../tokenizer');\nconst PositionTrackingPreprocessorMixin = require('../position-tracking/preprocessor-mixin');\n\nclass LocationInfoTokenizerMixin extends Mixin {\n    constructor(tokenizer) {\n        super(tokenizer);\n\n        this.tokenizer = tokenizer;\n        this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);\n        this.currentAttrLocation = null;\n        this.ctLoc = null;\n    }\n\n    _getCurrentLocation() {\n        return {\n            startLine: this.posTracker.line,\n            startCol: this.posTracker.col,\n            startOffset: this.posTracker.offset,\n            endLine: -1,\n            endCol: -1,\n            endOffset: -1\n        };\n    }\n\n    _attachCurrentAttrLocationInfo() {\n        this.currentAttrLocation.endLine = this.posTracker.line;\n        this.currentAttrLocation.endCol = this.posTracker.col;\n        this.currentAttrLocation.endOffset = this.posTracker.offset;\n\n        const currentToken = this.tokenizer.currentToken;\n        const currentAttr = this.tokenizer.currentAttr;\n\n        if (!currentToken.location.attrs) {\n            currentToken.location.attrs = Object.create(null);\n        }\n\n        currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        const methods = {\n            _createStartTagToken() {\n                orig._createStartTagToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createEndTagToken() {\n                orig._createEndTagToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createCommentToken() {\n                orig._createCommentToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createDoctypeToken(initialName) {\n                orig._createDoctypeToken.call(this, initialName);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createCharacterToken(type, ch) {\n                orig._createCharacterToken.call(this, type, ch);\n                this.currentCharacterToken.location = mxn.ctLoc;\n            },\n\n            _createEOFToken() {\n                orig._createEOFToken.call(this);\n                this.currentToken.location = mxn._getCurrentLocation();\n            },\n\n            _createAttr(attrNameFirstCh) {\n                orig._createAttr.call(this, attrNameFirstCh);\n                mxn.currentAttrLocation = mxn._getCurrentLocation();\n            },\n\n            _leaveAttrName(toState) {\n                orig._leaveAttrName.call(this, toState);\n                mxn._attachCurrentAttrLocationInfo();\n            },\n\n            _leaveAttrValue(toState) {\n                orig._leaveAttrValue.call(this, toState);\n                mxn._attachCurrentAttrLocationInfo();\n            },\n\n            _emitCurrentToken() {\n                const ctLoc = this.currentToken.location;\n\n                //NOTE: if we have pending character token make it's end location equal to the\n                //current token's start location.\n                if (this.currentCharacterToken) {\n                    this.currentCharacterToken.location.endLine = ctLoc.startLine;\n                    this.currentCharacterToken.location.endCol = ctLoc.startCol;\n                    this.currentCharacterToken.location.endOffset = ctLoc.startOffset;\n                }\n\n                if (this.currentToken.type === Tokenizer.EOF_TOKEN) {\n                    ctLoc.endLine = ctLoc.startLine;\n                    ctLoc.endCol = ctLoc.startCol;\n                    ctLoc.endOffset = ctLoc.startOffset;\n                } else {\n                    ctLoc.endLine = mxn.posTracker.line;\n                    ctLoc.endCol = mxn.posTracker.col + 1;\n                    ctLoc.endOffset = mxn.posTracker.offset + 1;\n                }\n\n                orig._emitCurrentToken.call(this);\n            },\n\n            _emitCurrentCharacterToken() {\n                const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;\n\n                //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\n                //then set it's location at the current preprocessor position.\n                //We don't need to increment preprocessor position, since character token\n                //emission is always forced by the start of the next character token here.\n                //So, we already have advanced position.\n                if (ctLoc && ctLoc.endOffset === -1) {\n                    ctLoc.endLine = mxn.posTracker.line;\n                    ctLoc.endCol = mxn.posTracker.col;\n                    ctLoc.endOffset = mxn.posTracker.offset;\n                }\n\n                orig._emitCurrentCharacterToken.call(this);\n            }\n        };\n\n        //NOTE: patch initial states for each mode to obtain token start position\n        Object.keys(Tokenizer.MODE).forEach(modeName => {\n            const state = Tokenizer.MODE[modeName];\n\n            methods[state] = function(cp) {\n                mxn.ctLoc = mxn._getCurrentLocation();\n                orig[state].call(this, cp);\n            };\n        });\n\n        return methods;\n    }\n}\n\nmodule.exports = LocationInfoTokenizerMixin;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$parse5$lib$tokenizer$index","~$module$node_modules$parse5$lib$utils$mixin","~$shadow.js","~$module$node_modules$parse5$lib$extensions$position_tracking$preprocessor_mixin"]],"~:properties",["^5",["ctLoc","attrs","currentAttrLocation","endLine","tokenizer","endOffset","location","startOffset","startLine","posTracker","startCol","endCol"]],"~:compiled-at",1676667638409,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$parse5$lib$extensions$location_info$tokenizer_mixin.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$parse5$lib$extensions$location_info$tokenizer_mixin\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nconst Mixin = require('../../utils/mixin');\\nconst Tokenizer = require('../../tokenizer');\\nconst PositionTrackingPreprocessorMixin = require('../position-tracking/preprocessor-mixin');\\n\\nclass LocationInfoTokenizerMixin extends Mixin {\\n    constructor(tokenizer) {\\n        super(tokenizer);\\n\\n        this.tokenizer = tokenizer;\\n        this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);\\n        this.currentAttrLocation = null;\\n        this.ctLoc = null;\\n    }\\n\\n    _getCurrentLocation() {\\n        return {\\n            startLine: this.posTracker.line,\\n            startCol: this.posTracker.col,\\n            startOffset: this.posTracker.offset,\\n            endLine: -1,\\n            endCol: -1,\\n            endOffset: -1\\n        };\\n    }\\n\\n    _attachCurrentAttrLocationInfo() {\\n        this.currentAttrLocation.endLine = this.posTracker.line;\\n        this.currentAttrLocation.endCol = this.posTracker.col;\\n        this.currentAttrLocation.endOffset = this.posTracker.offset;\\n\\n        const currentToken = this.tokenizer.currentToken;\\n        const currentAttr = this.tokenizer.currentAttr;\\n\\n        if (!currentToken.location.attrs) {\\n            currentToken.location.attrs = Object.create(null);\\n        }\\n\\n        currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;\\n    }\\n\\n    _getOverriddenMethods(mxn, orig) {\\n        const methods = {\\n            _createStartTagToken() {\\n                orig._createStartTagToken.call(this);\\n                this.currentToken.location = mxn.ctLoc;\\n            },\\n\\n            _createEndTagToken() {\\n                orig._createEndTagToken.call(this);\\n                this.currentToken.location = mxn.ctLoc;\\n            },\\n\\n            _createCommentToken() {\\n                orig._createCommentToken.call(this);\\n                this.currentToken.location = mxn.ctLoc;\\n            },\\n\\n            _createDoctypeToken(initialName) {\\n                orig._createDoctypeToken.call(this, initialName);\\n                this.currentToken.location = mxn.ctLoc;\\n            },\\n\\n            _createCharacterToken(type, ch) {\\n                orig._createCharacterToken.call(this, type, ch);\\n                this.currentCharacterToken.location = mxn.ctLoc;\\n            },\\n\\n            _createEOFToken() {\\n                orig._createEOFToken.call(this);\\n                this.currentToken.location = mxn._getCurrentLocation();\\n            },\\n\\n            _createAttr(attrNameFirstCh) {\\n                orig._createAttr.call(this, attrNameFirstCh);\\n                mxn.currentAttrLocation = mxn._getCurrentLocation();\\n            },\\n\\n            _leaveAttrName(toState) {\\n                orig._leaveAttrName.call(this, toState);\\n                mxn._attachCurrentAttrLocationInfo();\\n            },\\n\\n            _leaveAttrValue(toState) {\\n                orig._leaveAttrValue.call(this, toState);\\n                mxn._attachCurrentAttrLocationInfo();\\n            },\\n\\n            _emitCurrentToken() {\\n                const ctLoc = this.currentToken.location;\\n\\n                //NOTE: if we have pending character token make it's end location equal to the\\n                //current token's start location.\\n                if (this.currentCharacterToken) {\\n                    this.currentCharacterToken.location.endLine = ctLoc.startLine;\\n                    this.currentCharacterToken.location.endCol = ctLoc.startCol;\\n                    this.currentCharacterToken.location.endOffset = ctLoc.startOffset;\\n                }\\n\\n                if (this.currentToken.type === Tokenizer.EOF_TOKEN) {\\n                    ctLoc.endLine = ctLoc.startLine;\\n                    ctLoc.endCol = ctLoc.startCol;\\n                    ctLoc.endOffset = ctLoc.startOffset;\\n                } else {\\n                    ctLoc.endLine = mxn.posTracker.line;\\n                    ctLoc.endCol = mxn.posTracker.col + 1;\\n                    ctLoc.endOffset = mxn.posTracker.offset + 1;\\n                }\\n\\n                orig._emitCurrentToken.call(this);\\n            },\\n\\n            _emitCurrentCharacterToken() {\\n                const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;\\n\\n                //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\\n                //then set it's location at the current preprocessor position.\\n                //We don't need to increment preprocessor position, since character token\\n                //emission is always forced by the start of the next character token here.\\n                //So, we already have advanced position.\\n                if (ctLoc && ctLoc.endOffset === -1) {\\n                    ctLoc.endLine = mxn.posTracker.line;\\n                    ctLoc.endCol = mxn.posTracker.col;\\n                    ctLoc.endOffset = mxn.posTracker.offset;\\n                }\\n\\n                orig._emitCurrentCharacterToken.call(this);\\n            }\\n        };\\n\\n        //NOTE: patch initial states for each mode to obtain token start position\\n        Object.keys(Tokenizer.MODE).forEach(modeName => {\\n            const state = Tokenizer.MODE[modeName];\\n\\n            methods[state] = function(cp) {\\n                mxn.ctLoc = mxn._getCurrentLocation();\\n                orig[state].call(this, cp);\\n            };\\n        });\\n\\n        return methods;\\n    }\\n}\\n\\nmodule.exports = LocationInfoTokenizerMixin;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Mixin\",\"Tokenizer\",\"PositionTrackingPreprocessorMixin\",\"LocationInfoTokenizerMixin\",\"constructor\",\"tokenizer\",\"posTracker\",\"install\",\"preprocessor\",\"ctLoc\",\"currentAttrLocation\",\"_getCurrentLocation\",\"startLine\",\"line\",\"startCol\",\"col\",\"startOffset\",\"offset\",\"endLine\",\"endCol\",\"endOffset\",\"_attachCurrentAttrLocationInfo\",\"currentToken\",\"currentAttr\",\"location\",\"attrs\",\"Object\",\"create\",\"name\",\"_getOverriddenMethods\",\"mxn\",\"orig\",\"methods\",\"_createStartTagToken\",\"call\",\"_createEndTagToken\",\"_createCommentToken\",\"_createDoctypeToken\",\"initialName\",\"_createCharacterToken\",\"type\",\"ch\",\"currentCharacterToken\",\"_createEOFToken\",\"_createAttr\",\"attrNameFirstCh\",\"_leaveAttrName\",\"toState\",\"_leaveAttrValue\",\"_emitCurrentToken\",\"EOF_TOKEN\",\"_emitCurrentCharacterToken\",\"keys\",\"MODE\",\"forEach\",\"modeName\",\"state\",\"cp\"]\n}\n"]