["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/decode-named-character-reference/index.js"],"~:js","shadow$provide.module$node_modules$decode_named_character_reference$index=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.decodeNamedCharacterReference=function(value){return own.call(_characterEntities.characterEntities,value)?_characterEntities.characterEntities[value]:!1};var _characterEntities=require(\"module$node_modules$character_entities$index\");const own={}.hasOwnProperty}","~:source","shadow$provide[\"module$node_modules$decode_named_character_reference$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeNamedCharacterReference = decodeNamedCharacterReference;\n\nvar _characterEntities = require(\"character-entities\");\n\nconst own = {}.hasOwnProperty;\n/**\n * Decode a single character reference (without the `&` or `;`).\n * You probably only need this when youâ€™re building parsers yourself that follow\n * different rules compared to HTML.\n * This is optimized to be tiny in browsers.\n *\n * @param {string} value\n *   `notin` (named), `#123` (deci), `#x123` (hexa).\n * @returns {string|false}\n *   Decoded reference.\n */\n\nfunction decodeNamedCharacterReference(value) {\n  return own.call(_characterEntities.characterEntities, value) ? _characterEntities.characterEntities[value] : false;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$character_entities$index"]],"~:properties",["^5",["__esModule","value","decodeNamedCharacterReference"]],"~:compiled-at",1676665867278,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$decode_named_character_reference$index.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,CAAA,0DAAA,CAA+E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGvHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,6BAAR,CAiBAA,QAAsC,CAACD,KAAD,CAAQ,CAC5C,MAAOE,IAAIC,CAAAA,IAAJ,CAASC,kBAAmBC,CAAAA,iBAA5B,CAA+CL,KAA/C,CAAA,CAAwDI,kBAAmBC,CAAAA,iBAAnB,CAAqCL,KAArC,CAAxD,CAAsG,CAAA,CADjE,CAf9C,KAAII,mBAAqBT,OAAA,CAAQ,8CAAR,CAEzB,OAAMO,IAAM,EAAGI,CAAAA,cAVwG;\",\n\"sources\":[\"node_modules/decode-named-character-reference/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$decode_named_character_reference$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.decodeNamedCharacterReference = decodeNamedCharacterReference;\\n\\nvar _characterEntities = require(\\\"character-entities\\\");\\n\\nconst own = {}.hasOwnProperty;\\n/**\\n * Decode a single character reference (without the `&` or `;`).\\n * You probably only need this when you\\u2019re building parsers yourself that follow\\n * different rules compared to HTML.\\n * This is optimized to be tiny in browsers.\\n *\\n * @param {string} value\\n *   `notin` (named), `#123` (deci), `#x123` (hexa).\\n * @returns {string|false}\\n *   Decoded reference.\\n */\\n\\nfunction decodeNamedCharacterReference(value) {\\n  return own.call(_characterEntities.characterEntities, value) ? _characterEntities.characterEntities[value] : false;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"decodeNamedCharacterReference\",\"own\",\"call\",\"_characterEntities\",\"characterEntities\",\"hasOwnProperty\"]\n}\n"]