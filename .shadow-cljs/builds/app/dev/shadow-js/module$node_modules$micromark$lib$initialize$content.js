["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark/lib/initialize/content.js"],"~:js","shadow$provide.module$node_modules$micromark$lib$initialize$content=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.content=void 0;var _micromarkFactorySpace=require(\"module$node_modules$micromark_factory_space$index\"),_micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\");exports.content={tokenize:function(effects){function lineStart(code){const token=effects.enter(\"chunkText\",{contentType:\"text\",previous});previous&&\n(previous.next=token);previous=token;return data(code)}function data(code){if(null===code)effects.exit(\"chunkText\"),effects.exit(\"paragraph\"),effects.consume(code);else{if((0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.consume(code),effects.exit(\"chunkText\"),lineStart;effects.consume(code);return data}}const contentStart=effects.attempt(this.parser.constructs.contentInitial,function(code){if(null===code)effects.consume(code);else return effects.enter(\"lineEnding\"),effects.consume(code),\neffects.exit(\"lineEnding\"),(0,_micromarkFactorySpace.factorySpace)(effects,contentStart,\"linePrefix\")},function(code){effects.enter(\"paragraph\");return lineStart(code)});let previous;return contentStart}}}","~:source","shadow$provide[\"module$node_modules$micromark$lib$initialize$content\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.content = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\n\n/** @type {InitialConstruct} */\nconst content = {\n  tokenize: initializeContent\n};\n/** @type {Initializer} */\n\nexports.content = content;\n\nfunction initializeContent(effects) {\n  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);\n  /** @type {Token} */\n\n  let previous;\n  return contentStart;\n  /** @type {State} */\n\n  function afterContentStartConstruct(code) {\n    if (code === null) {\n      effects.consume(code);\n      return;\n    }\n\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    return (0, _micromarkFactorySpace.factorySpace)(effects, contentStart, 'linePrefix');\n  }\n  /** @type {State} */\n\n\n  function paragraphInitial(code) {\n    effects.enter('paragraph');\n    return lineStart(code);\n  }\n  /** @type {State} */\n\n\n  function lineStart(code) {\n    const token = effects.enter('chunkText', {\n      contentType: 'text',\n      previous\n    });\n\n    if (previous) {\n      previous.next = token;\n    }\n\n    previous = token;\n    return data(code);\n  }\n  /** @type {State} */\n\n\n  function data(code) {\n    if (code === null) {\n      effects.exit('chunkText');\n      effects.exit('paragraph');\n      effects.consume(code);\n      return;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.consume(code);\n      effects.exit('chunkText');\n      return lineStart;\n    } // Data.\n\n\n    effects.consume(code);\n    return data;\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js","~$module$node_modules$micromark_factory_space$index"]],"~:properties",["^5",["next","tokenize","__esModule","value","previous","content","contentType"]],"~:compiled-at",1676665867260,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark$lib$initialize$content.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,oDAAA,CAAyE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGjHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,OAAR,CAAkB,IAAK,EAEvB,KAAIC,uBAAyBP,OAAA,CAAQ,mDAAR,CAA7B,CAEIQ,wBAA0BR,OAAA,CAAQ,oDAAR,CAe9BE,QAAQI,CAAAA,OAAR,CALgBA,CACdG,SAMFC,QAA0B,CAACC,OAAD,CAAU,CA6BlCC,QAASA,UAAS,CAACC,IAAD,CAAO,CACvB,MAAMC,MAAQH,OAAQI,CAAAA,KAAR,CAAc,WAAd,CAA2B,CACvCC,YAAa,MAD0B,CAEvCC,QAFuC,CAA3B,CAKVA,SAAJ;CACEA,QAASC,CAAAA,IADX,CACkBJ,KADlB,CAIAG,SAAA,CAAWH,KACX,OAAOK,KAAA,CAAKN,IAAL,CAXgB,CAgBzBM,QAASA,KAAI,CAACN,IAAD,CAAO,CAClB,GAAa,IAAb,GAAIA,IAAJ,CACEF,OAAQS,CAAAA,IAAR,CAAa,WAAb,CAEA,CADAT,OAAQS,CAAAA,IAAR,CAAa,WAAb,CACA,CAAAT,OAAQU,CAAAA,OAAR,CAAgBR,IAAhB,CAHF,KAAA,CAOA,GAAI,GAAIL,uBAAwBc,CAAAA,kBAA5B,EAAgDT,IAAhD,CAAJ,CAGE,MAFAF,QAAQU,CAAAA,OAAR,CAAgBR,IAAhB,CAEOD,CADPD,OAAQS,CAAAA,IAAR,CAAa,WAAb,CACOR,CAAAA,SAITD,QAAQU,CAAAA,OAAR,CAAgBR,IAAhB,CACA,OAAOM,KAfP,CADkB,CA5CpB,MAAMI,aAAeZ,OAAQa,CAAAA,OAAR,CAAgB,IAAKC,CAAAA,MAAOC,CAAAA,UAAWC,CAAAA,cAAvC,CAOrBC,QAAmC,CAACf,IAAD,CAAO,CACxC,GAAa,IAAb,GAAIA,IAAJ,CACEF,OAAQU,CAAAA,OAAR,CAAgBR,IAAhB,CADF,KAQA,OAHAF,QAAQI,CAAAA,KAAR,CAAc,YAAd,CAGO,CAFPJ,OAAQU,CAAAA,OAAR,CAAgBR,IAAhB,CAEO;AADPF,OAAQS,CAAAA,IAAR,CAAa,YAAb,CACO,CAAA,GAAIb,sBAAuBsB,CAAAA,YAA3B,EAAyClB,OAAzC,CAAkDY,YAAlD,CAAgE,YAAhE,CATiC,CAPrB,CAqBrBO,QAAyB,CAACjB,IAAD,CAAO,CAC9BF,OAAQI,CAAAA,KAAR,CAAc,WAAd,CACA,OAAOH,UAAA,CAAUC,IAAV,CAFuB,CArBX,CAGrB,KAAII,QACJ,OAAOM,aAL2B,CAPpBjB,CApBiG;\",\n\"sources\":[\"node_modules/micromark/lib/initialize/content.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark$lib$initialize$content\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.content = void 0;\\n\\nvar _micromarkFactorySpace = require(\\\"micromark-factory-space\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\\n * @typedef {import('micromark-util-types').Initializer} Initializer\\n * @typedef {import('micromark-util-types').Token} Token\\n * @typedef {import('micromark-util-types').State} State\\n */\\n\\n/** @type {InitialConstruct} */\\nconst content = {\\n  tokenize: initializeContent\\n};\\n/** @type {Initializer} */\\n\\nexports.content = content;\\n\\nfunction initializeContent(effects) {\\n  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);\\n  /** @type {Token} */\\n\\n  let previous;\\n  return contentStart;\\n  /** @type {State} */\\n\\n  function afterContentStartConstruct(code) {\\n    if (code === null) {\\n      effects.consume(code);\\n      return;\\n    }\\n\\n    effects.enter('lineEnding');\\n    effects.consume(code);\\n    effects.exit('lineEnding');\\n    return (0, _micromarkFactorySpace.factorySpace)(effects, contentStart, 'linePrefix');\\n  }\\n  /** @type {State} */\\n\\n\\n  function paragraphInitial(code) {\\n    effects.enter('paragraph');\\n    return lineStart(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function lineStart(code) {\\n    const token = effects.enter('chunkText', {\\n      contentType: 'text',\\n      previous\\n    });\\n\\n    if (previous) {\\n      previous.next = token;\\n    }\\n\\n    previous = token;\\n    return data(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function data(code) {\\n    if (code === null) {\\n      effects.exit('chunkText');\\n      effects.exit('paragraph');\\n      effects.consume(code);\\n      return;\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.consume(code);\\n      effects.exit('chunkText');\\n      return lineStart;\\n    } // Data.\\n\\n\\n    effects.consume(code);\\n    return data;\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"content\",\"_micromarkFactorySpace\",\"_micromarkUtilCharacter\",\"tokenize\",\"initializeContent\",\"effects\",\"lineStart\",\"code\",\"token\",\"enter\",\"contentType\",\"previous\",\"next\",\"data\",\"exit\",\"consume\",\"markdownLineEnding\",\"contentStart\",\"attempt\",\"parser\",\"constructs\",\"contentInitial\",\"afterContentStartConstruct\",\"factorySpace\",\"paragraphInitial\"]\n}\n"]