["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mdast-util-to-hast/lib/handlers/code.js"],"~:js","shadow$provide.module$node_modules$mdast_util_to_hast$lib$handlers$code=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.code=function(state,node){var value=node.value?node.value+\"\\n\":\"\";const lang=node.lang?node.lang.match(/^[^ \\t]+(?=[ \\t]|$)/):null,properties={};lang&&(properties.className=[\"language-\"+lang]);value={type:\"element\",tagName:\"code\",properties,children:[{type:\"text\",value}]};node.meta&&(value.data={meta:node.meta});state.patch(node,\nvalue);value=state.applyData(node,value);value={type:\"element\",tagName:\"pre\",properties:{},children:[value]};state.patch(node,value);return value}}","~:source","shadow$provide[\"module$node_modules$mdast_util_to_hast$lib$handlers$code\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.code = code;\n\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n\n */\n\n/**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nfunction code(state, node) {\n  const value = node.value ? node.value + '\\n' : ''; // To do: next major, use `node.lang` w/o regex, the splittingâ€™s been going\n  // on for years in remark now.\n\n  const lang = node.lang ? node.lang.match(/^[^ \\t]+(?=[ \\t]|$)/) : null;\n  /** @type {Properties} */\n\n  const properties = {};\n\n  if (lang) {\n    properties.className = ['language-' + lang];\n  } // Create `<code>`.\n\n  /** @type {Element} */\n\n\n  let result = {\n    type: 'element',\n    tagName: 'code',\n    properties,\n    children: [{\n      type: 'text',\n      value\n    }]\n  };\n\n  if (node.meta) {\n    result.data = {\n      meta: node.meta\n    };\n  }\n\n  state.patch(node, result);\n  result = state.applyData(node, result); // Create `<pre>`.\n\n  result = {\n    type: 'element',\n    tagName: 'pre',\n    properties: {},\n    children: [result]\n  };\n  state.patch(node, result);\n  return result;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["properties","className","children","__esModule","value","type","tagName","meta","data","code"]],"~:compiled-at",1676665867309,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mdast_util_to_hast$lib$handlers$code.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,wDAAA,CAA6E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGrHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,IAAR,CAoBAA,QAAa,CAACC,KAAD,CAAQC,IAAR,CAAc,CACzB,IAAMH,MAAQG,IAAKH,CAAAA,KAAL,CAAaG,IAAKH,CAAAA,KAAlB,CAA0B,IAA1B,CAAiC,EAG/C,OAAMI,KAAOD,IAAKC,CAAAA,IAAL,CAAYD,IAAKC,CAAAA,IAAKC,CAAAA,KAAV,CAAgB,qBAAhB,CAAZ,CAAqD,IAAlE,CAGMC,WAAa,EAEfF,KAAJ,GACEE,UAAWC,CAAAA,SADb,CACyB,CAAC,WAAD,CAAeH,IAAf,CADzB,CAOII,MAAAA,CAAS,CACXC,KAAM,SADK,CAEXC,QAAS,MAFE,CAGXJ,UAHW,CAIXK,SAAU,CAAC,CACTF,KAAM,MADG,CAETT,KAFS,CAAD,CAJC,CAUTG,KAAKS,CAAAA,IAAT,GACEJ,KAAOK,CAAAA,IADT,CACgB,CACZD,KAAMT,IAAKS,CAAAA,IADC,CADhB,CAMAV,MAAMY,CAAAA,KAAN,CAAYX,IAAZ;AAAkBK,KAAlB,CACAA,MAAA,CAASN,KAAMa,CAAAA,SAAN,CAAgBZ,IAAhB,CAAsBK,KAAtB,CAETA,MAAA,CAAS,CACPC,KAAM,SADC,CAEPC,QAAS,KAFF,CAGPJ,WAAY,EAHL,CAIPK,SAAU,CAACH,KAAD,CAJH,CAMTN,MAAMY,CAAAA,KAAN,CAAYX,IAAZ,CAAkBK,KAAlB,CACA,OAAOA,MA1CkB,CA1B0F;\",\n\"sources\":[\"node_modules/mdast-util-to-hast/lib/handlers/code.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mdast_util_to_hast$lib$handlers$code\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.code = code;\\n\\n/**\\n * @typedef {import('hast').Element} Element\\n * @typedef {import('hast').Properties} Properties\\n * @typedef {import('mdast').Code} Code\\n * @typedef {import('../state.js').State} State\\n\\n */\\n\\n/**\\n * Turn an mdast `code` node into hast.\\n *\\n * @param {State} state\\n *   Info passed around.\\n * @param {Code} node\\n *   mdast node.\\n * @returns {Element}\\n *   hast node.\\n */\\nfunction code(state, node) {\\n  const value = node.value ? node.value + '\\\\n' : ''; // To do: next major, use `node.lang` w/o regex, the splitting\\u2019s been going\\n  // on for years in remark now.\\n\\n  const lang = node.lang ? node.lang.match(/^[^ \\\\t]+(?=[ \\\\t]|$)/) : null;\\n  /** @type {Properties} */\\n\\n  const properties = {};\\n\\n  if (lang) {\\n    properties.className = ['language-' + lang];\\n  } // Create `<code>`.\\n\\n  /** @type {Element} */\\n\\n\\n  let result = {\\n    type: 'element',\\n    tagName: 'code',\\n    properties,\\n    children: [{\\n      type: 'text',\\n      value\\n    }]\\n  };\\n\\n  if (node.meta) {\\n    result.data = {\\n      meta: node.meta\\n    };\\n  }\\n\\n  state.patch(node, result);\\n  result = state.applyData(node, result); // Create `<pre>`.\\n\\n  result = {\\n    type: 'element',\\n    tagName: 'pre',\\n    properties: {},\\n    children: [result]\\n  };\\n  state.patch(node, result);\\n  return result;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"code\",\"state\",\"node\",\"lang\",\"match\",\"properties\",\"className\",\"result\",\"type\",\"tagName\",\"children\",\"meta\",\"data\",\"patch\",\"applyData\"]\n}\n"]