["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/mermaid.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$mermaid=function(global,require,module,exports){function mermaid(Prism){Prism.languages.mermaid={comment:{pattern:/%%.*/,greedy:!0},style:{pattern:/^([ \\t]*(?:classDef|linkStyle|style)[ \\t]+[\\w$-]+[ \\t]+)\\w.*[^\\s;]/m,lookbehind:!0,inside:{property:/\\b\\w[\\w-]*(?=[ \\t]*:)/,operator:/:/,punctuation:/,/}},\"inter-arrow-label\":{pattern:/([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \\t]*(?:\"[^\"\\r\\n]*\"|[^\\s\".=-](?:[^\\r\\n.=-]*[^\\s.=-])?)[ \\t]*(?:\\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,\nlookbehind:!0,greedy:!0,inside:{arrow:{pattern:/(?:\\.+->?|--+[->]|==+[=>])$/,alias:\"operator\"},label:{pattern:/^([\\s\\S]{2}[ \\t]*)\\S(?:[\\s\\S]*\\S)?/,lookbehind:!0,alias:\"property\"},\"arrow-head\":{pattern:/^\\S+/,alias:[\"arrow\",\"operator\"]}}},arrow:[{pattern:/(^|[^{}|o.-])[|}][|o](?:--|\\.\\.)[|o][|{](?![{}|o.-])/,lookbehind:!0,alias:\"operator\"},{pattern:/(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\\.*-)[>ox]?|(?:==+|--+|-\\.*-)[>ox]|===+|---+|-\\.+-)(?![<>ox.=-])/,lookbehind:!0,alias:\"operator\"},{pattern:/(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,\nlookbehind:!0,alias:\"operator\"},{pattern:/(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\\|?(?:--|\\.\\.)|(?:--|\\.\\.)\\|?>|--|\\.\\.)(?![<>|*o.-])/,lookbehind:!0,alias:\"operator\"}],label:{pattern:/(^|[^|<])\\|(?:[^\\r\\n\"|]|\"[^\"\\r\\n]*\")+\\|/,lookbehind:!0,greedy:!0,alias:\"property\"},text:{pattern:/(?:[(\\[{]+|\\b>)(?:[^\\r\\n\"()\\[\\]{}]|\"[^\"\\r\\n]*\")+(?:[)\\]}]+|>)/,alias:\"string\"},string:{pattern:/\"[^\"\\r\\n]*\"/,greedy:!0},annotation:{pattern:/<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\\[\\[(?:choice|fork|join)\\]\\]/i,\nalias:\"important\"},keyword:[{pattern:/(^[ \\t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\\w$-])/m,lookbehind:!0,greedy:!0},{pattern:/(^[ \\t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \\t]+note)?|loop|opt|par|participant|rect|state|note[ \\t]+(?:over|(?:left|right)[ \\t]+of))(?![\\w$-])/im,lookbehind:!0,greedy:!0}],\nentity:/#[a-z0-9]+;/,operator:{pattern:/(\\w[ \\t]*)&(?=[ \\t]*\\w)|:::|:/,lookbehind:!0},punctuation:/[(){};]/}}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=mermaid;mermaid.displayName=\"mermaid\";mermaid.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$mermaid\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = mermaid;\n// @ts-nocheck\nmermaid.displayName = 'mermaid';\nmermaid.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction mermaid(Prism) {\n  Prism.languages.mermaid = {\n    comment: {\n      pattern: /%%.*/,\n      greedy: true\n    },\n    style: {\n      pattern: /^([ \\t]*(?:classDef|linkStyle|style)[ \\t]+[\\w$-]+[ \\t]+)\\w.*[^\\s;]/m,\n      lookbehind: true,\n      inside: {\n        property: /\\b\\w[\\w-]*(?=[ \\t]*:)/,\n        operator: /:/,\n        punctuation: /,/\n      }\n    },\n    'inter-arrow-label': {\n      pattern: /([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \\t]*(?:\"[^\"\\r\\n]*\"|[^\\s\".=-](?:[^\\r\\n.=-]*[^\\s.=-])?)[ \\t]*(?:\\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        arrow: {\n          pattern: /(?:\\.+->?|--+[->]|==+[=>])$/,\n          alias: 'operator'\n        },\n        label: {\n          pattern: /^([\\s\\S]{2}[ \\t]*)\\S(?:[\\s\\S]*\\S)?/,\n          lookbehind: true,\n          alias: 'property'\n        },\n        'arrow-head': {\n          pattern: /^\\S+/,\n          alias: ['arrow', 'operator']\n        }\n      }\n    },\n    arrow: [// This might look complex but it really isn't.\n    // There are many possible arrows (see tests) and it's impossible to fit all of them into one pattern. The\n    // problem is that we only have one lookbehind per pattern. However, we cannot disallow too many arrow\n    // characters in the one lookbehind because that would create too many false negatives. So we have to split the\n    // arrows into different patterns.\n    {\n      // ER diagram\n      pattern: /(^|[^{}|o.-])[|}][|o](?:--|\\.\\.)[|o][|{](?![{}|o.-])/,\n      lookbehind: true,\n      alias: 'operator'\n    }, {\n      // flow chart\n      // (?:==+|--+|-\\.*-)\n      pattern: /(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\\.*-)[>ox]?|(?:==+|--+|-\\.*-)[>ox]|===+|---+|-\\.+-)(?![<>ox.=-])/,\n      lookbehind: true,\n      alias: 'operator'\n    }, {\n      // sequence diagram\n      pattern: /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,\n      lookbehind: true,\n      alias: 'operator'\n    }, {\n      // class diagram\n      pattern: /(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\\|?(?:--|\\.\\.)|(?:--|\\.\\.)\\|?>|--|\\.\\.)(?![<>|*o.-])/,\n      lookbehind: true,\n      alias: 'operator'\n    }],\n    label: {\n      pattern: /(^|[^|<])\\|(?:[^\\r\\n\"|]|\"[^\"\\r\\n]*\")+\\|/,\n      lookbehind: true,\n      greedy: true,\n      alias: 'property'\n    },\n    text: {\n      pattern: /(?:[(\\[{]+|\\b>)(?:[^\\r\\n\"()\\[\\]{}]|\"[^\"\\r\\n]*\")+(?:[)\\]}]+|>)/,\n      alias: 'string'\n    },\n    string: {\n      pattern: /\"[^\"\\r\\n]*\"/,\n      greedy: true\n    },\n    annotation: {\n      pattern: /<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\\[\\[(?:choice|fork|join)\\]\\]/i,\n      alias: 'important'\n    },\n    keyword: [// This language has both case-sensitive and case-insensitive keywords\n    {\n      pattern: /(^[ \\t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\\w$-])/m,\n      lookbehind: true,\n      greedy: true\n    }, {\n      pattern: /(^[ \\t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \\t]+note)?|loop|opt|par|participant|rect|state|note[ \\t]+(?:over|(?:left|right)[ \\t]+of))(?![\\w$-])/im,\n      lookbehind: true,\n      greedy: true\n    }],\n    entity: /#[a-z0-9]+;/,\n    operator: {\n      pattern: /(\\w[ \\t]*)&(?=[ \\t]*\\w)|:::|:/,\n      lookbehind: true\n    },\n    punctuation: /[(){};]/\n  };\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["punctuation","string","aliases","arrow","operator","displayName","label","__esModule","lookbehind","style","value","text","keyword","greedy","property","mermaid","pattern","inside","annotation","alias","comment","entity","default"]],"~:compiled-at",1676841365437,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$mermaid.js\",\n\"lineCount\":5,\n\"mappings\":\"AAAAA,cAAA,CAAA,0CAAA,CAA+D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAYvGC,QAASA,QAAO,CAACC,KAAD,CAAQ,CACtBA,KAAMC,CAAAA,SAAUF,CAAAA,OAAhB,CAA0B,CACxBG,QAAS,CACPC,QAAS,MADF,CAEPC,OAAQ,CAAA,CAFD,CADe,CAKxBC,MAAO,CACLF,QAAS,qEADJ,CAELG,WAAY,CAAA,CAFP,CAGLC,OAAQ,CACNC,SAAU,uBADJ,CAENC,SAAU,GAFJ,CAGNC,YAAa,GAHP,CAHH,CALiB,CAcxB,oBAAqB,CACnBP,QAAS,2IADU;AAEnBG,WAAY,CAAA,CAFO,CAGnBF,OAAQ,CAAA,CAHW,CAInBG,OAAQ,CACNI,MAAO,CACLR,QAAS,6BADJ,CAELS,MAAO,UAFF,CADD,CAKNC,MAAO,CACLV,QAAS,oCADJ,CAELG,WAAY,CAAA,CAFP,CAGLM,MAAO,UAHF,CALD,CAUN,aAAc,CACZT,QAAS,MADG,CAEZS,MAAO,CAAC,OAAD,CAAU,UAAV,CAFK,CAVR,CAJW,CAdG,CAkCxBD,MAAO,CAKP,CAEER,QAAS,sDAFX,CAGEG,WAAY,CAAA,CAHd,CAIEM,MAAO,UAJT,CALO,CAUJ,CAGDT,QAAS,oGAHR,CAIDG,WAAY,CAAA,CAJX,CAKDM,MAAO,UALN,CAVI,CAgBJ,CAEDT,QAAS,kEAFR;AAGDG,WAAY,CAAA,CAHX,CAIDM,MAAO,UAJN,CAhBI,CAqBJ,CAEDT,QAAS,sFAFR,CAGDG,WAAY,CAAA,CAHX,CAIDM,MAAO,UAJN,CArBI,CAlCiB,CA6DxBC,MAAO,CACLV,QAAS,yCADJ,CAELG,WAAY,CAAA,CAFP,CAGLF,OAAQ,CAAA,CAHH,CAILQ,MAAO,UAJF,CA7DiB,CAmExBE,KAAM,CACJX,QAAS,+DADL,CAEJS,MAAO,QAFH,CAnEkB,CAuExBG,OAAQ,CACNZ,QAAS,aADH,CAENC,OAAQ,CAAA,CAFF,CAvEgB,CA2ExBY,WAAY,CACVb,QAAS,+FADC;AAEVS,MAAO,WAFG,CA3EY,CA+ExBK,QAAS,CACT,CACEd,QAAS,wOADX,CAEEG,WAAY,CAAA,CAFd,CAGEF,OAAQ,CAAA,CAHV,CADS,CAKN,CACDD,QAAS,0KADR,CAEDG,WAAY,CAAA,CAFX,CAGDF,OAAQ,CAAA,CAHP,CALM,CA/Ee;AAyFxBc,OAAQ,aAzFgB,CA0FxBT,SAAU,CACRN,QAAS,+BADD,CAERG,WAAY,CAAA,CAFJ,CA1Fc,CA8FxBI,YAAa,SA9FW,CADJ,CATxBS,MAAOC,CAAAA,cAAP,CAAsBtB,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CuB,MAAO,CAAA,CADoC,CAA7C,CAGAvB,QAAQwB,CAAAA,OAAR,CAAkBvB,OAElBA,QAAQwB,CAAAA,WAAR,CAAsB,SACtBxB,QAAQyB,CAAAA,OAAR,CAAkB,EATqF;\",\n\"sources\":[\"node_modules/refractor/lang/mermaid.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$mermaid\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = mermaid;\\n// @ts-nocheck\\nmermaid.displayName = 'mermaid';\\nmermaid.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction mermaid(Prism) {\\n  Prism.languages.mermaid = {\\n    comment: {\\n      pattern: /%%.*/,\\n      greedy: true\\n    },\\n    style: {\\n      pattern: /^([ \\\\t]*(?:classDef|linkStyle|style)[ \\\\t]+[\\\\w$-]+[ \\\\t]+)\\\\w.*[^\\\\s;]/m,\\n      lookbehind: true,\\n      inside: {\\n        property: /\\\\b\\\\w[\\\\w-]*(?=[ \\\\t]*:)/,\\n        operator: /:/,\\n        punctuation: /,/\\n      }\\n    },\\n    'inter-arrow-label': {\\n      pattern: /([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \\\\t]*(?:\\\"[^\\\"\\\\r\\\\n]*\\\"|[^\\\\s\\\".=-](?:[^\\\\r\\\\n.=-]*[^\\\\s.=-])?)[ \\\\t]*(?:\\\\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,\\n      lookbehind: true,\\n      greedy: true,\\n      inside: {\\n        arrow: {\\n          pattern: /(?:\\\\.+->?|--+[->]|==+[=>])$/,\\n          alias: 'operator'\\n        },\\n        label: {\\n          pattern: /^([\\\\s\\\\S]{2}[ \\\\t]*)\\\\S(?:[\\\\s\\\\S]*\\\\S)?/,\\n          lookbehind: true,\\n          alias: 'property'\\n        },\\n        'arrow-head': {\\n          pattern: /^\\\\S+/,\\n          alias: ['arrow', 'operator']\\n        }\\n      }\\n    },\\n    arrow: [// This might look complex but it really isn't.\\n    // There are many possible arrows (see tests) and it's impossible to fit all of them into one pattern. The\\n    // problem is that we only have one lookbehind per pattern. However, we cannot disallow too many arrow\\n    // characters in the one lookbehind because that would create too many false negatives. So we have to split the\\n    // arrows into different patterns.\\n    {\\n      // ER diagram\\n      pattern: /(^|[^{}|o.-])[|}][|o](?:--|\\\\.\\\\.)[|o][|{](?![{}|o.-])/,\\n      lookbehind: true,\\n      alias: 'operator'\\n    }, {\\n      // flow chart\\n      // (?:==+|--+|-\\\\.*-)\\n      pattern: /(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\\\\.*-)[>ox]?|(?:==+|--+|-\\\\.*-)[>ox]|===+|---+|-\\\\.+-)(?![<>ox.=-])/,\\n      lookbehind: true,\\n      alias: 'operator'\\n    }, {\\n      // sequence diagram\\n      pattern: /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,\\n      lookbehind: true,\\n      alias: 'operator'\\n    }, {\\n      // class diagram\\n      pattern: /(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\\\\|?(?:--|\\\\.\\\\.)|(?:--|\\\\.\\\\.)\\\\|?>|--|\\\\.\\\\.)(?![<>|*o.-])/,\\n      lookbehind: true,\\n      alias: 'operator'\\n    }],\\n    label: {\\n      pattern: /(^|[^|<])\\\\|(?:[^\\\\r\\\\n\\\"|]|\\\"[^\\\"\\\\r\\\\n]*\\\")+\\\\|/,\\n      lookbehind: true,\\n      greedy: true,\\n      alias: 'property'\\n    },\\n    text: {\\n      pattern: /(?:[(\\\\[{]+|\\\\b>)(?:[^\\\\r\\\\n\\\"()\\\\[\\\\]{}]|\\\"[^\\\"\\\\r\\\\n]*\\\")+(?:[)\\\\]}]+|>)/,\\n      alias: 'string'\\n    },\\n    string: {\\n      pattern: /\\\"[^\\\"\\\\r\\\\n]*\\\"/,\\n      greedy: true\\n    },\\n    annotation: {\\n      pattern: /<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\\\\[\\\\[(?:choice|fork|join)\\\\]\\\\]/i,\\n      alias: 'important'\\n    },\\n    keyword: [// This language has both case-sensitive and case-insensitive keywords\\n    {\\n      pattern: /(^[ \\\\t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\\\\w$-])/m,\\n      lookbehind: true,\\n      greedy: true\\n    }, {\\n      pattern: /(^[ \\\\t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \\\\t]+note)?|loop|opt|par|participant|rect|state|note[ \\\\t]+(?:over|(?:left|right)[ \\\\t]+of))(?![\\\\w$-])/im,\\n      lookbehind: true,\\n      greedy: true\\n    }],\\n    entity: /#[a-z0-9]+;/,\\n    operator: {\\n      pattern: /(\\\\w[ \\\\t]*)&(?=[ \\\\t]*\\\\w)|:::|:/,\\n      lookbehind: true\\n    },\\n    punctuation: /[(){};]/\\n  };\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"mermaid\",\"Prism\",\"languages\",\"comment\",\"pattern\",\"greedy\",\"style\",\"lookbehind\",\"inside\",\"property\",\"operator\",\"punctuation\",\"arrow\",\"alias\",\"label\",\"text\",\"string\",\"annotation\",\"keyword\",\"entity\",\"Object\",\"defineProperty\",\"value\",\"default\",\"displayName\",\"aliases\"]\n}\n"]