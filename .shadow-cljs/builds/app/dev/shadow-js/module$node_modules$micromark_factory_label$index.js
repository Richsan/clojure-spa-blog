["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-factory-label/index.js"],"~:js","shadow$provide.module$node_modules$micromark_factory_label$index=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.factoryLabel=function(effects,ok,nok,type,markerType,stringType){function atBreak(code){if(null===code||91===code||93===code&&!data||94===code&&!size&&\"_hiddenFootnoteSupport\"in self.parser.constructs||999<size)return nok(code);if(93===code)return effects.exit(stringType),effects.enter(markerType),effects.consume(code),effects.exit(markerType),\neffects.exit(type),ok;if((0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.enter(\"lineEnding\"),effects.consume(code),effects.exit(\"lineEnding\"),atBreak;effects.enter(\"chunkString\",{contentType:\"string\"});return label(code)}function label(code){if(null===code||91===code||93===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code)||999<size++)return effects.exit(\"chunkString\"),atBreak(code);effects.consume(code);data=data||!(0,_micromarkUtilCharacter.markdownSpace)(code);return 92===\ncode?labelEscape:label}function labelEscape(code){return 91===code||92===code||93===code?(effects.consume(code),size++,label):label(code)}const self=this;let size=0,data;return function(code){effects.enter(type);effects.enter(markerType);effects.consume(code);effects.exit(markerType);effects.enter(stringType);return atBreak}};var _micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\")}","~:source","shadow$provide[\"module$node_modules$micromark_factory_label$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factoryLabel = factoryLabel;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').State} State\n */\n\n/**\n * @this {TokenizeContext}\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nfunction factoryLabel(effects, ok, nok, type, markerType, stringType) {\n  const self = this;\n  let size = 0;\n  /** @type {boolean} */\n\n  let data;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type);\n    effects.enter(markerType);\n    effects.consume(code);\n    effects.exit(markerType);\n    effects.enter(stringType);\n    return atBreak;\n  }\n  /** @type {State} */\n\n\n  function atBreak(code) {\n    if (code === null || code === 91 || code === 93 && !data || code === 94 && !size && '_hiddenFootnoteSupport' in self.parser.constructs || size > 999) {\n      return nok(code);\n    }\n\n    if (code === 93) {\n      effects.exit(stringType);\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      effects.exit(type);\n      return ok;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return atBreak;\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function label(code) {\n    if (code === null || code === 91 || code === 93 || (0, _micromarkUtilCharacter.markdownLineEnding)(code) || size++ > 999) {\n      effects.exit('chunkString');\n      return atBreak(code);\n    }\n\n    effects.consume(code);\n    data = data || !(0, _micromarkUtilCharacter.markdownSpace)(code);\n    return code === 92 ? labelEscape : label;\n  }\n  /** @type {State} */\n\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return label;\n    }\n\n    return label(code);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js"]],"~:properties",["^5",["__esModule","value","factoryLabel","contentType"]],"~:compiled-at",1676665867285,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_factory_label$index.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-factory-label/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_factory_label$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.factoryLabel = factoryLabel;\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Effects} Effects\\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\\n * @typedef {import('micromark-util-types').State} State\\n */\\n\\n/**\\n * @this {TokenizeContext}\\n * @param {Effects} effects\\n * @param {State} ok\\n * @param {State} nok\\n * @param {string} type\\n * @param {string} markerType\\n * @param {string} stringType\\n * @returns {State}\\n */\\n// eslint-disable-next-line max-params\\nfunction factoryLabel(effects, ok, nok, type, markerType, stringType) {\\n  const self = this;\\n  let size = 0;\\n  /** @type {boolean} */\\n\\n  let data;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter(type);\\n    effects.enter(markerType);\\n    effects.consume(code);\\n    effects.exit(markerType);\\n    effects.enter(stringType);\\n    return atBreak;\\n  }\\n  /** @type {State} */\\n\\n\\n  function atBreak(code) {\\n    if (code === null || code === 91 || code === 93 && !data || code === 94 && !size && '_hiddenFootnoteSupport' in self.parser.constructs || size > 999) {\\n      return nok(code);\\n    }\\n\\n    if (code === 93) {\\n      effects.exit(stringType);\\n      effects.enter(markerType);\\n      effects.consume(code);\\n      effects.exit(markerType);\\n      effects.exit(type);\\n      return ok;\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.enter('lineEnding');\\n      effects.consume(code);\\n      effects.exit('lineEnding');\\n      return atBreak;\\n    }\\n\\n    effects.enter('chunkString', {\\n      contentType: 'string'\\n    });\\n    return label(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function label(code) {\\n    if (code === null || code === 91 || code === 93 || (0, _micromarkUtilCharacter.markdownLineEnding)(code) || size++ > 999) {\\n      effects.exit('chunkString');\\n      return atBreak(code);\\n    }\\n\\n    effects.consume(code);\\n    data = data || !(0, _micromarkUtilCharacter.markdownSpace)(code);\\n    return code === 92 ? labelEscape : label;\\n  }\\n  /** @type {State} */\\n\\n\\n  function labelEscape(code) {\\n    if (code === 91 || code === 92 || code === 93) {\\n      effects.consume(code);\\n      size++;\\n      return label;\\n    }\\n\\n    return label(code);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"factoryLabel\",\"effects\",\"ok\",\"nok\",\"type\",\"markerType\",\"stringType\",\"atBreak\",\"code\",\"data\",\"size\",\"self\",\"parser\",\"constructs\",\"exit\",\"enter\",\"consume\",\"_micromarkUtilCharacter\",\"markdownLineEnding\",\"contentType\",\"label\",\"markdownSpace\",\"labelEscape\",\"start\"]\n}\n"]