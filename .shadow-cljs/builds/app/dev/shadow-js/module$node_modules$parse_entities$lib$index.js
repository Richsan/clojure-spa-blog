["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/parse-entities/lib/index.js"],"~:js","shadow$provide.module$node_modules$parse_entities$lib$index=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.parseEntities=function(value,options={}){function now(){return{line,column,offset:index+((point?point.offset:0)||0)}}function warning(code,offset){let position;options.warning&&(position=now(),position.column+=offset,position.offset+=offset,options.warning.call(options.warningContext,messages[code],position,code))}function flush(){queue&&\n(result.push(queue),options.text&&options.text.call(options.textContext,queue,{start:previous,end:now()}),queue=\"\")}const additional=\"string\"===typeof options.additional?options.additional.charCodeAt(0):options.additional,result=[];let index=0,lines=-1,queue=\"\",point,indent;options.position&&(\"start\"in options.position||\"indent\"in options.position?(indent=options.position.indent,point=options.position.start):point=options.position);let line=(point?point.line:0)||1,column=(point?point.column:0)||1,\nprevious=now(),character;for(index--;++index<=value.length;)if(10===character&&(column=(indent?indent[lines]:0)||1),character=value.charCodeAt(index),38===character){var following=value.charCodeAt(index+1);if(9===following||10===following||12===following||32===following||38===following||60===following||Number.isNaN(following)||additional&&following===additional){queue+=fromCharCode(character);column++;continue}const start=index+1;var begin=start;let end=start;var type=void 0;35===following?(end=++begin,\nfollowing=value.charCodeAt(end),88===following||120===following?(type=\"hexadecimal\",end=++begin):type=\"decimal\"):type=\"named\";let characterReferenceCharacters=\"\",characters=following=\"\";var test=\"named\"===type?_isAlphanumerical.isAlphanumerical:\"decimal\"===type?_isDecimal.isDecimal:_isHexadecimal.isHexadecimal;for(end--;++end<=value.length;){var following$jscomp$0=value.charCodeAt(end);if(!test(following$jscomp$0))break;characters+=fromCharCode(following$jscomp$0);\"named\"===type&&_characterEntitiesLegacy.characterEntitiesLegacy.includes(characters)&&\n(characterReferenceCharacters=characters,following=(0,_decodeNamedCharacterReference.decodeNamedCharacterReference)(characters))}if(following$jscomp$0=59===value.charCodeAt(end))if(end++,test=\"named\"===type?(0,_decodeNamedCharacterReference.decodeNamedCharacterReference)(characters):!1)characterReferenceCharacters=characters,following=test;test=1+end-start;let reference=\"\";if(following$jscomp$0||!1!==options.nonTerminated)characters?\"named\"===type?(following$jscomp$0&&!following?warning(5,1):(characterReferenceCharacters!==\ncharacters&&(end=begin+characterReferenceCharacters.length,test=1+end-begin,following$jscomp$0=!1),following$jscomp$0||(begin=characterReferenceCharacters?1:3,options.attribute?(type=value.charCodeAt(end),61===type?(warning(begin,test),following=\"\"):(0,_isAlphanumerical.isAlphanumerical)(type)?following=\"\":warning(begin,test)):warning(begin,test))),reference=following):(following$jscomp$0||warning(2,test),begin=Number.parseInt(characters,\"hexadecimal\"===type?16:10),55296<=begin&&57343>=begin||1114111<\nbegin?(warning(7,test),reference=fromCharCode(65533)):begin in _characterReferenceInvalid.characterReferenceInvalid?(warning(6,test),reference=_characterReferenceInvalid.characterReferenceInvalid[begin]):(following=\"\",(1<=begin&&8>=begin||11===begin||13<=begin&&31>=begin||127<=begin&&159>=begin||64976<=begin&&65007>=begin||65535===(begin&65535)||65534===(begin&65535))&&warning(6,test),65535<begin&&(begin-=65536,following+=fromCharCode(begin>>>10|55296),begin=56320|begin&1023),reference=following+\nfromCharCode(begin))):\"named\"!==type&&warning(4,test);reference?(flush(),previous=now(),index=end-1,column+=end-start+1,result.push(reference),begin=now(),begin.offset++,options.reference&&options.reference.call(options.referenceContext,reference,{start:previous,end:begin},value.slice(start-1,end)),previous=begin):(characters=value.slice(start-1,end),queue+=characters,column+=characters.length,index=end-1)}else 10===character&&(line++,lines++,column=0),Number.isNaN(character)?flush():(queue+=fromCharCode(character),\ncolumn++);return result.join(\"\")};var _characterEntitiesLegacy=require(\"module$node_modules$character_entities_legacy$index\"),_characterReferenceInvalid=require(\"module$node_modules$character_reference_invalid$index\"),_isDecimal=require(\"module$node_modules$is_decimal$index\"),_isHexadecimal=require(\"module$node_modules$is_hexadecimal$index\"),_isAlphanumerical=require(\"module$node_modules$is_alphanumerical$index\"),_decodeNamedCharacterReference=require(\"module$node_modules$decode_named_character_reference$index\");\nconst fromCharCode=String.fromCharCode,messages=\";Named character references must be terminated by a semicolon;Numeric character references must be terminated by a semicolon;Named character references cannot be empty;Numeric character references cannot be empty;Named character references must be known;Numeric character references cannot be disallowed;Numeric character references cannot be outside the permissible Unicode range\".split(\";\")}","~:source","shadow$provide[\"module$node_modules$parse_entities$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseEntities = parseEntities;\n\nvar _characterEntitiesLegacy = require(\"character-entities-legacy\");\n\nvar _characterReferenceInvalid = require(\"character-reference-invalid\");\n\nvar _isDecimal = require(\"is-decimal\");\n\nvar _isHexadecimal = require(\"is-hexadecimal\");\n\nvar _isAlphanumerical = require(\"is-alphanumerical\");\n\nvar _decodeNamedCharacterReference = require(\"decode-named-character-reference\");\n\n/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\nconst fromCharCode = String.fromCharCode; // Warning messages.\n\nconst messages = ['',\n/* 1: Non terminated (named) */\n'Named character references must be terminated by a semicolon',\n/* 2: Non terminated (numeric) */\n'Numeric character references must be terminated by a semicolon',\n/* 3: Empty (named) */\n'Named character references cannot be empty',\n/* 4: Empty (numeric) */\n'Numeric character references cannot be empty',\n/* 5: Unknown (named) */\n'Named character references must be known',\n/* 6: Disallowed (numeric) */\n'Numeric character references cannot be disallowed',\n/* 7: Prohibited (numeric) */\n'Numeric character references cannot be outside the permissible Unicode range'];\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {import('../index.js').Options} [options={}]\n */\n\nfunction parseEntities(value, options = {}) {\n  const additional = typeof options.additional === 'string' ? options.additional.charCodeAt(0) : options.additional;\n  /** @type {Array<string>} */\n\n  const result = [];\n  let index = 0;\n  let lines = -1;\n  let queue = '';\n  /** @type {Point|undefined} */\n\n  let point;\n  /** @type {Array<number>|undefined} */\n\n  let indent;\n\n  if (options.position) {\n    if ('start' in options.position || 'indent' in options.position) {\n      // @ts-expect-error: points don’t have indent.\n      indent = options.position.indent; // @ts-expect-error: points don’t have indent.\n\n      point = options.position.start;\n    } else {\n      point = options.position;\n    }\n  }\n\n  let line = (point ? point.line : 0) || 1;\n  let column = (point ? point.column : 0) || 1; // Cache the current point.\n\n  let previous = now();\n  /** @type {number|undefined} */\n\n  let character; // Ensure the algorithm walks over the first character (inclusive).\n\n  index--;\n\n  while (++index <= value.length) {\n    // If the previous character was a newline.\n    if (character === 10\n    /* `\\n` */\n    ) {\n      column = (indent ? indent[lines] : 0) || 1;\n    }\n\n    character = value.charCodeAt(index);\n\n    if (character === 38\n    /* `&` */\n    ) {\n      const following = value.charCodeAt(index + 1); // The behavior depends on the identity of the next character.\n\n      if (following === 9\n      /* `\\t` */\n      || following === 10\n      /* `\\n` */\n      || following === 12\n      /* `\\f` */\n      || following === 32\n      /* ` ` */\n      || following === 38\n      /* `&` */\n      || following === 60\n      /* `<` */\n      || Number.isNaN(following) || additional && following === additional) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += fromCharCode(character);\n        column++;\n        continue;\n      }\n\n      const start = index + 1;\n      let begin = start;\n      let end = start;\n      /** @type {string} */\n\n      let type;\n\n      if (following === 35\n      /* `#` */\n      ) {\n        // Numerical reference.\n        end = ++begin; // The behavior further depends on the next character.\n\n        const following = value.charCodeAt(end);\n\n        if (following === 88\n        /* `X` */\n        || following === 120\n        /* `x` */\n        ) {\n          // ASCII hexadecimal digits.\n          type = 'hexadecimal';\n          end = ++begin;\n        } else {\n          // ASCII decimal digits.\n          type = 'decimal';\n        }\n      } else {\n        // Named reference.\n        type = 'named';\n      }\n\n      let characterReferenceCharacters = '';\n      let characterReference = '';\n      let characters = ''; // Each type of character reference accepts different characters.\n      // This test is used to detect whether a reference has ended (as the semicolon\n      // is not strictly needed).\n\n      const test = type === 'named' ? _isAlphanumerical.isAlphanumerical : type === 'decimal' ? _isDecimal.isDecimal : _isHexadecimal.isHexadecimal;\n      end--;\n\n      while (++end <= value.length) {\n        const following = value.charCodeAt(end);\n\n        if (!test(following)) {\n          break;\n        }\n\n        characters += fromCharCode(following); // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n\n        if (type === 'named' && _characterEntitiesLegacy.characterEntitiesLegacy.includes(characters)) {\n          characterReferenceCharacters = characters; // @ts-expect-error: always able to decode.\n\n          characterReference = (0, _decodeNamedCharacterReference.decodeNamedCharacterReference)(characters);\n        }\n      }\n\n      let terminated = value.charCodeAt(end) === 59;\n      /* `;` */\n\n      if (terminated) {\n        end++;\n        const namedReference = type === 'named' ? (0, _decodeNamedCharacterReference.decodeNamedCharacterReference)(characters) : false;\n\n        if (namedReference) {\n          characterReferenceCharacters = characters;\n          characterReference = namedReference;\n        }\n      }\n\n      let diff = 1 + end - start;\n      let reference = '';\n\n      if (!terminated && options.nonTerminated === false) {// Empty.\n      } else if (!characters) {\n        // An empty (possible) reference is valid, unless it’s numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== 'named') {\n          warning(4\n          /* Empty (numeric) */\n          , diff);\n        }\n      } else if (type === 'named') {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !characterReference) {\n          warning(5\n          /* Unknown (named) */\n          , 1);\n        } else {\n          // If there’s something after an named reference which is not known,\n          // cap the reference.\n          if (characterReferenceCharacters !== characters) {\n            end = begin + characterReferenceCharacters.length;\n            diff = 1 + end - begin;\n            terminated = false;\n          } // If the reference is not terminated, warn.\n\n\n          if (!terminated) {\n            const reason = characterReferenceCharacters ? 1\n            /* Non terminated (named) */\n            : 3;\n            /* Empty (named) */\n\n            if (options.attribute) {\n              const following = value.charCodeAt(end);\n\n              if (following === 61\n              /* `=` */\n              ) {\n                warning(reason, diff);\n                characterReference = '';\n              } else if ((0, _isAlphanumerical.isAlphanumerical)(following)) {\n                characterReference = '';\n              } else {\n                warning(reason, diff);\n              }\n            } else {\n              warning(reason, diff);\n            }\n          }\n        }\n\n        reference = characterReference;\n      } else {\n        if (!terminated) {\n          // All nonterminated numeric references are not rendered, and emit a\n          // warning.\n          warning(2\n          /* Non terminated (numeric) */\n          , diff);\n        } // When terminated and numerical, parse as either hexadecimal or\n        // decimal.\n\n\n        let referenceCode = Number.parseInt(characters, type === 'hexadecimal' ? 16 : 10); // Emit a warning when the parsed number is prohibited, and replace with\n        // replacement character.\n\n        if (prohibited(referenceCode)) {\n          warning(7\n          /* Prohibited (numeric) */\n          , diff);\n          reference = fromCharCode(65533\n          /* `�` */\n          );\n        } else if (referenceCode in _characterReferenceInvalid.characterReferenceInvalid) {\n          // Emit a warning when the parsed number is disallowed, and replace by\n          // an alternative.\n          warning(6\n          /* Disallowed (numeric) */\n          , diff);\n          reference = _characterReferenceInvalid.characterReferenceInvalid[referenceCode];\n        } else {\n          // Parse the number.\n          let output = ''; // Emit a warning when the parsed number should not be used.\n\n          if (disallowed(referenceCode)) {\n            warning(6\n            /* Disallowed (numeric) */\n            , diff);\n          } // Serialize the number.\n\n\n          if (referenceCode > 0xffff) {\n            referenceCode -= 0x10000;\n            output += fromCharCode(referenceCode >>> (10 & 0x3ff) | 0xd800);\n            referenceCode = 0xdc00 | referenceCode & 0x3ff;\n          }\n\n          reference = output + fromCharCode(referenceCode);\n        }\n      } // Found it!\n      // First eat the queued characters as normal text, then eat a reference.\n\n\n      if (reference) {\n        flush();\n        previous = now();\n        index = end - 1;\n        column += end - start + 1;\n        result.push(reference);\n        const next = now();\n        next.offset++;\n\n        if (options.reference) {\n          options.reference.call(options.referenceContext, reference, {\n            start: previous,\n            end: next\n          }, value.slice(start - 1, end));\n        }\n\n        previous = next;\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end);\n        queue += characters;\n        column += characters.length;\n        index = end - 1;\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (character === 10\n      /* `\\n` */\n      ) {\n        line++;\n        lines++;\n        column = 0;\n      }\n\n      if (Number.isNaN(character)) {\n        flush();\n      } else {\n        queue += fromCharCode(character);\n        column++;\n      }\n    }\n  } // Return the reduced nodes.\n\n\n  return result.join(''); // Get current position.\n\n  function now() {\n    return {\n      line,\n      column,\n      offset: index + ((point ? point.offset : 0) || 0)\n    };\n  }\n  /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */\n\n\n  function warning(code, offset) {\n    /** @type {ReturnType<now>} */\n    let position;\n\n    if (options.warning) {\n      position = now();\n      position.column += offset;\n      position.offset += offset;\n      options.warning.call(options.warningContext, messages[code], position, code);\n    }\n  }\n  /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */\n\n\n  function flush() {\n    if (queue) {\n      result.push(queue);\n\n      if (options.text) {\n        options.text.call(options.textContext, queue, {\n          start: previous,\n          end: now()\n        });\n      }\n\n      queue = '';\n    }\n  }\n}\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */\n\n\nfunction prohibited(code) {\n  return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;\n}\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */\n\n\nfunction disallowed(code) {\n  return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$is_decimal$index","~$module$node_modules$character_reference_invalid$index","~$shadow.js","~$module$node_modules$character_entities_legacy$index","~$module$node_modules$decode_named_character_reference$index","~$module$node_modules$is_hexadecimal$index","~$module$node_modules$is_alphanumerical$index"]],"~:properties",["^5",["offset","__esModule","value","start","line","column","end","parseEntities"]],"~:compiled-at",1676841365380,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$parse_entities$lib$index.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/parse-entities/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$parse_entities$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.parseEntities = parseEntities;\\n\\nvar _characterEntitiesLegacy = require(\\\"character-entities-legacy\\\");\\n\\nvar _characterReferenceInvalid = require(\\\"character-reference-invalid\\\");\\n\\nvar _isDecimal = require(\\\"is-decimal\\\");\\n\\nvar _isHexadecimal = require(\\\"is-hexadecimal\\\");\\n\\nvar _isAlphanumerical = require(\\\"is-alphanumerical\\\");\\n\\nvar _decodeNamedCharacterReference = require(\\\"decode-named-character-reference\\\");\\n\\n/**\\n * @typedef {import('unist').Point} Point\\n * @typedef {import('unist').Position} Position\\n */\\nconst fromCharCode = String.fromCharCode; // Warning messages.\\n\\nconst messages = ['',\\n/* 1: Non terminated (named) */\\n'Named character references must be terminated by a semicolon',\\n/* 2: Non terminated (numeric) */\\n'Numeric character references must be terminated by a semicolon',\\n/* 3: Empty (named) */\\n'Named character references cannot be empty',\\n/* 4: Empty (numeric) */\\n'Numeric character references cannot be empty',\\n/* 5: Unknown (named) */\\n'Named character references must be known',\\n/* 6: Disallowed (numeric) */\\n'Numeric character references cannot be disallowed',\\n/* 7: Prohibited (numeric) */\\n'Numeric character references cannot be outside the permissible Unicode range'];\\n/**\\n * Parse HTML character references.\\n *\\n * @param {string} value\\n * @param {import('../index.js').Options} [options={}]\\n */\\n\\nfunction parseEntities(value, options = {}) {\\n  const additional = typeof options.additional === 'string' ? options.additional.charCodeAt(0) : options.additional;\\n  /** @type {Array<string>} */\\n\\n  const result = [];\\n  let index = 0;\\n  let lines = -1;\\n  let queue = '';\\n  /** @type {Point|undefined} */\\n\\n  let point;\\n  /** @type {Array<number>|undefined} */\\n\\n  let indent;\\n\\n  if (options.position) {\\n    if ('start' in options.position || 'indent' in options.position) {\\n      // @ts-expect-error: points don\\u2019t have indent.\\n      indent = options.position.indent; // @ts-expect-error: points don\\u2019t have indent.\\n\\n      point = options.position.start;\\n    } else {\\n      point = options.position;\\n    }\\n  }\\n\\n  let line = (point ? point.line : 0) || 1;\\n  let column = (point ? point.column : 0) || 1; // Cache the current point.\\n\\n  let previous = now();\\n  /** @type {number|undefined} */\\n\\n  let character; // Ensure the algorithm walks over the first character (inclusive).\\n\\n  index--;\\n\\n  while (++index <= value.length) {\\n    // If the previous character was a newline.\\n    if (character === 10\\n    /* `\\\\n` */\\n    ) {\\n      column = (indent ? indent[lines] : 0) || 1;\\n    }\\n\\n    character = value.charCodeAt(index);\\n\\n    if (character === 38\\n    /* `&` */\\n    ) {\\n      const following = value.charCodeAt(index + 1); // The behavior depends on the identity of the next character.\\n\\n      if (following === 9\\n      /* `\\\\t` */\\n      || following === 10\\n      /* `\\\\n` */\\n      || following === 12\\n      /* `\\\\f` */\\n      || following === 32\\n      /* ` ` */\\n      || following === 38\\n      /* `&` */\\n      || following === 60\\n      /* `<` */\\n      || Number.isNaN(following) || additional && following === additional) {\\n        // Not a character reference.\\n        // No characters are consumed, and nothing is returned.\\n        // This is not an error, either.\\n        queue += fromCharCode(character);\\n        column++;\\n        continue;\\n      }\\n\\n      const start = index + 1;\\n      let begin = start;\\n      let end = start;\\n      /** @type {string} */\\n\\n      let type;\\n\\n      if (following === 35\\n      /* `#` */\\n      ) {\\n        // Numerical reference.\\n        end = ++begin; // The behavior further depends on the next character.\\n\\n        const following = value.charCodeAt(end);\\n\\n        if (following === 88\\n        /* `X` */\\n        || following === 120\\n        /* `x` */\\n        ) {\\n          // ASCII hexadecimal digits.\\n          type = 'hexadecimal';\\n          end = ++begin;\\n        } else {\\n          // ASCII decimal digits.\\n          type = 'decimal';\\n        }\\n      } else {\\n        // Named reference.\\n        type = 'named';\\n      }\\n\\n      let characterReferenceCharacters = '';\\n      let characterReference = '';\\n      let characters = ''; // Each type of character reference accepts different characters.\\n      // This test is used to detect whether a reference has ended (as the semicolon\\n      // is not strictly needed).\\n\\n      const test = type === 'named' ? _isAlphanumerical.isAlphanumerical : type === 'decimal' ? _isDecimal.isDecimal : _isHexadecimal.isHexadecimal;\\n      end--;\\n\\n      while (++end <= value.length) {\\n        const following = value.charCodeAt(end);\\n\\n        if (!test(following)) {\\n          break;\\n        }\\n\\n        characters += fromCharCode(following); // Check if we can match a legacy named reference.\\n        // If so, we cache that as the last viable named reference.\\n        // This ensures we do not need to walk backwards later.\\n\\n        if (type === 'named' && _characterEntitiesLegacy.characterEntitiesLegacy.includes(characters)) {\\n          characterReferenceCharacters = characters; // @ts-expect-error: always able to decode.\\n\\n          characterReference = (0, _decodeNamedCharacterReference.decodeNamedCharacterReference)(characters);\\n        }\\n      }\\n\\n      let terminated = value.charCodeAt(end) === 59;\\n      /* `;` */\\n\\n      if (terminated) {\\n        end++;\\n        const namedReference = type === 'named' ? (0, _decodeNamedCharacterReference.decodeNamedCharacterReference)(characters) : false;\\n\\n        if (namedReference) {\\n          characterReferenceCharacters = characters;\\n          characterReference = namedReference;\\n        }\\n      }\\n\\n      let diff = 1 + end - start;\\n      let reference = '';\\n\\n      if (!terminated && options.nonTerminated === false) {// Empty.\\n      } else if (!characters) {\\n        // An empty (possible) reference is valid, unless it\\u2019s numeric (thus an\\n        // ampersand followed by an octothorp).\\n        if (type !== 'named') {\\n          warning(4\\n          /* Empty (numeric) */\\n          , diff);\\n        }\\n      } else if (type === 'named') {\\n        // An ampersand followed by anything unknown, and not terminated, is\\n        // invalid.\\n        if (terminated && !characterReference) {\\n          warning(5\\n          /* Unknown (named) */\\n          , 1);\\n        } else {\\n          // If there\\u2019s something after an named reference which is not known,\\n          // cap the reference.\\n          if (characterReferenceCharacters !== characters) {\\n            end = begin + characterReferenceCharacters.length;\\n            diff = 1 + end - begin;\\n            terminated = false;\\n          } // If the reference is not terminated, warn.\\n\\n\\n          if (!terminated) {\\n            const reason = characterReferenceCharacters ? 1\\n            /* Non terminated (named) */\\n            : 3;\\n            /* Empty (named) */\\n\\n            if (options.attribute) {\\n              const following = value.charCodeAt(end);\\n\\n              if (following === 61\\n              /* `=` */\\n              ) {\\n                warning(reason, diff);\\n                characterReference = '';\\n              } else if ((0, _isAlphanumerical.isAlphanumerical)(following)) {\\n                characterReference = '';\\n              } else {\\n                warning(reason, diff);\\n              }\\n            } else {\\n              warning(reason, diff);\\n            }\\n          }\\n        }\\n\\n        reference = characterReference;\\n      } else {\\n        if (!terminated) {\\n          // All nonterminated numeric references are not rendered, and emit a\\n          // warning.\\n          warning(2\\n          /* Non terminated (numeric) */\\n          , diff);\\n        } // When terminated and numerical, parse as either hexadecimal or\\n        // decimal.\\n\\n\\n        let referenceCode = Number.parseInt(characters, type === 'hexadecimal' ? 16 : 10); // Emit a warning when the parsed number is prohibited, and replace with\\n        // replacement character.\\n\\n        if (prohibited(referenceCode)) {\\n          warning(7\\n          /* Prohibited (numeric) */\\n          , diff);\\n          reference = fromCharCode(65533\\n          /* `\\ufffd` */\\n          );\\n        } else if (referenceCode in _characterReferenceInvalid.characterReferenceInvalid) {\\n          // Emit a warning when the parsed number is disallowed, and replace by\\n          // an alternative.\\n          warning(6\\n          /* Disallowed (numeric) */\\n          , diff);\\n          reference = _characterReferenceInvalid.characterReferenceInvalid[referenceCode];\\n        } else {\\n          // Parse the number.\\n          let output = ''; // Emit a warning when the parsed number should not be used.\\n\\n          if (disallowed(referenceCode)) {\\n            warning(6\\n            /* Disallowed (numeric) */\\n            , diff);\\n          } // Serialize the number.\\n\\n\\n          if (referenceCode > 0xffff) {\\n            referenceCode -= 0x10000;\\n            output += fromCharCode(referenceCode >>> (10 & 0x3ff) | 0xd800);\\n            referenceCode = 0xdc00 | referenceCode & 0x3ff;\\n          }\\n\\n          reference = output + fromCharCode(referenceCode);\\n        }\\n      } // Found it!\\n      // First eat the queued characters as normal text, then eat a reference.\\n\\n\\n      if (reference) {\\n        flush();\\n        previous = now();\\n        index = end - 1;\\n        column += end - start + 1;\\n        result.push(reference);\\n        const next = now();\\n        next.offset++;\\n\\n        if (options.reference) {\\n          options.reference.call(options.referenceContext, reference, {\\n            start: previous,\\n            end: next\\n          }, value.slice(start - 1, end));\\n        }\\n\\n        previous = next;\\n      } else {\\n        // If we could not find a reference, queue the checked characters (as\\n        // normal characters), and move the pointer to their end.\\n        // This is possible because we can be certain neither newlines nor\\n        // ampersands are included.\\n        characters = value.slice(start - 1, end);\\n        queue += characters;\\n        column += characters.length;\\n        index = end - 1;\\n      }\\n    } else {\\n      // Handle anything other than an ampersand, including newlines and EOF.\\n      if (character === 10\\n      /* `\\\\n` */\\n      ) {\\n        line++;\\n        lines++;\\n        column = 0;\\n      }\\n\\n      if (Number.isNaN(character)) {\\n        flush();\\n      } else {\\n        queue += fromCharCode(character);\\n        column++;\\n      }\\n    }\\n  } // Return the reduced nodes.\\n\\n\\n  return result.join(''); // Get current position.\\n\\n  function now() {\\n    return {\\n      line,\\n      column,\\n      offset: index + ((point ? point.offset : 0) || 0)\\n    };\\n  }\\n  /**\\n   * Handle the warning.\\n   *\\n   * @param {1|2|3|4|5|6|7} code\\n   * @param {number} offset\\n   */\\n\\n\\n  function warning(code, offset) {\\n    /** @type {ReturnType<now>} */\\n    let position;\\n\\n    if (options.warning) {\\n      position = now();\\n      position.column += offset;\\n      position.offset += offset;\\n      options.warning.call(options.warningContext, messages[code], position, code);\\n    }\\n  }\\n  /**\\n   * Flush `queue` (normal text).\\n   * Macro invoked before each reference and at the end of `value`.\\n   * Does nothing when `queue` is empty.\\n   */\\n\\n\\n  function flush() {\\n    if (queue) {\\n      result.push(queue);\\n\\n      if (options.text) {\\n        options.text.call(options.textContext, queue, {\\n          start: previous,\\n          end: now()\\n        });\\n      }\\n\\n      queue = '';\\n    }\\n  }\\n}\\n/**\\n * Check if `character` is outside the permissible unicode range.\\n *\\n * @param {number} code\\n * @returns {boolean}\\n */\\n\\n\\nfunction prohibited(code) {\\n  return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;\\n}\\n/**\\n * Check if `character` is disallowed.\\n *\\n * @param {number} code\\n * @returns {boolean}\\n */\\n\\n\\nfunction disallowed(code) {\\n  return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"parseEntities\",\"options\",\"now\",\"line\",\"column\",\"offset\",\"index\",\"point\",\"warning\",\"code\",\"position\",\"call\",\"warningContext\",\"messages\",\"flush\",\"queue\",\"result\",\"push\",\"text\",\"textContext\",\"start\",\"previous\",\"end\",\"additional\",\"charCodeAt\",\"lines\",\"indent\",\"character\",\"length\",\"following\",\"Number\",\"isNaN\",\"fromCharCode\",\"begin\",\"type\",\"characterReferenceCharacters\",\"characters\",\"characterReference\",\"test\",\"_isAlphanumerical\",\"isAlphanumerical\",\"_isDecimal\",\"isDecimal\",\"_isHexadecimal\",\"isHexadecimal\",\"_characterEntitiesLegacy\",\"characterEntitiesLegacy\",\"includes\",\"_decodeNamedCharacterReference\",\"decodeNamedCharacterReference\",\"terminated\",\"namedReference\",\"diff\",\"reference\",\"nonTerminated\",\"reason\",\"attribute\",\"referenceCode\",\"parseInt\",\"_characterReferenceInvalid\",\"characterReferenceInvalid\",\"output\",\"next\",\"referenceContext\",\"slice\",\"join\",\"String\"]\n}\n"]