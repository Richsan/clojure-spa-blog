["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/naniscript.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$naniscript=function(global,require,module,exports){function naniscript(Prism$jscomp$0){(function(Prism){function getTextContent(token){return\"string\"===typeof token?token:Array.isArray(token)?token.map(getTextContent).join(\"\"):getTextContent(token.content)}var expressionDef=/\\{[^\\r\\n\\[\\]{}]*\\}/,params={\"quoted-string\":{pattern:/\"(?:[^\"\\\\]|\\\\.)*\"/,alias:\"operator\"},\"command-param-id\":{pattern:/(\\s)\\w+:/,lookbehind:!0,alias:\"property\"},\"command-param-value\":[{pattern:expressionDef,\nalias:\"selector\"},{pattern:/([\\t ])\\S+/,lookbehind:!0,greedy:!0,alias:\"operator\"},{pattern:/\\S(?:.*\\S)?/,alias:\"operator\"}]};Prism.languages.naniscript={comment:{pattern:/^([\\t ]*);.*/m,lookbehind:!0},define:{pattern:/^>.+/m,alias:\"tag\",inside:{value:{pattern:/(^>\\w+[\\t ]+)(?!\\s)[^{}\\r\\n]+/,lookbehind:!0,alias:\"operator\"},key:{pattern:/(^>)\\w+/,lookbehind:!0}}},label:{pattern:/^([\\t ]*)#[\\t ]*\\w+[\\t ]*$/m,lookbehind:!0,alias:\"regex\"},command:{pattern:/^([\\t ]*)@\\w+(?=[\\t ]|$).*/m,lookbehind:!0,alias:\"function\",\ninside:{\"command-name\":/^@\\w+/,expression:{pattern:expressionDef,greedy:!0,alias:\"selector\"},\"command-params\":{pattern:/\\s*\\S[\\s\\S]*/,inside:params}}},\"generic-text\":{pattern:/(^[ \\t]*)[^#@>;\\s].*/m,lookbehind:!0,alias:\"punctuation\",inside:{\"escaped-char\":/\\\\[{}\\[\\]\"]/,expression:{pattern:expressionDef,greedy:!0,alias:\"selector\"},\"inline-command\":{pattern:/\\[[\\t ]*\\w[^\\r\\n\\[\\]]*\\]/,greedy:!0,alias:\"function\",inside:{\"command-params\":{pattern:/(^\\[[\\t ]*\\w+\\b)[\\s\\S]+(?=\\]$)/,lookbehind:!0,inside:params},\n\"command-param-name\":{pattern:/^(\\[[\\t ]*)\\w+/,lookbehind:!0,alias:\"name\"},\"start-stop-char\":/[\\[\\]]/}}}}};Prism.languages.nani=Prism.languages.naniscript;Prism.hooks.add(\"after-tokenize\",function(env){env.tokens.forEach(function(token){if(\"string\"!==typeof token&&\"generic-text\"===token.type){var content=getTextContent(token);a:{var JSCompiler_inline_result=[];for(var i=0;i<content.length;i++){var bracketsIndex=\"[]{}\".indexOf(content[i]);if(-1!==bracketsIndex)if(0===bracketsIndex%2)JSCompiler_inline_result.push(bracketsIndex+\n1);else if(JSCompiler_inline_result.pop()!==bracketsIndex){JSCompiler_inline_result=!1;break a}}JSCompiler_inline_result=0===JSCompiler_inline_result.length}JSCompiler_inline_result||(token.type=\"bad-line\",token.content=content)}})})})(Prism$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=naniscript;naniscript.displayName=\"naniscript\";naniscript.aliases=[\"nani\"]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$naniscript\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = naniscript;\n// @ts-nocheck\nnaniscript.displayName = 'naniscript';\nnaniscript.aliases = ['nani'];\n/** @type {import('../core.js').Syntax} */\n\nfunction naniscript(Prism) {\n  ;\n\n  (function (Prism) {\n    var expressionDef = /\\{[^\\r\\n\\[\\]{}]*\\}/;\n    var params = {\n      'quoted-string': {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        alias: 'operator'\n      },\n      'command-param-id': {\n        pattern: /(\\s)\\w+:/,\n        lookbehind: true,\n        alias: 'property'\n      },\n      'command-param-value': [{\n        pattern: expressionDef,\n        alias: 'selector'\n      }, {\n        pattern: /([\\t ])\\S+/,\n        lookbehind: true,\n        greedy: true,\n        alias: 'operator'\n      }, {\n        pattern: /\\S(?:.*\\S)?/,\n        alias: 'operator'\n      }]\n    };\n    Prism.languages.naniscript = {\n      // ; ...\n      comment: {\n        pattern: /^([\\t ]*);.*/m,\n        lookbehind: true\n      },\n      // > ...\n      // Define is a control line starting with '>' followed by a word, a space and a text.\n      define: {\n        pattern: /^>.+/m,\n        alias: 'tag',\n        inside: {\n          value: {\n            pattern: /(^>\\w+[\\t ]+)(?!\\s)[^{}\\r\\n]+/,\n            lookbehind: true,\n            alias: 'operator'\n          },\n          key: {\n            pattern: /(^>)\\w+/,\n            lookbehind: true\n          }\n        }\n      },\n      // # ...\n      label: {\n        pattern: /^([\\t ]*)#[\\t ]*\\w+[\\t ]*$/m,\n        lookbehind: true,\n        alias: 'regex'\n      },\n      command: {\n        pattern: /^([\\t ]*)@\\w+(?=[\\t ]|$).*/m,\n        lookbehind: true,\n        alias: 'function',\n        inside: {\n          'command-name': /^@\\w+/,\n          expression: {\n            pattern: expressionDef,\n            greedy: true,\n            alias: 'selector'\n          },\n          'command-params': {\n            pattern: /\\s*\\S[\\s\\S]*/,\n            inside: params\n          }\n        }\n      },\n      // Generic is any line that doesn't start with operators: ;>#@\n      'generic-text': {\n        pattern: /(^[ \\t]*)[^#@>;\\s].*/m,\n        lookbehind: true,\n        alias: 'punctuation',\n        inside: {\n          // \\{ ... \\} ... \\[ ... \\] ... \\\"\n          'escaped-char': /\\\\[{}\\[\\]\"]/,\n          expression: {\n            pattern: expressionDef,\n            greedy: true,\n            alias: 'selector'\n          },\n          'inline-command': {\n            pattern: /\\[[\\t ]*\\w[^\\r\\n\\[\\]]*\\]/,\n            greedy: true,\n            alias: 'function',\n            inside: {\n              'command-params': {\n                pattern: /(^\\[[\\t ]*\\w+\\b)[\\s\\S]+(?=\\]$)/,\n                lookbehind: true,\n                inside: params\n              },\n              'command-param-name': {\n                pattern: /^(\\[[\\t ]*)\\w+/,\n                lookbehind: true,\n                alias: 'name'\n              },\n              'start-stop-char': /[\\[\\]]/\n            }\n          }\n        }\n      }\n    };\n    Prism.languages.nani = Prism.languages['naniscript'];\n    /** @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token */\n\n    /**\n     * This hook is used to validate generic-text tokens for balanced brackets.\n     * Mark token as bad-line when contains not balanced brackets: {},[]\n     */\n\n    Prism.hooks.add('after-tokenize', function (env) {\n      /** @type {(Token | string)[]} */\n      var tokens = env.tokens;\n      tokens.forEach(function (token) {\n        if (typeof token !== 'string' && token.type === 'generic-text') {\n          var content = getTextContent(token);\n\n          if (!isBracketsBalanced(content)) {\n            token.type = 'bad-line';\n            token.content = content;\n          }\n        }\n      });\n    });\n    /**\n     * @param {string} input\n     * @returns {boolean}\n     */\n\n    function isBracketsBalanced(input) {\n      var brackets = '[]{}';\n      var stack = [];\n\n      for (var i = 0; i < input.length; i++) {\n        var bracket = input[i];\n        var bracketsIndex = brackets.indexOf(bracket);\n\n        if (bracketsIndex !== -1) {\n          if (bracketsIndex % 2 === 0) {\n            stack.push(bracketsIndex + 1);\n          } else if (stack.pop() !== bracketsIndex) {\n            return false;\n          }\n        }\n      }\n\n      return stack.length === 0;\n    }\n    /**\n     * @param {string | Token | (string | Token)[]} token\n     * @returns {string}\n     */\n\n\n    function getTextContent(token) {\n      if (typeof token === 'string') {\n        return token;\n      } else if (Array.isArray(token)) {\n        return token.map(getTextContent).join('');\n      } else {\n        return getTextContent(token.content);\n      }\n    }\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["aliases","command","displayName","label","key","__esModule","expression","lookbehind","value","define","content","greedy","nani","pattern","type","inside","alias","comment","default","naniscript"]],"~:compiled-at",1676841365439,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$naniscript.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lang/naniscript.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$naniscript\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = naniscript;\\n// @ts-nocheck\\nnaniscript.displayName = 'naniscript';\\nnaniscript.aliases = ['nani'];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction naniscript(Prism) {\\n  ;\\n\\n  (function (Prism) {\\n    var expressionDef = /\\\\{[^\\\\r\\\\n\\\\[\\\\]{}]*\\\\}/;\\n    var params = {\\n      'quoted-string': {\\n        pattern: /\\\"(?:[^\\\"\\\\\\\\]|\\\\\\\\.)*\\\"/,\\n        alias: 'operator'\\n      },\\n      'command-param-id': {\\n        pattern: /(\\\\s)\\\\w+:/,\\n        lookbehind: true,\\n        alias: 'property'\\n      },\\n      'command-param-value': [{\\n        pattern: expressionDef,\\n        alias: 'selector'\\n      }, {\\n        pattern: /([\\\\t ])\\\\S+/,\\n        lookbehind: true,\\n        greedy: true,\\n        alias: 'operator'\\n      }, {\\n        pattern: /\\\\S(?:.*\\\\S)?/,\\n        alias: 'operator'\\n      }]\\n    };\\n    Prism.languages.naniscript = {\\n      // ; ...\\n      comment: {\\n        pattern: /^([\\\\t ]*);.*/m,\\n        lookbehind: true\\n      },\\n      // > ...\\n      // Define is a control line starting with '>' followed by a word, a space and a text.\\n      define: {\\n        pattern: /^>.+/m,\\n        alias: 'tag',\\n        inside: {\\n          value: {\\n            pattern: /(^>\\\\w+[\\\\t ]+)(?!\\\\s)[^{}\\\\r\\\\n]+/,\\n            lookbehind: true,\\n            alias: 'operator'\\n          },\\n          key: {\\n            pattern: /(^>)\\\\w+/,\\n            lookbehind: true\\n          }\\n        }\\n      },\\n      // # ...\\n      label: {\\n        pattern: /^([\\\\t ]*)#[\\\\t ]*\\\\w+[\\\\t ]*$/m,\\n        lookbehind: true,\\n        alias: 'regex'\\n      },\\n      command: {\\n        pattern: /^([\\\\t ]*)@\\\\w+(?=[\\\\t ]|$).*/m,\\n        lookbehind: true,\\n        alias: 'function',\\n        inside: {\\n          'command-name': /^@\\\\w+/,\\n          expression: {\\n            pattern: expressionDef,\\n            greedy: true,\\n            alias: 'selector'\\n          },\\n          'command-params': {\\n            pattern: /\\\\s*\\\\S[\\\\s\\\\S]*/,\\n            inside: params\\n          }\\n        }\\n      },\\n      // Generic is any line that doesn't start with operators: ;>#@\\n      'generic-text': {\\n        pattern: /(^[ \\\\t]*)[^#@>;\\\\s].*/m,\\n        lookbehind: true,\\n        alias: 'punctuation',\\n        inside: {\\n          // \\\\{ ... \\\\} ... \\\\[ ... \\\\] ... \\\\\\\"\\n          'escaped-char': /\\\\\\\\[{}\\\\[\\\\]\\\"]/,\\n          expression: {\\n            pattern: expressionDef,\\n            greedy: true,\\n            alias: 'selector'\\n          },\\n          'inline-command': {\\n            pattern: /\\\\[[\\\\t ]*\\\\w[^\\\\r\\\\n\\\\[\\\\]]*\\\\]/,\\n            greedy: true,\\n            alias: 'function',\\n            inside: {\\n              'command-params': {\\n                pattern: /(^\\\\[[\\\\t ]*\\\\w+\\\\b)[\\\\s\\\\S]+(?=\\\\]$)/,\\n                lookbehind: true,\\n                inside: params\\n              },\\n              'command-param-name': {\\n                pattern: /^(\\\\[[\\\\t ]*)\\\\w+/,\\n                lookbehind: true,\\n                alias: 'name'\\n              },\\n              'start-stop-char': /[\\\\[\\\\]]/\\n            }\\n          }\\n        }\\n      }\\n    };\\n    Prism.languages.nani = Prism.languages['naniscript'];\\n    /** @typedef {InstanceType<import(\\\"./prism-core\\\")[\\\"Token\\\"]>} Token */\\n\\n    /**\\n     * This hook is used to validate generic-text tokens for balanced brackets.\\n     * Mark token as bad-line when contains not balanced brackets: {},[]\\n     */\\n\\n    Prism.hooks.add('after-tokenize', function (env) {\\n      /** @type {(Token | string)[]} */\\n      var tokens = env.tokens;\\n      tokens.forEach(function (token) {\\n        if (typeof token !== 'string' && token.type === 'generic-text') {\\n          var content = getTextContent(token);\\n\\n          if (!isBracketsBalanced(content)) {\\n            token.type = 'bad-line';\\n            token.content = content;\\n          }\\n        }\\n      });\\n    });\\n    /**\\n     * @param {string} input\\n     * @returns {boolean}\\n     */\\n\\n    function isBracketsBalanced(input) {\\n      var brackets = '[]{}';\\n      var stack = [];\\n\\n      for (var i = 0; i < input.length; i++) {\\n        var bracket = input[i];\\n        var bracketsIndex = brackets.indexOf(bracket);\\n\\n        if (bracketsIndex !== -1) {\\n          if (bracketsIndex % 2 === 0) {\\n            stack.push(bracketsIndex + 1);\\n          } else if (stack.pop() !== bracketsIndex) {\\n            return false;\\n          }\\n        }\\n      }\\n\\n      return stack.length === 0;\\n    }\\n    /**\\n     * @param {string | Token | (string | Token)[]} token\\n     * @returns {string}\\n     */\\n\\n\\n    function getTextContent(token) {\\n      if (typeof token === 'string') {\\n        return token;\\n      } else if (Array.isArray(token)) {\\n        return token.map(getTextContent).join('');\\n      } else {\\n        return getTextContent(token.content);\\n      }\\n    }\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"naniscript\",\"Prism\",\"getTextContent\",\"token\",\"Array\",\"isArray\",\"map\",\"join\",\"content\",\"expressionDef\",\"params\",\"pattern\",\"alias\",\"lookbehind\",\"greedy\",\"languages\",\"comment\",\"define\",\"inside\",\"value\",\"key\",\"label\",\"command\",\"expression\",\"nani\",\"hooks\",\"add\",\"env\",\"tokens\",\"forEach\",\"type\",\"stack\",\"i\",\"length\",\"bracketsIndex\",\"brackets\",\"indexOf\",\"bracket\",\"push\",\"pop\",\"Object\",\"defineProperty\",\"default\",\"displayName\",\"aliases\"]\n}\n"]