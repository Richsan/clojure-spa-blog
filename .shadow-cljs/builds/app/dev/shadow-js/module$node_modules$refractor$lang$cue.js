["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/cue.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$cue=function(global,require,module,exports){function cue(Prism){var stringLiteral=\"(?:\"+(/\"\"\"(?:[^\\\\\"]|\"(?!\"\"\\2)|<esc>)*\"\"\"/.source+\"|\"+/'''(?:[^\\\\']|'(?!''\\2)|<esc>)*'''/.source+\"|\"+/\"(?:[^\\\\\\r\\n\"]|\"(?!\\2)|<esc>)*\"/.source+\"|\"+/'(?:[^\\\\\\r\\n']|'(?!\\2)|<esc>)*'/.source).replace(/<esc>/g,/\\\\(?:(?!\\2)|\\2(?:[^()\\r\\n]|\\([^()]*\\)))/.source)+\")\";Prism.languages.cue={comment:{pattern:/\\/\\/.*/,greedy:!0},\"string-literal\":{pattern:RegExp(/(^|[^#\"'\\\\])(#*)/.source+\nstringLiteral+/(?![\"'])\\2/.source),lookbehind:!0,greedy:!0,inside:{escape:{pattern:/(?=[\\s\\S]*[\"'](#*)$)\\\\\\1(?:U[a-fA-F0-9]{1,8}|u[a-fA-F0-9]{1,4}|x[a-fA-F0-9]{1,2}|\\d{2,3}|[^(])/,greedy:!0,alias:\"string\"},interpolation:{pattern:/(?=[\\s\\S]*[\"'](#*)$)\\\\\\1\\([^()]*\\)/,greedy:!0,inside:{punctuation:/^\\\\#*\\(|\\)$/,expression:{pattern:/[\\s\\S]+/,inside:null}}},string:/[\\s\\S]+/}},keyword:{pattern:/(^|[^\\w$])(?:for|if|import|in|let|null|package)(?![\\w$])/,lookbehind:!0},boolean:{pattern:/(^|[^\\w$])(?:false|true)(?![\\w$])/,\nlookbehind:!0},builtin:{pattern:/(^|[^\\w$])(?:bool|bytes|float|float(?:32|64)|u?int(?:8|16|32|64|128)?|number|rune|string)(?![\\w$])/,lookbehind:!0},attribute:{pattern:/@[\\w$]+(?=\\s*\\()/,alias:\"function\"},function:{pattern:/(^|[^\\w$])[a-z_$][\\w$]*(?=\\s*\\()/i,lookbehind:!0},number:{pattern:/(^|[^\\w$.])(?:0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|0[xX][0-9A-Fa-f]+(?:_[0-9A-Fa-f]+)*|(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[eE][+-]?\\d+(?:_\\d+)*)?(?:[KMGTP]i?)?)(?![\\w$])/,lookbehind:!0},\noperator:/\\.{3}|_\\|_|&&?|\\|\\|?|[=!]~|[<>=!]=?|[+\\-*/?]/,punctuation:/[()[\\]{},.:]/};Prism.languages.cue[\"string-literal\"].inside.interpolation.inside.expression.inside=Prism.languages.cue}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=cue;cue.displayName=\"cue\";cue.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$cue\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cue;\n// @ts-nocheck\ncue.displayName = 'cue';\ncue.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction cue(Prism) {\n  ;\n\n  (function (Prism) {\n    // https://cuelang.org/docs/references/spec/\n    // eslint-disable-next-line regexp/strict\n    var stringEscape = /\\\\(?:(?!\\2)|\\2(?:[^()\\r\\n]|\\([^()]*\\)))/.source; // eslint-disable-next-line regexp/strict\n\n    var stringTypes = /\"\"\"(?:[^\\\\\"]|\"(?!\"\"\\2)|<esc>)*\"\"\"/.source + // eslint-disable-next-line regexp/strict\n    '|' + /'''(?:[^\\\\']|'(?!''\\2)|<esc>)*'''/.source + // eslint-disable-next-line regexp/strict\n    '|' + /\"(?:[^\\\\\\r\\n\"]|\"(?!\\2)|<esc>)*\"/.source + // eslint-disable-next-line regexp/strict\n    '|' + /'(?:[^\\\\\\r\\n']|'(?!\\2)|<esc>)*'/.source;\n    var stringLiteral = '(?:' + stringTypes.replace(/<esc>/g, stringEscape) + ')';\n    Prism.languages.cue = {\n      comment: {\n        pattern: /\\/\\/.*/,\n        greedy: true\n      },\n      'string-literal': {\n        // eslint-disable-next-line regexp/strict\n        pattern: RegExp(/(^|[^#\"'\\\\])(#*)/.source + stringLiteral + /(?![\"'])\\2/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          // I'm using dirty hack here. We have to know the number hashes at the start of the string somehow,\n          // but we can't look back. So instead, we will use a lookahead, go to the end of the string, and\n          // capture the hashes at the end of the string.\n          escape: {\n            pattern: /(?=[\\s\\S]*[\"'](#*)$)\\\\\\1(?:U[a-fA-F0-9]{1,8}|u[a-fA-F0-9]{1,4}|x[a-fA-F0-9]{1,2}|\\d{2,3}|[^(])/,\n            greedy: true,\n            alias: 'string'\n          },\n          interpolation: {\n            pattern: /(?=[\\s\\S]*[\"'](#*)$)\\\\\\1\\([^()]*\\)/,\n            greedy: true,\n            inside: {\n              punctuation: /^\\\\#*\\(|\\)$/,\n              expression: {\n                pattern: /[\\s\\S]+/,\n                inside: null\n              }\n            }\n          },\n          string: /[\\s\\S]+/\n        }\n      },\n      keyword: {\n        pattern: /(^|[^\\w$])(?:for|if|import|in|let|null|package)(?![\\w$])/,\n        lookbehind: true\n      },\n      boolean: {\n        pattern: /(^|[^\\w$])(?:false|true)(?![\\w$])/,\n        lookbehind: true\n      },\n      builtin: {\n        pattern: /(^|[^\\w$])(?:bool|bytes|float|float(?:32|64)|u?int(?:8|16|32|64|128)?|number|rune|string)(?![\\w$])/,\n        lookbehind: true\n      },\n      attribute: {\n        pattern: /@[\\w$]+(?=\\s*\\()/,\n        alias: 'function'\n      },\n      function: {\n        pattern: /(^|[^\\w$])[a-z_$][\\w$]*(?=\\s*\\()/i,\n        lookbehind: true\n      },\n      number: {\n        pattern: /(^|[^\\w$.])(?:0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|0[xX][0-9A-Fa-f]+(?:_[0-9A-Fa-f]+)*|(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[eE][+-]?\\d+(?:_\\d+)*)?(?:[KMGTP]i?)?)(?![\\w$])/,\n        lookbehind: true\n      },\n      operator: /\\.{3}|_\\|_|&&?|\\|\\|?|[=!]~|[<>=!]=?|[+\\-*/?]/,\n      punctuation: /[()[\\]{},.:]/\n    };\n    Prism.languages.cue['string-literal'].inside.interpolation.inside.expression.inside = Prism.languages.cue;\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["boolean","punctuation","string","aliases","operator","displayName","__esModule","cue","attribute","expression","lookbehind","escape","value","keyword","number","greedy","function","pattern","inside","alias","comment","builtin","interpolation","default"]],"~:compiled-at",1676841365403,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$cue.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAA,sCAAA,CAA2D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAYnGC,QAASA,IAAG,CAACC,KAAD,CAAQ,CAYhB,IAAIC,cAAgB,KAAhBA,CAAoCC,CAJtB,mCAAoCC,CAAAA,MAIdD,CAHxC,GAGwCA,CAHlC,mCAAoCC,CAAAA,MAGFD,CAFxC,GAEwCA,CAFlC,iCAAkCC,CAAAA,MAEAD,CADxC,GACwCA,CADlC,iCAAkCC,CAAAA,MACAD,EAAAA,OAAZ,CAAoB,QAApB,CANT,yCAA0CC,CAAAA,MAMjC,CAAxBF,CAAsE,GA8DzED,MA7DKI,CAAAA,SAAUL,CAAAA,GAAhB,CAAsB,CACpBM,QAAS,CACPC,QAAS,QADF,CAEPC,OAAQ,CAAA,CAFD,CADW,CAKpB,iBAAkB,CAEhBD,QAASE,MAAA,CAAO,kBAAmBL,CAAAA,MAA1B;AAAmCF,aAAnC,CAAmD,YAAaE,CAAAA,MAAhE,CAFO,CAGhBM,WAAY,CAAA,CAHI,CAIhBF,OAAQ,CAAA,CAJQ,CAKhBG,OAAQ,CAINC,OAAQ,CACNL,QAAS,gGADH,CAENC,OAAQ,CAAA,CAFF,CAGNK,MAAO,QAHD,CAJF,CASNC,cAAe,CACbP,QAAS,oCADI,CAEbC,OAAQ,CAAA,CAFK,CAGbG,OAAQ,CACNI,YAAa,aADP,CAENC,WAAY,CACVT,QAAS,SADC,CAEVI,OAAQ,IAFE,CAFN,CAHK,CATT,CAoBNM,OAAQ,SApBF,CALQ,CALE,CAiCpBC,QAAS,CACPX,QAAS,0DADF,CAEPG,WAAY,CAAA,CAFL,CAjCW,CAqCpBS,QAAS,CACPZ,QAAS,mCADF;AAEPG,WAAY,CAAA,CAFL,CArCW,CAyCpBU,QAAS,CACPb,QAAS,oGADF,CAEPG,WAAY,CAAA,CAFL,CAzCW,CA6CpBW,UAAW,CACTd,QAAS,kBADA,CAETM,MAAO,UAFE,CA7CS,CAiDpBS,SAAU,CACRf,QAAS,mCADD,CAERG,WAAY,CAAA,CAFJ,CAjDU,CAqDpBa,OAAQ,CACNhB,QAAS,qMADH,CAENG,WAAY,CAAA,CAFN,CArDY;AAyDpBc,SAAU,8CAzDU,CA0DpBT,YAAa,cA1DO,CA6DrBd,MADKI,CAAAA,SAAUL,CAAAA,GAAhB,CAAoB,gBAApB,CAAsCW,CAAAA,MAAOG,CAAAA,aAAcH,CAAAA,MAAOK,CAAAA,UAAWL,CAAAA,MAA7E,CACCV,KAD2FI,CAAAA,SAAUL,CAAAA,GAzEtF,CATpByB,MAAOC,CAAAA,cAAP,CAAsB3B,OAAtB,CAA+B,YAA/B,CAA6C,CAC3C4B,MAAO,CAAA,CADoC,CAA7C,CAGA5B,QAAQ6B,CAAAA,OAAR,CAAkB5B,GAElBA,IAAI6B,CAAAA,WAAJ,CAAkB,KAClB7B,IAAI8B,CAAAA,OAAJ,CAAc,EATqF;\",\n\"sources\":[\"node_modules/refractor/lang/cue.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$cue\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = cue;\\n// @ts-nocheck\\ncue.displayName = 'cue';\\ncue.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction cue(Prism) {\\n  ;\\n\\n  (function (Prism) {\\n    // https://cuelang.org/docs/references/spec/\\n    // eslint-disable-next-line regexp/strict\\n    var stringEscape = /\\\\\\\\(?:(?!\\\\2)|\\\\2(?:[^()\\\\r\\\\n]|\\\\([^()]*\\\\)))/.source; // eslint-disable-next-line regexp/strict\\n\\n    var stringTypes = /\\\"\\\"\\\"(?:[^\\\\\\\\\\\"]|\\\"(?!\\\"\\\"\\\\2)|<esc>)*\\\"\\\"\\\"/.source + // eslint-disable-next-line regexp/strict\\n    '|' + /'''(?:[^\\\\\\\\']|'(?!''\\\\2)|<esc>)*'''/.source + // eslint-disable-next-line regexp/strict\\n    '|' + /\\\"(?:[^\\\\\\\\\\\\r\\\\n\\\"]|\\\"(?!\\\\2)|<esc>)*\\\"/.source + // eslint-disable-next-line regexp/strict\\n    '|' + /'(?:[^\\\\\\\\\\\\r\\\\n']|'(?!\\\\2)|<esc>)*'/.source;\\n    var stringLiteral = '(?:' + stringTypes.replace(/<esc>/g, stringEscape) + ')';\\n    Prism.languages.cue = {\\n      comment: {\\n        pattern: /\\\\/\\\\/.*/,\\n        greedy: true\\n      },\\n      'string-literal': {\\n        // eslint-disable-next-line regexp/strict\\n        pattern: RegExp(/(^|[^#\\\"'\\\\\\\\])(#*)/.source + stringLiteral + /(?![\\\"'])\\\\2/.source),\\n        lookbehind: true,\\n        greedy: true,\\n        inside: {\\n          // I'm using dirty hack here. We have to know the number hashes at the start of the string somehow,\\n          // but we can't look back. So instead, we will use a lookahead, go to the end of the string, and\\n          // capture the hashes at the end of the string.\\n          escape: {\\n            pattern: /(?=[\\\\s\\\\S]*[\\\"'](#*)$)\\\\\\\\\\\\1(?:U[a-fA-F0-9]{1,8}|u[a-fA-F0-9]{1,4}|x[a-fA-F0-9]{1,2}|\\\\d{2,3}|[^(])/,\\n            greedy: true,\\n            alias: 'string'\\n          },\\n          interpolation: {\\n            pattern: /(?=[\\\\s\\\\S]*[\\\"'](#*)$)\\\\\\\\\\\\1\\\\([^()]*\\\\)/,\\n            greedy: true,\\n            inside: {\\n              punctuation: /^\\\\\\\\#*\\\\(|\\\\)$/,\\n              expression: {\\n                pattern: /[\\\\s\\\\S]+/,\\n                inside: null\\n              }\\n            }\\n          },\\n          string: /[\\\\s\\\\S]+/\\n        }\\n      },\\n      keyword: {\\n        pattern: /(^|[^\\\\w$])(?:for|if|import|in|let|null|package)(?![\\\\w$])/,\\n        lookbehind: true\\n      },\\n      boolean: {\\n        pattern: /(^|[^\\\\w$])(?:false|true)(?![\\\\w$])/,\\n        lookbehind: true\\n      },\\n      builtin: {\\n        pattern: /(^|[^\\\\w$])(?:bool|bytes|float|float(?:32|64)|u?int(?:8|16|32|64|128)?|number|rune|string)(?![\\\\w$])/,\\n        lookbehind: true\\n      },\\n      attribute: {\\n        pattern: /@[\\\\w$]+(?=\\\\s*\\\\()/,\\n        alias: 'function'\\n      },\\n      function: {\\n        pattern: /(^|[^\\\\w$])[a-z_$][\\\\w$]*(?=\\\\s*\\\\()/i,\\n        lookbehind: true\\n      },\\n      number: {\\n        pattern: /(^|[^\\\\w$.])(?:0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|0[xX][0-9A-Fa-f]+(?:_[0-9A-Fa-f]+)*|(?:\\\\d+(?:_\\\\d+)*(?:\\\\.(?:\\\\d+(?:_\\\\d+)*)?)?|\\\\.\\\\d+(?:_\\\\d+)*)(?:[eE][+-]?\\\\d+(?:_\\\\d+)*)?(?:[KMGTP]i?)?)(?![\\\\w$])/,\\n        lookbehind: true\\n      },\\n      operator: /\\\\.{3}|_\\\\|_|&&?|\\\\|\\\\|?|[=!]~|[<>=!]=?|[+\\\\-*/?]/,\\n      punctuation: /[()[\\\\]{},.:]/\\n    };\\n    Prism.languages.cue['string-literal'].inside.interpolation.inside.expression.inside = Prism.languages.cue;\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"cue\",\"Prism\",\"stringLiteral\",\"replace\",\"source\",\"languages\",\"comment\",\"pattern\",\"greedy\",\"RegExp\",\"lookbehind\",\"inside\",\"escape\",\"alias\",\"interpolation\",\"punctuation\",\"expression\",\"string\",\"keyword\",\"boolean\",\"builtin\",\"attribute\",\"function\",\"number\",\"operator\",\"Object\",\"defineProperty\",\"value\",\"default\",\"displayName\",\"aliases\"]\n}\n"]