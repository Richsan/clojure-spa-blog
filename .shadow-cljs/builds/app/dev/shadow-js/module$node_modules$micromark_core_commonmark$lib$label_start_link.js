["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-core-commonmark/lib/label-start-link.js"],"~:js","shadow$provide.module$node_modules$micromark_core_commonmark$lib$label_start_link=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.labelStartLink=void 0;global={name:\"labelStartLink\",tokenize:function(effects,ok,nok){function after(code){return 94===code&&\"_hiddenFootnoteSupport\"in self.parser.constructs?nok(code):ok(code)}const self=this;return function(code){effects.enter(\"labelLink\");effects.enter(\"labelMarker\");effects.consume(code);effects.exit(\"labelMarker\");\neffects.exit(\"labelLink\");return after}},resolveAll:require(\"module$node_modules$micromark_core_commonmark$lib$label_end\").labelEnd.resolveAll};exports.labelStartLink=global}","~:source","shadow$provide[\"module$node_modules$micromark_core_commonmark$lib$label_start_link\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.labelStartLink = void 0;\n\nvar _labelEnd = require(\"./label-end.js\");\n\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\n\n/** @type {Construct} */\nconst labelStartLink = {\n  name: 'labelStartLink',\n  tokenize: tokenizeLabelStartLink,\n  resolveAll: _labelEnd.labelEnd.resolveAll\n};\n/** @type {Tokenizer} */\n\nexports.labelStartLink = labelStartLink;\n\nfunction tokenizeLabelStartLink(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('labelLink');\n    effects.enter('labelMarker');\n    effects.consume(code);\n    effects.exit('labelMarker');\n    effects.exit('labelLink');\n    return after;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    /* To do: remove in the future once we’ve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesn’t need this */\n\n    /* Hidden footnotes hook. */\n\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs ? nok(code) : ok(code);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_core_commonmark$lib$label_end","~$shadow.js"]],"~:properties",["^5",["resolveAll","tokenize","__esModule","name","value","labelStartLink"]],"~:compiled-at",1676665867294,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_core_commonmark$lib$label_start_link.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,kEAAA,CAAuF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG/HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,cAAR,CAAyB,IAAK,EAWxBA,OAAAA,CAAiB,CACrBC,KAAM,gBADe,CAErBC,SAOFC,QAA+B,CAACC,OAAD,CAAUC,EAAV,CAAcC,GAAd,CAAmB,CAgBhDC,QAASA,MAAK,CAACC,IAAD,CAAO,CAQnB,MAAgB,GAAT,GAAAA,IAAA,EAAe,wBAAf,EAA2CC,KAAKC,CAAAA,MAAOC,CAAAA,UAAvD,CAAoEL,GAAA,CAAIE,IAAJ,CAApE,CAAgFH,EAAA,CAAGG,IAAH,CARpE,CAfrB,MAAMC,KAAO,IACb,OAGAG,SAAc,CAACJ,IAAD,CAAO,CACnBJ,OAAQS,CAAAA,KAAR,CAAc,WAAd,CACAT,QAAQS,CAAAA,KAAR,CAAc,aAAd,CACAT,QAAQU,CAAAA,OAAR,CAAgBN,IAAhB,CACAJ,QAAQW,CAAAA,IAAR,CAAa,aAAb,CACAX;OAAQW,CAAAA,IAAR,CAAa,WAAb,CACA,OAAOR,MANY,CAL2B,CAT3B,CAGrBS,WAZctB,OAAAuB,CAAQ,6DAARA,CAYQC,CAAAA,QAASF,CAAAA,UAHV,CAOvBpB,QAAQI,CAAAA,cAAR,CAAyBA,MAxBsG;\",\n\"sources\":[\"node_modules/micromark-core-commonmark/lib/label-start-link.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_core_commonmark$lib$label_start_link\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.labelStartLink = void 0;\\n\\nvar _labelEnd = require(\\\"./label-end.js\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').State} State\\n */\\n\\n/** @type {Construct} */\\nconst labelStartLink = {\\n  name: 'labelStartLink',\\n  tokenize: tokenizeLabelStartLink,\\n  resolveAll: _labelEnd.labelEnd.resolveAll\\n};\\n/** @type {Tokenizer} */\\n\\nexports.labelStartLink = labelStartLink;\\n\\nfunction tokenizeLabelStartLink(effects, ok, nok) {\\n  const self = this;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('labelLink');\\n    effects.enter('labelMarker');\\n    effects.consume(code);\\n    effects.exit('labelMarker');\\n    effects.exit('labelLink');\\n    return after;\\n  }\\n  /** @type {State} */\\n\\n\\n  function after(code) {\\n    /* To do: remove in the future once we\\u2019ve switched from\\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\\n     * which doesn\\u2019t need this */\\n\\n    /* Hidden footnotes hook. */\\n\\n    /* c8 ignore next 3 */\\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs ? nok(code) : ok(code);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"labelStartLink\",\"name\",\"tokenize\",\"tokenizeLabelStartLink\",\"effects\",\"ok\",\"nok\",\"after\",\"code\",\"self\",\"parser\",\"constructs\",\"start\",\"enter\",\"consume\",\"exit\",\"resolveAll\",\"_labelEnd\",\"labelEnd\"]\n}\n"]