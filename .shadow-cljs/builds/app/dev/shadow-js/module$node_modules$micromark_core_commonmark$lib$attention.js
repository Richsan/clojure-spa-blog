["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-core-commonmark/lib/attention.js"],"~:js","shadow$provide.module$node_modules$micromark_core_commonmark$lib$attention=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.attention=void 0;var _micromarkUtilChunked=require(\"module$node_modules$micromark_util_chunked$index\"),_micromarkUtilClassifyCharacter=require(\"module$node_modules$micromark_util_classify_character$index\"),_micromarkUtilResolveAll=require(\"module$node_modules$micromark_util_resolve_all$index\");exports.attention={name:\"attention\",\ntokenize:function(effects,ok){function sequence(code){if(code===marker)return effects.consume(code),sequence;const token=effects.exit(\"attentionSequence\"),after=(0,_micromarkUtilClassifyCharacter.classifyCharacter)(code),open=!after||2===after&&before||attentionMarkers.includes(code),close=!before||2===before&&after||attentionMarkers.includes(previous);token._open=!(42===marker?!open:!open||!before&&close);token._close=!(42===marker?!close:!close||!after&&open);return ok(code)}const attentionMarkers=\nthis.parser.constructs.attentionMarkers.null,previous=this.previous,before=(0,_micromarkUtilClassifyCharacter.classifyCharacter)(previous);let marker;return function(code){effects.enter(\"attentionSequence\");marker=code;return sequence(code)}},resolveAll:function(events,context){let index=-1,open;for(var group,text,openingSequence,closingSequence,use;++index<events.length;)if(\"enter\"===events[index][0]&&\"attentionSequence\"===events[index][1].type&&events[index][1]._close)for(open=index;open--;)if(\"exit\"===\nevents[open][0]&&\"attentionSequence\"===events[open][1].type&&events[open][1]._open&&context.sliceSerialize(events[open][1]).charCodeAt(0)===context.sliceSerialize(events[index][1]).charCodeAt(0)&&(!((events[open][1]._close||events[index][1]._open)&&(events[index][1].end.offset-events[index][1].start.offset)%3)||(events[open][1].end.offset-events[open][1].start.offset+events[index][1].end.offset-events[index][1].start.offset)%3)){use=1<events[open][1].end.offset-events[open][1].start.offset&&1<events[index][1].end.offset-\nevents[index][1].start.offset?2:1;openingSequence=Object.assign({},events[open][1].end);text=Object.assign({},events[index][1].start);closingSequence=openingSequence;group=-use;closingSequence.column+=group;closingSequence.offset+=group;closingSequence._bufferIndex+=group;closingSequence=text;group=use;closingSequence.column+=group;closingSequence.offset+=group;closingSequence._bufferIndex+=group;openingSequence={type:1<use?\"strongSequence\":\"emphasisSequence\",start:openingSequence,end:Object.assign({},\nevents[open][1].end)};closingSequence={type:1<use?\"strongSequence\":\"emphasisSequence\",start:Object.assign({},events[index][1].start),end:text};text={type:1<use?\"strongText\":\"emphasisText\",start:Object.assign({},events[open][1].end),end:Object.assign({},events[index][1].start)};group={type:1<use?\"strong\":\"emphasis\",start:Object.assign({},openingSequence.start),end:Object.assign({},closingSequence.end)};events[open][1].end=Object.assign({},openingSequence.start);events[index][1].start=Object.assign({},\nclosingSequence.end);use=[];events[open][1].end.offset-events[open][1].start.offset&&(use=(0,_micromarkUtilChunked.push)(use,[[\"enter\",events[open][1],context],[\"exit\",events[open][1],context]]));use=(0,_micromarkUtilChunked.push)(use,[[\"enter\",group,context],[\"enter\",openingSequence,context],[\"exit\",openingSequence,context],[\"enter\",text,context]]);use=(0,_micromarkUtilChunked.push)(use,(0,_micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan.null,events.slice(open+1,index),context));\nuse=(0,_micromarkUtilChunked.push)(use,[[\"exit\",text,context],[\"enter\",closingSequence,context],[\"exit\",closingSequence,context],[\"exit\",group,context]]);events[index][1].end.offset-events[index][1].start.offset?(text=2,use=(0,_micromarkUtilChunked.push)(use,[[\"enter\",events[index][1],context],[\"exit\",events[index][1],context]])):text=0;(0,_micromarkUtilChunked.splice)(events,open-1,index-open+3,use);index=open+use.length-text-2;break}for(index=-1;++index<events.length;)\"attentionSequence\"===events[index][1].type&&\n(events[index][1].type=\"data\");return events}}}","~:source","shadow$provide[\"module$node_modules$micromark_core_commonmark$lib$attention\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attention = void 0;\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\nvar _micromarkUtilClassifyCharacter = require(\"micromark-util-classify-character\");\n\nvar _micromarkUtilResolveAll = require(\"micromark-util-resolve-all\");\n\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Point} Point\n */\n\n/** @type {Construct} */\nconst attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n};\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\n\nexports.attention = attention;\n\nfunction resolveAllAttention(events, context) {\n  let index = -1;\n  /** @type {number} */\n\n  let open;\n  /** @type {Token} */\n\n  let group;\n  /** @type {Token} */\n\n  let text;\n  /** @type {Token} */\n\n  let openingSequence;\n  /** @type {Token} */\n\n  let closingSequence;\n  /** @type {number} */\n\n  let use;\n  /** @type {Event[]} */\n\n  let nextEvents;\n  /** @type {number} */\n\n  let offset; // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (events[index][0] === 'enter' && events[index][1].type === 'attentionSequence' && events[index][1]._close) {\n      open = index; // Now walk back to find an opener.\n\n      while (open--) {\n        // Find a token that can open the closer.\n        if (events[open][0] === 'exit' && events[open][1].type === 'attentionSequence' && events[open][1]._open && // If the markers are the same:\n        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index][1]).charCodeAt(0)) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if ((events[open][1]._close || events[index][1]._open) && (events[index][1].end.offset - events[index][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index][1].end.offset - events[index][1].start.offset) % 3)) {\n            continue;\n          } // Number of markers to use from the sequence.\n\n\n          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index][1].end.offset - events[index][1].start.offset > 1 ? 2 : 1;\n          const start = Object.assign({}, events[open][1].end);\n          const end = Object.assign({}, events[index][1].start);\n          movePoint(start, -use);\n          movePoint(end, use);\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start,\n            end: Object.assign({}, events[open][1].end)\n          };\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: Object.assign({}, events[index][1].start),\n            end\n          };\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: Object.assign({}, events[open][1].end),\n            end: Object.assign({}, events[index][1].start)\n          };\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: Object.assign({}, openingSequence.start),\n            end: Object.assign({}, closingSequence.end)\n          };\n          events[open][1].end = Object.assign({}, openingSequence.start);\n          events[index][1].start = Object.assign({}, closingSequence.end);\n          nextEvents = []; // If there are more markers in the opening, add them before.\n\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, [['enter', events[open][1], context], ['exit', events[open][1], context]]);\n          } // Opening.\n\n\n          nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, [['enter', group, context], ['enter', openingSequence, context], ['exit', openingSequence, context], ['enter', text, context]]); // Between.\n\n          nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, (0, _micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context)); // Closing.\n\n          nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, [['exit', text, context], ['enter', closingSequence, context], ['exit', closingSequence, context], ['exit', group, context]]); // If there are more markers in the closing, add them after.\n\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2;\n            nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, [['enter', events[index][1], context], ['exit', events[index][1], context]]);\n          } else {\n            offset = 0;\n          }\n\n          (0, _micromarkUtilChunked.splice)(events, open - 1, index - open + 3, nextEvents);\n          index = open + nextEvents.length - offset - 2;\n          break;\n        }\n      }\n    }\n  } // Remove remaining sequences.\n\n\n  index = -1;\n\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data';\n    }\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeAttention(effects, ok) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null;\n  const previous = this.previous;\n  const before = (0, _micromarkUtilClassifyCharacter.classifyCharacter)(previous);\n  /** @type {NonNullable<Code>} */\n\n  let marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('attentionSequence');\n    marker = code;\n    return sequence(code);\n  }\n  /** @type {State} */\n\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return sequence;\n    }\n\n    const token = effects.exit('attentionSequence');\n    const after = (0, _micromarkUtilClassifyCharacter.classifyCharacter)(code);\n    const open = !after || after === 2 && before || attentionMarkers.includes(code);\n    const close = !before || before === 2 && after || attentionMarkers.includes(previous);\n    token._open = Boolean(marker === 42 ? open : open && (before || !close));\n    token._close = Boolean(marker === 42 ? close : close && (after || !open));\n    return ok(code);\n  }\n}\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! It’s not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {void}\n */\n\n\nfunction movePoint(point, offset) {\n  point.column += offset;\n  point.offset += offset;\n  point._bufferIndex += offset;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_classify_character$index","~$module$node_modules$micromark_util_resolve_all$index","~$shadow.js","~$module$node_modules$micromark_util_chunked$index"]],"~:properties",["^5",["resolveAll","tokenize","offset","_open","__esModule","name","value","attention","start","column","type","_bufferIndex","_close","end"]],"~:compiled-at",1676665867265,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_core_commonmark$lib$attention.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-core-commonmark/lib/attention.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_core_commonmark$lib$attention\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.attention = void 0;\\n\\nvar _micromarkUtilChunked = require(\\\"micromark-util-chunked\\\");\\n\\nvar _micromarkUtilClassifyCharacter = require(\\\"micromark-util-classify-character\\\");\\n\\nvar _micromarkUtilResolveAll = require(\\\"micromark-util-resolve-all\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').Resolver} Resolver\\n * @typedef {import('micromark-util-types').State} State\\n * @typedef {import('micromark-util-types').Token} Token\\n * @typedef {import('micromark-util-types').Event} Event\\n * @typedef {import('micromark-util-types').Code} Code\\n * @typedef {import('micromark-util-types').Point} Point\\n */\\n\\n/** @type {Construct} */\\nconst attention = {\\n  name: 'attention',\\n  tokenize: tokenizeAttention,\\n  resolveAll: resolveAllAttention\\n};\\n/**\\n * Take all events and resolve attention to emphasis or strong.\\n *\\n * @type {Resolver}\\n */\\n\\nexports.attention = attention;\\n\\nfunction resolveAllAttention(events, context) {\\n  let index = -1;\\n  /** @type {number} */\\n\\n  let open;\\n  /** @type {Token} */\\n\\n  let group;\\n  /** @type {Token} */\\n\\n  let text;\\n  /** @type {Token} */\\n\\n  let openingSequence;\\n  /** @type {Token} */\\n\\n  let closingSequence;\\n  /** @type {number} */\\n\\n  let use;\\n  /** @type {Event[]} */\\n\\n  let nextEvents;\\n  /** @type {number} */\\n\\n  let offset; // Walk through all events.\\n  //\\n  // Note: performance of this is fine on an mb of normal markdown, but it\\u2019s\\n  // a bottleneck for malicious stuff.\\n\\n  while (++index < events.length) {\\n    // Find a token that can close.\\n    if (events[index][0] === 'enter' && events[index][1].type === 'attentionSequence' && events[index][1]._close) {\\n      open = index; // Now walk back to find an opener.\\n\\n      while (open--) {\\n        // Find a token that can open the closer.\\n        if (events[open][0] === 'exit' && events[open][1].type === 'attentionSequence' && events[open][1]._open && // If the markers are the same:\\n        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index][1]).charCodeAt(0)) {\\n          // If the opening can close or the closing can open,\\n          // and the close size *is not* a multiple of three,\\n          // but the sum of the opening and closing size *is* multiple of three,\\n          // then don\\u2019t match.\\n          if ((events[open][1]._close || events[index][1]._open) && (events[index][1].end.offset - events[index][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index][1].end.offset - events[index][1].start.offset) % 3)) {\\n            continue;\\n          } // Number of markers to use from the sequence.\\n\\n\\n          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index][1].end.offset - events[index][1].start.offset > 1 ? 2 : 1;\\n          const start = Object.assign({}, events[open][1].end);\\n          const end = Object.assign({}, events[index][1].start);\\n          movePoint(start, -use);\\n          movePoint(end, use);\\n          openingSequence = {\\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\\n            start,\\n            end: Object.assign({}, events[open][1].end)\\n          };\\n          closingSequence = {\\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\\n            start: Object.assign({}, events[index][1].start),\\n            end\\n          };\\n          text = {\\n            type: use > 1 ? 'strongText' : 'emphasisText',\\n            start: Object.assign({}, events[open][1].end),\\n            end: Object.assign({}, events[index][1].start)\\n          };\\n          group = {\\n            type: use > 1 ? 'strong' : 'emphasis',\\n            start: Object.assign({}, openingSequence.start),\\n            end: Object.assign({}, closingSequence.end)\\n          };\\n          events[open][1].end = Object.assign({}, openingSequence.start);\\n          events[index][1].start = Object.assign({}, closingSequence.end);\\n          nextEvents = []; // If there are more markers in the opening, add them before.\\n\\n          if (events[open][1].end.offset - events[open][1].start.offset) {\\n            nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, [['enter', events[open][1], context], ['exit', events[open][1], context]]);\\n          } // Opening.\\n\\n\\n          nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, [['enter', group, context], ['enter', openingSequence, context], ['exit', openingSequence, context], ['enter', text, context]]); // Between.\\n\\n          nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, (0, _micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context)); // Closing.\\n\\n          nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, [['exit', text, context], ['enter', closingSequence, context], ['exit', closingSequence, context], ['exit', group, context]]); // If there are more markers in the closing, add them after.\\n\\n          if (events[index][1].end.offset - events[index][1].start.offset) {\\n            offset = 2;\\n            nextEvents = (0, _micromarkUtilChunked.push)(nextEvents, [['enter', events[index][1], context], ['exit', events[index][1], context]]);\\n          } else {\\n            offset = 0;\\n          }\\n\\n          (0, _micromarkUtilChunked.splice)(events, open - 1, index - open + 3, nextEvents);\\n          index = open + nextEvents.length - offset - 2;\\n          break;\\n        }\\n      }\\n    }\\n  } // Remove remaining sequences.\\n\\n\\n  index = -1;\\n\\n  while (++index < events.length) {\\n    if (events[index][1].type === 'attentionSequence') {\\n      events[index][1].type = 'data';\\n    }\\n  }\\n\\n  return events;\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeAttention(effects, ok) {\\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null;\\n  const previous = this.previous;\\n  const before = (0, _micromarkUtilClassifyCharacter.classifyCharacter)(previous);\\n  /** @type {NonNullable<Code>} */\\n\\n  let marker;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('attentionSequence');\\n    marker = code;\\n    return sequence(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function sequence(code) {\\n    if (code === marker) {\\n      effects.consume(code);\\n      return sequence;\\n    }\\n\\n    const token = effects.exit('attentionSequence');\\n    const after = (0, _micromarkUtilClassifyCharacter.classifyCharacter)(code);\\n    const open = !after || after === 2 && before || attentionMarkers.includes(code);\\n    const close = !before || before === 2 && after || attentionMarkers.includes(previous);\\n    token._open = Boolean(marker === 42 ? open : open && (before || !close));\\n    token._close = Boolean(marker === 42 ? close : close && (after || !open));\\n    return ok(code);\\n  }\\n}\\n/**\\n * Move a point a bit.\\n *\\n * Note: `move` only works inside lines! It\\u2019s not possible to move past other\\n * chunks (replacement characters, tabs, or line endings).\\n *\\n * @param {Point} point\\n * @param {number} offset\\n * @returns {void}\\n */\\n\\n\\nfunction movePoint(point, offset) {\\n  point.column += offset;\\n  point.offset += offset;\\n  point._bufferIndex += offset;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"attention\",\"_micromarkUtilChunked\",\"_micromarkUtilClassifyCharacter\",\"_micromarkUtilResolveAll\",\"name\",\"tokenize\",\"tokenizeAttention\",\"effects\",\"ok\",\"sequence\",\"code\",\"marker\",\"consume\",\"token\",\"exit\",\"after\",\"classifyCharacter\",\"open\",\"before\",\"attentionMarkers\",\"includes\",\"close\",\"previous\",\"_open\",\"_close\",\"parser\",\"constructs\",\"null\",\"start\",\"enter\",\"resolveAll\",\"resolveAllAttention\",\"events\",\"context\",\"index\",\"group\",\"text\",\"openingSequence\",\"closingSequence\",\"use\",\"length\",\"type\",\"sliceSerialize\",\"charCodeAt\",\"end\",\"offset\",\"assign\",\"point\",\"column\",\"_bufferIndex\",\"nextEvents\",\"push\",\"insideSpan\",\"slice\",\"splice\"]\n}\n"]