["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/unist-util-find-after/lib/index.js"],"~:js","shadow$provide.module$node_modules$unist_util_find_after$lib$index=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.findAfter=void 0;var _unistUtilIs=require(\"module$node_modules$unist_util_is$index\");exports.findAfter=function(parent,index,test){test=(0,_unistUtilIs.convert)(test);if(!parent||!parent.type||!parent.children)throw Error(\"Expected parent node\");if(\"number\"===typeof index){if(0>index||index===Number.POSITIVE_INFINITY)throw Error(\"Expected positive finite number as index\");\n}else if(index=parent.children.indexOf(index),0>index)throw Error(\"Expected child node or index\");for(;++index<parent.children.length;)if(test(parent.children[index],index,parent))return parent.children[index];return null}}","~:source","shadow$provide[\"module$node_modules$unist_util_find_after$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findAfter = void 0;\n\nvar _unistUtilIs = require(\"unist-util-is\");\n\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n\n * @param parent\n *   Parent node.\n * @param index\n *   Child of `parent` or itâ€™s index.\n * @param test\n *   `unist-util-is`-compatible test.\n * @returns\n *   Child of `parent` or `null`.\n */\nconst findAfter =\n/**\n * @param {Parent} parent\n * @param {Node | number} index\n * @param {Test} [test]\n * @returns {Node | null}\n */\nfunction (parent, index, test) {\n  const is = (0, _unistUtilIs.convert)(test);\n\n  if (!parent || !parent.type || !parent.children) {\n    throw new Error('Expected parent node');\n  }\n\n  if (typeof index === 'number') {\n    if (index < 0 || index === Number.POSITIVE_INFINITY) {\n      throw new Error('Expected positive finite number as index');\n    }\n  } else {\n    index = parent.children.indexOf(index);\n\n    if (index < 0) {\n      throw new Error('Expected child node or index');\n    }\n  }\n\n  while (++index < parent.children.length) {\n    if (is(parent.children[index], index, parent)) {\n      return parent.children[index];\n    }\n  }\n\n  return null;\n};\n\nexports.findAfter = findAfter;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$unist_util_is$index"]],"~:properties",["^5",["__esModule","findAfter","value"]],"~:compiled-at",1676667638369,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$unist_util_find_after$lib$index.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,mDAAA,CAAwE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGhHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,SAAR,CAAoB,IAAK,EAEzB,KAAIC,aAAeP,OAAA,CAAQ,yCAAR,CAwDnBE,QAAQI,CAAAA,SAAR,CA5BAA,QAAS,CAACE,MAAD,CAASC,KAAT,CAAgBC,IAAhB,CAAsB,CACvBC,IAAAA,CAAK,GAAIJ,YAAaK,CAAAA,OAAjB,EAA0BF,IAA1B,CAEX,IAAI,CAACF,MAAL,EAAe,CAACA,MAAOK,CAAAA,IAAvB,EAA+B,CAACL,MAAOM,CAAAA,QAAvC,CACE,KAAUC,MAAJ,CAAU,sBAAV,CAAN,CAGF,GAAqB,QAArB,GAAI,MAAON,MAAX,CACE,IAAY,CAAZ,CAAIA,KAAJ,EAAiBA,KAAjB,GAA2BO,MAAOC,CAAAA,iBAAlC,CACE,KAAUF,MAAJ,CAAU,0CAAV,CAAN;AADF,CADF,IAOE,IAFAN,KAEI,CAFID,MAAOM,CAAAA,QAASI,CAAAA,OAAhB,CAAwBT,KAAxB,CAEJ,CAAQ,CAAR,CAAAA,KAAJ,CACE,KAAUM,MAAJ,CAAU,8BAAV,CAAN,CAIJ,IAAA,CAAO,EAAEN,KAAT,CAAiBD,MAAOM,CAAAA,QAASK,CAAAA,MAAjC,CAAA,CACE,GAAIR,IAAA,CAAGH,MAAOM,CAAAA,QAAP,CAAgBL,KAAhB,CAAH,CAA2BA,KAA3B,CAAkCD,MAAlC,CAAJ,CACE,MAAOA,OAAOM,CAAAA,QAAP,CAAgBL,KAAhB,CAIX,OAAO,KAzBsB,CApCiF;\",\n\"sources\":[\"node_modules/unist-util-find-after/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$unist_util_find_after$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.findAfter = void 0;\\n\\nvar _unistUtilIs = require(\\\"unist-util-is\\\");\\n\\n/**\\n * @typedef {import('unist').Node} Node\\n * @typedef {import('unist').Parent} Parent\\n * @typedef {import('unist-util-is').Test} Test\\n */\\n\\n/**\\n * Find the first node in `parent` after another `node` or after an index,\\n * that passes `test`.\\n\\n * @param parent\\n *   Parent node.\\n * @param index\\n *   Child of `parent` or it\\u2019s index.\\n * @param test\\n *   `unist-util-is`-compatible test.\\n * @returns\\n *   Child of `parent` or `null`.\\n */\\nconst findAfter =\\n/**\\n * @param {Parent} parent\\n * @param {Node | number} index\\n * @param {Test} [test]\\n * @returns {Node | null}\\n */\\nfunction (parent, index, test) {\\n  const is = (0, _unistUtilIs.convert)(test);\\n\\n  if (!parent || !parent.type || !parent.children) {\\n    throw new Error('Expected parent node');\\n  }\\n\\n  if (typeof index === 'number') {\\n    if (index < 0 || index === Number.POSITIVE_INFINITY) {\\n      throw new Error('Expected positive finite number as index');\\n    }\\n  } else {\\n    index = parent.children.indexOf(index);\\n\\n    if (index < 0) {\\n      throw new Error('Expected child node or index');\\n    }\\n  }\\n\\n  while (++index < parent.children.length) {\\n    if (is(parent.children[index], index, parent)) {\\n      return parent.children[index];\\n    }\\n  }\\n\\n  return null;\\n};\\n\\nexports.findAfter = findAfter;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"findAfter\",\"_unistUtilIs\",\"parent\",\"index\",\"test\",\"is\",\"convert\",\"type\",\"children\",\"Error\",\"Number\",\"POSITIVE_INFINITY\",\"indexOf\",\"length\"]\n}\n"]