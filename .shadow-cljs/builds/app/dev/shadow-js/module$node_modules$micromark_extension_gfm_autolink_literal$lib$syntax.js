["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js"],"~:js","shadow$provide.module$node_modules$micromark_extension_gfm_autolink_literal$lib$syntax=function(global,require,module,exports){function trailingPunctuation(code){return 33===code||34===code||39===code||41===code||42===code||44===code||46===code||58===code||59===code||60===code||63===code||95===code||126===code}function pathEnd(code){return null===code||60===code||(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code)}function gfmAtext(code){return 43===code||45===code||46===code||95===code||\n(0,_micromarkUtilCharacter.asciiAlphanumeric)(code)}function previousWww(code){return null===code||40===code||42===code||95===code||126===code||(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code)}function previousHttp(code){return null===code||!(0,_micromarkUtilCharacter.asciiAlpha)(code)}function previousEmail(code){return 47!==code&&previousHttp(code)}function previousUnbalanced(events){let index=events.length,result=!1;for(;index--;){const token=events[index][1];if((\"labelLink\"===token.type||\n\"labelImage\"===token.type)&&!token._balanced){result=!0;break}if(token._gfmAutolinkLiteralWalkedInto){result=!1;break}}0<events.length&&!result&&(events[events.length-1][1]._gfmAutolinkLiteralWalkedInto=!0);return result}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.gfmAutolinkLiteral=void 0;var _micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\");const www={tokenize:function(effects,ok,nok){function w2(code){return 87===code||119===code?(effects.consume(code),\nw3):nok(code)}function w3(code){return 87===code||119===code?(effects.consume(code),dot):nok(code)}function dot(code){return 46===code?(effects.consume(code),after):nok(code)}function after(code){return null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code)?nok(code):ok(code)}return function(code){effects.consume(code);return w2}},partial:!0},domain$jscomp$0={tokenize:function(effects,ok,nok){function domain(code){if(38===code)return effects.check(namedCharacterReference,done,punctuationContinuation)(code);\nif(46===code||95===code)return effects.check(punctuation,done,punctuationContinuation)(code);if(null===code||(0,_micromarkUtilCharacter.asciiControl)(code)||(0,_micromarkUtilCharacter.unicodeWhitespace)(code)||45!==code&&(0,_micromarkUtilCharacter.unicodePunctuation)(code))return done(code);effects.consume(code);return domain}function punctuationContinuation(code){if(46===code)return hasUnderscoreInLastLastSegment=hasUnderscoreInLastSegment,hasUnderscoreInLastSegment=void 0,effects.consume(code),\ndomain;95===code&&(hasUnderscoreInLastSegment=!0);effects.consume(code);return domain}function done(code){return hasUnderscoreInLastLastSegment||hasUnderscoreInLastSegment?nok(code):ok(code)}let hasUnderscoreInLastSegment,hasUnderscoreInLastLastSegment;return domain},partial:!0},path={tokenize:function(effects,ok){function inPath(code){if(38===code)return effects.check(namedCharacterReference,ok,continuedPunctuation)(code);40===code&&balance++;if(41===code)return effects.check(punctuation,parenAtPathEnd,\ncontinuedPunctuation)(code);if(pathEnd(code))return ok(code);if(trailingPunctuation(code))return effects.check(punctuation,ok,continuedPunctuation)(code);effects.consume(code);return inPath}function continuedPunctuation(code){effects.consume(code);return inPath}function parenAtPathEnd(code){balance--;return 0>balance?ok(code):continuedPunctuation(code)}let balance=0;return inPath},partial:!0},punctuation={tokenize:function(effects,ok,nok){function after(code){return trailingPunctuation(code)?(effects.consume(code),\nafter):pathEnd(code)?ok(code):nok(code)}return function(code){effects.consume(code);return after}},partial:!0},namedCharacterReference={tokenize:function(effects,ok,nok){function inside(code){return(0,_micromarkUtilCharacter.asciiAlpha)(code)?(effects.consume(code),inside):59===code?(effects.consume(code),after):nok(code)}function after(code){return pathEnd(code)?ok(code):nok(code)}return function(code){effects.consume(code);return inside}},partial:!0};global={tokenize:function(effects,ok,nok){function done(code){effects.exit(\"literalAutolinkWww\");\neffects.exit(\"literalAutolink\");return ok(code)}const self=this;return function(code){if(87!==code&&119!==code||!previousWww(self.previous)||previousUnbalanced(self.events))return nok(code);effects.enter(\"literalAutolink\");effects.enter(\"literalAutolinkWww\");return effects.check(www,effects.attempt(domain$jscomp$0,effects.attempt(path,done),nok),nok)(code)}},previous:previousWww};require={tokenize:function(effects,ok,nok){function t1(code){return 84===code||116===code?(effects.consume(code),t2):nok(code)}\nfunction t2(code){return 84===code||116===code?(effects.consume(code),p):nok(code)}function p(code){return 80===code||112===code?(effects.consume(code),s):nok(code)}function s(code){return 83===code||115===code?(effects.consume(code),colon):colon(code)}function colon(code){return 58===code?(effects.consume(code),slash1):nok(code)}function slash1(code){return 47===code?(effects.consume(code),slash2):nok(code)}function slash2(code){return 47===code?(effects.consume(code),after):nok(code)}function after(code){return null===\ncode||(0,_micromarkUtilCharacter.asciiControl)(code)||(0,_micromarkUtilCharacter.unicodeWhitespace)(code)||(0,_micromarkUtilCharacter.unicodePunctuation)(code)?nok(code):effects.attempt(domain$jscomp$0,effects.attempt(path,done),nok)(code)}function done(code){effects.exit(\"literalAutolinkHttp\");effects.exit(\"literalAutolink\");return ok(code)}const self=this;return function(code){if(72!==code&&104!==code||!previousHttp(self.previous)||previousUnbalanced(self.events))return nok(code);effects.enter(\"literalAutolink\");\neffects.enter(\"literalAutolinkHttp\");effects.consume(code);return t1}},previous:previousHttp};module={tokenize:function(effects,ok,nok){function atext(code){return gfmAtext(code)?(effects.consume(code),atext):64===code?(effects.consume(code),label):nok(code)}function label(code){return 46===code?effects.check(punctuation,done,dotContinuation)(code):45===code||95===code?effects.check(punctuation,nok,dashOrUnderscoreContinuation)(code):(0,_micromarkUtilCharacter.asciiAlphanumeric)(code)?(!hasDigitInLastSegment&&\n(0,_micromarkUtilCharacter.asciiDigit)(code)&&(hasDigitInLastSegment=!0),effects.consume(code),label):done(code)}function dotContinuation(code){effects.consume(code);hasDot=!0;hasDigitInLastSegment=void 0;return label}function dashOrUnderscoreContinuation(code){effects.consume(code);return afterDashOrUnderscore}function afterDashOrUnderscore(code){return 46===code?effects.check(punctuation,nok,dotContinuation)(code):label(code)}function done(code){return hasDot&&!hasDigitInLastSegment?(effects.exit(\"literalAutolinkEmail\"),\neffects.exit(\"literalAutolink\"),ok(code)):nok(code)}const self=this;let hasDot,hasDigitInLastSegment;return function(code){if(!gfmAtext(code)||!previousEmail(self.previous)||previousUnbalanced(self.events))return nok(code);effects.enter(\"literalAutolink\");effects.enter(\"literalAutolinkEmail\");return atext(code)}},previous:previousEmail};const text={};exports.gfmAutolinkLiteral={text};for(exports=48;123>exports;)text[exports]=module,exports++,58===exports?exports=65:91===exports&&(exports=97);text[43]=\nmodule;text[45]=module;text[46]=module;text[95]=module;text[72]=[module,require];text[104]=[module,require];text[87]=[module,global];text[119]=[module,global]}","~:source","shadow$provide[\"module$node_modules$micromark_extension_gfm_autolink_literal$lib$syntax\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gfmAutolinkLiteral = void 0;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nconst www = {\n  tokenize: tokenizeWww,\n  partial: true\n};\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n};\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n};\nconst punctuation = {\n  tokenize: tokenizePunctuation,\n  partial: true\n};\nconst namedCharacterReference = {\n  tokenize: tokenizeNamedCharacterReference,\n  partial: true\n};\nconst wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n};\nconst httpAutolink = {\n  tokenize: tokenizeHttpAutolink,\n  previous: previousHttp\n};\nconst emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n};\n/** @type {ConstructRecord} */\n\nconst text = {};\n/** @type {Extension} */\n\nconst gfmAutolinkLiteral = {\n  text\n};\nexports.gfmAutolinkLiteral = gfmAutolinkLiteral;\nlet code = 48; // Add alphanumerics.\n\nwhile (code < 123) {\n  text[code] = emailAutolink;\n  code++;\n  if (code === 58) code = 65;else if (code === 91) code = 97;\n}\n\ntext[43] = emailAutolink;\ntext[45] = emailAutolink;\ntext[46] = emailAutolink;\ntext[95] = emailAutolink;\ntext[72] = [emailAutolink, httpAutolink];\ntext[104] = [emailAutolink, httpAutolink];\ntext[87] = [emailAutolink, wwwAutolink];\ntext[119] = [emailAutolink, wwwAutolink];\n/** @type {Tokenizer} */\n\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this;\n  /** @type {boolean} */\n\n  let hasDot;\n  /** @type {boolean|undefined} */\n\n  let hasDigitInLastSegment;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!gfmAtext(code) || !previousEmail(self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkEmail');\n    return atext(code);\n  }\n  /** @type {State} */\n\n\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code);\n      return atext;\n    }\n\n    if (code === 64) {\n      effects.consume(code);\n      return label;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function label(code) {\n    if (code === 46) {\n      return effects.check(punctuation, done, dotContinuation)(code);\n    }\n\n    if (code === 45 || code === 95) {\n      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.asciiAlphanumeric)(code)) {\n      if (!hasDigitInLastSegment && (0, _micromarkUtilCharacter.asciiDigit)(code)) {\n        hasDigitInLastSegment = true;\n      }\n\n      effects.consume(code);\n      return label;\n    }\n\n    return done(code);\n  }\n  /** @type {State} */\n\n\n  function dotContinuation(code) {\n    effects.consume(code);\n    hasDot = true;\n    hasDigitInLastSegment = undefined;\n    return label;\n  }\n  /** @type {State} */\n\n\n  function dashOrUnderscoreContinuation(code) {\n    effects.consume(code);\n    return afterDashOrUnderscore;\n  }\n  /** @type {State} */\n\n\n  function afterDashOrUnderscore(code) {\n    if (code === 46) {\n      return effects.check(punctuation, nok, dotContinuation)(code);\n    }\n\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    if (hasDot && !hasDigitInLastSegment) {\n      effects.exit('literalAutolinkEmail');\n      effects.exit('literalAutolink');\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code !== 87 && code !== 119 || !previousWww(self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkWww'); // For `www.` we check instead of attempt, because when it matches, GH\n    // treats it as part of a domain (yes, it says a valid domain must come\n    // after `www.`, but that’s not how it’s implemented by them).\n\n    return effects.check(www, effects.attempt(domain, effects.attempt(path, done), nok), nok)(code);\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    effects.exit('literalAutolinkWww');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeHttpAutolink(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code !== 72 && code !== 104 || !previousHttp(self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkHttp');\n    effects.consume(code);\n    return t1;\n  }\n  /** @type {State} */\n\n\n  function t1(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code);\n      return t2;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function t2(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code);\n      return p;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function p(code) {\n    if (code === 80 || code === 112) {\n      effects.consume(code);\n      return s;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function s(code) {\n    if (code === 83 || code === 115) {\n      effects.consume(code);\n      return colon;\n    }\n\n    return colon(code);\n  }\n  /** @type {State} */\n\n\n  function colon(code) {\n    if (code === 58) {\n      effects.consume(code);\n      return slash1;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function slash1(code) {\n    if (code === 47) {\n      effects.consume(code);\n      return slash2;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function slash2(code) {\n    if (code === 47) {\n      effects.consume(code);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    return code === null || (0, _micromarkUtilCharacter.asciiControl)(code) || (0, _micromarkUtilCharacter.unicodeWhitespace)(code) || (0, _micromarkUtilCharacter.unicodePunctuation)(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, done), nok)(code);\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    effects.exit('literalAutolinkHttp');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeWww(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code);\n    return w2;\n  }\n  /** @type {State} */\n\n\n  function w2(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code);\n      return w3;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function w3(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code);\n      return dot;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function dot(code) {\n    if (code === 46) {\n      effects.consume(code);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    return code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code) ? nok(code) : ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean|undefined} */\n  let hasUnderscoreInLastSegment;\n  /** @type {boolean|undefined} */\n\n  let hasUnderscoreInLastLastSegment;\n  return domain;\n  /** @type {State} */\n\n  function domain(code) {\n    if (code === 38) {\n      return effects.check(namedCharacterReference, done, punctuationContinuation)(code);\n    }\n\n    if (code === 46 || code === 95) {\n      return effects.check(punctuation, done, punctuationContinuation)(code);\n    } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n    // so that’s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n\n\n    if (code === null || (0, _micromarkUtilCharacter.asciiControl)(code) || (0, _micromarkUtilCharacter.unicodeWhitespace)(code) || code !== 45 && (0, _micromarkUtilCharacter.unicodePunctuation)(code)) {\n      return done(code);\n    }\n\n    effects.consume(code);\n    return domain;\n  }\n  /** @type {State} */\n\n\n  function punctuationContinuation(code) {\n    if (code === 46) {\n      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;\n      hasUnderscoreInLastSegment = undefined;\n      effects.consume(code);\n      return domain;\n    }\n\n    if (code === 95) hasUnderscoreInLastSegment = true;\n    effects.consume(code);\n    return domain;\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizePath(effects, ok) {\n  let balance = 0;\n  return inPath;\n  /** @type {State} */\n\n  function inPath(code) {\n    if (code === 38) {\n      return effects.check(namedCharacterReference, ok, continuedPunctuation)(code);\n    }\n\n    if (code === 40) {\n      balance++;\n    }\n\n    if (code === 41) {\n      return effects.check(punctuation, parenAtPathEnd, continuedPunctuation)(code);\n    }\n\n    if (pathEnd(code)) {\n      return ok(code);\n    }\n\n    if (trailingPunctuation(code)) {\n      return effects.check(punctuation, ok, continuedPunctuation)(code);\n    }\n\n    effects.consume(code);\n    return inPath;\n  }\n  /** @type {State} */\n\n\n  function continuedPunctuation(code) {\n    effects.consume(code);\n    return inPath;\n  }\n  /** @type {State} */\n\n\n  function parenAtPathEnd(code) {\n    balance--;\n    return balance < 0 ? ok(code) : continuedPunctuation(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNamedCharacterReference(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code);\n    return inside;\n  }\n  /** @type {State} */\n\n\n  function inside(code) {\n    if ((0, _micromarkUtilCharacter.asciiAlpha)(code)) {\n      effects.consume(code);\n      return inside;\n    }\n\n    if (code === 59) {\n      effects.consume(code);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    // If the named character reference is followed by the end of the path, it’s\n    // not continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizePunctuation(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code);\n    return after;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    // Check the next.\n    if (trailingPunctuation(code)) {\n      effects.consume(code);\n      return after;\n    } // If the punctuation marker is followed by the end of the path, it’s not\n    // continued punctuation.\n\n\n    return pathEnd(code) ? ok(code) : nok(code);\n  }\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\n\nfunction trailingPunctuation(code) {\n  return code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 95 || code === 126;\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\n\nfunction pathEnd(code) {\n  return code === null || code === 60 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code);\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\n\nfunction gfmAtext(code) {\n  return code === 43 || code === 45 || code === 46 || code === 95 || (0, _micromarkUtilCharacter.asciiAlphanumeric)(code);\n}\n/** @type {Previous} */\n\n\nfunction previousWww(code) {\n  return code === null || code === 40 || code === 42 || code === 95 || code === 126 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code);\n}\n/** @type {Previous} */\n\n\nfunction previousHttp(code) {\n  return code === null || !(0, _micromarkUtilCharacter.asciiAlpha)(code);\n}\n/** @type {Previous} */\n\n\nfunction previousEmail(code) {\n  return code !== 47 && previousHttp(code);\n}\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\n\n\nfunction previousUnbalanced(events) {\n  let index = events.length;\n  let result = false;\n\n  while (index--) {\n    const token = events[index][1];\n\n    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {\n      result = true;\n      break;\n    } // @ts-expect-error If we’ve seen this token, and it was marked as not\n    // having any unbalanced bracket before it, we can exit.\n\n\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false;\n      break;\n    }\n  }\n\n  if (events.length > 0 && !result) {\n    // @ts-expect-error Mark the last token as “walked into” w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n  }\n\n  return result;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js"]],"~:properties",["^5",["partial","tokenize","__esModule","value","previous","text","_gfmAutolinkLiteralWalkedInto","gfmAutolinkLiteral"]],"~:compiled-at",1676841365309,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_extension_gfm_autolink_literal$lib$syntax.js\",\n\"lineCount\":15,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_extension_gfm_autolink_literal$lib$syntax\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.gfmAutolinkLiteral = void 0;\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Extension} Extension\\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').Previous} Previous\\n * @typedef {import('micromark-util-types').State} State\\n * @typedef {import('micromark-util-types').Event} Event\\n * @typedef {import('micromark-util-types').Code} Code\\n */\\nconst www = {\\n  tokenize: tokenizeWww,\\n  partial: true\\n};\\nconst domain = {\\n  tokenize: tokenizeDomain,\\n  partial: true\\n};\\nconst path = {\\n  tokenize: tokenizePath,\\n  partial: true\\n};\\nconst punctuation = {\\n  tokenize: tokenizePunctuation,\\n  partial: true\\n};\\nconst namedCharacterReference = {\\n  tokenize: tokenizeNamedCharacterReference,\\n  partial: true\\n};\\nconst wwwAutolink = {\\n  tokenize: tokenizeWwwAutolink,\\n  previous: previousWww\\n};\\nconst httpAutolink = {\\n  tokenize: tokenizeHttpAutolink,\\n  previous: previousHttp\\n};\\nconst emailAutolink = {\\n  tokenize: tokenizeEmailAutolink,\\n  previous: previousEmail\\n};\\n/** @type {ConstructRecord} */\\n\\nconst text = {};\\n/** @type {Extension} */\\n\\nconst gfmAutolinkLiteral = {\\n  text\\n};\\nexports.gfmAutolinkLiteral = gfmAutolinkLiteral;\\nlet code = 48; // Add alphanumerics.\\n\\nwhile (code < 123) {\\n  text[code] = emailAutolink;\\n  code++;\\n  if (code === 58) code = 65;else if (code === 91) code = 97;\\n}\\n\\ntext[43] = emailAutolink;\\ntext[45] = emailAutolink;\\ntext[46] = emailAutolink;\\ntext[95] = emailAutolink;\\ntext[72] = [emailAutolink, httpAutolink];\\ntext[104] = [emailAutolink, httpAutolink];\\ntext[87] = [emailAutolink, wwwAutolink];\\ntext[119] = [emailAutolink, wwwAutolink];\\n/** @type {Tokenizer} */\\n\\nfunction tokenizeEmailAutolink(effects, ok, nok) {\\n  const self = this;\\n  /** @type {boolean} */\\n\\n  let hasDot;\\n  /** @type {boolean|undefined} */\\n\\n  let hasDigitInLastSegment;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    if (!gfmAtext(code) || !previousEmail(self.previous) || previousUnbalanced(self.events)) {\\n      return nok(code);\\n    }\\n\\n    effects.enter('literalAutolink');\\n    effects.enter('literalAutolinkEmail');\\n    return atext(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function atext(code) {\\n    if (gfmAtext(code)) {\\n      effects.consume(code);\\n      return atext;\\n    }\\n\\n    if (code === 64) {\\n      effects.consume(code);\\n      return label;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function label(code) {\\n    if (code === 46) {\\n      return effects.check(punctuation, done, dotContinuation)(code);\\n    }\\n\\n    if (code === 45 || code === 95) {\\n      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code);\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.asciiAlphanumeric)(code)) {\\n      if (!hasDigitInLastSegment && (0, _micromarkUtilCharacter.asciiDigit)(code)) {\\n        hasDigitInLastSegment = true;\\n      }\\n\\n      effects.consume(code);\\n      return label;\\n    }\\n\\n    return done(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function dotContinuation(code) {\\n    effects.consume(code);\\n    hasDot = true;\\n    hasDigitInLastSegment = undefined;\\n    return label;\\n  }\\n  /** @type {State} */\\n\\n\\n  function dashOrUnderscoreContinuation(code) {\\n    effects.consume(code);\\n    return afterDashOrUnderscore;\\n  }\\n  /** @type {State} */\\n\\n\\n  function afterDashOrUnderscore(code) {\\n    if (code === 46) {\\n      return effects.check(punctuation, nok, dotContinuation)(code);\\n    }\\n\\n    return label(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function done(code) {\\n    if (hasDot && !hasDigitInLastSegment) {\\n      effects.exit('literalAutolinkEmail');\\n      effects.exit('literalAutolink');\\n      return ok(code);\\n    }\\n\\n    return nok(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeWwwAutolink(effects, ok, nok) {\\n  const self = this;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    if (code !== 87 && code !== 119 || !previousWww(self.previous) || previousUnbalanced(self.events)) {\\n      return nok(code);\\n    }\\n\\n    effects.enter('literalAutolink');\\n    effects.enter('literalAutolinkWww'); // For `www.` we check instead of attempt, because when it matches, GH\\n    // treats it as part of a domain (yes, it says a valid domain must come\\n    // after `www.`, but that\\u2019s not how it\\u2019s implemented by them).\\n\\n    return effects.check(www, effects.attempt(domain, effects.attempt(path, done), nok), nok)(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function done(code) {\\n    effects.exit('literalAutolinkWww');\\n    effects.exit('literalAutolink');\\n    return ok(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeHttpAutolink(effects, ok, nok) {\\n  const self = this;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    if (code !== 72 && code !== 104 || !previousHttp(self.previous) || previousUnbalanced(self.events)) {\\n      return nok(code);\\n    }\\n\\n    effects.enter('literalAutolink');\\n    effects.enter('literalAutolinkHttp');\\n    effects.consume(code);\\n    return t1;\\n  }\\n  /** @type {State} */\\n\\n\\n  function t1(code) {\\n    if (code === 84 || code === 116) {\\n      effects.consume(code);\\n      return t2;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function t2(code) {\\n    if (code === 84 || code === 116) {\\n      effects.consume(code);\\n      return p;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function p(code) {\\n    if (code === 80 || code === 112) {\\n      effects.consume(code);\\n      return s;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function s(code) {\\n    if (code === 83 || code === 115) {\\n      effects.consume(code);\\n      return colon;\\n    }\\n\\n    return colon(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function colon(code) {\\n    if (code === 58) {\\n      effects.consume(code);\\n      return slash1;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function slash1(code) {\\n    if (code === 47) {\\n      effects.consume(code);\\n      return slash2;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function slash2(code) {\\n    if (code === 47) {\\n      effects.consume(code);\\n      return after;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function after(code) {\\n    return code === null || (0, _micromarkUtilCharacter.asciiControl)(code) || (0, _micromarkUtilCharacter.unicodeWhitespace)(code) || (0, _micromarkUtilCharacter.unicodePunctuation)(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, done), nok)(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function done(code) {\\n    effects.exit('literalAutolinkHttp');\\n    effects.exit('literalAutolink');\\n    return ok(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeWww(effects, ok, nok) {\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.consume(code);\\n    return w2;\\n  }\\n  /** @type {State} */\\n\\n\\n  function w2(code) {\\n    if (code === 87 || code === 119) {\\n      effects.consume(code);\\n      return w3;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function w3(code) {\\n    if (code === 87 || code === 119) {\\n      effects.consume(code);\\n      return dot;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function dot(code) {\\n    if (code === 46) {\\n      effects.consume(code);\\n      return after;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function after(code) {\\n    return code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code) ? nok(code) : ok(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeDomain(effects, ok, nok) {\\n  /** @type {boolean|undefined} */\\n  let hasUnderscoreInLastSegment;\\n  /** @type {boolean|undefined} */\\n\\n  let hasUnderscoreInLastLastSegment;\\n  return domain;\\n  /** @type {State} */\\n\\n  function domain(code) {\\n    if (code === 38) {\\n      return effects.check(namedCharacterReference, done, punctuationContinuation)(code);\\n    }\\n\\n    if (code === 46 || code === 95) {\\n      return effects.check(punctuation, done, punctuationContinuation)(code);\\n    } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\\n    // occur, which sounds like ASCII only, but they also support `www.\\u9ede\\u770b.com`,\\n    // so that\\u2019s Unicode.\\n    // Instead of some new production for Unicode alphanumerics, markdown\\n    // already has that for Unicode punctuation and whitespace, so use those.\\n\\n\\n    if (code === null || (0, _micromarkUtilCharacter.asciiControl)(code) || (0, _micromarkUtilCharacter.unicodeWhitespace)(code) || code !== 45 && (0, _micromarkUtilCharacter.unicodePunctuation)(code)) {\\n      return done(code);\\n    }\\n\\n    effects.consume(code);\\n    return domain;\\n  }\\n  /** @type {State} */\\n\\n\\n  function punctuationContinuation(code) {\\n    if (code === 46) {\\n      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;\\n      hasUnderscoreInLastSegment = undefined;\\n      effects.consume(code);\\n      return domain;\\n    }\\n\\n    if (code === 95) hasUnderscoreInLastSegment = true;\\n    effects.consume(code);\\n    return domain;\\n  }\\n  /** @type {State} */\\n\\n\\n  function done(code) {\\n    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {\\n      return ok(code);\\n    }\\n\\n    return nok(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizePath(effects, ok) {\\n  let balance = 0;\\n  return inPath;\\n  /** @type {State} */\\n\\n  function inPath(code) {\\n    if (code === 38) {\\n      return effects.check(namedCharacterReference, ok, continuedPunctuation)(code);\\n    }\\n\\n    if (code === 40) {\\n      balance++;\\n    }\\n\\n    if (code === 41) {\\n      return effects.check(punctuation, parenAtPathEnd, continuedPunctuation)(code);\\n    }\\n\\n    if (pathEnd(code)) {\\n      return ok(code);\\n    }\\n\\n    if (trailingPunctuation(code)) {\\n      return effects.check(punctuation, ok, continuedPunctuation)(code);\\n    }\\n\\n    effects.consume(code);\\n    return inPath;\\n  }\\n  /** @type {State} */\\n\\n\\n  function continuedPunctuation(code) {\\n    effects.consume(code);\\n    return inPath;\\n  }\\n  /** @type {State} */\\n\\n\\n  function parenAtPathEnd(code) {\\n    balance--;\\n    return balance < 0 ? ok(code) : continuedPunctuation(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeNamedCharacterReference(effects, ok, nok) {\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.consume(code);\\n    return inside;\\n  }\\n  /** @type {State} */\\n\\n\\n  function inside(code) {\\n    if ((0, _micromarkUtilCharacter.asciiAlpha)(code)) {\\n      effects.consume(code);\\n      return inside;\\n    }\\n\\n    if (code === 59) {\\n      effects.consume(code);\\n      return after;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function after(code) {\\n    // If the named character reference is followed by the end of the path, it\\u2019s\\n    // not continued punctuation.\\n    return pathEnd(code) ? ok(code) : nok(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizePunctuation(effects, ok, nok) {\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.consume(code);\\n    return after;\\n  }\\n  /** @type {State} */\\n\\n\\n  function after(code) {\\n    // Check the next.\\n    if (trailingPunctuation(code)) {\\n      effects.consume(code);\\n      return after;\\n    } // If the punctuation marker is followed by the end of the path, it\\u2019s not\\n    // continued punctuation.\\n\\n\\n    return pathEnd(code) ? ok(code) : nok(code);\\n  }\\n}\\n/**\\n * @param {Code} code\\n * @returns {boolean}\\n */\\n\\n\\nfunction trailingPunctuation(code) {\\n  return code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 95 || code === 126;\\n}\\n/**\\n * @param {Code} code\\n * @returns {boolean}\\n */\\n\\n\\nfunction pathEnd(code) {\\n  return code === null || code === 60 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code);\\n}\\n/**\\n * @param {Code} code\\n * @returns {boolean}\\n */\\n\\n\\nfunction gfmAtext(code) {\\n  return code === 43 || code === 45 || code === 46 || code === 95 || (0, _micromarkUtilCharacter.asciiAlphanumeric)(code);\\n}\\n/** @type {Previous} */\\n\\n\\nfunction previousWww(code) {\\n  return code === null || code === 40 || code === 42 || code === 95 || code === 126 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code);\\n}\\n/** @type {Previous} */\\n\\n\\nfunction previousHttp(code) {\\n  return code === null || !(0, _micromarkUtilCharacter.asciiAlpha)(code);\\n}\\n/** @type {Previous} */\\n\\n\\nfunction previousEmail(code) {\\n  return code !== 47 && previousHttp(code);\\n}\\n/**\\n * @param {Array<Event>} events\\n * @returns {boolean}\\n */\\n\\n\\nfunction previousUnbalanced(events) {\\n  let index = events.length;\\n  let result = false;\\n\\n  while (index--) {\\n    const token = events[index][1];\\n\\n    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {\\n      result = true;\\n      break;\\n    } // @ts-expect-error If we\\u2019ve seen this token, and it was marked as not\\n    // having any unbalanced bracket before it, we can exit.\\n\\n\\n    if (token._gfmAutolinkLiteralWalkedInto) {\\n      result = false;\\n      break;\\n    }\\n  }\\n\\n  if (events.length > 0 && !result) {\\n    // @ts-expect-error Mark the last token as \\u201cwalked into\\u201d w/o finding\\n    // anything.\\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\\n  }\\n\\n  return result;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"trailingPunctuation\",\"code\",\"pathEnd\",\"_micromarkUtilCharacter\",\"markdownLineEndingOrSpace\",\"gfmAtext\",\"asciiAlphanumeric\",\"previousWww\",\"previousHttp\",\"asciiAlpha\",\"previousEmail\",\"previousUnbalanced\",\"events\",\"index\",\"length\",\"result\",\"token\",\"type\",\"_balanced\",\"_gfmAutolinkLiteralWalkedInto\",\"Object\",\"defineProperty\",\"value\",\"gfmAutolinkLiteral\",\"www\",\"tokenize\",\"tokenizeWww\",\"effects\",\"ok\",\"nok\",\"w2\",\"consume\",\"w3\",\"dot\",\"after\",\"markdownLineEnding\",\"start\",\"partial\",\"domain\",\"tokenizeDomain\",\"check\",\"namedCharacterReference\",\"done\",\"punctuationContinuation\",\"punctuation\",\"asciiControl\",\"unicodeWhitespace\",\"unicodePunctuation\",\"hasUnderscoreInLastLastSegment\",\"hasUnderscoreInLastSegment\",\"undefined\",\"path\",\"tokenizePath\",\"inPath\",\"continuedPunctuation\",\"balance\",\"parenAtPathEnd\",\"tokenizePunctuation\",\"tokenizeNamedCharacterReference\",\"inside\",\"wwwAutolink\",\"tokenizeWwwAutolink\",\"exit\",\"self\",\"previous\",\"enter\",\"attempt\",\"httpAutolink\",\"tokenizeHttpAutolink\",\"t1\",\"t2\",\"p\",\"s\",\"colon\",\"slash1\",\"slash2\",\"emailAutolink\",\"tokenizeEmailAutolink\",\"atext\",\"label\",\"dotContinuation\",\"dashOrUnderscoreContinuation\",\"hasDigitInLastSegment\",\"asciiDigit\",\"hasDot\",\"afterDashOrUnderscore\",\"text\"]\n}\n"]