["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mdast-util-from-markdown/lib/index.js"],"~:js","shadow$provide.module$node_modules$mdast_util_from_markdown$lib$index=function(global,require,module,exports){function compiler(options){function setData(key,value){data$jscomp$0[key]=value}function getData(key){return data$jscomp$0[key]}function opener(create,and){return function(token){enter.call(this,create(token),token);and&&and.call(this,token)}}function buffer(){this.stack.push({type:\"fragment\",children:[]})}function enter(node,token,errorHandler){this.stack[this.stack.length-1].children.push(node);\nthis.stack.push(node);this.tokenStack.push([token,errorHandler]);node.position={start:point(token.start)};return node}function closer(and){return function(token){and&&and.call(this,token);exit.call(this,token)}}function exit(token,onExitError){const node=this.stack.pop(),open=this.tokenStack.pop();if(open)open[0].type!==token.type&&(onExitError?onExitError.call(this,token,open[0]):(open[1]||defaultOnError).call(this,token,open[0]));else throw Error(\"Cannot close `\"+token.type+\"` (\"+(0,_unistUtilStringifyPosition.stringifyPosition)({start:token.start,\nend:token.end})+\"): itâ€™s not open\");node.position.end=point(token.end);return node}function resume(){return(0,_mdastUtilToString.toString)(this.stack.pop())}function onenterdata(token){const node=this.stack[this.stack.length-1];let tail=node.children[node.children.length-1];tail&&\"text\"===tail.type||(tail={type:\"text\",value:\"\"},tail.position={start:point(token.start)},node.children.push(tail));this.stack.push(tail)}function onexitdata(token){const tail=this.stack.pop();tail.value+=this.sliceSerialize(token);\ntail.position.end=point(token.end)}function onexithardbreak(){data$jscomp$0.atHardBreak=!0}function onexitcharacterreferencemarker(token){data$jscomp$0.characterReferenceType=token.type}function codeFlow(){return{type:\"code\",lang:null,meta:null,value:\"\"}}function heading(){return{type:\"heading\",depth:void 0,children:[]}}function hardBreak(){return{type:\"break\"}}function html(){return{type:\"html\",value:\"\"}}function link(){return{type:\"link\",title:null,url:\"\",children:[]}}function list(token){return{type:\"list\",\nordered:\"listOrdered\"===token.type,start:null,spread:token._spread,children:[]}}const config={transforms:[],canContainEols:[\"emphasis\",\"fragment\",\"heading\",\"paragraph\",\"strong\"],enter:{autolink:opener(link),autolinkProtocol:onenterdata,autolinkEmail:onenterdata,atxHeading:opener(heading),blockQuote:opener(function(){return{type:\"blockquote\",children:[]}}),characterEscape:onenterdata,characterReference:onenterdata,codeFenced:opener(codeFlow),codeFencedFenceInfo:buffer,codeFencedFenceMeta:buffer,codeIndented:opener(codeFlow,\nbuffer),codeText:opener(function(){return{type:\"inlineCode\",value:\"\"}},buffer),codeTextData:onenterdata,data:onenterdata,codeFlowValue:onenterdata,definition:opener(function(){return{type:\"definition\",identifier:\"\",label:null,title:null,url:\"\"}}),definitionDestinationString:buffer,definitionLabelString:buffer,definitionTitleString:buffer,emphasis:opener(function(){return{type:\"emphasis\",children:[]}}),hardBreakEscape:opener(hardBreak),hardBreakTrailing:opener(hardBreak),htmlFlow:opener(html,buffer),\nhtmlFlowData:onenterdata,htmlText:opener(html,buffer),htmlTextData:onenterdata,image:opener(function(){return{type:\"image\",title:null,url:\"\",alt:null}}),label:buffer,link:opener(link),listItem:opener(function(token){return{type:\"listItem\",spread:token._spread,checked:null,children:[]}}),listItemValue:function(token){data$jscomp$0.expectingFirstListItemValue&&(this.stack[this.stack.length-2].start=Number.parseInt(this.sliceSerialize(token),10),data$jscomp$0.expectingFirstListItemValue=void 0)},listOrdered:opener(list,\nfunction(){data$jscomp$0.expectingFirstListItemValue=!0}),listUnordered:opener(list),paragraph:opener(function(){return{type:\"paragraph\",children:[]}}),reference:function(){data$jscomp$0.referenceType=\"collapsed\"},referenceString:buffer,resourceDestinationString:buffer,resourceTitleString:buffer,setextHeading:opener(heading),strong:opener(function(){return{type:\"strong\",children:[]}}),thematicBreak:opener(function(){return{type:\"thematicBreak\"}})},exit:{atxHeading:closer(),atxHeadingSequence:function(token){const node=\nthis.stack[this.stack.length-1];node.depth||(token=this.sliceSerialize(token).length,node.depth=token)},autolink:closer(),autolinkEmail:function(token){onexitdata.call(this,token);this.stack[this.stack.length-1].url=\"mailto:\"+this.sliceSerialize(token)},autolinkProtocol:function(token){onexitdata.call(this,token);this.stack[this.stack.length-1].url=this.sliceSerialize(token)},blockQuote:closer(),characterEscapeValue:onexitdata,characterReferenceMarkerHexadecimal:onexitcharacterreferencemarker,characterReferenceMarkerNumeric:onexitcharacterreferencemarker,\ncharacterReferenceValue:function(token){var data=this.sliceSerialize(token),type=data$jscomp$0.characterReferenceType;type?(data=(0,_micromarkUtilDecodeNumericCharacterReference.decodeNumericCharacterReference)(data,\"characterReferenceMarkerNumeric\"===type?10:16),data$jscomp$0.characterReferenceType=void 0):data=(0,_decodeNamedCharacterReference.decodeNamedCharacterReference)(data);type=this.stack.pop();type.value+=data;type.position.end=point(token.end)},codeFenced:closer(function(){const data=this.resume();\nthis.stack[this.stack.length-1].value=data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g,\"\");data$jscomp$0.flowCodeInside=void 0}),codeFencedFence:function(){data$jscomp$0.flowCodeInside||(this.buffer(),data$jscomp$0.flowCodeInside=!0)},codeFencedFenceInfo:function(){const data=this.resume();this.stack[this.stack.length-1].lang=data},codeFencedFenceMeta:function(){const data=this.resume();this.stack[this.stack.length-1].meta=data},codeFlowValue:onexitdata,codeIndented:closer(function(){const data=this.resume();\nthis.stack[this.stack.length-1].value=data.replace(/(\\r?\\n|\\r)$/g,\"\")}),codeText:closer(function(){const data=this.resume();this.stack[this.stack.length-1].value=data}),codeTextData:onexitdata,data:onexitdata,definition:closer(),definitionDestinationString:function(){const data=this.resume();this.stack[this.stack.length-1].url=data},definitionLabelString:function(token){const label=this.resume(),node=this.stack[this.stack.length-1];node.label=label;node.identifier=(0,_micromarkUtilNormalizeIdentifier.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase()},\ndefinitionTitleString:function(){const data=this.resume();this.stack[this.stack.length-1].title=data},emphasis:closer(),hardBreakEscape:closer(onexithardbreak),hardBreakTrailing:closer(onexithardbreak),htmlFlow:closer(function(){const data=this.resume();this.stack[this.stack.length-1].value=data}),htmlFlowData:onexitdata,htmlText:closer(function(){const data=this.resume();this.stack[this.stack.length-1].value=data}),htmlTextData:onexitdata,image:closer(function(){const node=this.stack[this.stack.length-\n1];if(data$jscomp$0.inReference){const referenceType=data$jscomp$0.referenceType||\"shortcut\";node.type+=\"Reference\";node.referenceType=referenceType;delete node.url;delete node.title}else delete node.identifier,delete node.label;data$jscomp$0.referenceType=void 0}),label:function(){const fragment=this.stack[this.stack.length-1],value=this.resume(),node=this.stack[this.stack.length-1];data$jscomp$0.inReference=!0;\"link\"===node.type?node.children=fragment.children:node.alt=value},labelText:function(token){token=\nthis.sliceSerialize(token);const ancestor=this.stack[this.stack.length-2];ancestor.label=(0,_micromarkUtilDecodeString.decodeString)(token);ancestor.identifier=(0,_micromarkUtilNormalizeIdentifier.normalizeIdentifier)(token).toLowerCase()},lineEnding:function(token){const context=this.stack[this.stack.length-1];data$jscomp$0.atHardBreak?(context.children[context.children.length-1].position.end=point(token.end),data$jscomp$0.atHardBreak=void 0):!data$jscomp$0.setextHeadingSlurpLineEnding&&config.canContainEols.includes(context.type)&&\n(onenterdata.call(this,token),onexitdata.call(this,token))},link:closer(function(){const node=this.stack[this.stack.length-1];if(data$jscomp$0.inReference){const referenceType=data$jscomp$0.referenceType||\"shortcut\";node.type+=\"Reference\";node.referenceType=referenceType;delete node.url;delete node.title}else delete node.identifier,delete node.label;data$jscomp$0.referenceType=void 0}),listItem:closer(),listOrdered:closer(),listUnordered:closer(),paragraph:closer(),referenceString:function(token){const label=\nthis.resume(),node=this.stack[this.stack.length-1];node.label=label;node.identifier=(0,_micromarkUtilNormalizeIdentifier.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();data$jscomp$0.referenceType=\"full\"},resourceDestinationString:function(){const data=this.resume();this.stack[this.stack.length-1].url=data},resourceTitleString:function(){const data=this.resume();this.stack[this.stack.length-1].title=data},resource:function(){data$jscomp$0.inReference=void 0},setextHeading:closer(function(){data$jscomp$0.setextHeadingSlurpLineEnding=\nvoid 0}),setextHeadingLineSequence:function(token){this.stack[this.stack.length-1].depth=61===this.sliceSerialize(token).charCodeAt(0)?1:2},setextHeadingText:function(){data$jscomp$0.setextHeadingSlurpLineEnding=!0},strong:closer(),thematicBreak:closer()}};configure(config,(options||{}).mdastExtensions||[]);const data$jscomp$0={};return function(events$jscomp$0){let tree={type:\"root\",children:[]};const context={stack:[tree],tokenStack:[],config,enter,exit,buffer,resume,setData,getData};for(var listStack=\n[],index$jscomp$0=-1;++index$jscomp$0<events$jscomp$0.length;)if(\"listOrdered\"===events$jscomp$0[index$jscomp$0][1].type||\"listUnordered\"===events$jscomp$0[index$jscomp$0][1].type)if(\"enter\"===events$jscomp$0[index$jscomp$0][0])listStack.push(index$jscomp$0);else{var tail=listStack.pop();let atMarker=void 0,firstBlankLineIndex=void 0,lineIndex,listItem=void 0;var events=events$jscomp$0;let index=tail-1,containerBalance=-1,listSpread=!1;for(;++index<=index$jscomp$0;){const event=events[index];\"listUnordered\"===\nevent[1].type||\"listOrdered\"===event[1].type||\"blockQuote\"===event[1].type?(\"enter\"===event[0]?containerBalance++:containerBalance--,atMarker=void 0):\"lineEndingBlank\"===event[1].type?\"enter\"===event[0]&&(!listItem||atMarker||containerBalance||firstBlankLineIndex||(firstBlankLineIndex=index),atMarker=void 0):\"linePrefix\"!==event[1].type&&\"listItemValue\"!==event[1].type&&\"listItemMarker\"!==event[1].type&&\"listItemPrefix\"!==event[1].type&&\"listItemPrefixWhitespace\"!==event[1].type&&(atMarker=void 0);\nif(!containerBalance&&\"enter\"===event[0]&&\"listItemPrefix\"===event[1].type||-1===containerBalance&&\"exit\"===event[0]&&(\"listUnordered\"===event[1].type||\"listOrdered\"===event[1].type)){if(listItem){let tailIndex=index;for(lineIndex=void 0;tailIndex--;){const tailEvent=events[tailIndex];if(\"lineEnding\"===tailEvent[1].type||\"lineEndingBlank\"===tailEvent[1].type)\"exit\"!==tailEvent[0]&&(lineIndex&&(events[lineIndex][1].type=\"lineEndingBlank\",listSpread=!0),tailEvent[1].type=\"lineEnding\",lineIndex=tailIndex);\nelse if(\"linePrefix\"!==tailEvent[1].type&&\"blockQuotePrefix\"!==tailEvent[1].type&&\"blockQuotePrefixWhitespace\"!==tailEvent[1].type&&\"blockQuoteMarker\"!==tailEvent[1].type&&\"listItemIndent\"!==tailEvent[1].type)break}firstBlankLineIndex&&(!lineIndex||firstBlankLineIndex<lineIndex)&&(listItem._spread=!0);listItem.end=Object.assign({},lineIndex?events[lineIndex][1].start:event[1].end);events.splice(lineIndex||index,0,[\"exit\",listItem,event[2]]);index++;index$jscomp$0++}\"listItemPrefix\"===event[1].type&&\n(listItem={type:\"listItem\",_spread:!1,start:Object.assign({},event[1].start)},events.splice(index,0,[\"enter\",listItem,event[2]]),index++,index$jscomp$0++,firstBlankLineIndex=void 0,atMarker=!0)}}events[tail][1]._spread=listSpread}for(index$jscomp$0=-1;++index$jscomp$0<events$jscomp$0.length;)listStack=config[events$jscomp$0[index$jscomp$0][0]],own.call(listStack,events$jscomp$0[index$jscomp$0][1].type)&&listStack[events$jscomp$0[index$jscomp$0][1].type].call(Object.assign({sliceSerialize:events$jscomp$0[index$jscomp$0][2].sliceSerialize},\ncontext),events$jscomp$0[index$jscomp$0][1]);0<context.tokenStack.length&&(listStack=context.tokenStack[context.tokenStack.length-1],(listStack[1]||defaultOnError).call(context,void 0,listStack[0]));tree.position={start:point(0<events$jscomp$0.length?events$jscomp$0[0][1].start:{line:1,column:1,offset:0}),end:point(0<events$jscomp$0.length?events$jscomp$0[events$jscomp$0.length-2][1].end:{line:1,column:1,offset:0})};for(index$jscomp$0=-1;++index$jscomp$0<config.transforms.length;)tree=config.transforms[index$jscomp$0](tree)||\ntree;return tree}}function point(d){return{line:d.line,column:d.column,offset:d.offset}}function configure(combined,extensions){let index=-1;for(;++index<extensions.length;){var value=extensions[index];if(Array.isArray(value))configure(combined,value);else{let key=void 0;var combined$jscomp$0=combined;for(key in value)if(own.call(value,key))if(\"canContainEols\"===key){var right=value[key];right&&combined$jscomp$0[key].push(...right)}else\"transforms\"===key?(right=value[key])&&combined$jscomp$0[key].push(...right):\n(\"enter\"===key||\"exit\"===key)&&(right=value[key])&&Object.assign(combined$jscomp$0[key],right)}}}function defaultOnError(left,right){if(left)throw Error(\"Cannot close `\"+left.type+\"` (\"+(0,_unistUtilStringifyPosition.stringifyPosition)({start:left.start,end:left.end})+\"): a different token (`\"+right.type+\"`, \"+(0,_unistUtilStringifyPosition.stringifyPosition)({start:right.start,end:right.end})+\") is open\");throw Error(\"Cannot close document, a token (`\"+right.type+\"`, \"+(0,_unistUtilStringifyPosition.stringifyPosition)({start:right.start,\nend:right.end})+\") is still open\");}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.fromMarkdown=void 0;var _mdastUtilToString=require(\"module$node_modules$mdast_util_to_string$index\"),_parse=require(\"module$node_modules$micromark$lib$parse\"),_preprocess=require(\"module$node_modules$micromark$lib$preprocess\"),_postprocess=require(\"module$node_modules$micromark$lib$postprocess\"),_micromarkUtilDecodeNumericCharacterReference=require(\"module$node_modules$micromark_util_decode_numeric_character_reference$index\"),\n_micromarkUtilDecodeString=require(\"module$node_modules$micromark_util_decode_string$index\"),_micromarkUtilNormalizeIdentifier=require(\"module$node_modules$micromark_util_normalize_identifier$index\"),_decodeNamedCharacterReference=require(\"module$node_modules$decode_named_character_reference$index\"),_unistUtilStringifyPosition=require(\"module$node_modules$unist_util_stringify_position$index\");const own={}.hasOwnProperty;exports.fromMarkdown=function(value,encoding,options){\"string\"!==typeof encoding&&\n(options=encoding,encoding=void 0);return compiler(options)((0,_postprocess.postprocess)((0,_parse.parse)(options).document().write((0,_preprocess.preprocess)()(value,encoding,!0))))}}","~:source","shadow$provide[\"module$node_modules$mdast_util_from_markdown$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromMarkdown = void 0;\n\nvar _mdastUtilToString = require(\"mdast-util-to-string\");\n\nvar _parse = require(\"micromark/lib/parse.js\");\n\nvar _preprocess = require(\"micromark/lib/preprocess.js\");\n\nvar _postprocess = require(\"micromark/lib/postprocess.js\");\n\nvar _micromarkUtilDecodeNumericCharacterReference = require(\"micromark-util-decode-numeric-character-reference\");\n\nvar _micromarkUtilDecodeString = require(\"micromark-util-decode-string\");\n\nvar _micromarkUtilNormalizeIdentifier = require(\"micromark-util-normalize-identifier\");\n\nvar _decodeNamedCharacterReference = require(\"decode-named-character-reference\");\n\nvar _unistUtilStringifyPosition = require(\"unist-util-stringify-position\");\n\n/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('../index.js').CompileData} CompileData\n */\n\n/**\n * @typedef {Root | Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n *\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | undefined | null | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isnâ€™t closed properly.\n */\n\n/**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Node | Fragment>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\n *   Get data from the key/value store.\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\n *   Set data into the key/value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */\n// To do: micromark: create a registry of tokens?\n// To do: next major: donâ€™t return given `Node` from `enter`.\n// To do: next major: remove setter/getter.\nconst own = {}.hasOwnProperty;\n/**\n * @param value\n *   Markdown to parse.\n * @param encoding\n *   Character encoding for when `value` is `Buffer`.\n * @param options\n *   Configuration.\n * @returns\n *   mdast tree.\n */\n\nconst fromMarkdown =\n/**\n * @type {(\n *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n *   ((value: Value, options?: Options | null | undefined) => Root)\n * )}\n */\n\n/**\n * @param {Value} value\n * @param {Encoding | Options | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n */\nfunction (value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding;\n    encoding = undefined;\n  }\n\n  return compiler(options)((0, _postprocess.postprocess)( // @ts-expect-error: micromark types need to accept `null`.\n  (0, _parse.parse)(options).document().write((0, _preprocess.preprocess)()(value, encoding, true))));\n};\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\n\n\nexports.fromMarkdown = fromMarkdown;\n\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  };\n  configure(config, (options || {}).mdastExtensions || []);\n  /** @type {CompileData} */\n\n  const data = {};\n  return compile;\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    };\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    };\n    /** @type {Array<number>} */\n\n    const listStack = [];\n    let index = -1;\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (events[index][1].type === 'listOrdered' || events[index][1].type === 'listUnordered') {\n        if (events[index][0] === 'enter') {\n          listStack.push(index);\n        } else {\n          const tail = listStack.pop();\n          index = prepareList(events, tail, index);\n        }\n      }\n    }\n\n    index = -1;\n\n    while (++index < events.length) {\n      const handler = config[events[index][0]];\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(Object.assign({\n          sliceSerialize: events[index][2].sliceSerialize\n        }, context), events[index][1]);\n      }\n    } // Handle tokens still being open.\n\n\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1];\n      const handler = tail[1] || defaultOnError;\n      handler.call(context, undefined, tail[0]);\n    } // Figure out `root` position.\n\n\n    tree.position = {\n      start: point(events.length > 0 ? events[0][1].start : {\n        line: 1,\n        column: 1,\n        offset: 0\n      }),\n      end: point(events.length > 0 ? events[events.length - 2][1].end : {\n        line: 1,\n        column: 1,\n        offset: 0\n      })\n    }; // Call transforms.\n\n    index = -1;\n\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree;\n    }\n\n    return tree;\n  }\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n\n\n  function prepareList(events, start, length) {\n    let index = start - 1;\n    let containerBalance = -1;\n    let listSpread = false;\n    /** @type {Token | undefined} */\n\n    let listItem;\n    /** @type {number | undefined} */\n\n    let lineIndex;\n    /** @type {number | undefined} */\n\n    let firstBlankLineIndex;\n    /** @type {boolean | undefined} */\n\n    let atMarker;\n\n    while (++index <= length) {\n      const event = events[index];\n\n      if (event[1].type === 'listUnordered' || event[1].type === 'listOrdered' || event[1].type === 'blockQuote') {\n        if (event[0] === 'enter') {\n          containerBalance++;\n        } else {\n          containerBalance--;\n        }\n\n        atMarker = undefined;\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n            firstBlankLineIndex = index;\n          }\n\n          atMarker = undefined;\n        }\n      } else if (event[1].type === 'linePrefix' || event[1].type === 'listItemValue' || event[1].type === 'listItemMarker' || event[1].type === 'listItemPrefix' || event[1].type === 'listItemPrefixWhitespace') {// Empty.\n      } else {\n        atMarker = undefined;\n      }\n\n      if (!containerBalance && event[0] === 'enter' && event[1].type === 'listItemPrefix' || containerBalance === -1 && event[0] === 'exit' && (event[1].type === 'listUnordered' || event[1].type === 'listOrdered')) {\n        if (listItem) {\n          let tailIndex = index;\n          lineIndex = undefined;\n\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex];\n\n            if (tailEvent[1].type === 'lineEnding' || tailEvent[1].type === 'lineEndingBlank') {\n              if (tailEvent[0] === 'exit') continue;\n\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank';\n                listSpread = true;\n              }\n\n              tailEvent[1].type = 'lineEnding';\n              lineIndex = tailIndex;\n            } else if (tailEvent[1].type === 'linePrefix' || tailEvent[1].type === 'blockQuotePrefix' || tailEvent[1].type === 'blockQuotePrefixWhitespace' || tailEvent[1].type === 'blockQuoteMarker' || tailEvent[1].type === 'listItemIndent') {// Empty\n            } else {\n              break;\n            }\n          }\n\n          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n            // @ts-expect-error Patched.\n            listItem._spread = true;\n          } // Fix position.\n\n\n          listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);\n          index++;\n          length++;\n        } // Create a new list item.\n\n\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            // @ts-expect-error Patched\n            _spread: false,\n            start: Object.assign({}, event[1].start)\n          }; // @ts-expect-error: `listItem` is most definitely defined, TS...\n\n          events.splice(index, 0, ['enter', listItem, event[2]]);\n          index++;\n          length++;\n          firstBlankLineIndex = undefined;\n          atMarker = true;\n        }\n      }\n    } // @ts-expect-error Patched.\n\n\n    events[start][1]._spread = listSpread;\n    return length;\n  }\n  /**\n   * Set data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @param {CompileData[Key]} [value]\n   *   New value.\n   * @returns {void}\n   *   Nothing.\n   */\n\n\n  function setData(key, value) {\n    data[key] = value;\n  }\n  /**\n   * Get data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @returns {CompileData[Key]}\n   *   Value.\n   */\n\n\n  function getData(key) {\n    return data[key];\n  }\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Node} create\n   *   Create a node.\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n\n\n  function opener(create, and) {\n    return open;\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function open(token) {\n      enter.call(this, create(token), token);\n      if (and) and.call(this, token);\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @returns {void}\n   */\n\n\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    });\n  }\n  /**\n   * @template {Node} Kind\n   *   Node type.\n   * @this {CompileContext}\n   *   Context.\n   * @param {Kind} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {Kind}\n   *   The given node.\n   */\n\n\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]; // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n\n    parent.children.push(node);\n    this.stack.push(node);\n    this.tokenStack.push([token, errorHandler]); // @ts-expect-error: `end` will be patched later.\n\n    node.position = {\n      start: point(token.start)\n    };\n    return node;\n  }\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n\n\n  function closer(and) {\n    return close;\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function close(token) {\n      if (and) and.call(this, token);\n      exit.call(this, token);\n    }\n  }\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {Node}\n   *   The closed node.\n   */\n\n\n  function exit(token, onExitError) {\n    const node = this.stack.pop();\n    const open = this.tokenStack.pop();\n\n    if (!open) {\n      throw new Error('Cannot close `' + token.type + '` (' + (0, _unistUtilStringifyPosition.stringifyPosition)({\n        start: token.start,\n        end: token.end\n      }) + '): itâ€™s not open');\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0]);\n      } else {\n        const handler = open[1] || defaultOnError;\n        handler.call(this, token, open[0]);\n      }\n    }\n\n    node.position.end = point(token.end);\n    return node;\n  }\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n\n\n  function resume() {\n    return (0, _mdastUtilToString.toString)(this.stack.pop());\n  } //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor = this.stack[this.stack.length - 2];\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);\n      setData('expectingFirstListItemValue');\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.lang = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefencedfencemeta() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return;\n    this.buffer();\n    setData('flowCodeInside', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodefenced() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    setData('flowCodeInside');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodeindented() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinitiontitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1];\n\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length;\n      node.depth = depth;\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1];\n    let tail = node.children[node.children.length - 1];\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text(); // @ts-expect-error: weâ€™ll add `end` later.\n\n      tail.position = {\n        start: point(token.start)\n      }; // @ts-expect-error: Assume `parent` accepts `text`.\n\n      node.children.push(tail);\n    }\n\n    this.stack.push(tail);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitdata(token) {\n    const tail = this.stack.pop();\n    tail.value += this.sliceSerialize(token);\n    tail.position.end = point(token.end);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]; // If weâ€™re at a hard break, include the line ending in there.\n\n    if (getData('atHardBreak')) {\n      const tail = context.children[context.children.length - 1];\n      tail.position.end = point(token.end);\n      setData('atHardBreak');\n      return;\n    }\n\n    if (!getData('setextHeadingSlurpLineEnding') && config.canContainEols.includes(context.type)) {\n      onenterdata.call(this, token);\n      onexitdata.call(this, token);\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexithardbreak() {\n    setData('atHardBreak', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexithtmlflow() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexithtmltext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcodetext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1]; // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut';\n      node.type += 'Reference'; // @ts-expect-error: mutate.\n\n      node.referenceType = referenceType; // @ts-expect-error: mutate.\n\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier; // @ts-expect-error: mutate.\n\n      delete node.label;\n    }\n\n    setData('referenceType');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1]; // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut';\n      node.type += 'Reference'; // @ts-expect-error: mutate.\n\n      node.referenceType = referenceType; // @ts-expect-error: mutate.\n\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier; // @ts-expect-error: mutate.\n\n      delete node.label;\n    }\n\n    setData('referenceType');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token);\n    const ancestor = this.stack[this.stack.length - 2]; // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n\n    ancestor.label = (0, _micromarkUtilDecodeString.decodeString)(string); // @ts-expect-error: same as above.\n\n    ancestor.identifier = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(string).toLowerCase();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1];\n    const value = this.resume();\n    const node = this.stack[this.stack.length - 1]; // Assume a reference.\n\n    setData('inReference', true);\n\n    if (node.type === 'link') {\n      /** @type {Array<StaticPhrasingContent>} */\n      // @ts-expect-error: Assume static phrasing content.\n      const children = fragment.children;\n      node.children = children;\n    } else {\n      node.alt = value;\n    }\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitresourcetitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitresource() {\n    setData('inReference');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitreferencestring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1]; // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n\n    node.label = label; // @ts-expect-error: same as above.\n\n    node.identifier = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n    setData('referenceType', 'full');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token);\n    const type = getData('characterReferenceType');\n    /** @type {string} */\n\n    let value;\n\n    if (type) {\n      value = (0, _micromarkUtilDecodeNumericCharacterReference.decodeNumericCharacterReference)(data, type === 'characterReferenceMarkerNumeric' ? 10 : 16);\n      setData('characterReferenceType');\n    } else {\n      const result = (0, _decodeNamedCharacterReference.decodeNamedCharacterReference)(data);\n      value = result;\n    }\n\n    const tail = this.stack.pop();\n    tail.value += value;\n    tail.position.end = point(token.end);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    node.url = this.sliceSerialize(token);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    node.url = 'mailto:' + this.sliceSerialize(token);\n  } //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n\n\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    };\n  }\n  /** @returns {Code} */\n\n\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    };\n  }\n  /** @returns {InlineCode} */\n\n\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    };\n  }\n  /** @returns {Definition} */\n\n\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    };\n  }\n  /** @returns {Emphasis} */\n\n\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    };\n  }\n  /** @returns {Heading} */\n\n\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    };\n  }\n  /** @returns {Break} */\n\n\n  function hardBreak() {\n    return {\n      type: 'break'\n    };\n  }\n  /** @returns {HTML} */\n\n\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    };\n  }\n  /** @returns {Image} */\n\n\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    };\n  }\n  /** @returns {Link} */\n\n\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    };\n  }\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n\n\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      children: []\n    };\n  }\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n\n\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      checked: null,\n      children: []\n    };\n  }\n  /** @returns {Paragraph} */\n\n\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    };\n  }\n  /** @returns {Strong} */\n\n\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    };\n  }\n  /** @returns {Text} */\n\n\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    };\n  }\n  /** @returns {ThematicBreak} */\n\n\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    };\n  }\n}\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\n\n\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  };\n}\n/**\n * @param {Config} combined\n * @param {Array<Extension | Array<Extension>>} extensions\n * @returns {void}\n */\n\n\nfunction configure(combined, extensions) {\n  let index = -1;\n\n  while (++index < extensions.length) {\n    const value = extensions[index];\n\n    if (Array.isArray(value)) {\n      configure(combined, value);\n    } else {\n      extension(combined, value);\n    }\n  }\n}\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {void}\n */\n\n\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key;\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      if (key === 'canContainEols') {\n        const right = extension[key];\n\n        if (right) {\n          combined[key].push(...right);\n        }\n      } else if (key === 'transforms') {\n        const right = extension[key];\n\n        if (right) {\n          combined[key].push(...right);\n        }\n      } else if (key === 'enter' || key === 'exit') {\n        const right = extension[key];\n\n        if (right) {\n          Object.assign(combined[key], right);\n        }\n      }\n    }\n  }\n}\n/** @type {OnEnterError} */\n\n\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error('Cannot close `' + left.type + '` (' + (0, _unistUtilStringifyPosition.stringifyPosition)({\n      start: left.start,\n      end: left.end\n    }) + '): a different token (`' + right.type + '`, ' + (0, _unistUtilStringifyPosition.stringifyPosition)({\n      start: right.start,\n      end: right.end\n    }) + ') is open');\n  } else {\n    throw new Error('Cannot close document, a token (`' + right.type + '`, ' + (0, _unistUtilStringifyPosition.stringifyPosition)({\n      start: right.start,\n      end: right.end\n    }) + ') is still open');\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_normalize_identifier$index","~$module$node_modules$micromark_util_decode_numeric_character_reference$index","~$shadow.js","~$module$node_modules$micromark$lib$postprocess","~$module$node_modules$decode_named_character_reference$index","~$module$node_modules$mdast_util_to_string$index","~$module$node_modules$micromark$lib$preprocess","~$module$node_modules$micromark$lib$parse","~$module$node_modules$micromark_util_decode_string$index","~$module$node_modules$unist_util_stringify_position$index"]],"~:properties",["^5",["atxHeadingSequence","canContainEols","resource","definitionLabelString","setData","lang","characterReferenceValue","hardBreakEscape","setextHeadingText","url","ordered","getData","atxHeading","labelText","config","offset","fromMarkdown","htmlFlow","image","label","codeFlowValue","blockQuote","htmlFlowData","children","__esModule","codeFencedFenceMeta","htmlText","characterEscape","resourceTitleString","autolinkEmail","codeFencedFence","characterReference","buffer","resourceDestinationString","position","codeTextData","characterReferenceMarkerHexadecimal","value","referenceType","start","alt","autolinkProtocol","codeText","sliceSerialize","identifier","setextHeadingLineSequence","lineEnding","paragraph","definition","line","characterReferenceMarkerNumeric","definitionTitleString","listItem","referenceString","column","definitionDestinationString","reference","title","link","type","characterEscapeValue","depth","codeFencedFenceInfo","meta","listOrdered","codeFenced","transforms","_spread","emphasis","exit","listItemValue","strong","setextHeading","hardBreakTrailing","thematicBreak","codeIndented","htmlTextData","data","enter","listUnordered","checked","spread","end","stack","autolink","tokenStack","resume"]],"~:compiled-at",1676665867308,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mdast_util_from_markdown$lib$index.js\",\n\"lineCount\":29,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mdast-util-from-markdown/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mdast_util_from_markdown$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.fromMarkdown = void 0;\\n\\nvar _mdastUtilToString = require(\\\"mdast-util-to-string\\\");\\n\\nvar _parse = require(\\\"micromark/lib/parse.js\\\");\\n\\nvar _preprocess = require(\\\"micromark/lib/preprocess.js\\\");\\n\\nvar _postprocess = require(\\\"micromark/lib/postprocess.js\\\");\\n\\nvar _micromarkUtilDecodeNumericCharacterReference = require(\\\"micromark-util-decode-numeric-character-reference\\\");\\n\\nvar _micromarkUtilDecodeString = require(\\\"micromark-util-decode-string\\\");\\n\\nvar _micromarkUtilNormalizeIdentifier = require(\\\"micromark-util-normalize-identifier\\\");\\n\\nvar _decodeNamedCharacterReference = require(\\\"decode-named-character-reference\\\");\\n\\nvar _unistUtilStringifyPosition = require(\\\"unist-util-stringify-position\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Encoding} Encoding\\n * @typedef {import('micromark-util-types').Event} Event\\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\\n * @typedef {import('micromark-util-types').Token} Token\\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\\n * @typedef {import('micromark-util-types').Value} Value\\n *\\n * @typedef {import('unist').Parent} UnistParent\\n * @typedef {import('unist').Point} Point\\n *\\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\\n * @typedef {import('mdast').Content} Content\\n * @typedef {import('mdast').Break} Break\\n * @typedef {import('mdast').Blockquote} Blockquote\\n * @typedef {import('mdast').Code} Code\\n * @typedef {import('mdast').Definition} Definition\\n * @typedef {import('mdast').Emphasis} Emphasis\\n * @typedef {import('mdast').Heading} Heading\\n * @typedef {import('mdast').HTML} HTML\\n * @typedef {import('mdast').Image} Image\\n * @typedef {import('mdast').ImageReference} ImageReference\\n * @typedef {import('mdast').InlineCode} InlineCode\\n * @typedef {import('mdast').Link} Link\\n * @typedef {import('mdast').LinkReference} LinkReference\\n * @typedef {import('mdast').List} List\\n * @typedef {import('mdast').ListItem} ListItem\\n * @typedef {import('mdast').Paragraph} Paragraph\\n * @typedef {import('mdast').Root} Root\\n * @typedef {import('mdast').Strong} Strong\\n * @typedef {import('mdast').Text} Text\\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\\n * @typedef {import('mdast').ReferenceType} ReferenceType\\n * @typedef {import('../index.js').CompileData} CompileData\\n */\\n\\n/**\\n * @typedef {Root | Content} Node\\n * @typedef {Extract<Node, UnistParent>} Parent\\n *\\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\\n */\\n\\n/**\\n * @callback Transform\\n *   Extra transform, to change the AST afterwards.\\n * @param {Root} tree\\n *   Tree to transform.\\n * @returns {Root | undefined | null | void}\\n *   New tree or nothing (in which case the current tree is used).\\n *\\n * @callback Handle\\n *   Handle a token.\\n * @param {CompileContext} this\\n *   Context.\\n * @param {Token} token\\n *   Current token.\\n * @returns {void}\\n *   Nothing.\\n *\\n * @typedef {Record<string, Handle>} Handles\\n *   Token types mapping to handles\\n *\\n * @callback OnEnterError\\n *   Handle the case where the `right` token is open, but it is closed (by the\\n *   `left` token) or because we reached the end of the document.\\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\\n *   Context.\\n * @param {Token | undefined} left\\n *   Left token.\\n * @param {Token} right\\n *   Right token.\\n * @returns {void}\\n *   Nothing.\\n *\\n * @callback OnExitError\\n *   Handle the case where the `right` token is open but it is closed by\\n *   exiting the `left` token.\\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\\n *   Context.\\n * @param {Token} left\\n *   Left token.\\n * @param {Token} right\\n *   Right token.\\n * @returns {void}\\n *   Nothing.\\n *\\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\\n *   Open token on the stack, with an optional error handler for when\\n *   that token isn\\u2019t closed properly.\\n */\\n\\n/**\\n * @typedef Config\\n *   Configuration.\\n *\\n *   We have our defaults, but extensions will add more.\\n * @property {Array<string>} canContainEols\\n *   Token types where line endings are used.\\n * @property {Handles} enter\\n *   Opening handles.\\n * @property {Handles} exit\\n *   Closing handles.\\n * @property {Array<Transform>} transforms\\n *   Tree transforms.\\n *\\n * @typedef {Partial<Config>} Extension\\n *   Change how markdown tokens from micromark are turned into mdast.\\n *\\n * @typedef CompileContext\\n *   mdast compiler context.\\n * @property {Array<Node | Fragment>} stack\\n *   Stack of nodes.\\n * @property {Array<TokenTuple>} tokenStack\\n *   Stack of tokens.\\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\\n *   Get data from the key/value store.\\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\\n *   Set data into the key/value store.\\n * @property {(this: CompileContext) => void} buffer\\n *   Capture some of the output data.\\n * @property {(this: CompileContext) => string} resume\\n *   Stop capturing and access the output data.\\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\\n *   Enter a token.\\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\\n *   Exit a token.\\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\\n *   Get the string value of a token.\\n * @property {Config} config\\n *   Configuration.\\n *\\n * @typedef FromMarkdownOptions\\n *   Configuration for how to build mdast.\\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\\n *   Extensions for this utility to change how tokens are turned into a tree.\\n *\\n * @typedef {ParseOptions & FromMarkdownOptions} Options\\n *   Configuration.\\n */\\n// To do: micromark: create a registry of tokens?\\n// To do: next major: don\\u2019t return given `Node` from `enter`.\\n// To do: next major: remove setter/getter.\\nconst own = {}.hasOwnProperty;\\n/**\\n * @param value\\n *   Markdown to parse.\\n * @param encoding\\n *   Character encoding for when `value` is `Buffer`.\\n * @param options\\n *   Configuration.\\n * @returns\\n *   mdast tree.\\n */\\n\\nconst fromMarkdown =\\n/**\\n * @type {(\\n *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\\n *   ((value: Value, options?: Options | null | undefined) => Root)\\n * )}\\n */\\n\\n/**\\n * @param {Value} value\\n * @param {Encoding | Options | null | undefined} [encoding]\\n * @param {Options | null | undefined} [options]\\n * @returns {Root}\\n */\\nfunction (value, encoding, options) {\\n  if (typeof encoding !== 'string') {\\n    options = encoding;\\n    encoding = undefined;\\n  }\\n\\n  return compiler(options)((0, _postprocess.postprocess)( // @ts-expect-error: micromark types need to accept `null`.\\n  (0, _parse.parse)(options).document().write((0, _preprocess.preprocess)()(value, encoding, true))));\\n};\\n/**\\n * Note this compiler only understand complete buffering, not streaming.\\n *\\n * @param {Options | null | undefined} [options]\\n */\\n\\n\\nexports.fromMarkdown = fromMarkdown;\\n\\nfunction compiler(options) {\\n  /** @type {Config} */\\n  const config = {\\n    transforms: [],\\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\\n    enter: {\\n      autolink: opener(link),\\n      autolinkProtocol: onenterdata,\\n      autolinkEmail: onenterdata,\\n      atxHeading: opener(heading),\\n      blockQuote: opener(blockQuote),\\n      characterEscape: onenterdata,\\n      characterReference: onenterdata,\\n      codeFenced: opener(codeFlow),\\n      codeFencedFenceInfo: buffer,\\n      codeFencedFenceMeta: buffer,\\n      codeIndented: opener(codeFlow, buffer),\\n      codeText: opener(codeText, buffer),\\n      codeTextData: onenterdata,\\n      data: onenterdata,\\n      codeFlowValue: onenterdata,\\n      definition: opener(definition),\\n      definitionDestinationString: buffer,\\n      definitionLabelString: buffer,\\n      definitionTitleString: buffer,\\n      emphasis: opener(emphasis),\\n      hardBreakEscape: opener(hardBreak),\\n      hardBreakTrailing: opener(hardBreak),\\n      htmlFlow: opener(html, buffer),\\n      htmlFlowData: onenterdata,\\n      htmlText: opener(html, buffer),\\n      htmlTextData: onenterdata,\\n      image: opener(image),\\n      label: buffer,\\n      link: opener(link),\\n      listItem: opener(listItem),\\n      listItemValue: onenterlistitemvalue,\\n      listOrdered: opener(list, onenterlistordered),\\n      listUnordered: opener(list),\\n      paragraph: opener(paragraph),\\n      reference: onenterreference,\\n      referenceString: buffer,\\n      resourceDestinationString: buffer,\\n      resourceTitleString: buffer,\\n      setextHeading: opener(heading),\\n      strong: opener(strong),\\n      thematicBreak: opener(thematicBreak)\\n    },\\n    exit: {\\n      atxHeading: closer(),\\n      atxHeadingSequence: onexitatxheadingsequence,\\n      autolink: closer(),\\n      autolinkEmail: onexitautolinkemail,\\n      autolinkProtocol: onexitautolinkprotocol,\\n      blockQuote: closer(),\\n      characterEscapeValue: onexitdata,\\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\\n      characterReferenceValue: onexitcharacterreferencevalue,\\n      codeFenced: closer(onexitcodefenced),\\n      codeFencedFence: onexitcodefencedfence,\\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\\n      codeFlowValue: onexitdata,\\n      codeIndented: closer(onexitcodeindented),\\n      codeText: closer(onexitcodetext),\\n      codeTextData: onexitdata,\\n      data: onexitdata,\\n      definition: closer(),\\n      definitionDestinationString: onexitdefinitiondestinationstring,\\n      definitionLabelString: onexitdefinitionlabelstring,\\n      definitionTitleString: onexitdefinitiontitlestring,\\n      emphasis: closer(),\\n      hardBreakEscape: closer(onexithardbreak),\\n      hardBreakTrailing: closer(onexithardbreak),\\n      htmlFlow: closer(onexithtmlflow),\\n      htmlFlowData: onexitdata,\\n      htmlText: closer(onexithtmltext),\\n      htmlTextData: onexitdata,\\n      image: closer(onexitimage),\\n      label: onexitlabel,\\n      labelText: onexitlabeltext,\\n      lineEnding: onexitlineending,\\n      link: closer(onexitlink),\\n      listItem: closer(),\\n      listOrdered: closer(),\\n      listUnordered: closer(),\\n      paragraph: closer(),\\n      referenceString: onexitreferencestring,\\n      resourceDestinationString: onexitresourcedestinationstring,\\n      resourceTitleString: onexitresourcetitlestring,\\n      resource: onexitresource,\\n      setextHeading: closer(onexitsetextheading),\\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\\n      setextHeadingText: onexitsetextheadingtext,\\n      strong: closer(),\\n      thematicBreak: closer()\\n    }\\n  };\\n  configure(config, (options || {}).mdastExtensions || []);\\n  /** @type {CompileData} */\\n\\n  const data = {};\\n  return compile;\\n  /**\\n   * Turn micromark events into an mdast tree.\\n   *\\n   * @param {Array<Event>} events\\n   *   Events.\\n   * @returns {Root}\\n   *   mdast tree.\\n   */\\n\\n  function compile(events) {\\n    /** @type {Root} */\\n    let tree = {\\n      type: 'root',\\n      children: []\\n    };\\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\\n\\n    const context = {\\n      stack: [tree],\\n      tokenStack: [],\\n      config,\\n      enter,\\n      exit,\\n      buffer,\\n      resume,\\n      setData,\\n      getData\\n    };\\n    /** @type {Array<number>} */\\n\\n    const listStack = [];\\n    let index = -1;\\n\\n    while (++index < events.length) {\\n      // We preprocess lists to add `listItem` tokens, and to infer whether\\n      // items the list itself are spread out.\\n      if (events[index][1].type === 'listOrdered' || events[index][1].type === 'listUnordered') {\\n        if (events[index][0] === 'enter') {\\n          listStack.push(index);\\n        } else {\\n          const tail = listStack.pop();\\n          index = prepareList(events, tail, index);\\n        }\\n      }\\n    }\\n\\n    index = -1;\\n\\n    while (++index < events.length) {\\n      const handler = config[events[index][0]];\\n\\n      if (own.call(handler, events[index][1].type)) {\\n        handler[events[index][1].type].call(Object.assign({\\n          sliceSerialize: events[index][2].sliceSerialize\\n        }, context), events[index][1]);\\n      }\\n    } // Handle tokens still being open.\\n\\n\\n    if (context.tokenStack.length > 0) {\\n      const tail = context.tokenStack[context.tokenStack.length - 1];\\n      const handler = tail[1] || defaultOnError;\\n      handler.call(context, undefined, tail[0]);\\n    } // Figure out `root` position.\\n\\n\\n    tree.position = {\\n      start: point(events.length > 0 ? events[0][1].start : {\\n        line: 1,\\n        column: 1,\\n        offset: 0\\n      }),\\n      end: point(events.length > 0 ? events[events.length - 2][1].end : {\\n        line: 1,\\n        column: 1,\\n        offset: 0\\n      })\\n    }; // Call transforms.\\n\\n    index = -1;\\n\\n    while (++index < config.transforms.length) {\\n      tree = config.transforms[index](tree) || tree;\\n    }\\n\\n    return tree;\\n  }\\n  /**\\n   * @param {Array<Event>} events\\n   * @param {number} start\\n   * @param {number} length\\n   * @returns {number}\\n   */\\n\\n\\n  function prepareList(events, start, length) {\\n    let index = start - 1;\\n    let containerBalance = -1;\\n    let listSpread = false;\\n    /** @type {Token | undefined} */\\n\\n    let listItem;\\n    /** @type {number | undefined} */\\n\\n    let lineIndex;\\n    /** @type {number | undefined} */\\n\\n    let firstBlankLineIndex;\\n    /** @type {boolean | undefined} */\\n\\n    let atMarker;\\n\\n    while (++index <= length) {\\n      const event = events[index];\\n\\n      if (event[1].type === 'listUnordered' || event[1].type === 'listOrdered' || event[1].type === 'blockQuote') {\\n        if (event[0] === 'enter') {\\n          containerBalance++;\\n        } else {\\n          containerBalance--;\\n        }\\n\\n        atMarker = undefined;\\n      } else if (event[1].type === 'lineEndingBlank') {\\n        if (event[0] === 'enter') {\\n          if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\\n            firstBlankLineIndex = index;\\n          }\\n\\n          atMarker = undefined;\\n        }\\n      } else if (event[1].type === 'linePrefix' || event[1].type === 'listItemValue' || event[1].type === 'listItemMarker' || event[1].type === 'listItemPrefix' || event[1].type === 'listItemPrefixWhitespace') {// Empty.\\n      } else {\\n        atMarker = undefined;\\n      }\\n\\n      if (!containerBalance && event[0] === 'enter' && event[1].type === 'listItemPrefix' || containerBalance === -1 && event[0] === 'exit' && (event[1].type === 'listUnordered' || event[1].type === 'listOrdered')) {\\n        if (listItem) {\\n          let tailIndex = index;\\n          lineIndex = undefined;\\n\\n          while (tailIndex--) {\\n            const tailEvent = events[tailIndex];\\n\\n            if (tailEvent[1].type === 'lineEnding' || tailEvent[1].type === 'lineEndingBlank') {\\n              if (tailEvent[0] === 'exit') continue;\\n\\n              if (lineIndex) {\\n                events[lineIndex][1].type = 'lineEndingBlank';\\n                listSpread = true;\\n              }\\n\\n              tailEvent[1].type = 'lineEnding';\\n              lineIndex = tailIndex;\\n            } else if (tailEvent[1].type === 'linePrefix' || tailEvent[1].type === 'blockQuotePrefix' || tailEvent[1].type === 'blockQuotePrefixWhitespace' || tailEvent[1].type === 'blockQuoteMarker' || tailEvent[1].type === 'listItemIndent') {// Empty\\n            } else {\\n              break;\\n            }\\n          }\\n\\n          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\\n            // @ts-expect-error Patched.\\n            listItem._spread = true;\\n          } // Fix position.\\n\\n\\n          listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);\\n          index++;\\n          length++;\\n        } // Create a new list item.\\n\\n\\n        if (event[1].type === 'listItemPrefix') {\\n          listItem = {\\n            type: 'listItem',\\n            // @ts-expect-error Patched\\n            _spread: false,\\n            start: Object.assign({}, event[1].start)\\n          }; // @ts-expect-error: `listItem` is most definitely defined, TS...\\n\\n          events.splice(index, 0, ['enter', listItem, event[2]]);\\n          index++;\\n          length++;\\n          firstBlankLineIndex = undefined;\\n          atMarker = true;\\n        }\\n      }\\n    } // @ts-expect-error Patched.\\n\\n\\n    events[start][1]._spread = listSpread;\\n    return length;\\n  }\\n  /**\\n   * Set data.\\n   *\\n   * @template {keyof CompileData} Key\\n   *   Field type.\\n   * @param {Key} key\\n   *   Key of field.\\n   * @param {CompileData[Key]} [value]\\n   *   New value.\\n   * @returns {void}\\n   *   Nothing.\\n   */\\n\\n\\n  function setData(key, value) {\\n    data[key] = value;\\n  }\\n  /**\\n   * Get data.\\n   *\\n   * @template {keyof CompileData} Key\\n   *   Field type.\\n   * @param {Key} key\\n   *   Key of field.\\n   * @returns {CompileData[Key]}\\n   *   Value.\\n   */\\n\\n\\n  function getData(key) {\\n    return data[key];\\n  }\\n  /**\\n   * Create an opener handle.\\n   *\\n   * @param {(token: Token) => Node} create\\n   *   Create a node.\\n   * @param {Handle} [and]\\n   *   Optional function to also run.\\n   * @returns {Handle}\\n   *   Handle.\\n   */\\n\\n\\n  function opener(create, and) {\\n    return open;\\n    /**\\n     * @this {CompileContext}\\n     * @param {Token} token\\n     * @returns {void}\\n     */\\n\\n    function open(token) {\\n      enter.call(this, create(token), token);\\n      if (and) and.call(this, token);\\n    }\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @returns {void}\\n   */\\n\\n\\n  function buffer() {\\n    this.stack.push({\\n      type: 'fragment',\\n      children: []\\n    });\\n  }\\n  /**\\n   * @template {Node} Kind\\n   *   Node type.\\n   * @this {CompileContext}\\n   *   Context.\\n   * @param {Kind} node\\n   *   Node to enter.\\n   * @param {Token} token\\n   *   Corresponding token.\\n   * @param {OnEnterError | undefined} [errorHandler]\\n   *   Handle the case where this token is open, but it is closed by something else.\\n   * @returns {Kind}\\n   *   The given node.\\n   */\\n\\n\\n  function enter(node, token, errorHandler) {\\n    const parent = this.stack[this.stack.length - 1]; // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\\n\\n    parent.children.push(node);\\n    this.stack.push(node);\\n    this.tokenStack.push([token, errorHandler]); // @ts-expect-error: `end` will be patched later.\\n\\n    node.position = {\\n      start: point(token.start)\\n    };\\n    return node;\\n  }\\n  /**\\n   * Create a closer handle.\\n   *\\n   * @param {Handle} [and]\\n   *   Optional function to also run.\\n   * @returns {Handle}\\n   *   Handle.\\n   */\\n\\n\\n  function closer(and) {\\n    return close;\\n    /**\\n     * @this {CompileContext}\\n     * @param {Token} token\\n     * @returns {void}\\n     */\\n\\n    function close(token) {\\n      if (and) and.call(this, token);\\n      exit.call(this, token);\\n    }\\n  }\\n  /**\\n   * @this {CompileContext}\\n   *   Context.\\n   * @param {Token} token\\n   *   Corresponding token.\\n   * @param {OnExitError | undefined} [onExitError]\\n   *   Handle the case where another token is open.\\n   * @returns {Node}\\n   *   The closed node.\\n   */\\n\\n\\n  function exit(token, onExitError) {\\n    const node = this.stack.pop();\\n    const open = this.tokenStack.pop();\\n\\n    if (!open) {\\n      throw new Error('Cannot close `' + token.type + '` (' + (0, _unistUtilStringifyPosition.stringifyPosition)({\\n        start: token.start,\\n        end: token.end\\n      }) + '): it\\u2019s not open');\\n    } else if (open[0].type !== token.type) {\\n      if (onExitError) {\\n        onExitError.call(this, token, open[0]);\\n      } else {\\n        const handler = open[1] || defaultOnError;\\n        handler.call(this, token, open[0]);\\n      }\\n    }\\n\\n    node.position.end = point(token.end);\\n    return node;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @returns {string}\\n   */\\n\\n\\n  function resume() {\\n    return (0, _mdastUtilToString.toString)(this.stack.pop());\\n  } //\\n  // Handlers.\\n  //\\n\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onenterlistordered() {\\n    setData('expectingFirstListItemValue', true);\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onenterlistitemvalue(token) {\\n    if (getData('expectingFirstListItemValue')) {\\n      const ancestor = this.stack[this.stack.length - 2];\\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);\\n      setData('expectingFirstListItemValue');\\n    }\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitcodefencedfenceinfo() {\\n    const data = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.lang = data;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitcodefencedfencemeta() {\\n    const data = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.meta = data;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitcodefencedfence() {\\n    // Exit if this is the closing fence.\\n    if (getData('flowCodeInside')) return;\\n    this.buffer();\\n    setData('flowCodeInside', true);\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitcodefenced() {\\n    const data = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.value = data.replace(/^(\\\\r?\\\\n|\\\\r)|(\\\\r?\\\\n|\\\\r)$/g, '');\\n    setData('flowCodeInside');\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitcodeindented() {\\n    const data = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.value = data.replace(/(\\\\r?\\\\n|\\\\r)$/g, '');\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitdefinitionlabelstring(token) {\\n    const label = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.label = label;\\n    node.identifier = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitdefinitiontitlestring() {\\n    const data = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.title = data;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitdefinitiondestinationstring() {\\n    const data = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.url = data;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitatxheadingsequence(token) {\\n    const node = this.stack[this.stack.length - 1];\\n\\n    if (!node.depth) {\\n      const depth = this.sliceSerialize(token).length;\\n      node.depth = depth;\\n    }\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitsetextheadingtext() {\\n    setData('setextHeadingSlurpLineEnding', true);\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitsetextheadinglinesequence(token) {\\n    const node = this.stack[this.stack.length - 1];\\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitsetextheading() {\\n    setData('setextHeadingSlurpLineEnding');\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onenterdata(token) {\\n    const node = this.stack[this.stack.length - 1];\\n    let tail = node.children[node.children.length - 1];\\n\\n    if (!tail || tail.type !== 'text') {\\n      // Add a new text node.\\n      tail = text(); // @ts-expect-error: we\\u2019ll add `end` later.\\n\\n      tail.position = {\\n        start: point(token.start)\\n      }; // @ts-expect-error: Assume `parent` accepts `text`.\\n\\n      node.children.push(tail);\\n    }\\n\\n    this.stack.push(tail);\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitdata(token) {\\n    const tail = this.stack.pop();\\n    tail.value += this.sliceSerialize(token);\\n    tail.position.end = point(token.end);\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitlineending(token) {\\n    const context = this.stack[this.stack.length - 1]; // If we\\u2019re at a hard break, include the line ending in there.\\n\\n    if (getData('atHardBreak')) {\\n      const tail = context.children[context.children.length - 1];\\n      tail.position.end = point(token.end);\\n      setData('atHardBreak');\\n      return;\\n    }\\n\\n    if (!getData('setextHeadingSlurpLineEnding') && config.canContainEols.includes(context.type)) {\\n      onenterdata.call(this, token);\\n      onexitdata.call(this, token);\\n    }\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexithardbreak() {\\n    setData('atHardBreak', true);\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexithtmlflow() {\\n    const data = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.value = data;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexithtmltext() {\\n    const data = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.value = data;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitcodetext() {\\n    const data = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.value = data;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitlink() {\\n    const node = this.stack[this.stack.length - 1]; // Note: there are also `identifier` and `label` fields on this link node!\\n    // These are used / cleaned here.\\n    // To do: clean.\\n\\n    if (getData('inReference')) {\\n      /** @type {ReferenceType} */\\n      const referenceType = getData('referenceType') || 'shortcut';\\n      node.type += 'Reference'; // @ts-expect-error: mutate.\\n\\n      node.referenceType = referenceType; // @ts-expect-error: mutate.\\n\\n      delete node.url;\\n      delete node.title;\\n    } else {\\n      // @ts-expect-error: mutate.\\n      delete node.identifier; // @ts-expect-error: mutate.\\n\\n      delete node.label;\\n    }\\n\\n    setData('referenceType');\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitimage() {\\n    const node = this.stack[this.stack.length - 1]; // Note: there are also `identifier` and `label` fields on this link node!\\n    // These are used / cleaned here.\\n    // To do: clean.\\n\\n    if (getData('inReference')) {\\n      /** @type {ReferenceType} */\\n      const referenceType = getData('referenceType') || 'shortcut';\\n      node.type += 'Reference'; // @ts-expect-error: mutate.\\n\\n      node.referenceType = referenceType; // @ts-expect-error: mutate.\\n\\n      delete node.url;\\n      delete node.title;\\n    } else {\\n      // @ts-expect-error: mutate.\\n      delete node.identifier; // @ts-expect-error: mutate.\\n\\n      delete node.label;\\n    }\\n\\n    setData('referenceType');\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitlabeltext(token) {\\n    const string = this.sliceSerialize(token);\\n    const ancestor = this.stack[this.stack.length - 2]; // @ts-expect-error: stash this on the node, as it might become a reference\\n    // later.\\n\\n    ancestor.label = (0, _micromarkUtilDecodeString.decodeString)(string); // @ts-expect-error: same as above.\\n\\n    ancestor.identifier = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(string).toLowerCase();\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitlabel() {\\n    const fragment = this.stack[this.stack.length - 1];\\n    const value = this.resume();\\n    const node = this.stack[this.stack.length - 1]; // Assume a reference.\\n\\n    setData('inReference', true);\\n\\n    if (node.type === 'link') {\\n      /** @type {Array<StaticPhrasingContent>} */\\n      // @ts-expect-error: Assume static phrasing content.\\n      const children = fragment.children;\\n      node.children = children;\\n    } else {\\n      node.alt = value;\\n    }\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitresourcedestinationstring() {\\n    const data = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.url = data;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitresourcetitlestring() {\\n    const data = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.title = data;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitresource() {\\n    setData('inReference');\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onenterreference() {\\n    setData('referenceType', 'collapsed');\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitreferencestring(token) {\\n    const label = this.resume();\\n    const node = this.stack[this.stack.length - 1]; // @ts-expect-error: stash this on the node, as it might become a reference\\n    // later.\\n\\n    node.label = label; // @ts-expect-error: same as above.\\n\\n    node.identifier = (0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\\n    setData('referenceType', 'full');\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitcharacterreferencemarker(token) {\\n    setData('characterReferenceType', token.type);\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitcharacterreferencevalue(token) {\\n    const data = this.sliceSerialize(token);\\n    const type = getData('characterReferenceType');\\n    /** @type {string} */\\n\\n    let value;\\n\\n    if (type) {\\n      value = (0, _micromarkUtilDecodeNumericCharacterReference.decodeNumericCharacterReference)(data, type === 'characterReferenceMarkerNumeric' ? 10 : 16);\\n      setData('characterReferenceType');\\n    } else {\\n      const result = (0, _decodeNamedCharacterReference.decodeNamedCharacterReference)(data);\\n      value = result;\\n    }\\n\\n    const tail = this.stack.pop();\\n    tail.value += value;\\n    tail.position.end = point(token.end);\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitautolinkprotocol(token) {\\n    onexitdata.call(this, token);\\n    const node = this.stack[this.stack.length - 1];\\n    node.url = this.sliceSerialize(token);\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {Handle}\\n   */\\n\\n\\n  function onexitautolinkemail(token) {\\n    onexitdata.call(this, token);\\n    const node = this.stack[this.stack.length - 1];\\n    node.url = 'mailto:' + this.sliceSerialize(token);\\n  } //\\n  // Creaters.\\n  //\\n\\n  /** @returns {Blockquote} */\\n\\n\\n  function blockQuote() {\\n    return {\\n      type: 'blockquote',\\n      children: []\\n    };\\n  }\\n  /** @returns {Code} */\\n\\n\\n  function codeFlow() {\\n    return {\\n      type: 'code',\\n      lang: null,\\n      meta: null,\\n      value: ''\\n    };\\n  }\\n  /** @returns {InlineCode} */\\n\\n\\n  function codeText() {\\n    return {\\n      type: 'inlineCode',\\n      value: ''\\n    };\\n  }\\n  /** @returns {Definition} */\\n\\n\\n  function definition() {\\n    return {\\n      type: 'definition',\\n      identifier: '',\\n      label: null,\\n      title: null,\\n      url: ''\\n    };\\n  }\\n  /** @returns {Emphasis} */\\n\\n\\n  function emphasis() {\\n    return {\\n      type: 'emphasis',\\n      children: []\\n    };\\n  }\\n  /** @returns {Heading} */\\n\\n\\n  function heading() {\\n    // @ts-expect-error `depth` will be set later.\\n    return {\\n      type: 'heading',\\n      depth: undefined,\\n      children: []\\n    };\\n  }\\n  /** @returns {Break} */\\n\\n\\n  function hardBreak() {\\n    return {\\n      type: 'break'\\n    };\\n  }\\n  /** @returns {HTML} */\\n\\n\\n  function html() {\\n    return {\\n      type: 'html',\\n      value: ''\\n    };\\n  }\\n  /** @returns {Image} */\\n\\n\\n  function image() {\\n    return {\\n      type: 'image',\\n      title: null,\\n      url: '',\\n      alt: null\\n    };\\n  }\\n  /** @returns {Link} */\\n\\n\\n  function link() {\\n    return {\\n      type: 'link',\\n      title: null,\\n      url: '',\\n      children: []\\n    };\\n  }\\n  /**\\n   * @param {Token} token\\n   * @returns {List}\\n   */\\n\\n\\n  function list(token) {\\n    return {\\n      type: 'list',\\n      ordered: token.type === 'listOrdered',\\n      start: null,\\n      // @ts-expect-error Patched.\\n      spread: token._spread,\\n      children: []\\n    };\\n  }\\n  /**\\n   * @param {Token} token\\n   * @returns {ListItem}\\n   */\\n\\n\\n  function listItem(token) {\\n    return {\\n      type: 'listItem',\\n      // @ts-expect-error Patched.\\n      spread: token._spread,\\n      checked: null,\\n      children: []\\n    };\\n  }\\n  /** @returns {Paragraph} */\\n\\n\\n  function paragraph() {\\n    return {\\n      type: 'paragraph',\\n      children: []\\n    };\\n  }\\n  /** @returns {Strong} */\\n\\n\\n  function strong() {\\n    return {\\n      type: 'strong',\\n      children: []\\n    };\\n  }\\n  /** @returns {Text} */\\n\\n\\n  function text() {\\n    return {\\n      type: 'text',\\n      value: ''\\n    };\\n  }\\n  /** @returns {ThematicBreak} */\\n\\n\\n  function thematicBreak() {\\n    return {\\n      type: 'thematicBreak'\\n    };\\n  }\\n}\\n/**\\n * Copy a point-like value.\\n *\\n * @param {Point} d\\n *   Point-like value.\\n * @returns {Point}\\n *   unist point.\\n */\\n\\n\\nfunction point(d) {\\n  return {\\n    line: d.line,\\n    column: d.column,\\n    offset: d.offset\\n  };\\n}\\n/**\\n * @param {Config} combined\\n * @param {Array<Extension | Array<Extension>>} extensions\\n * @returns {void}\\n */\\n\\n\\nfunction configure(combined, extensions) {\\n  let index = -1;\\n\\n  while (++index < extensions.length) {\\n    const value = extensions[index];\\n\\n    if (Array.isArray(value)) {\\n      configure(combined, value);\\n    } else {\\n      extension(combined, value);\\n    }\\n  }\\n}\\n/**\\n * @param {Config} combined\\n * @param {Extension} extension\\n * @returns {void}\\n */\\n\\n\\nfunction extension(combined, extension) {\\n  /** @type {keyof Extension} */\\n  let key;\\n\\n  for (key in extension) {\\n    if (own.call(extension, key)) {\\n      if (key === 'canContainEols') {\\n        const right = extension[key];\\n\\n        if (right) {\\n          combined[key].push(...right);\\n        }\\n      } else if (key === 'transforms') {\\n        const right = extension[key];\\n\\n        if (right) {\\n          combined[key].push(...right);\\n        }\\n      } else if (key === 'enter' || key === 'exit') {\\n        const right = extension[key];\\n\\n        if (right) {\\n          Object.assign(combined[key], right);\\n        }\\n      }\\n    }\\n  }\\n}\\n/** @type {OnEnterError} */\\n\\n\\nfunction defaultOnError(left, right) {\\n  if (left) {\\n    throw new Error('Cannot close `' + left.type + '` (' + (0, _unistUtilStringifyPosition.stringifyPosition)({\\n      start: left.start,\\n      end: left.end\\n    }) + '): a different token (`' + right.type + '`, ' + (0, _unistUtilStringifyPosition.stringifyPosition)({\\n      start: right.start,\\n      end: right.end\\n    }) + ') is open');\\n  } else {\\n    throw new Error('Cannot close document, a token (`' + right.type + '`, ' + (0, _unistUtilStringifyPosition.stringifyPosition)({\\n      start: right.start,\\n      end: right.end\\n    }) + ') is still open');\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"compiler\",\"options\",\"setData\",\"key\",\"value\",\"data\",\"getData\",\"opener\",\"create\",\"and\",\"open\",\"token\",\"enter\",\"call\",\"buffer\",\"stack\",\"push\",\"type\",\"children\",\"node\",\"errorHandler\",\"parent\",\"length\",\"tokenStack\",\"position\",\"start\",\"point\",\"closer\",\"close\",\"exit\",\"onExitError\",\"pop\",\"defaultOnError\",\"Error\",\"_unistUtilStringifyPosition\",\"stringifyPosition\",\"end\",\"resume\",\"_mdastUtilToString\",\"toString\",\"onenterdata\",\"tail\",\"onexitdata\",\"sliceSerialize\",\"onexithardbreak\",\"onexitcharacterreferencemarker\",\"codeFlow\",\"lang\",\"meta\",\"heading\",\"depth\",\"undefined\",\"hardBreak\",\"html\",\"link\",\"title\",\"url\",\"list\",\"ordered\",\"spread\",\"_spread\",\"config\",\"transforms\",\"canContainEols\",\"autolink\",\"autolinkProtocol\",\"autolinkEmail\",\"atxHeading\",\"blockQuote\",\"characterEscape\",\"characterReference\",\"codeFenced\",\"codeFencedFenceInfo\",\"codeFencedFenceMeta\",\"codeIndented\",\"codeText\",\"codeTextData\",\"codeFlowValue\",\"definition\",\"identifier\",\"label\",\"definitionDestinationString\",\"definitionLabelString\",\"definitionTitleString\",\"emphasis\",\"hardBreakEscape\",\"hardBreakTrailing\",\"htmlFlow\",\"htmlFlowData\",\"htmlText\",\"htmlTextData\",\"image\",\"alt\",\"listItem\",\"checked\",\"listItemValue\",\"onenterlistitemvalue\",\"ancestor\",\"Number\",\"parseInt\",\"listOrdered\",\"onenterlistordered\",\"listUnordered\",\"paragraph\",\"reference\",\"onenterreference\",\"referenceString\",\"resourceDestinationString\",\"resourceTitleString\",\"setextHeading\",\"strong\",\"thematicBreak\",\"atxHeadingSequence\",\"onexitatxheadingsequence\",\"onexitautolinkemail\",\"onexitautolinkprotocol\",\"characterEscapeValue\",\"characterReferenceMarkerHexadecimal\",\"characterReferenceMarkerNumeric\",\"characterReferenceValue\",\"onexitcharacterreferencevalue\",\"_micromarkUtilDecodeNumericCharacterReference\",\"decodeNumericCharacterReference\",\"result\",\"_decodeNamedCharacterReference\",\"decodeNamedCharacterReference\",\"onexitcodefenced\",\"replace\",\"codeFencedFence\",\"onexitcodefencedfence\",\"onexitcodefencedfenceinfo\",\"onexitcodefencedfencemeta\",\"onexitcodeindented\",\"onexitcodetext\",\"onexitdefinitiondestinationstring\",\"onexitdefinitionlabelstring\",\"_micromarkUtilNormalizeIdentifier\",\"normalizeIdentifier\",\"toLowerCase\",\"onexitdefinitiontitlestring\",\"onexithtmlflow\",\"onexithtmltext\",\"onexitimage\",\"referenceType\",\"onexitlabel\",\"fragment\",\"labelText\",\"onexitlabeltext\",\"string\",\"_micromarkUtilDecodeString\",\"decodeString\",\"lineEnding\",\"onexitlineending\",\"context\",\"includes\",\"onexitlink\",\"onexitreferencestring\",\"onexitresourcedestinationstring\",\"onexitresourcetitlestring\",\"resource\",\"onexitresource\",\"onexitsetextheading\",\"setextHeadingLineSequence\",\"onexitsetextheadinglinesequence\",\"charCodeAt\",\"setextHeadingText\",\"onexitsetextheadingtext\",\"configure\",\"mdastExtensions\",\"compile\",\"events\",\"tree\",\"listStack\",\"index\",\"atMarker\",\"firstBlankLineIndex\",\"lineIndex\",\"containerBalance\",\"listSpread\",\"event\",\"tailIndex\",\"tailEvent\",\"Object\",\"assign\",\"splice\",\"handler\",\"own\",\"line\",\"column\",\"offset\",\"d\",\"combined\",\"extensions\",\"Array\",\"isArray\",\"extension\",\"right\",\"left\",\"defineProperty\",\"fromMarkdown\",\"_parse\",\"_preprocess\",\"_postprocess\",\"hasOwnProperty\",\"encoding\",\"postprocess\",\"parse\",\"document\",\"write\",\"preprocess\"]\n}\n"]