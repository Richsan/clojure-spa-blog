["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/kumir.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$kumir=function(global,require,module,exports){function kumir(Prism$jscomp$0){(function(Prism){function wrapId(pattern,flags){return RegExp(pattern.replace(/<nonId>/g,nonId),flags)}var nonId=/\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source;Prism.languages.kumir={comment:{pattern:/\\|.*/},prolog:{pattern:/#.*/,greedy:!0},string:{pattern:/\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,greedy:!0},boolean:{pattern:wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),\nlookbehind:!0},\"operator-word\":{pattern:wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),lookbehind:!0,alias:\"keyword\"},\"system-variable\":{pattern:wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),lookbehind:!0,alias:\"keyword\"},type:[{pattern:wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\\x20*таб)?(?=[<nonId>]|$)/.source),lookbehind:!0,alias:\"builtin\"},{pattern:wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),lookbehind:!0,alias:\"important\"}],keyword:{pattern:wrapId(/(^|[<nonId>])(?:алг|арг(?:\\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\\x20+|_)исп)?|кц(?:(?:\\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),\nlookbehind:!0},name:{pattern:wrapId(/(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),lookbehind:!0},number:{pattern:wrapId(/(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/.source,\"i\"),lookbehind:!0},punctuation:/:=|[(),:;\\[\\]]/,\"operator-char\":{pattern:/\\*\\*?|<[=>]?|>=?|[-+/=]/,alias:\"operator\"}};Prism.languages.kum=Prism.languages.kumir})(Prism$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=\nkumir;kumir.displayName=\"kumir\";kumir.aliases=[\"kum\"]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$kumir\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = kumir;\n// @ts-nocheck\nkumir.displayName = 'kumir';\nkumir.aliases = ['kum'];\n/** @type {import('../core.js').Syntax} */\n\nfunction kumir(Prism) {\n  /* eslint-disable regexp/no-dupe-characters-character-class */\n  ;\n\n  (function (Prism) {\n    /**\n     * Regular expression for characters that are not allowed in identifiers.\n     *\n     * @type {string}\n     */\n    var nonId = /\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source;\n    /**\n     * Surround a regular expression for IDs with patterns for non-ID sequences.\n     *\n     * @param {string} pattern A regular expression for identifiers.\n     * @param {string} [flags] The regular expression flags.\n     * @returns {RegExp} A wrapped regular expression for identifiers.\n     */\n\n    function wrapId(pattern, flags) {\n      return RegExp(pattern.replace(/<nonId>/g, nonId), flags);\n    }\n\n    Prism.languages.kumir = {\n      comment: {\n        pattern: /\\|.*/\n      },\n      prolog: {\n        pattern: /#.*/,\n        greedy: true\n      },\n      string: {\n        pattern: /\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,\n        greedy: true\n      },\n      boolean: {\n        pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),\n        lookbehind: true\n      },\n      'operator-word': {\n        pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      'system-variable': {\n        pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      type: [{\n        pattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\\x20*таб)?(?=[<nonId>]|$)/.source),\n        lookbehind: true,\n        alias: 'builtin'\n      }, {\n        pattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),\n        lookbehind: true,\n        alias: 'important'\n      }],\n\n      /**\n       * Should be performed after searching for type names because of \"таб\".\n       * \"таб\" is a reserved word, but never used without a preceding type name.\n       * \"НАЗНАЧИТЬ\", \"Фввод\", and \"Фвывод\" are not reserved words.\n       */\n      keyword: {\n        pattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\\x20+|_)исп)?|кц(?:(?:\\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),\n        lookbehind: true\n      },\n\n      /** Should be performed after searching for reserved words. */\n      name: {\n        // eslint-disable-next-line regexp/no-super-linear-backtracking\n        pattern: wrapId(/(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),\n        lookbehind: true\n      },\n\n      /** Should be performed after searching for names. */\n      number: {\n        pattern: wrapId(/(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/.source, 'i'),\n        lookbehind: true\n      },\n\n      /** Should be performed after searching for words. */\n      punctuation: /:=|[(),:;\\[\\]]/,\n\n      /**\n       * Should be performed after searching for\n       * - numeric constants (because of \"+\" and \"-\");\n       * - punctuation marks (because of \":=\" and \"=\").\n       */\n      'operator-char': {\n        pattern: /\\*\\*?|<[=>]?|>=?|[-+/=]/,\n        alias: 'operator'\n      }\n    };\n    Prism.languages.kum = Prism.languages.kumir;\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["boolean","punctuation","string","aliases","displayName","__esModule","prolog","kumir","lookbehind","name","value","keyword","number","greedy","kum","pattern","type","alias","comment","default"]],"~:compiled-at",1676841365431,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$kumir.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAA,wCAAA,CAA6D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAYrGC,QAASA,MAAK,CAACC,cAAD,CAAQ,CAInB,SAAS,CAACA,KAAD,CAAQ,CAehBC,QAASA,OAAM,CAACC,OAAD,CAAUC,KAAV,CAAiB,CAC9B,MAAOC,OAAA,CAAOF,OAAQG,CAAAA,OAAR,CAAgB,UAAhB,CAA4BC,KAA5B,CAAP,CAA2CH,KAA3C,CADuB,CAThC,IAAIG,MAAQ,qDAAsDC,CAAAA,MAalEP,MAAMQ,CAAAA,SAAUT,CAAAA,KAAhB,CAAwB,CACtBU,QAAS,CACPP,QAAS,MADF,CADa,CAItBQ,OAAQ,CACNR,QAAS,KADH,CAENS,OAAQ,CAAA,CAFF,CAJc,CAQtBC,OAAQ,CACNV,QAAS,yBADH,CAENS,OAAQ,CAAA,CAFF,CARc,CAYtBE,QAAS,CACPX,QAASD,MAAA,CAAO,wCAAyCM,CAAAA,MAAhD,CADF;AAEPO,WAAY,CAAA,CAFL,CAZa,CAgBtB,gBAAiB,CACfZ,QAASD,MAAA,CAAO,0CAA2CM,CAAAA,MAAlD,CADM,CAEfO,WAAY,CAAA,CAFG,CAGfC,MAAO,SAHQ,CAhBK,CAqBtB,kBAAmB,CACjBb,QAASD,MAAA,CAAO,kCAAmCM,CAAAA,MAA1C,CADQ,CAEjBO,WAAY,CAAA,CAFK,CAGjBC,MAAO,SAHU,CArBG,CA0BtBC,KAAM,CAAC,CACLd,QAASD,MAAA,CAAO,kEAAmEM,CAAAA,MAA1E,CADJ,CAELO,WAAY,CAAA,CAFP,CAGLC,MAAO,SAHF,CAAD,CAIH,CACDb,QAASD,MAAA,CAAO,yDAA0DM,CAAAA,MAAjE,CADR,CAEDO,WAAY,CAAA,CAFX,CAGDC,MAAO,WAHN,CAJG,CA1BgB,CAyCtBE,QAAS,CACPf,QAASD,MAAA,CAAO,oPAAqPM,CAAAA,MAA5P,CADF;AAEPO,WAAY,CAAA,CAFL,CAzCa,CA+CtBI,KAAM,CAEJhB,QAASD,MAAA,CAAO,0EAA2EM,CAAAA,MAAlF,CAFL,CAGJO,WAAY,CAAA,CAHR,CA/CgB,CAsDtBK,OAAQ,CACNjB,QAASD,MAAA,CAAO,0FAA2FM,CAAAA,MAAlG,CAA0G,GAA1G,CADH,CAENO,WAAY,CAAA,CAFN,CAtDc,CA4DtBM,YAAa,gBA5DS,CAmEtB,gBAAiB,CACflB,QAAS,yBADM,CAEfa,MAAO,UAFQ,CAnEK,CAwExBf,MAAMQ,CAAAA,SAAUa,CAAAA,GAAhB,CAAsBrB,KAAMQ,CAAAA,SAAUT,CAAAA,KA3FtB,CAAjB,CAAD,CA4FGC,cA5FH,CAJoB,CATtBsB,MAAOC,CAAAA,cAAP,CAAsBzB,OAAtB,CAA+B,YAA/B,CAA6C,CAC3C0B,MAAO,CAAA,CADoC,CAA7C,CAGA1B,QAAQ2B,CAAAA,OAAR;AAAkB1B,KAElBA,MAAM2B,CAAAA,WAAN,CAAoB,OACpB3B,MAAM4B,CAAAA,OAAN,CAAgB,CAAC,KAAD,CATqF;\",\n\"sources\":[\"node_modules/refractor/lang/kumir.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$kumir\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = kumir;\\n// @ts-nocheck\\nkumir.displayName = 'kumir';\\nkumir.aliases = ['kum'];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction kumir(Prism) {\\n  /* eslint-disable regexp/no-dupe-characters-character-class */\\n  ;\\n\\n  (function (Prism) {\\n    /**\\n     * Regular expression for characters that are not allowed in identifiers.\\n     *\\n     * @type {string}\\n     */\\n    var nonId = /\\\\s\\\\x00-\\\\x1f\\\\x22-\\\\x2f\\\\x3a-\\\\x3f\\\\x5b-\\\\x5e\\\\x60\\\\x7b-\\\\x7e/.source;\\n    /**\\n     * Surround a regular expression for IDs with patterns for non-ID sequences.\\n     *\\n     * @param {string} pattern A regular expression for identifiers.\\n     * @param {string} [flags] The regular expression flags.\\n     * @returns {RegExp} A wrapped regular expression for identifiers.\\n     */\\n\\n    function wrapId(pattern, flags) {\\n      return RegExp(pattern.replace(/<nonId>/g, nonId), flags);\\n    }\\n\\n    Prism.languages.kumir = {\\n      comment: {\\n        pattern: /\\\\|.*/\\n      },\\n      prolog: {\\n        pattern: /#.*/,\\n        greedy: true\\n      },\\n      string: {\\n        pattern: /\\\"[^\\\\n\\\\r\\\"]*\\\"|'[^\\\\n\\\\r']*'/,\\n        greedy: true\\n      },\\n      boolean: {\\n        pattern: wrapId(/(^|[<nonId>])(?:\\u0434\\u0430|\\u043d\\u0435\\u0442)(?=[<nonId>]|$)/.source),\\n        lookbehind: true\\n      },\\n      'operator-word': {\\n        pattern: wrapId(/(^|[<nonId>])(?:\\u0438|\\u0438\\u043b\\u0438|\\u043d\\u0435)(?=[<nonId>]|$)/.source),\\n        lookbehind: true,\\n        alias: 'keyword'\\n      },\\n      'system-variable': {\\n        pattern: wrapId(/(^|[<nonId>])\\u0437\\u043d\\u0430\\u0447(?=[<nonId>]|$)/.source),\\n        lookbehind: true,\\n        alias: 'keyword'\\n      },\\n      type: [{\\n        pattern: wrapId(/(^|[<nonId>])(?:\\u0432\\u0435\\u0449|\\u043b\\u0438\\u0442|\\u043b\\u043e\\u0433|\\u0441\\u0438\\u043c|\\u0446\\u0435\\u043b)(?:\\\\x20*\\u0442\\u0430\\u0431)?(?=[<nonId>]|$)/.source),\\n        lookbehind: true,\\n        alias: 'builtin'\\n      }, {\\n        pattern: wrapId(/(^|[<nonId>])(?:\\u043a\\u043e\\u043c\\u043f\\u043b|\\u0441\\u043a\\u0430\\u043d\\u043a\\u043e\\u0434|\\u0444\\u0430\\u0439\\u043b|\\u0446\\u0432\\u0435\\u0442)(?=[<nonId>]|$)/.source),\\n        lookbehind: true,\\n        alias: 'important'\\n      }],\\n\\n      /**\\n       * Should be performed after searching for type names because of \\\"\\u0442\\u0430\\u0431\\\".\\n       * \\\"\\u0442\\u0430\\u0431\\\" is a reserved word, but never used without a preceding type name.\\n       * \\\"\\u041d\\u0410\\u0417\\u041d\\u0410\\u0427\\u0418\\u0422\\u042c\\\", \\\"\\u0424\\u0432\\u0432\\u043e\\u0434\\\", and \\\"\\u0424\\u0432\\u044b\\u0432\\u043e\\u0434\\\" are not reserved words.\\n       */\\n      keyword: {\\n        pattern: wrapId(/(^|[<nonId>])(?:\\u0430\\u043b\\u0433|\\u0430\\u0440\\u0433(?:\\\\x20*\\u0440\\u0435\\u0437)?|\\u0432\\u0432\\u043e\\u0434|\\u0412\\u041a\\u041b\\u042e\\u0427\\u0418\\u0422\\u042c|\\u0432\\u0441[\\u0435\\u0451]|\\u0432\\u044b\\u0431\\u043e\\u0440|\\u0432\\u044b\\u0432\\u043e\\u0434|\\u0432\\u044b\\u0445\\u043e\\u0434|\\u0434\\u0430\\u043d\\u043e|\\u0434\\u043b\\u044f|\\u0434\\u043e|\\u0434\\u0441|\\u0435\\u0441\\u043b\\u0438|\\u0438\\u043d\\u0430\\u0447\\u0435|\\u0438\\u0441\\u043f|\\u0438\\u0441\\u043f\\u043e\\u043b\\u044c\\u0437\\u043e\\u0432\\u0430\\u0442\\u044c|\\u043a\\u043e\\u043d(?:(?:\\\\x20+|_)\\u0438\\u0441\\u043f)?|\\u043a\\u0446(?:(?:\\\\x20+|_)\\u043f\\u0440\\u0438)?|\\u043d\\u0430\\u0434\\u043e|\\u043d\\u0430\\u0447|\\u043d\\u0441|\\u043d\\u0446|\\u043e\\u0442|\\u043f\\u0430\\u0443\\u0437\\u0430|\\u043f\\u043e\\u043a\\u0430|\\u043f\\u0440\\u0438|\\u0440\\u0430\\u0437\\u0430?|\\u0440\\u0435\\u0437|\\u0441\\u0442\\u043e\\u043f|\\u0442\\u0430\\u0431|\\u0442\\u043e|\\u0443\\u0442\\u0432|\\u0448\\u0430\\u0433)(?=[<nonId>]|$)/.source),\\n        lookbehind: true\\n      },\\n\\n      /** Should be performed after searching for reserved words. */\\n      name: {\\n        // eslint-disable-next-line regexp/no-super-linear-backtracking\\n        pattern: wrapId(/(^|[<nonId>])[^\\\\d<nonId>][^<nonId>]*(?:\\\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),\\n        lookbehind: true\\n      },\\n\\n      /** Should be performed after searching for names. */\\n      number: {\\n        pattern: wrapId(/(^|[<nonId>])(?:\\\\B\\\\$[\\\\da-f]+\\\\b|(?:\\\\b\\\\d+(?:\\\\.\\\\d*)?|\\\\B\\\\.\\\\d+)(?:e[+-]?\\\\d+)?)(?=[<nonId>]|$)/.source, 'i'),\\n        lookbehind: true\\n      },\\n\\n      /** Should be performed after searching for words. */\\n      punctuation: /:=|[(),:;\\\\[\\\\]]/,\\n\\n      /**\\n       * Should be performed after searching for\\n       * - numeric constants (because of \\\"+\\\" and \\\"-\\\");\\n       * - punctuation marks (because of \\\":=\\\" and \\\"=\\\").\\n       */\\n      'operator-char': {\\n        pattern: /\\\\*\\\\*?|<[=>]?|>=?|[-+/=]/,\\n        alias: 'operator'\\n      }\\n    };\\n    Prism.languages.kum = Prism.languages.kumir;\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"kumir\",\"Prism\",\"wrapId\",\"pattern\",\"flags\",\"RegExp\",\"replace\",\"nonId\",\"source\",\"languages\",\"comment\",\"prolog\",\"greedy\",\"string\",\"boolean\",\"lookbehind\",\"alias\",\"type\",\"keyword\",\"name\",\"number\",\"punctuation\",\"kum\",\"Object\",\"defineProperty\",\"value\",\"default\",\"displayName\",\"aliases\"]\n}\n"]