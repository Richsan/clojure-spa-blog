["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mdast-util-to-hast/lib/state.js"],"~:js","shadow$provide.module$node_modules$mdast_util_to_hast$lib$state=function(global,require,module,exports){function patch(from,to){from.position&&(to.position=(0,_unistUtilPosition.position)(from))}function applyData(from,to){if(from&&from.data){const hName=from.data.hName,hChildren=from.data.hChildren;from=from.data.hProperties;\"string\"===typeof hName&&(\"element\"===to.type?to.tagName=hName:to={type:\"element\",tagName:hName,properties:{},children:[]});\"element\"===to.type&&from&&(to.properties={...to.properties,\n...from});\"children\"in to&&to.children&&null!==hChildren&&void 0!==hChildren&&(to.children=hChildren)}return to}function one(state,node,parent){const type=node&&node.type;if(!type)throw Error(\"Expected node, got `\"+node+\"`\");if(own.call(state.handlers,type))return state.handlers[type](state,node,parent);if(state.passThrough&&state.passThrough.includes(type))return\"children\"in node?{...node,children:all(state,node)}:node;if(state.unknownHandler)return state.unknownHandler(state,node,parent);parent=\nnode.data||{};parent=\"value\"in node&&!own.call(parent,\"hProperties\")&&!own.call(parent,\"hChildren\")?{type:\"text\",value:node.value}:{type:\"element\",tagName:\"div\",properties:{},children:all(state,node)};state.patch(node,parent);return state.applyData(node,parent)}function all(state,parent){const values=[];if(\"children\"in parent){const nodes=parent.children;let index=-1;for(;++index<nodes.length;){const result=one(state,nodes[index],parent);if(result){if(index&&\"break\"===nodes[index-1].type&&(Array.isArray(result)||\n\"text\"!==result.type||(result.value=result.value.replace(/^\\s+/,\"\")),!Array.isArray(result)&&\"element\"===result.type)){const head=result.children[0];head&&\"text\"===head.type&&(head.value=head.value.replace(/^\\s+/,\"\"))}Array.isArray(result)?values.push(...result):values.push(result)}}}return values}function wrap(nodes,loose){const result=[];let index=-1;for(loose&&result.push({type:\"text\",value:\"\\n\"});++index<nodes.length;)index&&result.push({type:\"text\",value:\"\\n\"}),result.push(nodes[index]);loose&&\n0<nodes.length&&result.push({type:\"text\",value:\"\\n\"});return result}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.createState=function(tree,options){function augment(left,right){if(left&&\"data\"in left&&left.data){const data=left.data;data.hName&&(\"element\"!==right.type&&(right={type:\"element\",tagName:\"\",properties:{},children:[]}),right.tagName=data.hName);\"element\"===right.type&&data.hProperties&&(right.properties={...right.properties,...data.hProperties});\"children\"in right&&right.children&&\ndata.hChildren&&(right.children=data.hChildren)}left&&(left=\"type\"in left?left:{position:left},(0,_unistUtilGenerated.generated)(left)||(right.position={start:(0,_unistUtilPosition.pointStart)(left),end:(0,_unistUtilPosition.pointEnd)(left)}));return right}function state(node,tagName,props,children){Array.isArray(props)&&(children=props,props={});return augment(node,{type:\"element\",tagName,properties:props||{},children:children||[]})}options=options||{};const footnoteById={};state.dangerous=options.allowDangerousHtml||\n!1;state.clobberPrefix=void 0===options.clobberPrefix||null===options.clobberPrefix?\"user-content-\":options.clobberPrefix;state.footnoteLabel=options.footnoteLabel||\"Footnotes\";state.footnoteLabelTagName=options.footnoteLabelTagName||\"h2\";state.footnoteLabelProperties=options.footnoteLabelProperties||{className:[\"sr-only\"]};state.footnoteBackLabel=options.footnoteBackLabel||\"Back to content\";state.unknownHandler=options.unknownHandler;state.passThrough=options.passThrough;state.handlers={..._index.handlers,\n...options.handlers};state.definition=(0,_mdastUtilDefinitions.definitions)(tree);state.footnoteById=footnoteById;state.footnoteOrder=[];state.footnoteCounts={};state.patch=patch;state.applyData=applyData;state.one=function(node,parent){return one(state,node,parent)};state.all=function(parent){return all(state,parent)};state.wrap=wrap;state.augment=augment;(0,_unistUtilVisit.visit)(tree,\"footnoteDefinition\",definition=>{const id=String(definition.identifier).toUpperCase();own.call(footnoteById,id)||\n(footnoteById[id]=definition)});return state};exports.one=one;exports.all=all;exports.wrap=wrap;var _unistUtilVisit=require(\"module$node_modules$unist_util_visit$index\"),_unistUtilPosition=require(\"module$node_modules$unist_util_position$index\"),_unistUtilGenerated=require(\"module$node_modules$unist_util_generated$index\"),_mdastUtilDefinitions=require(\"module$node_modules$mdast_util_definitions$index\"),_index=require(\"module$node_modules$mdast_util_to_hast$lib$handlers$index\");const own={}.hasOwnProperty}","~:source","shadow$provide[\"module$node_modules$mdast_util_to_hast$lib$state\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createState = createState;\nexports.one = one;\nexports.all = all;\nexports.wrap = wrap;\n\nvar _unistUtilVisit = require(\"unist-util-visit\");\n\nvar _unistUtilPosition = require(\"unist-util-position\");\n\nvar _unistUtilGenerated = require(\"unist-util-generated\");\n\nvar _mdastUtilDefinitions = require(\"mdast-util-definitions\");\n\nvar _index = require(\"./handlers/index.js\");\n\n/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} MdastRoot\n */\n\n/**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n * @typedef {Extract<MdastNodes, MdastParent>} MdastParents\n *\n * @typedef EmbeddedHastFields\n *   hast fields.\n * @property {string | null | undefined} [hName]\n *   Generate a specific element with this tag name instead.\n * @property {HastProperties | null | undefined} [hProperties]\n *   Generate an element with these properties instead.\n * @property {Array<HastElementContent> | null | undefined} [hChildren]\n *   Generate an element with this content instead.\n *\n * @typedef {Record<string, unknown> & EmbeddedHastFields} MdastData\n *   mdast data with embedded hast fields.\n *\n * @typedef {MdastNodes & {data?: MdastData | null | undefined}} MdastNodeWithData\n *   mdast node with embedded hast data.\n *\n * @typedef PointLike\n *   Point-like value.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @typedef PositionLike\n *   Position-like value.\n * @property {PointLike | null | undefined} [start]\n *   Point-like value.\n * @property {PointLike | null | undefined} [end]\n *   Point-like value.\n *\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | null | undefined} parent\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   hast node.\n *\n * @callback HFunctionProps\n *   Signature of `state` for when props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {HastProperties} props\n *   Properties.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @callback HFunctionNoProps\n *   Signature of `state` for when no props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @typedef HFields\n *   Info on `state`.\n * @property {boolean} dangerous\n *   Whether HTML is allowed.\n * @property {string} clobberPrefix\n *   Prefix to use to prevent DOM clobbering.\n * @property {string} footnoteLabel\n *   Label to use to introduce the footnote section.\n * @property {string} footnoteLabelTagName\n *   HTML used for the footnote label.\n * @property {HastProperties} footnoteLabelProperties\n *   Properties on the HTML tag used for the footnote label.\n * @property {string} footnoteBackLabel\n *   Label to use from backreferences back to their footnote call.\n * @property {(identifier: string) => MdastDefinition | null} definition\n *   Definition cache.\n * @property {Record<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Record<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {Handler} unknownHandler\n *   Handler for any none not in `passThrough` or otherwise handled.\n * @property {(from: MdastNodes, node: HastNodes) => void} patch\n *   Copy a nodeâ€™s positional info.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => Type | HastElement} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {(node: MdastNodes, parent: MdastParents | null | undefined) => HastElementContent | Array<HastElementContent> | null | undefined} one\n *   Transform an mdast node to hast.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastContent>(nodes: Array<Type>, loose?: boolean | null | undefined) => Array<Type | HastText>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n * @property {(left: MdastNodeWithData | PositionLike | null | undefined, right: HastElementContent) => HastElementContent} augment\n *   Like `state` but lower-level and usable on non-elements.\n *   Deprecated: use `patch` and `applyData`.\n * @property {Array<string>} passThrough\n *   List of node types to pass through untouched (except for their children).\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree.\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` attribute on footnotes to prevent it from\n *   *clobbering*.\n * @property {string | null | undefined} [footnoteBackLabel='Back to content']\n *   Label to use from backreferences back to their footnote call (affects\n *   screen readers).\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Label to use for the footnotes section (affects screen readers).\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (note that `id: 'footnote-label'`\n *   is always added as footnote calls use it with `aria-describedby` to\n *   provide an accessible label).\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   Tag name to use for the footnote label.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes.\n * @property {Array<string> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes.\n *\n * @typedef {Record<string, Handler>} Handlers\n *   Handle nodes.\n *\n * @typedef {HFunctionProps & HFunctionNoProps & HFields} State\n *   Info passed around.\n */\nconst own = {}.hasOwnProperty;\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {State}\n *   `state` function.\n */\n\nfunction createState(tree, options) {\n  const settings = options || {};\n  const dangerous = settings.allowDangerousHtml || false;\n  /** @type {Record<string, MdastFootnoteDefinition>} */\n\n  const footnoteById = {}; // To do: next major: add `options` to state, remove:\n  // `dangerous`, `clobberPrefix`, `footnoteLabel`, `footnoteLabelTagName`,\n  // `footnoteLabelProperties`, `footnoteBackLabel`, `passThrough`,\n  // `unknownHandler`.\n  // To do: next major: move to `state.options.allowDangerousHtml`.\n\n  state.dangerous = dangerous; // To do: next major: move to `state.options`.\n\n  state.clobberPrefix = settings.clobberPrefix === undefined || settings.clobberPrefix === null ? 'user-content-' : settings.clobberPrefix; // To do: next major: move to `state.options`.\n\n  state.footnoteLabel = settings.footnoteLabel || 'Footnotes'; // To do: next major: move to `state.options`.\n\n  state.footnoteLabelTagName = settings.footnoteLabelTagName || 'h2'; // To do: next major: move to `state.options`.\n\n  state.footnoteLabelProperties = settings.footnoteLabelProperties || {\n    className: ['sr-only']\n  }; // To do: next major: move to `state.options`.\n\n  state.footnoteBackLabel = settings.footnoteBackLabel || 'Back to content'; // To do: next major: move to `state.options`.\n\n  state.unknownHandler = settings.unknownHandler; // To do: next major: move to `state.options`.\n\n  state.passThrough = settings.passThrough;\n  state.handlers = { ..._index.handlers,\n    ...settings.handlers\n  }; // To do: next major: replace utility with `definitionById` object, so we\n  // only walk once (as we need footnotes too).\n\n  state.definition = (0, _mdastUtilDefinitions.definitions)(tree);\n  state.footnoteById = footnoteById;\n  /** @type {Array<string>} */\n\n  state.footnoteOrder = [];\n  /** @type {Record<string, number>} */\n\n  state.footnoteCounts = {};\n  state.patch = patch;\n  state.applyData = applyData;\n  state.one = oneBound;\n  state.all = allBound;\n  state.wrap = wrap; // To do: next major: remove `augment`.\n\n  state.augment = augment;\n  (0, _unistUtilVisit.visit)(tree, 'footnoteDefinition', definition => {\n    const id = String(definition.identifier).toUpperCase(); // Mimick CM behavior of link definitions.\n    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.\n\n    if (!own.call(footnoteById, id)) {\n      footnoteById[id] = definition;\n    }\n  }); // @ts-expect-error Hush, itâ€™s fine!\n\n  return state;\n  /**\n   * Finalise the created `right`, a hast node, from `left`, an mdast node.\n   *\n   * @param {MdastNodeWithData | PositionLike | null | undefined} left\n   * @param {HastElementContent} right\n   * @returns {HastElementContent}\n   */\n\n  /* c8 ignore start */\n  // To do: next major: remove.\n\n  function augment(left, right) {\n    // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n    if (left && 'data' in left && left.data) {\n      /** @type {MdastData} */\n      const data = left.data;\n\n      if (data.hName) {\n        if (right.type !== 'element') {\n          right = {\n            type: 'element',\n            tagName: '',\n            properties: {},\n            children: []\n          };\n        }\n\n        right.tagName = data.hName;\n      }\n\n      if (right.type === 'element' && data.hProperties) {\n        right.properties = { ...right.properties,\n          ...data.hProperties\n        };\n      }\n\n      if ('children' in right && right.children && data.hChildren) {\n        right.children = data.hChildren;\n      }\n    }\n\n    if (left) {\n      const ctx = 'type' in left ? left : {\n        position: left\n      };\n\n      if (!(0, _unistUtilGenerated.generated)(ctx)) {\n        // @ts-expect-error: fine.\n        right.position = {\n          start: (0, _unistUtilPosition.pointStart)(ctx),\n          end: (0, _unistUtilPosition.pointEnd)(ctx)\n        };\n      }\n    }\n\n    return right;\n  }\n  /* c8 ignore stop */\n\n  /**\n   * Create an element for `node`.\n   *\n   * @type {HFunctionProps}\n   */\n\n  /* c8 ignore start */\n  // To do: next major: remove.\n\n\n  function state(node, tagName, props, children) {\n    if (Array.isArray(props)) {\n      children = props;\n      props = {};\n    } // @ts-expect-error augmenting an element yields an element.\n\n\n    return augment(node, {\n      type: 'element',\n      tagName,\n      properties: props || {},\n      children: children || []\n    });\n  }\n  /* c8 ignore stop */\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | null | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n   *   Resulting hast node.\n   */\n\n\n  function oneBound(node, parent) {\n    // @ts-expect-error: thatâ€™s a state :)\n    return one(state, node, parent);\n  }\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n\n\n  function allBound(parent) {\n    // @ts-expect-error: thatâ€™s a state :)\n    return all(state, parent);\n  }\n}\n/**\n * Copy a nodeâ€™s positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {void}\n *   Nothing.\n */\n\n\nfunction patch(from, to) {\n  if (from.position) to.position = (0, _unistUtilPosition.position)(from);\n}\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {Type | HastElement}\n *   Nothing.\n */\n\n\nfunction applyData(from, to) {\n  /** @type {Type | HastElement} */\n  let result = to; // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n\n  if (from && from.data) {\n    const hName = from.data.hName;\n    const hChildren = from.data.hChildren;\n    const hProperties = from.data.hProperties;\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName;\n      } // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent is likely to keep the content around (otherwise: pass\n      // `hChildren`).\n      else {\n        result = {\n          type: 'element',\n          tagName: hName,\n          properties: {},\n          children: []\n        }; // To do: next major: take the children from the `root`, or inject the\n        // raw/text/comment or so into the element?\n        // if ('children' in node) {\n        //   // @ts-expect-error: assume `children` are allowed in elements.\n        //   result.children = node.children\n        // } else {\n        //   // @ts-expect-error: assume `node` is allowed in elements.\n        //   result.children.push(node)\n        // }\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      result.properties = { ...result.properties,\n        ...hProperties\n      };\n    }\n\n    if ('children' in result && result.children && hChildren !== null && hChildren !== undefined) {\n      // @ts-expect-error: assume valid children are defined.\n      result.children = hChildren;\n    }\n  }\n\n  return result;\n}\n/**\n * Transform an mdast node into a hast node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   mdast node.\n * @param {MdastParents | null | undefined} [parent]\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   Resulting hast node.\n */\n// To do: next major: do not expose, keep bound.\n\n\nfunction one(state, node, parent) {\n  const type = node && node.type; // Fail on non-nodes.\n\n  if (!type) {\n    throw new Error('Expected node, got `' + node + '`');\n  }\n\n  if (own.call(state.handlers, type)) {\n    return state.handlers[type](state, node, parent);\n  }\n\n  if (state.passThrough && state.passThrough.includes(type)) {\n    // To do: next major: deep clone.\n    // @ts-expect-error: types of passed through nodes are expected to be added manually.\n    return 'children' in node ? { ...node,\n      children: all(state, node)\n    } : node;\n  }\n\n  if (state.unknownHandler) {\n    return state.unknownHandler(state, node, parent);\n  }\n\n  return defaultUnknownHandler(state, node);\n}\n/**\n * Transform the children of an mdast node into hast nodes.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} parent\n *   mdast node to compile\n * @returns {Array<HastElementContent>}\n *   Resulting hast nodes.\n */\n// To do: next major: do not expose, keep bound.\n\n\nfunction all(state, parent) {\n  /** @type {Array<HastElementContent>} */\n  const values = [];\n\n  if ('children' in parent) {\n    const nodes = parent.children;\n    let index = -1;\n\n    while (++index < nodes.length) {\n      const result = one(state, nodes[index], parent); // To do: see if we van clean this? Can we merge texts?\n\n      if (result) {\n        if (index && nodes[index - 1].type === 'break') {\n          if (!Array.isArray(result) && result.type === 'text') {\n            result.value = result.value.replace(/^\\s+/, '');\n          }\n\n          if (!Array.isArray(result) && result.type === 'element') {\n            const head = result.children[0];\n\n            if (head && head.type === 'text') {\n              head.value = head.value.replace(/^\\s+/, '');\n            }\n          }\n        }\n\n        if (Array.isArray(result)) {\n          values.push(...result);\n        } else {\n          values.push(result);\n        }\n      }\n    }\n  }\n\n  return values;\n}\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastText | HastElement}\n *   Resulting hast node.\n */\n\n\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {};\n  /** @type {HastText | HastElement} */\n\n  const result = 'value' in node && !(own.call(data, 'hProperties') || own.call(data, 'hChildren')) ? {\n    type: 'text',\n    value: node.value\n  } : {\n    type: 'element',\n    tagName: 'div',\n    properties: {},\n    children: all(state, node)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | null | undefined} [loose=false]\n *   Whether to add line endings at start and end.\n * @returns {Array<Type | HastText>}\n *   Wrapped nodes.\n */\n\n\nfunction wrap(nodes, loose) {\n  /** @type {Array<Type | HastText>} */\n  const result = [];\n  let index = -1;\n\n  if (loose) {\n    result.push({\n      type: 'text',\n      value: '\\n'\n    });\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({\n      type: 'text',\n      value: '\\n'\n    });\n    result.push(nodes[index]);\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({\n      type: 'text',\n      value: '\\n'\n    });\n  }\n\n  return result;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$unist_util_visit$index","~$module$node_modules$unist_util_position$index","~$shadow.js","~$module$node_modules$mdast_util_to_hast$lib$handlers$index","~$module$node_modules$mdast_util_definitions$index","~$module$node_modules$unist_util_generated$index"]],"~:properties",["^5",["properties","footnoteLabelTagName","footnoteBackLabel","handlers","clobberPrefix","className","children","__esModule","footnoteLabel","augment","dangerous","wrap","position","unknownHandler","value","start","patch","footnoteOrder","applyData","definition","type","one","tagName","all","footnoteCounts","passThrough","footnoteLabelProperties","end","footnoteById","createState"]],"~:compiled-at",1676665867322,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mdast_util_to_hast$lib$state.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mdast-util-to-hast/lib/state.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mdast_util_to_hast$lib$state\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createState = createState;\\nexports.one = one;\\nexports.all = all;\\nexports.wrap = wrap;\\n\\nvar _unistUtilVisit = require(\\\"unist-util-visit\\\");\\n\\nvar _unistUtilPosition = require(\\\"unist-util-position\\\");\\n\\nvar _unistUtilGenerated = require(\\\"unist-util-generated\\\");\\n\\nvar _mdastUtilDefinitions = require(\\\"mdast-util-definitions\\\");\\n\\nvar _index = require(\\\"./handlers/index.js\\\");\\n\\n/**\\n * @typedef {import('hast').Content} HastContent\\n * @typedef {import('hast').Element} HastElement\\n * @typedef {import('hast').ElementContent} HastElementContent\\n * @typedef {import('hast').Properties} HastProperties\\n * @typedef {import('hast').Root} HastRoot\\n * @typedef {import('hast').Text} HastText\\n *\\n * @typedef {import('mdast').Content} MdastContent\\n * @typedef {import('mdast').Definition} MdastDefinition\\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\\n * @typedef {import('mdast').Parent} MdastParent\\n * @typedef {import('mdast').Root} MdastRoot\\n */\\n\\n/**\\n * @typedef {HastRoot | HastContent} HastNodes\\n * @typedef {MdastRoot | MdastContent} MdastNodes\\n * @typedef {Extract<MdastNodes, MdastParent>} MdastParents\\n *\\n * @typedef EmbeddedHastFields\\n *   hast fields.\\n * @property {string | null | undefined} [hName]\\n *   Generate a specific element with this tag name instead.\\n * @property {HastProperties | null | undefined} [hProperties]\\n *   Generate an element with these properties instead.\\n * @property {Array<HastElementContent> | null | undefined} [hChildren]\\n *   Generate an element with this content instead.\\n *\\n * @typedef {Record<string, unknown> & EmbeddedHastFields} MdastData\\n *   mdast data with embedded hast fields.\\n *\\n * @typedef {MdastNodes & {data?: MdastData | null | undefined}} MdastNodeWithData\\n *   mdast node with embedded hast data.\\n *\\n * @typedef PointLike\\n *   Point-like value.\\n * @property {number | null | undefined} [line]\\n *   Line.\\n * @property {number | null | undefined} [column]\\n *   Column.\\n * @property {number | null | undefined} [offset]\\n *   Offset.\\n *\\n * @typedef PositionLike\\n *   Position-like value.\\n * @property {PointLike | null | undefined} [start]\\n *   Point-like value.\\n * @property {PointLike | null | undefined} [end]\\n *   Point-like value.\\n *\\n * @callback Handler\\n *   Handle a node.\\n * @param {State} state\\n *   Info passed around.\\n * @param {any} node\\n *   mdast node to handle.\\n * @param {MdastParents | null | undefined} parent\\n *   Parent of `node`.\\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\\n *   hast node.\\n *\\n * @callback HFunctionProps\\n *   Signature of `state` for when props are passed.\\n * @param {MdastNodes | PositionLike | null | undefined} node\\n *   mdast node or unist position.\\n * @param {string} tagName\\n *   HTML tag name.\\n * @param {HastProperties} props\\n *   Properties.\\n * @param {Array<HastElementContent> | null | undefined} [children]\\n *   hast content.\\n * @returns {HastElement}\\n *   Compiled element.\\n *\\n * @callback HFunctionNoProps\\n *   Signature of `state` for when no props are passed.\\n * @param {MdastNodes | PositionLike | null | undefined} node\\n *   mdast node or unist position.\\n * @param {string} tagName\\n *   HTML tag name.\\n * @param {Array<HastElementContent> | null | undefined} [children]\\n *   hast content.\\n * @returns {HastElement}\\n *   Compiled element.\\n *\\n * @typedef HFields\\n *   Info on `state`.\\n * @property {boolean} dangerous\\n *   Whether HTML is allowed.\\n * @property {string} clobberPrefix\\n *   Prefix to use to prevent DOM clobbering.\\n * @property {string} footnoteLabel\\n *   Label to use to introduce the footnote section.\\n * @property {string} footnoteLabelTagName\\n *   HTML used for the footnote label.\\n * @property {HastProperties} footnoteLabelProperties\\n *   Properties on the HTML tag used for the footnote label.\\n * @property {string} footnoteBackLabel\\n *   Label to use from backreferences back to their footnote call.\\n * @property {(identifier: string) => MdastDefinition | null} definition\\n *   Definition cache.\\n * @property {Record<string, MdastFootnoteDefinition>} footnoteById\\n *   Footnote definitions by their identifier.\\n * @property {Array<string>} footnoteOrder\\n *   Identifiers of order when footnote calls first appear in tree order.\\n * @property {Record<string, number>} footnoteCounts\\n *   Counts for how often the same footnote was called.\\n * @property {Handlers} handlers\\n *   Applied handlers.\\n * @property {Handler} unknownHandler\\n *   Handler for any none not in `passThrough` or otherwise handled.\\n * @property {(from: MdastNodes, node: HastNodes) => void} patch\\n *   Copy a node\\u2019s positional info.\\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => Type | HastElement} applyData\\n *   Honor the `data` of `from`, and generate an element instead of `node`.\\n * @property {(node: MdastNodes, parent: MdastParents | null | undefined) => HastElementContent | Array<HastElementContent> | null | undefined} one\\n *   Transform an mdast node to hast.\\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\\n *   Transform the children of an mdast parent to hast.\\n * @property {<Type extends HastContent>(nodes: Array<Type>, loose?: boolean | null | undefined) => Array<Type | HastText>} wrap\\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\\n * @property {(left: MdastNodeWithData | PositionLike | null | undefined, right: HastElementContent) => HastElementContent} augment\\n *   Like `state` but lower-level and usable on non-elements.\\n *   Deprecated: use `patch` and `applyData`.\\n * @property {Array<string>} passThrough\\n *   List of node types to pass through untouched (except for their children).\\n *\\n * @typedef Options\\n *   Configuration (optional).\\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\\n *   Whether to persist raw HTML in markdown in the hast tree.\\n * @property {string | null | undefined} [clobberPrefix='user-content-']\\n *   Prefix to use before the `id` attribute on footnotes to prevent it from\\n *   *clobbering*.\\n * @property {string | null | undefined} [footnoteBackLabel='Back to content']\\n *   Label to use from backreferences back to their footnote call (affects\\n *   screen readers).\\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\\n *   Label to use for the footnotes section (affects screen readers).\\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\\n *   Properties to use on the footnote label (note that `id: 'footnote-label'`\\n *   is always added as footnote calls use it with `aria-describedby` to\\n *   provide an accessible label).\\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\\n *   Tag name to use for the footnote label.\\n * @property {Handlers | null | undefined} [handlers]\\n *   Extra handlers for nodes.\\n * @property {Array<string> | null | undefined} [passThrough]\\n *   List of custom mdast node types to pass through (keep) in hast (note that\\n *   the node itself is passed, but eventual children are transformed).\\n * @property {Handler | null | undefined} [unknownHandler]\\n *   Handler for all unknown nodes.\\n *\\n * @typedef {Record<string, Handler>} Handlers\\n *   Handle nodes.\\n *\\n * @typedef {HFunctionProps & HFunctionNoProps & HFields} State\\n *   Info passed around.\\n */\\nconst own = {}.hasOwnProperty;\\n/**\\n * Create `state` from an mdast tree.\\n *\\n * @param {MdastNodes} tree\\n *   mdast node to transform.\\n * @param {Options | null | undefined} [options]\\n *   Configuration.\\n * @returns {State}\\n *   `state` function.\\n */\\n\\nfunction createState(tree, options) {\\n  const settings = options || {};\\n  const dangerous = settings.allowDangerousHtml || false;\\n  /** @type {Record<string, MdastFootnoteDefinition>} */\\n\\n  const footnoteById = {}; // To do: next major: add `options` to state, remove:\\n  // `dangerous`, `clobberPrefix`, `footnoteLabel`, `footnoteLabelTagName`,\\n  // `footnoteLabelProperties`, `footnoteBackLabel`, `passThrough`,\\n  // `unknownHandler`.\\n  // To do: next major: move to `state.options.allowDangerousHtml`.\\n\\n  state.dangerous = dangerous; // To do: next major: move to `state.options`.\\n\\n  state.clobberPrefix = settings.clobberPrefix === undefined || settings.clobberPrefix === null ? 'user-content-' : settings.clobberPrefix; // To do: next major: move to `state.options`.\\n\\n  state.footnoteLabel = settings.footnoteLabel || 'Footnotes'; // To do: next major: move to `state.options`.\\n\\n  state.footnoteLabelTagName = settings.footnoteLabelTagName || 'h2'; // To do: next major: move to `state.options`.\\n\\n  state.footnoteLabelProperties = settings.footnoteLabelProperties || {\\n    className: ['sr-only']\\n  }; // To do: next major: move to `state.options`.\\n\\n  state.footnoteBackLabel = settings.footnoteBackLabel || 'Back to content'; // To do: next major: move to `state.options`.\\n\\n  state.unknownHandler = settings.unknownHandler; // To do: next major: move to `state.options`.\\n\\n  state.passThrough = settings.passThrough;\\n  state.handlers = { ..._index.handlers,\\n    ...settings.handlers\\n  }; // To do: next major: replace utility with `definitionById` object, so we\\n  // only walk once (as we need footnotes too).\\n\\n  state.definition = (0, _mdastUtilDefinitions.definitions)(tree);\\n  state.footnoteById = footnoteById;\\n  /** @type {Array<string>} */\\n\\n  state.footnoteOrder = [];\\n  /** @type {Record<string, number>} */\\n\\n  state.footnoteCounts = {};\\n  state.patch = patch;\\n  state.applyData = applyData;\\n  state.one = oneBound;\\n  state.all = allBound;\\n  state.wrap = wrap; // To do: next major: remove `augment`.\\n\\n  state.augment = augment;\\n  (0, _unistUtilVisit.visit)(tree, 'footnoteDefinition', definition => {\\n    const id = String(definition.identifier).toUpperCase(); // Mimick CM behavior of link definitions.\\n    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.\\n\\n    if (!own.call(footnoteById, id)) {\\n      footnoteById[id] = definition;\\n    }\\n  }); // @ts-expect-error Hush, it\\u2019s fine!\\n\\n  return state;\\n  /**\\n   * Finalise the created `right`, a hast node, from `left`, an mdast node.\\n   *\\n   * @param {MdastNodeWithData | PositionLike | null | undefined} left\\n   * @param {HastElementContent} right\\n   * @returns {HastElementContent}\\n   */\\n\\n  /* c8 ignore start */\\n  // To do: next major: remove.\\n\\n  function augment(left, right) {\\n    // Handle `data.hName`, `data.hProperties, `data.hChildren`.\\n    if (left && 'data' in left && left.data) {\\n      /** @type {MdastData} */\\n      const data = left.data;\\n\\n      if (data.hName) {\\n        if (right.type !== 'element') {\\n          right = {\\n            type: 'element',\\n            tagName: '',\\n            properties: {},\\n            children: []\\n          };\\n        }\\n\\n        right.tagName = data.hName;\\n      }\\n\\n      if (right.type === 'element' && data.hProperties) {\\n        right.properties = { ...right.properties,\\n          ...data.hProperties\\n        };\\n      }\\n\\n      if ('children' in right && right.children && data.hChildren) {\\n        right.children = data.hChildren;\\n      }\\n    }\\n\\n    if (left) {\\n      const ctx = 'type' in left ? left : {\\n        position: left\\n      };\\n\\n      if (!(0, _unistUtilGenerated.generated)(ctx)) {\\n        // @ts-expect-error: fine.\\n        right.position = {\\n          start: (0, _unistUtilPosition.pointStart)(ctx),\\n          end: (0, _unistUtilPosition.pointEnd)(ctx)\\n        };\\n      }\\n    }\\n\\n    return right;\\n  }\\n  /* c8 ignore stop */\\n\\n  /**\\n   * Create an element for `node`.\\n   *\\n   * @type {HFunctionProps}\\n   */\\n\\n  /* c8 ignore start */\\n  // To do: next major: remove.\\n\\n\\n  function state(node, tagName, props, children) {\\n    if (Array.isArray(props)) {\\n      children = props;\\n      props = {};\\n    } // @ts-expect-error augmenting an element yields an element.\\n\\n\\n    return augment(node, {\\n      type: 'element',\\n      tagName,\\n      properties: props || {},\\n      children: children || []\\n    });\\n  }\\n  /* c8 ignore stop */\\n\\n  /**\\n   * Transform an mdast node into a hast node.\\n   *\\n   * @param {MdastNodes} node\\n   *   mdast node.\\n   * @param {MdastParents | null | undefined} [parent]\\n   *   Parent of `node`.\\n   * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\\n   *   Resulting hast node.\\n   */\\n\\n\\n  function oneBound(node, parent) {\\n    // @ts-expect-error: that\\u2019s a state :)\\n    return one(state, node, parent);\\n  }\\n  /**\\n   * Transform the children of an mdast node into hast nodes.\\n   *\\n   * @param {MdastNodes} parent\\n   *   mdast node to compile\\n   * @returns {Array<HastElementContent>}\\n   *   Resulting hast nodes.\\n   */\\n\\n\\n  function allBound(parent) {\\n    // @ts-expect-error: that\\u2019s a state :)\\n    return all(state, parent);\\n  }\\n}\\n/**\\n * Copy a node\\u2019s positional info.\\n *\\n * @param {MdastNodes} from\\n *   mdast node to copy from.\\n * @param {HastNodes} to\\n *   hast node to copy into.\\n * @returns {void}\\n *   Nothing.\\n */\\n\\n\\nfunction patch(from, to) {\\n  if (from.position) to.position = (0, _unistUtilPosition.position)(from);\\n}\\n/**\\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\\n *\\n * @template {HastNodes} Type\\n *   Node type.\\n * @param {MdastNodes} from\\n *   mdast node to use data from.\\n * @param {Type} to\\n *   hast node to change.\\n * @returns {Type | HastElement}\\n *   Nothing.\\n */\\n\\n\\nfunction applyData(from, to) {\\n  /** @type {Type | HastElement} */\\n  let result = to; // Handle `data.hName`, `data.hProperties, `data.hChildren`.\\n\\n  if (from && from.data) {\\n    const hName = from.data.hName;\\n    const hChildren = from.data.hChildren;\\n    const hProperties = from.data.hProperties;\\n\\n    if (typeof hName === 'string') {\\n      // Transforming the node resulted in an element with a different name\\n      // than wanted:\\n      if (result.type === 'element') {\\n        result.tagName = hName;\\n      } // Transforming the node resulted in a non-element, which happens for\\n      // raw, text, and root nodes (unless custom handlers are passed).\\n      // The intent is likely to keep the content around (otherwise: pass\\n      // `hChildren`).\\n      else {\\n        result = {\\n          type: 'element',\\n          tagName: hName,\\n          properties: {},\\n          children: []\\n        }; // To do: next major: take the children from the `root`, or inject the\\n        // raw/text/comment or so into the element?\\n        // if ('children' in node) {\\n        //   // @ts-expect-error: assume `children` are allowed in elements.\\n        //   result.children = node.children\\n        // } else {\\n        //   // @ts-expect-error: assume `node` is allowed in elements.\\n        //   result.children.push(node)\\n        // }\\n      }\\n    }\\n\\n    if (result.type === 'element' && hProperties) {\\n      result.properties = { ...result.properties,\\n        ...hProperties\\n      };\\n    }\\n\\n    if ('children' in result && result.children && hChildren !== null && hChildren !== undefined) {\\n      // @ts-expect-error: assume valid children are defined.\\n      result.children = hChildren;\\n    }\\n  }\\n\\n  return result;\\n}\\n/**\\n * Transform an mdast node into a hast node.\\n *\\n * @param {State} state\\n *   Info passed around.\\n * @param {MdastNodes} node\\n *   mdast node.\\n * @param {MdastParents | null | undefined} [parent]\\n *   Parent of `node`.\\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\\n *   Resulting hast node.\\n */\\n// To do: next major: do not expose, keep bound.\\n\\n\\nfunction one(state, node, parent) {\\n  const type = node && node.type; // Fail on non-nodes.\\n\\n  if (!type) {\\n    throw new Error('Expected node, got `' + node + '`');\\n  }\\n\\n  if (own.call(state.handlers, type)) {\\n    return state.handlers[type](state, node, parent);\\n  }\\n\\n  if (state.passThrough && state.passThrough.includes(type)) {\\n    // To do: next major: deep clone.\\n    // @ts-expect-error: types of passed through nodes are expected to be added manually.\\n    return 'children' in node ? { ...node,\\n      children: all(state, node)\\n    } : node;\\n  }\\n\\n  if (state.unknownHandler) {\\n    return state.unknownHandler(state, node, parent);\\n  }\\n\\n  return defaultUnknownHandler(state, node);\\n}\\n/**\\n * Transform the children of an mdast node into hast nodes.\\n *\\n * @param {State} state\\n *   Info passed around.\\n * @param {MdastNodes} parent\\n *   mdast node to compile\\n * @returns {Array<HastElementContent>}\\n *   Resulting hast nodes.\\n */\\n// To do: next major: do not expose, keep bound.\\n\\n\\nfunction all(state, parent) {\\n  /** @type {Array<HastElementContent>} */\\n  const values = [];\\n\\n  if ('children' in parent) {\\n    const nodes = parent.children;\\n    let index = -1;\\n\\n    while (++index < nodes.length) {\\n      const result = one(state, nodes[index], parent); // To do: see if we van clean this? Can we merge texts?\\n\\n      if (result) {\\n        if (index && nodes[index - 1].type === 'break') {\\n          if (!Array.isArray(result) && result.type === 'text') {\\n            result.value = result.value.replace(/^\\\\s+/, '');\\n          }\\n\\n          if (!Array.isArray(result) && result.type === 'element') {\\n            const head = result.children[0];\\n\\n            if (head && head.type === 'text') {\\n              head.value = head.value.replace(/^\\\\s+/, '');\\n            }\\n          }\\n        }\\n\\n        if (Array.isArray(result)) {\\n          values.push(...result);\\n        } else {\\n          values.push(result);\\n        }\\n      }\\n    }\\n  }\\n\\n  return values;\\n}\\n/**\\n * Transform an unknown node.\\n *\\n * @param {State} state\\n *   Info passed around.\\n * @param {MdastNodes} node\\n *   Unknown mdast node.\\n * @returns {HastText | HastElement}\\n *   Resulting hast node.\\n */\\n\\n\\nfunction defaultUnknownHandler(state, node) {\\n  const data = node.data || {};\\n  /** @type {HastText | HastElement} */\\n\\n  const result = 'value' in node && !(own.call(data, 'hProperties') || own.call(data, 'hChildren')) ? {\\n    type: 'text',\\n    value: node.value\\n  } : {\\n    type: 'element',\\n    tagName: 'div',\\n    properties: {},\\n    children: all(state, node)\\n  };\\n  state.patch(node, result);\\n  return state.applyData(node, result);\\n}\\n/**\\n * Wrap `nodes` with line endings between each node.\\n *\\n * @template {HastContent} Type\\n *   Node type.\\n * @param {Array<Type>} nodes\\n *   List of nodes to wrap.\\n * @param {boolean | null | undefined} [loose=false]\\n *   Whether to add line endings at start and end.\\n * @returns {Array<Type | HastText>}\\n *   Wrapped nodes.\\n */\\n\\n\\nfunction wrap(nodes, loose) {\\n  /** @type {Array<Type | HastText>} */\\n  const result = [];\\n  let index = -1;\\n\\n  if (loose) {\\n    result.push({\\n      type: 'text',\\n      value: '\\\\n'\\n    });\\n  }\\n\\n  while (++index < nodes.length) {\\n    if (index) result.push({\\n      type: 'text',\\n      value: '\\\\n'\\n    });\\n    result.push(nodes[index]);\\n  }\\n\\n  if (loose && nodes.length > 0) {\\n    result.push({\\n      type: 'text',\\n      value: '\\\\n'\\n    });\\n  }\\n\\n  return result;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"patch\",\"from\",\"to\",\"position\",\"_unistUtilPosition\",\"applyData\",\"data\",\"hName\",\"hChildren\",\"hProperties\",\"result\",\"type\",\"tagName\",\"properties\",\"children\",\"undefined\",\"one\",\"state\",\"node\",\"parent\",\"Error\",\"own\",\"call\",\"handlers\",\"passThrough\",\"includes\",\"all\",\"unknownHandler\",\"value\",\"values\",\"nodes\",\"index\",\"length\",\"Array\",\"isArray\",\"replace\",\"head\",\"push\",\"wrap\",\"loose\",\"Object\",\"defineProperty\",\"createState\",\"tree\",\"options\",\"augment\",\"left\",\"right\",\"ctx\",\"_unistUtilGenerated\",\"generated\",\"start\",\"pointStart\",\"end\",\"pointEnd\",\"props\",\"settings\",\"footnoteById\",\"dangerous\",\"allowDangerousHtml\",\"clobberPrefix\",\"footnoteLabel\",\"footnoteLabelTagName\",\"footnoteLabelProperties\",\"className\",\"footnoteBackLabel\",\"_index\",\"definition\",\"_mdastUtilDefinitions\",\"definitions\",\"footnoteOrder\",\"footnoteCounts\",\"oneBound\",\"allBound\",\"_unistUtilVisit\",\"visit\",\"id\",\"String\",\"identifier\",\"toUpperCase\",\"hasOwnProperty\"]\n}\n"]