["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hast-util-to-string/index.js"],"~:js","shadow$provide.module$node_modules$hast_util_to_string$index=function(global,require,module,exports){function all(node){let index=-1;const result=[];for(;++index<node.children.length;){var JSCompiler_temp_const=index;var JSCompiler_inline_result=node.children[index];JSCompiler_inline_result=\"text\"===JSCompiler_inline_result.type?JSCompiler_inline_result.value:\"children\"in JSCompiler_inline_result?all(JSCompiler_inline_result):\"\";result[JSCompiler_temp_const]=JSCompiler_inline_result}return result.join(\"\")}\nObject.defineProperty(exports,\"__esModule\",{value:!0});exports.toString=function(node){return\"children\"in node?all(node):\"value\"in node?node.value:\"\"}}","~:source","shadow$provide[\"module$node_modules$hast_util_to_string$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toString = toString;\n\n/**\n * @fileoverview\n *   Get the plain-text value of a hast node.\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {h} from 'hastscript'\n *   import {toString} from 'hast-util-to-string'\n *\n *   toString(h('p', 'Alpha'))\n *   //=> 'Alpha'\n *   toString(h('div', [h('b', 'Bold'), ' and ', h('i', 'italic'), '.']))\n *   //=> 'Bold and italic.'\n *   ```\n *\n *   ## API\n *\n *   ### `toString(node)`\n *\n *   Transform a node to a string.\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {Root|Root['children'][number]} Node\n */\n\n/**\n * Get the plain-text value of a hast node.\n *\n * @param {Node} node\n * @returns {string}\n */\nfunction toString(node) {\n  // “The concatenation of data of all the Text node descendants of the context\n  // object, in tree order.”\n  if ('children' in node) {\n    return all(node);\n  } // “Context object’s data.”\n\n\n  return 'value' in node ? node.value : '';\n}\n/**\n * @param {Node} node\n * @returns {string}\n */\n\n\nfunction one(node) {\n  if (node.type === 'text') {\n    return node.value;\n  }\n\n  return 'children' in node ? all(node) : '';\n}\n/**\n * @param {Root|Element} node\n * @returns {string}\n */\n\n\nfunction all(node) {\n  let index = -1;\n  /** @type {string[]} */\n\n  const result = [];\n\n  while (++index < node.children.length) {\n    result[index] = one(node.children[index]);\n  }\n\n  return result.join('');\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["__esModule","toString","value"]],"~:compiled-at",1676841365351,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hast_util_to_string$index.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,6CAAA,CAAkE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAwE1GC,QAASA,IAAG,CAACC,IAAD,CAAO,CACjB,IAAIC,MAAQ,CAAC,CAGb,OAAMC,OAAS,EAEf,KAAA,CAAO,EAAED,KAAT,CAAiBD,IAAKG,CAAAA,QAASC,CAAAA,MAA/B,CAAA,CAAuC,CAC9BH,IAAAA,sBAAAA,KAAa,KAAA,yBAAAD,IAAKG,CAAAA,QAAL,CAAcF,KAAd,CAlBpB,yBAAA,CADgB,MAAlB,GAAID,wBAAKK,CAAAA,IAAT,CACSL,wBAAKM,CAAAA,KADd,CAIO,UAAA,EAAcN,yBAAd,CAAqBD,GAAA,CAAIC,wBAAJ,CAArB,CAAiC,EAetCE,OAAA,CAAOD,qBAAP,CAAA,CAAgB,wBADqB,CAIvC,MAAOC,OAAOK,CAAAA,IAAP,CAAY,EAAZ,CAVU;AArEnBC,MAAOC,CAAAA,cAAP,CAAsBX,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CQ,MAAO,CAAA,CADoC,CAA7C,CAGAR,QAAQY,CAAAA,QAAR,CAqCAA,QAAiB,CAACV,IAAD,CAAO,CAGtB,MAAI,UAAJ,EAAkBA,KAAlB,CACSD,GAAA,CAAIC,IAAJ,CADT,CAKO,OAAA,EAAWA,KAAX,CAAkBA,IAAKM,CAAAA,KAAvB,CAA+B,EARhB,CA3CkF;\",\n\"sources\":[\"node_modules/hast-util-to-string/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hast_util_to_string$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.toString = toString;\\n\\n/**\\n * @fileoverview\\n *   Get the plain-text value of a hast node.\\n * @longdescription\\n *   ## Use\\n *\\n *   ```js\\n *   import {h} from 'hastscript'\\n *   import {toString} from 'hast-util-to-string'\\n *\\n *   toString(h('p', 'Alpha'))\\n *   //=> 'Alpha'\\n *   toString(h('div', [h('b', 'Bold'), ' and ', h('i', 'italic'), '.']))\\n *   //=> 'Bold and italic.'\\n *   ```\\n *\\n *   ## API\\n *\\n *   ### `toString(node)`\\n *\\n *   Transform a node to a string.\\n */\\n\\n/**\\n * @typedef {import('hast').Root} Root\\n * @typedef {import('hast').Element} Element\\n * @typedef {Root|Root['children'][number]} Node\\n */\\n\\n/**\\n * Get the plain-text value of a hast node.\\n *\\n * @param {Node} node\\n * @returns {string}\\n */\\nfunction toString(node) {\\n  // \\u201cThe concatenation of data of all the Text node descendants of the context\\n  // object, in tree order.\\u201d\\n  if ('children' in node) {\\n    return all(node);\\n  } // \\u201cContext object\\u2019s data.\\u201d\\n\\n\\n  return 'value' in node ? node.value : '';\\n}\\n/**\\n * @param {Node} node\\n * @returns {string}\\n */\\n\\n\\nfunction one(node) {\\n  if (node.type === 'text') {\\n    return node.value;\\n  }\\n\\n  return 'children' in node ? all(node) : '';\\n}\\n/**\\n * @param {Root|Element} node\\n * @returns {string}\\n */\\n\\n\\nfunction all(node) {\\n  let index = -1;\\n  /** @type {string[]} */\\n\\n  const result = [];\\n\\n  while (++index < node.children.length) {\\n    result[index] = one(node.children[index]);\\n  }\\n\\n  return result.join('');\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"all\",\"node\",\"index\",\"result\",\"children\",\"length\",\"type\",\"value\",\"join\",\"Object\",\"defineProperty\",\"toString\"]\n}\n"]