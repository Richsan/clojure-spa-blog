["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark/lib/initialize/text.js"],"~:js","shadow$provide.module$node_modules$micromark$lib$initialize$text=function(global,require,module,exports){function initializeFactory(field){return{tokenize:function(effects){function start(code){return atBreak(code)?text(code):notText(code)}function notText(code){if(null===code)effects.consume(code);else return effects.enter(\"data\"),effects.consume(code),data}function data(code){if(atBreak(code))return effects.exit(\"data\"),text(code);effects.consume(code);return data}function atBreak(code){if(null===\ncode)return!0;code=constructs[code];let index=-1;if(code)for(;++index<code.length;){const item=code[index];if(!item.previous||item.previous.call(self,self.previous))return!0}return!1}const self=this,constructs=this.parser.constructs[field],text=effects.attempt(constructs,start,notText);return start},resolveAll:createResolver(\"text\"===field?resolveAllLineSuffixes:void 0)}}function createResolver(extraResolver){return function(events,context){let index=-1,enter;for(;++index<=events.length;)void 0===\nenter?events[index]&&\"data\"===events[index][1].type&&(enter=index,index++):events[index]&&\"data\"===events[index][1].type||(index!==enter+2&&(events[enter][1].end=events[index-1][1].end,events.splice(enter+2,index-enter-2),index=enter+2),enter=void 0);return extraResolver?extraResolver(events,context):events}}function resolveAllLineSuffixes(events,context){let eventIndex=0;for(;++eventIndex<=events.length;)if((eventIndex===events.length||\"lineEnding\"===events[eventIndex][1].type)&&\"data\"===events[eventIndex-\n1][1].type){const data=events[eventIndex-1][1];var chunks=context.sliceStream(data);let index=chunks.length,bufferIndex=-1,size=0,tabs;for(;index--;){const chunk=chunks[index];if(\"string\"===typeof chunk){for(bufferIndex=chunk.length;32===chunk.charCodeAt(bufferIndex-1);)size++,bufferIndex--;if(bufferIndex)break;bufferIndex=-1}else if(-2===chunk)tabs=!0,size++;else if(-1!==chunk){index++;break}}size&&(chunks={type:eventIndex===events.length||tabs||2>size?\"lineSuffix\":\"hardBreakTrailing\",start:{line:data.end.line,\ncolumn:data.end.column-size,offset:data.end.offset-size,_index:data.start._index+index,_bufferIndex:index?bufferIndex:data.start._bufferIndex+bufferIndex},end:Object.assign({},data.end)},data.end=Object.assign({},chunks.start),data.start.offset===data.end.offset?Object.assign(data,chunks):(events.splice(eventIndex,0,[\"enter\",chunks,context],[\"exit\",chunks,context]),eventIndex+=2));eventIndex++}return events}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.text=exports.string=exports.resolver=\nvoid 0;global={resolveAll:createResolver()};exports.resolver=global;global=initializeFactory(\"string\");exports.string=global;global=initializeFactory(\"text\");exports.text=global}","~:source","shadow$provide[\"module$node_modules$micromark$lib$initialize$text\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.text = exports.string = exports.resolver = void 0;\n\n/**\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nconst resolver = {\n  resolveAll: createResolver()\n};\nexports.resolver = resolver;\nconst string = initializeFactory('string');\nexports.string = string;\nconst text = initializeFactory('text');\n/**\n * @param {'string'|'text'} field\n * @returns {InitialConstruct}\n */\n\nexports.text = text;\n\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(field === 'text' ? resolveAllLineSuffixes : undefined)\n  };\n  /** @type {Initializer} */\n\n  function initializeText(effects) {\n    const self = this;\n    const constructs = this.parser.constructs[field];\n    const text = effects.attempt(constructs, start, notText);\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code);\n    }\n    /** @type {State} */\n\n\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code);\n        return;\n      }\n\n      effects.enter('data');\n      effects.consume(code);\n      return data;\n    }\n    /** @type {State} */\n\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data');\n        return text(code);\n      } // Data.\n\n\n      effects.consume(code);\n      return data;\n    }\n    /**\n     * @param {Code} code\n     * @returns {boolean}\n     */\n\n\n    function atBreak(code) {\n      if (code === null) {\n        return true;\n      }\n\n      const list = constructs[code];\n      let index = -1;\n\n      if (list) {\n        while (++index < list.length) {\n          const item = list[index];\n\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  }\n}\n/**\n * @param {Resolver} [extraResolver]\n * @returns {Resolver}\n */\n\n\nfunction createResolver(extraResolver) {\n  return resolveAllText;\n  /** @type {Resolver} */\n\n  function resolveAllText(events, context) {\n    let index = -1;\n    /** @type {number|undefined} */\n\n    let enter; // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index;\n          index++;\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end;\n          events.splice(enter + 2, index - enter - 2);\n          index = enter + 2;\n        }\n\n        enter = undefined;\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events;\n  }\n}\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we can’t hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\n\n\nfunction resolveAllLineSuffixes(events, context) {\n  let eventIndex = 0; // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if ((eventIndex === events.length || events[eventIndex][1].type === 'lineEnding') && events[eventIndex - 1][1].type === 'data') {\n      const data = events[eventIndex - 1][1];\n      const chunks = context.sliceStream(data);\n      let index = chunks.length;\n      let bufferIndex = -1;\n      let size = 0;\n      /** @type {boolean|undefined} */\n\n      let tabs;\n\n      while (index--) {\n        const chunk = chunks[index];\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length;\n\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++;\n            bufferIndex--;\n          }\n\n          if (bufferIndex) break;\n          bufferIndex = -1;\n        } // Number\n        else if (chunk === -2) {\n          tabs = true;\n          size++;\n        } else if (chunk === -1) {// Empty\n        } else {\n          // Replacement character, exit.\n          index++;\n          break;\n        }\n      }\n\n      if (size) {\n        const token = {\n          type: eventIndex === events.length || tabs || size < 2 ? 'lineSuffix' : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex\n          },\n          end: Object.assign({}, data.end)\n        };\n        data.end = Object.assign({}, token.start);\n\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token);\n        } else {\n          events.splice(eventIndex, 0, ['enter', token, context], ['exit', token, context]);\n          eventIndex += 2;\n        }\n      }\n\n      eventIndex++;\n    }\n  }\n\n  return events;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["resolver","resolveAll","string","tokenize","offset","__esModule","value","start","text","line","column","type","_bufferIndex","_index","end"]],"~:compiled-at",1676665867299,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark$lib$initialize$text.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark/lib/initialize/text.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark$lib$initialize$text\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.text = exports.string = exports.resolver = void 0;\\n\\n/**\\n * @typedef {import('micromark-util-types').Resolver} Resolver\\n * @typedef {import('micromark-util-types').Initializer} Initializer\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\\n * @typedef {import('micromark-util-types').State} State\\n * @typedef {import('micromark-util-types').Code} Code\\n */\\nconst resolver = {\\n  resolveAll: createResolver()\\n};\\nexports.resolver = resolver;\\nconst string = initializeFactory('string');\\nexports.string = string;\\nconst text = initializeFactory('text');\\n/**\\n * @param {'string'|'text'} field\\n * @returns {InitialConstruct}\\n */\\n\\nexports.text = text;\\n\\nfunction initializeFactory(field) {\\n  return {\\n    tokenize: initializeText,\\n    resolveAll: createResolver(field === 'text' ? resolveAllLineSuffixes : undefined)\\n  };\\n  /** @type {Initializer} */\\n\\n  function initializeText(effects) {\\n    const self = this;\\n    const constructs = this.parser.constructs[field];\\n    const text = effects.attempt(constructs, start, notText);\\n    return start;\\n    /** @type {State} */\\n\\n    function start(code) {\\n      return atBreak(code) ? text(code) : notText(code);\\n    }\\n    /** @type {State} */\\n\\n\\n    function notText(code) {\\n      if (code === null) {\\n        effects.consume(code);\\n        return;\\n      }\\n\\n      effects.enter('data');\\n      effects.consume(code);\\n      return data;\\n    }\\n    /** @type {State} */\\n\\n\\n    function data(code) {\\n      if (atBreak(code)) {\\n        effects.exit('data');\\n        return text(code);\\n      } // Data.\\n\\n\\n      effects.consume(code);\\n      return data;\\n    }\\n    /**\\n     * @param {Code} code\\n     * @returns {boolean}\\n     */\\n\\n\\n    function atBreak(code) {\\n      if (code === null) {\\n        return true;\\n      }\\n\\n      const list = constructs[code];\\n      let index = -1;\\n\\n      if (list) {\\n        while (++index < list.length) {\\n          const item = list[index];\\n\\n          if (!item.previous || item.previous.call(self, self.previous)) {\\n            return true;\\n          }\\n        }\\n      }\\n\\n      return false;\\n    }\\n  }\\n}\\n/**\\n * @param {Resolver} [extraResolver]\\n * @returns {Resolver}\\n */\\n\\n\\nfunction createResolver(extraResolver) {\\n  return resolveAllText;\\n  /** @type {Resolver} */\\n\\n  function resolveAllText(events, context) {\\n    let index = -1;\\n    /** @type {number|undefined} */\\n\\n    let enter; // A rather boring computation (to merge adjacent `data` events) which\\n    // improves mm performance by 29%.\\n\\n    while (++index <= events.length) {\\n      if (enter === undefined) {\\n        if (events[index] && events[index][1].type === 'data') {\\n          enter = index;\\n          index++;\\n        }\\n      } else if (!events[index] || events[index][1].type !== 'data') {\\n        // Don\\u2019t do anything if there is one data token.\\n        if (index !== enter + 2) {\\n          events[enter][1].end = events[index - 1][1].end;\\n          events.splice(enter + 2, index - enter - 2);\\n          index = enter + 2;\\n        }\\n\\n        enter = undefined;\\n      }\\n    }\\n\\n    return extraResolver ? extraResolver(events, context) : events;\\n  }\\n}\\n/**\\n * A rather ugly set of instructions which again looks at chunks in the input\\n * stream.\\n * The reason to do this here is that it is *much* faster to parse in reverse.\\n * And that we can\\u2019t hook into `null` to split the line suffix before an EOF.\\n * To do: figure out if we can make this into a clean utility, or even in core.\\n * As it will be useful for GFMs literal autolink extension (and maybe even\\n * tables?)\\n *\\n * @type {Resolver}\\n */\\n\\n\\nfunction resolveAllLineSuffixes(events, context) {\\n  let eventIndex = 0; // Skip first.\\n\\n  while (++eventIndex <= events.length) {\\n    if ((eventIndex === events.length || events[eventIndex][1].type === 'lineEnding') && events[eventIndex - 1][1].type === 'data') {\\n      const data = events[eventIndex - 1][1];\\n      const chunks = context.sliceStream(data);\\n      let index = chunks.length;\\n      let bufferIndex = -1;\\n      let size = 0;\\n      /** @type {boolean|undefined} */\\n\\n      let tabs;\\n\\n      while (index--) {\\n        const chunk = chunks[index];\\n\\n        if (typeof chunk === 'string') {\\n          bufferIndex = chunk.length;\\n\\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\\n            size++;\\n            bufferIndex--;\\n          }\\n\\n          if (bufferIndex) break;\\n          bufferIndex = -1;\\n        } // Number\\n        else if (chunk === -2) {\\n          tabs = true;\\n          size++;\\n        } else if (chunk === -1) {// Empty\\n        } else {\\n          // Replacement character, exit.\\n          index++;\\n          break;\\n        }\\n      }\\n\\n      if (size) {\\n        const token = {\\n          type: eventIndex === events.length || tabs || size < 2 ? 'lineSuffix' : 'hardBreakTrailing',\\n          start: {\\n            line: data.end.line,\\n            column: data.end.column - size,\\n            offset: data.end.offset - size,\\n            _index: data.start._index + index,\\n            _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex\\n          },\\n          end: Object.assign({}, data.end)\\n        };\\n        data.end = Object.assign({}, token.start);\\n\\n        if (data.start.offset === data.end.offset) {\\n          Object.assign(data, token);\\n        } else {\\n          events.splice(eventIndex, 0, ['enter', token, context], ['exit', token, context]);\\n          eventIndex += 2;\\n        }\\n      }\\n\\n      eventIndex++;\\n    }\\n  }\\n\\n  return events;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"initializeFactory\",\"field\",\"tokenize\",\"initializeText\",\"effects\",\"start\",\"code\",\"atBreak\",\"text\",\"notText\",\"consume\",\"enter\",\"data\",\"exit\",\"list\",\"constructs\",\"index\",\"length\",\"item\",\"previous\",\"call\",\"self\",\"parser\",\"attempt\",\"resolveAll\",\"createResolver\",\"resolveAllLineSuffixes\",\"undefined\",\"extraResolver\",\"resolveAllText\",\"events\",\"context\",\"type\",\"end\",\"splice\",\"eventIndex\",\"chunks\",\"sliceStream\",\"bufferIndex\",\"size\",\"tabs\",\"chunk\",\"charCodeAt\",\"token\",\"line\",\"column\",\"offset\",\"_index\",\"_bufferIndex\",\"Object\",\"assign\",\"defineProperty\",\"value\",\"string\",\"resolver\"]\n}\n"]