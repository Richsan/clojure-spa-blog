["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mdast-util-math/lib/index.js"],"~:js","shadow$provide.module$node_modules$mdast_util_math$lib$index=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.mathFromMarkdown=function(){function exitMathData(token){this.config.enter.data.call(this,token);this.config.exit.data.call(this,token)}return{enter:{mathFlow:function(token){this.enter({type:\"math\",meta:null,value:\"\",data:{hName:\"div\",hProperties:{className:[\"math\",\"math-display\"]},hChildren:[{type:\"text\",value:\"\"}]}},token)},mathFlowFenceMeta:function(){this.buffer()},\nmathText:function(token){this.enter({type:\"inlineMath\",value:\"\",data:{hName:\"span\",hProperties:{className:[\"math\",\"math-inline\"]},hChildren:[{type:\"text\",value:\"\"}]}},token);this.buffer()}},exit:{mathFlow:function(token){const data=this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g,\"\");token=this.exit(token);token.value=data;token.data.hChildren[0].value=data;this.setData(\"mathFlowInside\")},mathFlowFence:function(){this.getData(\"mathFlowInside\")||(this.buffer(),this.setData(\"mathFlowInside\",!0))},mathFlowFenceMeta:function(){const data=\nthis.resume();this.stack[this.stack.length-1].meta=data},mathFlowValue:exitMathData,mathText:function(token){const data=this.resume();token=this.exit(token);token.value=data;token.data.hChildren[0].value=data},mathTextData:exitMathData}}};exports.mathToMarkdown=function(options){function inlineMath(node,_,context){node=node.value||\"\";_=1;for(single||_++;(new RegExp(\"(^|[^$])\"+\"\\\\$\".repeat(_)+\"([^$]|$)\")).test(node);)_++;_=\"$\".repeat(_);/[^ \\r\\n]/.test(node)&&(/^[ \\r\\n]/.test(node)&&/[ \\r\\n]$/.test(node)||\n/^\\$|\\$$/.test(node))&&(node=\" \"+node+\" \");let index=-1;for(;++index<context.unsafe.length;){var pattern=context.unsafe[index];const expression=(0,_patternCompile.patternCompile)(pattern);if(pattern.atBreak)for(;pattern=expression.exec(node);){let position=pattern.index;10===node.codePointAt(position)&&13===node.codePointAt(position-1)&&position--;node=node.slice(0,position)+\" \"+node.slice(pattern.index+1)}}return _+node+_}let single=(options||{}).singleDollarTextMath;if(null===single||void 0===single)single=\n!0;inlineMath.peek=function(){return\"$\"};return{unsafe:[{character:\"\\r\",inConstruct:\"mathFlowMeta\"},{character:\"\\n\",inConstruct:\"mathFlowMeta\"},{character:\"$\",after:single?void 0:\"\\\\$\",inConstruct:\"phrasing\"},{character:\"$\",inConstruct:\"mathFlowMeta\"},{atBreak:!0,character:\"$\",after:\"\\\\$\"}],handlers:{math:function(node,_,context,safeOptions){_=node.value||\"\";safeOptions=(0,_track.track)(safeOptions);const sequence=\"$\".repeat(Math.max((0,_longestStreak.longestStreak)(_,\"$\")+1,2)),exit=context.enter(\"mathFlow\");\nlet value=safeOptions.move(sequence);if(node.meta){const subexit=context.enter(\"mathFlowMeta\");value+=safeOptions.move((0,_safe.safe)(context,node.meta,{before:value,after:\"\\n\",encode:[\"$\"],...safeOptions.current()}));subexit()}value+=safeOptions.move(\"\\n\");_&&(value+=safeOptions.move(_+\"\\n\"));value+=safeOptions.move(sequence);exit();return value},inlineMath}}};var _longestStreak=require(\"module$node_modules$longest_streak$index\"),_safe=require(\"module$node_modules$mdast_util_to_markdown$lib$util$safe\"),\n_track=require(\"module$node_modules$mdast_util_to_markdown$lib$util$track\"),_patternCompile=require(\"module$node_modules$mdast_util_to_markdown$lib$util$pattern_compile\")}","~:source","shadow$provide[\"module$node_modules$mdast_util_math$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mathFromMarkdown = mathFromMarkdown;\nexports.mathToMarkdown = mathToMarkdown;\n\nvar _longestStreak = require(\"longest-streak\");\n\nvar _safe = require(\"mdast-util-to-markdown/lib/util/safe.js\");\n\nvar _track = require(\"mdast-util-to-markdown/lib/util/track.js\");\n\nvar _patternCompile = require(\"mdast-util-to-markdown/lib/util/pattern-compile.js\");\n\n/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nfunction mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  };\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n\n  function enterMathFlow(token) {\n    this.enter({\n      type: 'math',\n      meta: null,\n      value: '',\n      data: {\n        hName: 'div',\n        hProperties: {\n          className: ['math', 'math-display']\n        },\n        hChildren: [{\n          type: 'text',\n          value: ''\n        }]\n      }\n    }, token);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n\n\n  function enterMathFlowMeta() {\n    this.buffer();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n\n\n  function exitMathFlowMeta() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n\n\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return;\n    this.buffer();\n    this.setData('mathFlowInside', true);\n  }\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n\n\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    const node = this.exit(token);\n    node.value = data; // @ts-expect-error: we defined it.\n\n    node.data.hChildren[0].value = data;\n    this.setData('mathFlowInside');\n  }\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n\n\n  function enterMathText(token) {\n    this.enter({\n      type: 'inlineMath',\n      value: '',\n      data: {\n        hName: 'span',\n        hProperties: {\n          className: ['math', 'math-inline']\n        },\n        hChildren: [{\n          type: 'text',\n          value: ''\n        }]\n      }\n    }, token);\n    this.buffer();\n  }\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n\n\n  function exitMathText(token) {\n    const data = this.resume();\n    const node = this.exit(token);\n    node.value = data; // @ts-expect-error: we defined it.\n\n    node.data.hChildren[0].value = data;\n  }\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n\n\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token);\n    this.config.exit.data.call(this, token);\n  }\n}\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\n\n\nfunction mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath;\n\n  if (single === null || single === undefined) {\n    single = true;\n  }\n\n  inlineMath.peek = inlineMathPeek;\n  return {\n    unsafe: [{\n      character: '\\r',\n      inConstruct: 'mathFlowMeta'\n    }, {\n      character: '\\n',\n      inConstruct: 'mathFlowMeta'\n    }, {\n      character: '$',\n      after: single ? undefined : '\\\\$',\n      inConstruct: 'phrasing'\n    }, {\n      character: '$',\n      inConstruct: 'mathFlowMeta'\n    }, {\n      atBreak: true,\n      character: '$',\n      after: '\\\\$'\n    }],\n    handlers: {\n      math,\n      inlineMath\n    }\n  };\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // To do: next major: rename `context` to state, `safeOptions` to info.\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || '';\n    const tracker = (0, _track.track)(safeOptions);\n    const sequence = '$'.repeat(Math.max((0, _longestStreak.longestStreak)(raw, '$') + 1, 2));\n    const exit = context.enter('mathFlow');\n    let value = tracker.move(sequence);\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta');\n      value += tracker.move((0, _safe.safe)(context, node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['$'],\n        ...tracker.current()\n      }));\n      subexit();\n    }\n\n    value += tracker.move('\\n');\n\n    if (raw) {\n      value += tracker.move(raw + '\\n');\n    }\n\n    value += tracker.move(sequence);\n    exit();\n    return value;\n  }\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  //\n  // To do: next major: rename `context` to state.\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n\n\n  function inlineMath(node, _, context) {\n    let value = node.value || '';\n    let size = 1;\n    if (!single) size++; // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n\n    while (new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)) {\n      size++;\n    }\n\n    const sequence = '$'.repeat(size); // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n\n    if ( // Contains non-space.\n    /[^ \\r\\n]/.test(value) && (/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) || // Starts or ends with dollar.\n    /^\\$|\\$$/.test(value))) {\n      value = ' ' + value + ' ';\n    }\n\n    let index = -1; // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n\n    while (++index < context.unsafe.length) {\n      const pattern = context.unsafe[index];\n      const expression = (0, _patternCompile.patternCompile)(pattern);\n      /** @type {RegExpExecArray | null} */\n\n      let match; // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n\n      if (!pattern.atBreak) continue;\n\n      while (match = expression.exec(value)) {\n        let position = match.index; // Support CRLF (patterns only look for one of the characters).\n\n        if (value.codePointAt(position) === 10\n        /* `\\n` */\n        && value.codePointAt(position - 1) === 13\n        /* `\\r` */\n        ) {\n          position--;\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\n      }\n    }\n\n    return sequence + value + sequence;\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  function inlineMathPeek() {\n    return '$';\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mdast_util_to_markdown$lib$util$track","~$shadow.js","~$module$node_modules$longest_streak$index","~$module$node_modules$mdast_util_to_markdown$lib$util$safe","~$module$node_modules$mdast_util_to_markdown$lib$util$pattern_compile"]],"~:properties",["^5",["peek","mathFlow","after","mathFromMarkdown","hChildren","handlers","className","__esModule","hName","mathFlowFenceMeta","mathFlowValue","unsafe","mathFlowFence","math","value","mathTextData","character","inlineMath","mathText","inConstruct","atBreak","type","meta","mathToMarkdown","hProperties","exit","before","data","encode","enter"]],"~:compiled-at",1676667584528,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mdast_util_math$lib$index.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mdast-util-math/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mdast_util_math$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.mathFromMarkdown = mathFromMarkdown;\\nexports.mathToMarkdown = mathToMarkdown;\\n\\nvar _longestStreak = require(\\\"longest-streak\\\");\\n\\nvar _safe = require(\\\"mdast-util-to-markdown/lib/util/safe.js\\\");\\n\\nvar _track = require(\\\"mdast-util-to-markdown/lib/util/track.js\\\");\\n\\nvar _patternCompile = require(\\\"mdast-util-to-markdown/lib/util/pattern-compile.js\\\");\\n\\n/**\\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\\n * @typedef {import('../index.js').Math} Math\\n * @typedef {import('../index.js').InlineMath} InlineMath\\n *\\n * @typedef ToOptions\\n *   Configuration.\\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\\n *   Whether to support math (text) with a single dollar.\\n *\\n *   Single dollars work in Pandoc and many other places, but often interfere\\n *   with \\u201cnormal\\u201d dollars in text.\\n *   If you turn this off, you can still use two or more dollars for text math.\\n */\\n\\n/**\\n * Create an extension for `mdast-util-from-markdown`.\\n *\\n * @returns {FromMarkdownExtension}\\n *   Extension for `mdast-util-from-markdown`.\\n */\\nfunction mathFromMarkdown() {\\n  return {\\n    enter: {\\n      mathFlow: enterMathFlow,\\n      mathFlowFenceMeta: enterMathFlowMeta,\\n      mathText: enterMathText\\n    },\\n    exit: {\\n      mathFlow: exitMathFlow,\\n      mathFlowFence: exitMathFlowFence,\\n      mathFlowFenceMeta: exitMathFlowMeta,\\n      mathFlowValue: exitMathData,\\n      mathText: exitMathText,\\n      mathTextData: exitMathData\\n    }\\n  };\\n  /**\\n   * @this {CompileContext}\\n   * @type {FromMarkdownHandle}\\n   */\\n\\n  function enterMathFlow(token) {\\n    this.enter({\\n      type: 'math',\\n      meta: null,\\n      value: '',\\n      data: {\\n        hName: 'div',\\n        hProperties: {\\n          className: ['math', 'math-display']\\n        },\\n        hChildren: [{\\n          type: 'text',\\n          value: ''\\n        }]\\n      }\\n    }, token);\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {FromMarkdownHandle}\\n   */\\n\\n\\n  function enterMathFlowMeta() {\\n    this.buffer();\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {FromMarkdownHandle}\\n   */\\n\\n\\n  function exitMathFlowMeta() {\\n    const data = this.resume();\\n    const node = this.stack[this.stack.length - 1];\\n    node.meta = data;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {FromMarkdownHandle}\\n   */\\n\\n\\n  function exitMathFlowFence() {\\n    // Exit if this is the closing fence.\\n    if (this.getData('mathFlowInside')) return;\\n    this.buffer();\\n    this.setData('mathFlowInside', true);\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {FromMarkdownHandle}\\n   */\\n\\n\\n  function exitMathFlow(token) {\\n    const data = this.resume().replace(/^(\\\\r?\\\\n|\\\\r)|(\\\\r?\\\\n|\\\\r)$/g, '');\\n    const node = this.exit(token);\\n    node.value = data; // @ts-expect-error: we defined it.\\n\\n    node.data.hChildren[0].value = data;\\n    this.setData('mathFlowInside');\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {FromMarkdownHandle}\\n   */\\n\\n\\n  function enterMathText(token) {\\n    this.enter({\\n      type: 'inlineMath',\\n      value: '',\\n      data: {\\n        hName: 'span',\\n        hProperties: {\\n          className: ['math', 'math-inline']\\n        },\\n        hChildren: [{\\n          type: 'text',\\n          value: ''\\n        }]\\n      }\\n    }, token);\\n    this.buffer();\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {FromMarkdownHandle}\\n   */\\n\\n\\n  function exitMathText(token) {\\n    const data = this.resume();\\n    const node = this.exit(token);\\n    node.value = data; // @ts-expect-error: we defined it.\\n\\n    node.data.hChildren[0].value = data;\\n  }\\n  /**\\n   * @this {CompileContext}\\n   * @type {FromMarkdownHandle}\\n   */\\n\\n\\n  function exitMathData(token) {\\n    this.config.enter.data.call(this, token);\\n    this.config.exit.data.call(this, token);\\n  }\\n}\\n/**\\n * Create an extension for `mdast-util-to-markdown`.\\n *\\n * @param {ToOptions | null | undefined} [options]\\n *   Configuration.\\n * @returns {ToMarkdownExtension}\\n *   Extension for `mdast-util-to-markdown`.\\n */\\n\\n\\nfunction mathToMarkdown(options) {\\n  let single = (options || {}).singleDollarTextMath;\\n\\n  if (single === null || single === undefined) {\\n    single = true;\\n  }\\n\\n  inlineMath.peek = inlineMathPeek;\\n  return {\\n    unsafe: [{\\n      character: '\\\\r',\\n      inConstruct: 'mathFlowMeta'\\n    }, {\\n      character: '\\\\n',\\n      inConstruct: 'mathFlowMeta'\\n    }, {\\n      character: '$',\\n      after: single ? undefined : '\\\\\\\\$',\\n      inConstruct: 'phrasing'\\n    }, {\\n      character: '$',\\n      inConstruct: 'mathFlowMeta'\\n    }, {\\n      atBreak: true,\\n      character: '$',\\n      after: '\\\\\\\\$'\\n    }],\\n    handlers: {\\n      math,\\n      inlineMath\\n    }\\n  };\\n  /**\\n   * @type {ToMarkdownHandle}\\n   * @param {Math} node\\n   */\\n  // To do: next major: rename `context` to state, `safeOptions` to info.\\n  // Note: fixing this code? Please also fix the similar code for code:\\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\\n\\n  function math(node, _, context, safeOptions) {\\n    const raw = node.value || '';\\n    const tracker = (0, _track.track)(safeOptions);\\n    const sequence = '$'.repeat(Math.max((0, _longestStreak.longestStreak)(raw, '$') + 1, 2));\\n    const exit = context.enter('mathFlow');\\n    let value = tracker.move(sequence);\\n\\n    if (node.meta) {\\n      const subexit = context.enter('mathFlowMeta');\\n      value += tracker.move((0, _safe.safe)(context, node.meta, {\\n        before: value,\\n        after: '\\\\n',\\n        encode: ['$'],\\n        ...tracker.current()\\n      }));\\n      subexit();\\n    }\\n\\n    value += tracker.move('\\\\n');\\n\\n    if (raw) {\\n      value += tracker.move(raw + '\\\\n');\\n    }\\n\\n    value += tracker.move(sequence);\\n    exit();\\n    return value;\\n  }\\n  /**\\n   * @type {ToMarkdownHandle}\\n   * @param {InlineMath} node\\n   */\\n  // Note: fixing this code? Please also fix the similar code for inline code:\\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\\n  //\\n  // To do: next major: rename `context` to state.\\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\\n\\n\\n  function inlineMath(node, _, context) {\\n    let value = node.value || '';\\n    let size = 1;\\n    if (!single) size++; // If there is a single dollar sign on its own in the math, use a fence of\\n    // two.\\n    // If there are two in a row, use one.\\n\\n    while (new RegExp('(^|[^$])' + '\\\\\\\\$'.repeat(size) + '([^$]|$)').test(value)) {\\n      size++;\\n    }\\n\\n    const sequence = '$'.repeat(size); // If this is not just spaces or eols (tabs don\\u2019t count), and either the\\n    // first and last character are a space or eol, or the first or last\\n    // character are dollar signs, then pad with spaces.\\n\\n    if ( // Contains non-space.\\n    /[^ \\\\r\\\\n]/.test(value) && (/^[ \\\\r\\\\n]/.test(value) && /[ \\\\r\\\\n]$/.test(value) || // Starts or ends with dollar.\\n    /^\\\\$|\\\\$$/.test(value))) {\\n      value = ' ' + value + ' ';\\n    }\\n\\n    let index = -1; // We have a potential problem: certain characters after eols could result in\\n    // blocks being seen.\\n    // For example, if someone injected the string `'\\\\n# b'`, then that would\\n    // result in an ATX heading.\\n    // We can\\u2019t escape characters in `inlineMath`, but because eols are\\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\\n    // them out.\\n\\n    while (++index < context.unsafe.length) {\\n      const pattern = context.unsafe[index];\\n      const expression = (0, _patternCompile.patternCompile)(pattern);\\n      /** @type {RegExpExecArray | null} */\\n\\n      let match; // Only look for `atBreak`s.\\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\\n      // CR.\\n\\n      if (!pattern.atBreak) continue;\\n\\n      while (match = expression.exec(value)) {\\n        let position = match.index; // Support CRLF (patterns only look for one of the characters).\\n\\n        if (value.codePointAt(position) === 10\\n        /* `\\\\n` */\\n        && value.codePointAt(position - 1) === 13\\n        /* `\\\\r` */\\n        ) {\\n          position--;\\n        }\\n\\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\\n      }\\n    }\\n\\n    return sequence + value + sequence;\\n  }\\n  /**\\n   * @returns {string}\\n   */\\n\\n\\n  function inlineMathPeek() {\\n    return '$';\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"mathFromMarkdown\",\"exitMathData\",\"token\",\"config\",\"enter\",\"data\",\"call\",\"exit\",\"mathFlow\",\"enterMathFlow\",\"type\",\"meta\",\"hName\",\"hProperties\",\"className\",\"hChildren\",\"mathFlowFenceMeta\",\"enterMathFlowMeta\",\"buffer\",\"mathText\",\"enterMathText\",\"exitMathFlow\",\"resume\",\"replace\",\"node\",\"setData\",\"mathFlowFence\",\"exitMathFlowFence\",\"getData\",\"exitMathFlowMeta\",\"stack\",\"length\",\"mathFlowValue\",\"exitMathText\",\"mathTextData\",\"mathToMarkdown\",\"options\",\"inlineMath\",\"_\",\"context\",\"size\",\"single\",\"test\",\"RegExp\",\"repeat\",\"sequence\",\"index\",\"unsafe\",\"pattern\",\"expression\",\"_patternCompile\",\"patternCompile\",\"atBreak\",\"match\",\"exec\",\"position\",\"codePointAt\",\"slice\",\"singleDollarTextMath\",\"undefined\",\"peek\",\"inlineMathPeek\",\"character\",\"inConstruct\",\"after\",\"handlers\",\"math\",\"safeOptions\",\"raw\",\"tracker\",\"_track\",\"track\",\"Math\",\"max\",\"_longestStreak\",\"longestStreak\",\"move\",\"subexit\",\"_safe\",\"safe\",\"before\",\"encode\",\"current\"]\n}\n"]