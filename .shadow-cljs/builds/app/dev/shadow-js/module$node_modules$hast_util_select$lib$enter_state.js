["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hast-util-select/lib/enter-state.js"],"~:js","shadow$provide.module$node_modules$hast_util_select$lib$enter_state=function(global,require,module,exports){function dirBidi(value){value=(0,_direction.direction)(value);return\"neutral\"===value?void 0:value}function dirProperty(node){node=\"element\"===node.type&&node.properties&&\"string\"===typeof node.properties.dir?node.properties.dir.toLowerCase():void 0;return\"auto\"===node||\"ltr\"===node||\"rtl\"===node?node:void 0}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.enterState=function(state,\nnode){function inferDirectionality(child){if(\"text\"===child.type)return(dirInferred=dirBidi(child.value))?_unistUtilVisit.EXIT:void 0;if(child!==node&&\"element\"===child.type&&(\"bdi\"===child.tagName||\"script\"===child.tagName||\"style\"===child.tagName||\"textare\"===child.tagName||dirProperty(child)))return _unistUtilVisit.SKIP}const schema=state.schema,language=state.language,currentDirection=state.direction,editableOrEditingHost=state.editableOrEditingHost;let dirInferred;if(\"element\"===node.type&&node.properties){const lang=\nnode.properties.xmlLang||node.properties.lang,type=node.properties.type||\"text\",dir=dirProperty(node);void 0!==lang&&null!==lang&&(state.language=String(lang));if(schema&&\"html\"===schema.space){\"true\"===node.properties.contentEditable&&(state.editableOrEditingHost=!0);\"svg\"===node.tagName&&(state.schema=_propertyInformation.svg);if(\"rtl\"===dir)dirInferred=dir;else if(\"ltr\"===dir||\"auto\"!==dir&&\"html\"===node.tagName||\"auto\"!==dir&&\"input\"===node.tagName&&\"tel\"===type)dirInferred=\"ltr\";else if(\"auto\"===\ndir||\"bdi\"===node.tagName)\"textarea\"===node.tagName?dirInferred=dirBidi((0,_hastUtilToString.toString)(node)):\"input\"!==node.tagName||\"email\"!==type&&\"search\"!==type&&\"tel\"!==type&&\"text\"!==type?(0,_unistUtilVisit.visit)(node,inferDirectionality):dirInferred=node.properties.value?dirBidi(node.properties.value):\"ltr\";dirInferred&&(state.direction=dirInferred)}else state.editableOrEditingHost&&(state.editableOrEditingHost=!1)}return function(){state.schema=schema;state.language=language;state.direction=\ncurrentDirection;state.editableOrEditingHost=editableOrEditingHost}};var _direction=require(\"module$node_modules$direction$index\"),_hastUtilToString=require(\"module$node_modules$hast_util_to_string$index\"),_propertyInformation=require(\"module$node_modules$property_information$index\"),_unistUtilVisit=require(\"module$node_modules$unist_util_visit$index\")}","~:source","shadow$provide[\"module$node_modules$hast_util_select$lib$enter_state\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enterState = enterState;\n\nvar _direction = require(\"direction\");\n\nvar _hastUtilToString = require(\"hast-util-to-string\");\n\nvar _propertyInformation = require(\"property-information\");\n\nvar _unistUtilVisit = require(\"unist-util-visit\");\n\n/**\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').ElementChild} ElementChild\n * @typedef {import('./types.js').Direction} Direction\n * @typedef {import('unist-util-visit/complex-types.js').Visitor<ElementChild>} Visitor\n */\n\n/**\n * Enter a node.\n *\n * The caller is responsible for calling the return value `exit`.\n *\n * @param {SelectState} state\n *   Current state.\n *\n *   Will be mutated: `exit` undos the changes.\n * @param {Node} node\n *   Node to enter.\n * @returns {() => void}\n *   Call to exit.\n */\n// eslint-disable-next-line complexity\nfunction enterState(state, node) {\n  const schema = state.schema;\n  const language = state.language;\n  const currentDirection = state.direction;\n  const editableOrEditingHost = state.editableOrEditingHost;\n  /** @type {Direction | undefined} */\n\n  let dirInferred;\n\n  if (node.type === 'element' && node.properties) {\n    const lang = node.properties.xmlLang || node.properties.lang;\n    const type = node.properties.type || 'text';\n    const dir = dirProperty(node);\n\n    if (lang !== undefined && lang !== null) {\n      state.language = String(lang);\n    }\n\n    if (schema && schema.space === 'html') {\n      if (node.properties.contentEditable === 'true') {\n        state.editableOrEditingHost = true;\n      }\n\n      if (node.tagName === 'svg') {\n        state.schema = _propertyInformation.svg;\n      } // See: <https://html.spec.whatwg.org/#the-directionality>.\n      // Explicit `[dir=rtl]`.\n\n\n      if (dir === 'rtl') {\n        dirInferred = dir;\n      } else if ( // Explicit `[dir=ltr]`.\n      dir === 'ltr' || dir !== 'auto' && node.tagName === 'html' || dir !== 'auto' && node.tagName === 'input' && type === 'tel') {\n        dirInferred = 'ltr'; // `[dir=auto]` or `bdi` with an invalid or no `[dir]`.\n      } else if (dir === 'auto' || node.tagName === 'bdi') {\n        if (node.tagName === 'textarea') {\n          // Check contents of `<textarea>`.\n          dirInferred = dirBidi((0, _hastUtilToString.toString)(node));\n        } else if (node.tagName === 'input' && (type === 'email' || type === 'search' || type === 'tel' || type === 'text')) {\n          // Check value of `<input>`.\n          dirInferred = node.properties.value ? // @ts-expect-error Assume string\n          dirBidi(node.properties.value) : 'ltr';\n        } else {\n          // Check text nodes in `node`.\n          (0, _unistUtilVisit.visit)(node, inferDirectionality);\n        }\n      }\n\n      if (dirInferred) {\n        state.direction = dirInferred;\n      }\n    } // Turn off editing mode in non-HTML spaces.\n    else if (state.editableOrEditingHost) {\n      state.editableOrEditingHost = false;\n    }\n  }\n\n  return reset;\n\n  function reset() {\n    state.schema = schema;\n    state.language = language;\n    state.direction = currentDirection;\n    state.editableOrEditingHost = editableOrEditingHost;\n  }\n  /** @type {Visitor} */\n\n\n  function inferDirectionality(child) {\n    if (child.type === 'text') {\n      dirInferred = dirBidi(child.value);\n      return dirInferred ? _unistUtilVisit.EXIT : undefined;\n    }\n\n    if (child !== node && child.type === 'element' && (child.tagName === 'bdi' || child.tagName === 'script' || child.tagName === 'style' || child.tagName === 'textare' || dirProperty(child))) {\n      return _unistUtilVisit.SKIP;\n    }\n  }\n}\n/**\n * @param {string} value\n * @returns {Direction | undefined}\n */\n\n\nfunction dirBidi(value) {\n  const result = (0, _direction.direction)(value);\n  return result === 'neutral' ? undefined : result;\n}\n/**\n * @param {ElementChild} node\n * @returns {Direction | undefined}\n */\n\n\nfunction dirProperty(node) {\n  const value = node.type === 'element' && node.properties && typeof node.properties.dir === 'string' ? node.properties.dir.toLowerCase() : undefined;\n  return value === 'auto' || value === 'ltr' || value === 'rtl' ? value : undefined;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$property_information$index","~$module$node_modules$unist_util_visit$index","~$shadow.js","~$module$node_modules$direction$index","~$module$node_modules$hast_util_to_string$index"]],"~:properties",["^5",["enterState","__esModule","schema","value","direction","editableOrEditingHost","language"]],"~:compiled-at",1676841365492,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hast_util_select$lib$enter_state.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/hast-util-select/lib/enter-state.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hast_util_select$lib$enter_state\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.enterState = enterState;\\n\\nvar _direction = require(\\\"direction\\\");\\n\\nvar _hastUtilToString = require(\\\"hast-util-to-string\\\");\\n\\nvar _propertyInformation = require(\\\"property-information\\\");\\n\\nvar _unistUtilVisit = require(\\\"unist-util-visit\\\");\\n\\n/**\\n * @typedef {import('./types.js').SelectState} SelectState\\n * @typedef {import('./types.js').Node} Node\\n * @typedef {import('./types.js').ElementChild} ElementChild\\n * @typedef {import('./types.js').Direction} Direction\\n * @typedef {import('unist-util-visit/complex-types.js').Visitor<ElementChild>} Visitor\\n */\\n\\n/**\\n * Enter a node.\\n *\\n * The caller is responsible for calling the return value `exit`.\\n *\\n * @param {SelectState} state\\n *   Current state.\\n *\\n *   Will be mutated: `exit` undos the changes.\\n * @param {Node} node\\n *   Node to enter.\\n * @returns {() => void}\\n *   Call to exit.\\n */\\n// eslint-disable-next-line complexity\\nfunction enterState(state, node) {\\n  const schema = state.schema;\\n  const language = state.language;\\n  const currentDirection = state.direction;\\n  const editableOrEditingHost = state.editableOrEditingHost;\\n  /** @type {Direction | undefined} */\\n\\n  let dirInferred;\\n\\n  if (node.type === 'element' && node.properties) {\\n    const lang = node.properties.xmlLang || node.properties.lang;\\n    const type = node.properties.type || 'text';\\n    const dir = dirProperty(node);\\n\\n    if (lang !== undefined && lang !== null) {\\n      state.language = String(lang);\\n    }\\n\\n    if (schema && schema.space === 'html') {\\n      if (node.properties.contentEditable === 'true') {\\n        state.editableOrEditingHost = true;\\n      }\\n\\n      if (node.tagName === 'svg') {\\n        state.schema = _propertyInformation.svg;\\n      } // See: <https://html.spec.whatwg.org/#the-directionality>.\\n      // Explicit `[dir=rtl]`.\\n\\n\\n      if (dir === 'rtl') {\\n        dirInferred = dir;\\n      } else if ( // Explicit `[dir=ltr]`.\\n      dir === 'ltr' || dir !== 'auto' && node.tagName === 'html' || dir !== 'auto' && node.tagName === 'input' && type === 'tel') {\\n        dirInferred = 'ltr'; // `[dir=auto]` or `bdi` with an invalid or no `[dir]`.\\n      } else if (dir === 'auto' || node.tagName === 'bdi') {\\n        if (node.tagName === 'textarea') {\\n          // Check contents of `<textarea>`.\\n          dirInferred = dirBidi((0, _hastUtilToString.toString)(node));\\n        } else if (node.tagName === 'input' && (type === 'email' || type === 'search' || type === 'tel' || type === 'text')) {\\n          // Check value of `<input>`.\\n          dirInferred = node.properties.value ? // @ts-expect-error Assume string\\n          dirBidi(node.properties.value) : 'ltr';\\n        } else {\\n          // Check text nodes in `node`.\\n          (0, _unistUtilVisit.visit)(node, inferDirectionality);\\n        }\\n      }\\n\\n      if (dirInferred) {\\n        state.direction = dirInferred;\\n      }\\n    } // Turn off editing mode in non-HTML spaces.\\n    else if (state.editableOrEditingHost) {\\n      state.editableOrEditingHost = false;\\n    }\\n  }\\n\\n  return reset;\\n\\n  function reset() {\\n    state.schema = schema;\\n    state.language = language;\\n    state.direction = currentDirection;\\n    state.editableOrEditingHost = editableOrEditingHost;\\n  }\\n  /** @type {Visitor} */\\n\\n\\n  function inferDirectionality(child) {\\n    if (child.type === 'text') {\\n      dirInferred = dirBidi(child.value);\\n      return dirInferred ? _unistUtilVisit.EXIT : undefined;\\n    }\\n\\n    if (child !== node && child.type === 'element' && (child.tagName === 'bdi' || child.tagName === 'script' || child.tagName === 'style' || child.tagName === 'textare' || dirProperty(child))) {\\n      return _unistUtilVisit.SKIP;\\n    }\\n  }\\n}\\n/**\\n * @param {string} value\\n * @returns {Direction | undefined}\\n */\\n\\n\\nfunction dirBidi(value) {\\n  const result = (0, _direction.direction)(value);\\n  return result === 'neutral' ? undefined : result;\\n}\\n/**\\n * @param {ElementChild} node\\n * @returns {Direction | undefined}\\n */\\n\\n\\nfunction dirProperty(node) {\\n  const value = node.type === 'element' && node.properties && typeof node.properties.dir === 'string' ? node.properties.dir.toLowerCase() : undefined;\\n  return value === 'auto' || value === 'ltr' || value === 'rtl' ? value : undefined;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"dirBidi\",\"value\",\"result\",\"_direction\",\"direction\",\"undefined\",\"dirProperty\",\"node\",\"type\",\"properties\",\"dir\",\"toLowerCase\",\"Object\",\"defineProperty\",\"enterState\",\"state\",\"inferDirectionality\",\"child\",\"dirInferred\",\"_unistUtilVisit\",\"EXIT\",\"tagName\",\"SKIP\",\"schema\",\"language\",\"currentDirection\",\"editableOrEditingHost\",\"lang\",\"xmlLang\",\"String\",\"space\",\"contentEditable\",\"_propertyInformation\",\"svg\",\"_hastUtilToString\",\"toString\",\"visit\",\"reset\"]\n}\n"]