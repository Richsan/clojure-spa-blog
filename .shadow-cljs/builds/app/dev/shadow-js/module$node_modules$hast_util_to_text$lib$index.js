["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hast-util-to-text/lib/index.js"],"~:js","shadow$provide.module$node_modules$hast_util_to_text$lib$index=function(global,require,module,exports){function innerTextCollection(node,parent,info){if(\"element\"===node.type){{info=inferWhitespace(node,info);const children=node.children||[];let index=-1,items=[];if(!notRendered(node)){var prefix;if(br(node))var suffix=\"\\n\";else row(node)&&(0,_unistUtilFindAfter.findAfter)(parent,node,row)?suffix=\"\\n\":p(node)?suffix=prefix=2:blockOrCaption(node)&&(suffix=prefix=1);for(;++index<children.length;)items=\nitems.concat(innerTextCollection(children[index],node,{whitespace:info,breakBefore:index?void 0:prefix,breakAfter:index<children.length-1?br(children[index+1]):suffix}));cell(node)&&(0,_unistUtilFindAfter.findAfter)(parent,node,cell)&&items.push(\"\\t\");prefix&&items.unshift(prefix);suffix&&items.push(suffix)}node=items}return node}return\"text\"===node.type?\"normal\"===info.whitespace?collectText(node,info):[String(node.value)]:[]}function collectText(node,info){const value=String(node.value);node=[];\nconst result$jscomp$0=[];for(var start$jscomp$0=0;start$jscomp$0<=value.length;){searchLineFeeds.lastIndex=start$jscomp$0;var match$jscomp$0=searchLineFeeds.exec(value);const end=match$jscomp$0&&\"index\"in match$jscomp$0?match$jscomp$0.index:value.length;match$jscomp$0=node;var JSCompiler_temp_const=match$jscomp$0.push;let end$jscomp$0=void 0;var JSCompiler_inline_result=value.slice(start$jscomp$0,end).replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g,\"\");start$jscomp$0=0===start$jscomp$0?\ninfo.breakBefore:!0;var breakAfter=end===value.length?info.breakAfter:!0;const result=[];let start=0;for(;start<JSCompiler_inline_result.length;){searchTabOrSpaces.lastIndex=start;const match=searchTabOrSpaces.exec(JSCompiler_inline_result);end$jscomp$0=match?match.index:JSCompiler_inline_result.length;start||end$jscomp$0||!match||start$jscomp$0||result.push(\"\");start!==end$jscomp$0&&result.push(JSCompiler_inline_result.slice(start,end$jscomp$0));start=match?end$jscomp$0+match[0].length:end$jscomp$0}start===\nend$jscomp$0||breakAfter||result.push(\"\");JSCompiler_inline_result=result.join(\" \");JSCompiler_temp_const.call(match$jscomp$0,JSCompiler_inline_result);start$jscomp$0=end+1}info=-1;let join;for(;++info<node.length;)8203===node[info].charCodeAt(node[info].length-1)||info<node.length-1&&8203===node[info+1].charCodeAt(0)?(result$jscomp$0.push(node[info]),join=void 0):node[info]?(\"number\"===typeof join&&result$jscomp$0.push(join),result$jscomp$0.push(node[info]),join=0):0!==info&&info!==node.length-1||\nresult$jscomp$0.push(0);return result$jscomp$0}function inferWhitespace(node,info){if(\"element\"===node.type){const props=node.properties||{};switch(node.tagName){case \"listing\":case \"plaintext\":case \"xmp\":return\"pre\";case \"nobr\":return\"nowrap\";case \"pre\":return props.wrap?\"pre-wrap\":\"pre\";case \"td\":case \"th\":return props.noWrap?\"nowrap\":info.whitespace;case \"textarea\":return\"pre-wrap\"}}return info.whitespace}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.toText=function(tree,options=\n{}){var children=\"children\"in tree?tree.children:[];const block=blockOrCaption(tree),whitespace=inferWhitespace(tree,{whitespace:options.whitespace||\"normal\",breakBefore:!1,breakAfter:!1});options=[];\"text\"!==tree.type&&\"comment\"!==tree.type||options.push(...collectText(tree,{whitespace,breakBefore:!0,breakAfter:!0}));let index=-1;for(;++index<children.length;)options.push(...innerTextCollection(children[index],tree,{whitespace,breakBefore:index?void 0:block,breakAfter:index<children.length-1?br(children[index+\n1]):block}));tree=[];let count;for(index=-1;++index<options.length;)children=options[index],\"number\"===typeof children?void 0!==count&&children>count&&(count=children):children&&(void 0!==count&&-1<count&&tree.push(\"\\n\".repeat(count)||\" \"),count=-1,tree.push(children));return tree.join(\"\")};global=require(\"module$node_modules$hast_util_is_element$index\");var _unistUtilFindAfter=require(\"module$node_modules$unist_util_find_after$index\");const searchLineFeeds=/\\n/g,searchTabOrSpaces=/[\\t ]+/g,br=(0,global.convertElement)(\"br\"),\np=(0,global.convertElement)(\"p\"),cell=(0,global.convertElement)([\"th\",\"td\"]),row=(0,global.convertElement)(\"tr\"),notRendered=(0,global.convertElement)([\"datalist\",\"head\",\"noembed\",\"noframes\",\"noscript\",\"rp\",\"script\",\"style\",\"template\",\"title\",function(node){return!!(node.properties||{}).hidden},function(node){return\"dialog\"===node.tagName&&!(node.properties||{}).open}]),blockOrCaption=(0,global.convertElement)(\"address article aside blockquote body caption center dd dialog dir dl dt div figure figcaption footer form, h1 h2 h3 h4 h5 h6 header hgroup hr html legend listing main menu nav ol p plaintext pre section ul xmp\".split(\" \"))}","~:source","shadow$provide[\"module$node_modules$hast_util_to_text$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toText = toText;\n\nvar _hastUtilIsElement = require(\"hast-util-is-element\");\n\nvar _unistUtilFindAfter = require(\"unist-util-find-after\");\n\n/**\n * @typedef {import('hast-util-is-element').TestFunctionAnything} TestFunctionAnything\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n */\n\n/**\n * @typedef {Content | Root} Node\n *   Any node.\n * @typedef {Extract<Node, import('unist').Parent>} Parent\n *   Any parent.\n * @typedef {'normal' | 'pre' | 'nowrap' | 'pre-wrap'} Whitespace\n *   Valid and useful whitespace values (from CSS).\n * @typedef {0 | 1 | 2} BreakNumber\n *   Specific break:\n *\n *   *   `0` — space\n *   *   `1` — line ending\n *   *   `2` — blank line\n * @typedef {'\\n'} BreakForce\n *   Forced break.\n * @typedef {boolean} BreakValue\n *   Whether there was a break.\n * @typedef {BreakValue | BreakNumber | undefined} BreakBefore\n *   Any value for a break before.\n * @typedef {BreakValue | BreakNumber | BreakForce | undefined} BreakAfter\n *   Any value for a break after.\n *\n * @typedef CollectionInfo\n *   Info on current collection.\n * @property {Whitespace} whitespace\n *   Current whitespace setting.\n * @property {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @property {BreakAfter} breakAfter\n *   Whether there was a break after.\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace | null | undefined} [whitespace='normal']\n *   Initial CSS whitespace setting to use.\n */\nconst searchLineFeeds = /\\n/g;\nconst searchTabOrSpaces = /[\\t ]+/g;\nconst br = (0, _hastUtilIsElement.convertElement)('br');\nconst p = (0, _hastUtilIsElement.convertElement)('p');\nconst cell = (0, _hastUtilIsElement.convertElement)(['th', 'td']);\nconst row = (0, _hastUtilIsElement.convertElement)('tr'); // Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\n\nconst notRendered = (0, _hastUtilIsElement.convertElement)([// List from: <https://html.spec.whatwg.org/#hidden-elements>\n'datalist', 'head', 'noembed', 'noframes', 'noscript', // Act as if we support scripting.\n'rp', 'script', 'style', 'template', 'title', // Hidden attribute.\nhidden, // From: <https://html.spec.whatwg.org/#flow-content-3>\nclosedDialog]); // See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n\nconst blockOrCaption = (0, _hastUtilIsElement.convertElement)(['address', // Flow content\n'article', // Sections and headings\n'aside', // Sections and headings\n'blockquote', // Flow content\n'body', // Page\n'caption', // `table-caption`\n'center', // Flow content (legacy)\n'dd', // Lists\n'dialog', // Flow content\n'dir', // Lists (legacy)\n'dl', // Lists\n'dt', // Lists\n'div', // Flow content\n'figure', // Flow content\n'figcaption', // Flow content\n'footer', // Flow content\n'form,', // Flow content\n'h1', // Sections and headings\n'h2', // Sections and headings\n'h3', // Sections and headings\n'h4', // Sections and headings\n'h5', // Sections and headings\n'h6', // Sections and headings\n'header', // Flow content\n'hgroup', // Sections and headings\n'hr', // Flow content\n'html', // Page\n'legend', // Flow content\n'listing', // Flow content (legacy)\n'main', // Flow content\n'menu', // Lists\n'nav', // Sections and headings\n'ol', // Lists\n'p', // Flow content\n'plaintext', // Flow content (legacy)\n'pre', // Flow content\n'section', // Sections and headings\n'ul', // Lists\n'xmp' // Flow content (legacy)\n]);\n/**\n * Get the plain-text value of a node.\n *\n * ###### Algorithm\n *\n * *   if `tree` is a comment, returns its `value`\n * *   if `tree` is a text, applies normal whitespace collapsing to its\n *     `value`, as defined by the CSS Text spec\n * *   if `tree` is a root or element, applies an algorithm similar to the\n *     `innerText` getter as defined by HTML\n *\n * ###### Notes\n *\n * > \uD83D\uDC49 **Note**: the algorithm acts as if `tree` is being rendered, and as if\n * > we’re a CSS-supporting user agent, with scripting enabled.\n *\n * *   if `tree` is an element that is not displayed (such as a `head`), we’ll\n *     still use the `innerText` algorithm instead of switching to `textContent`\n * *   if descendants of `tree` are elements that are not displayed, they are\n *     ignored\n * *   CSS is not considered, except for the default user agent style sheet\n * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,\n *     or Halfwidth East Asian Width characters are used, the same goes for a case\n *     with Chinese, Japanese, or Yi writing systems\n * *   replaced elements (such as `audio`) are treated like non-replaced elements\n *\n * @param {Node} tree\n *   Tree to turn into text.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `tree`.\n */\n\nfunction toText(tree, options = {}) {\n  const children = 'children' in tree ? tree.children : [];\n  const block = blockOrCaption(tree);\n  const whitespace = inferWhitespace(tree, {\n    whitespace: options.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  });\n  /** @type {Array<string | BreakNumber>} */\n\n  const results = []; // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n\n  if (tree.type === 'text' || tree.type === 'comment') {\n    results.push(...collectText(tree, {\n      whitespace,\n      breakBefore: true,\n      breakAfter: true\n    }));\n  } // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n  // 2.  Let results be a new empty list.\n\n\n  let index = -1; // 3.  For each child node node of this element:\n\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results.push( // @ts-expect-error Looks like a parent.\n    ...innerTextCollection(children[index], tree, {\n      whitespace,\n      breakBefore: index ? undefined : block,\n      breakAfter: index < children.length - 1 ? br(children[index + 1]) : block\n    }));\n  } // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n\n  /** @type {Array<string>} */\n\n\n  const result = [];\n  /** @type {number | undefined} */\n\n  let count;\n  index = -1;\n\n  while (++index < results.length) {\n    const value = results[index];\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value;\n    } else if (value) {\n      if (count !== undefined && count > -1) {\n        result.push('\\n'.repeat(count) || ' ');\n      }\n\n      count = -1;\n      result.push(value);\n    }\n  } // 7.  Return the concatenation of the string items in results.\n\n\n  return result.join('');\n}\n/**\n * <https://html.spec.whatwg.org/#inner-text-collection-steps>\n *\n * @param {Node} node\n * @param {Parent} parent\n * @param {CollectionInfo} info\n * @returns {Array<string | BreakNumber>}\n */\n\n\nfunction innerTextCollection(node, parent, info) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, info);\n  }\n\n  if (node.type === 'text') {\n    return info.whitespace === 'normal' ? collectText(node, info) : collectPreText(node);\n  }\n\n  return [];\n}\n/**\n * Collect an element.\n *\n * @param {Element} node\n *   Element node.\n * @param {Parent} parent\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<string | BreakNumber>}\n */\n\n\nfunction collectElement(node, parent, info) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, info);\n  const children = node.children || [];\n  let index = -1;\n  /** @type {Array<string | BreakNumber>} */\n\n  let items = []; // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n\n  if (notRendered(node)) {\n    return items;\n  }\n  /** @type {BreakNumber | undefined} */\n\n\n  let prefix;\n  /** @type {BreakNumber | BreakForce | undefined} */\n\n  let suffix; // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n  // See `collectText` for step 4.\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n\n  if (br(node)) {\n    suffix = '\\n';\n  } // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && (0, _unistUtilFindAfter.findAfter)(parent, node, row)) {\n    suffix = '\\n';\n  } // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2;\n    suffix = 2;\n  } // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1;\n    suffix = 1;\n  } // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n\n\n  while (++index < children.length) {\n    items = items.concat(innerTextCollection(children[index], node, {\n      whitespace,\n      breakBefore: index ? undefined : prefix,\n      breakAfter: index < children.length - 1 ? br(children[index + 1]) : suffix\n    }));\n  } // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n\n\n  if (cell(node) && (0, _unistUtilFindAfter.findAfter)(parent, node, cell)) {\n    items.push('\\t');\n  } // Add the pre- and suffix.\n\n\n  if (prefix) items.unshift(prefix);\n  if (suffix) items.push(suffix);\n  return items;\n}\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we don’t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {Text | Comment} node\n *   Text node.\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<string | BreakNumber>}\n *   Result.\n */\n\n\nfunction collectText(node, info) {\n  const value = String(node.value);\n  /** @type {Array<string>} */\n\n  const lines = [];\n  /** @type {Array<string | BreakNumber>} */\n\n  const result = [];\n  let start = 0;\n\n  while (start <= value.length) {\n    searchLineFeeds.lastIndex = start;\n    const match = searchLineFeeds.exec(value);\n    const end = match && 'index' in match ? match.index : value.length;\n    lines.push( // Any sequence of collapsible spaces and tabs immediately preceding or\n    // following a segment break is removed.\n    trimAndCollapseSpacesAndTabs( // […] ignoring bidi formatting characters (characters with the\n    // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n    // they were not there.\n    value.slice(start, end).replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''), start === 0 ? info.breakBefore : true, end === value.length ? info.breakAfter : true));\n    start = end + 1;\n  } // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n\n\n  let index = -1;\n  /** @type {BreakNumber | undefined} */\n\n  let join;\n\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (lines[index].charCodeAt(lines[index].length - 1) === 0x200b\n    /* ZWSP */\n    || index < lines.length - 1 && lines[index + 1].charCodeAt(0) === 0x200b\n    /* ZWSP */\n    ) {\n      result.push(lines[index]);\n      join = undefined;\n    } // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (typeof join === 'number') result.push(join);\n      result.push(lines[index]);\n      join = 0;\n    } else if (index === 0 || index === lines.length - 1) {\n      // If this line is empty, and it’s the first or last, add a space.\n      // Note that this function is only called in normal whitespace, so we\n      // don’t worry about `pre`.\n      result.push(0);\n    }\n  }\n\n  return result;\n}\n/**\n * Collect a text node as “pre” whitespace.\n *\n * @param {Text} node\n *   Text node.\n * @returns {Array<string | BreakNumber>}\n *   Result.\n */\n\n\nfunction collectPreText(node) {\n  return [String(node.value)];\n}\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     space—even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     context—is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n *   Value to collapse.\n * @param {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @param {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @returns {string}\n *   Result.\n */\n\n\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array<string>} */\n  const result = [];\n  let start = 0;\n  /** @type {number | undefined} */\n\n  let end;\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start;\n    const match = searchTabOrSpaces.exec(value);\n    end = match ? match.index : value.length; // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n\n    if (!start && !end && match && !breakBefore) {\n      result.push('');\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end));\n    }\n\n    start = match ? end + match[0].length : end;\n  } // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n\n\n  if (start !== end && !breakAfter) {\n    result.push('');\n  }\n\n  return result.join(' ');\n}\n/**\n * Figure out the whitespace of a node.\n *\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {Node} node\n *   Node (typically `Element`).\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Whitespace}\n *   Applied whitespace.\n */\n\n\nfunction inferWhitespace(node, info) {\n  if (node.type === 'element') {\n    const props = node.properties || {};\n\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp':\n        {\n          return 'pre';\n        }\n\n      case 'nobr':\n        {\n          return 'nowrap';\n        }\n\n      case 'pre':\n        {\n          return props.wrap ? 'pre-wrap' : 'pre';\n        }\n\n      case 'td':\n      case 'th':\n        {\n          return props.noWrap ? 'nowrap' : info.whitespace;\n        }\n\n      case 'textarea':\n        {\n          return 'pre-wrap';\n        }\n\n      default:\n    }\n  }\n\n  return info.whitespace;\n}\n/** @type {TestFunctionAnything} */\n\n\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden);\n}\n/** @type {TestFunctionAnything} */\n\n\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$unist_util_find_after$index","~$shadow.js","~$module$node_modules$hast_util_is_element$index"]],"~:properties",["^5",["breakBefore","__esModule","lastIndex","breakAfter","value","toText","whitespace"]],"~:compiled-at",1676667638370,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hast_util_to_text$lib$index.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/hast-util-to-text/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hast_util_to_text$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.toText = toText;\\n\\nvar _hastUtilIsElement = require(\\\"hast-util-is-element\\\");\\n\\nvar _unistUtilFindAfter = require(\\\"unist-util-find-after\\\");\\n\\n/**\\n * @typedef {import('hast-util-is-element').TestFunctionAnything} TestFunctionAnything\\n * @typedef {import('hast').Content} Content\\n * @typedef {import('hast').Text} Text\\n * @typedef {import('hast').Comment} Comment\\n * @typedef {import('hast').Root} Root\\n * @typedef {import('hast').Element} Element\\n */\\n\\n/**\\n * @typedef {Content | Root} Node\\n *   Any node.\\n * @typedef {Extract<Node, import('unist').Parent>} Parent\\n *   Any parent.\\n * @typedef {'normal' | 'pre' | 'nowrap' | 'pre-wrap'} Whitespace\\n *   Valid and useful whitespace values (from CSS).\\n * @typedef {0 | 1 | 2} BreakNumber\\n *   Specific break:\\n *\\n *   *   `0` \\u2014 space\\n *   *   `1` \\u2014 line ending\\n *   *   `2` \\u2014 blank line\\n * @typedef {'\\\\n'} BreakForce\\n *   Forced break.\\n * @typedef {boolean} BreakValue\\n *   Whether there was a break.\\n * @typedef {BreakValue | BreakNumber | undefined} BreakBefore\\n *   Any value for a break before.\\n * @typedef {BreakValue | BreakNumber | BreakForce | undefined} BreakAfter\\n *   Any value for a break after.\\n *\\n * @typedef CollectionInfo\\n *   Info on current collection.\\n * @property {Whitespace} whitespace\\n *   Current whitespace setting.\\n * @property {BreakBefore} breakBefore\\n *   Whether there was a break before.\\n * @property {BreakAfter} breakAfter\\n *   Whether there was a break after.\\n *\\n * @typedef Options\\n *   Configuration.\\n * @property {Whitespace | null | undefined} [whitespace='normal']\\n *   Initial CSS whitespace setting to use.\\n */\\nconst searchLineFeeds = /\\\\n/g;\\nconst searchTabOrSpaces = /[\\\\t ]+/g;\\nconst br = (0, _hastUtilIsElement.convertElement)('br');\\nconst p = (0, _hastUtilIsElement.convertElement)('p');\\nconst cell = (0, _hastUtilIsElement.convertElement)(['th', 'td']);\\nconst row = (0, _hastUtilIsElement.convertElement)('tr'); // Note that we don\\u2019t need to include void elements here as they don\\u2019t have text.\\n// See: <https://github.com/wooorm/html-void-elements>\\n\\nconst notRendered = (0, _hastUtilIsElement.convertElement)([// List from: <https://html.spec.whatwg.org/#hidden-elements>\\n'datalist', 'head', 'noembed', 'noframes', 'noscript', // Act as if we support scripting.\\n'rp', 'script', 'style', 'template', 'title', // Hidden attribute.\\nhidden, // From: <https://html.spec.whatwg.org/#flow-content-3>\\nclosedDialog]); // See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\\n\\nconst blockOrCaption = (0, _hastUtilIsElement.convertElement)(['address', // Flow content\\n'article', // Sections and headings\\n'aside', // Sections and headings\\n'blockquote', // Flow content\\n'body', // Page\\n'caption', // `table-caption`\\n'center', // Flow content (legacy)\\n'dd', // Lists\\n'dialog', // Flow content\\n'dir', // Lists (legacy)\\n'dl', // Lists\\n'dt', // Lists\\n'div', // Flow content\\n'figure', // Flow content\\n'figcaption', // Flow content\\n'footer', // Flow content\\n'form,', // Flow content\\n'h1', // Sections and headings\\n'h2', // Sections and headings\\n'h3', // Sections and headings\\n'h4', // Sections and headings\\n'h5', // Sections and headings\\n'h6', // Sections and headings\\n'header', // Flow content\\n'hgroup', // Sections and headings\\n'hr', // Flow content\\n'html', // Page\\n'legend', // Flow content\\n'listing', // Flow content (legacy)\\n'main', // Flow content\\n'menu', // Lists\\n'nav', // Sections and headings\\n'ol', // Lists\\n'p', // Flow content\\n'plaintext', // Flow content (legacy)\\n'pre', // Flow content\\n'section', // Sections and headings\\n'ul', // Lists\\n'xmp' // Flow content (legacy)\\n]);\\n/**\\n * Get the plain-text value of a node.\\n *\\n * ###### Algorithm\\n *\\n * *   if `tree` is a comment, returns its `value`\\n * *   if `tree` is a text, applies normal whitespace collapsing to its\\n *     `value`, as defined by the CSS Text spec\\n * *   if `tree` is a root or element, applies an algorithm similar to the\\n *     `innerText` getter as defined by HTML\\n *\\n * ###### Notes\\n *\\n * > \\ud83d\\udc49 **Note**: the algorithm acts as if `tree` is being rendered, and as if\\n * > we\\u2019re a CSS-supporting user agent, with scripting enabled.\\n *\\n * *   if `tree` is an element that is not displayed (such as a `head`), we\\u2019ll\\n *     still use the `innerText` algorithm instead of switching to `textContent`\\n * *   if descendants of `tree` are elements that are not displayed, they are\\n *     ignored\\n * *   CSS is not considered, except for the default user agent style sheet\\n * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,\\n *     or Halfwidth East Asian Width characters are used, the same goes for a case\\n *     with Chinese, Japanese, or Yi writing systems\\n * *   replaced elements (such as `audio`) are treated like non-replaced elements\\n *\\n * @param {Node} tree\\n *   Tree to turn into text.\\n * @param {Options} [options]\\n *   Configuration (optional).\\n * @returns {string}\\n *   Serialized `tree`.\\n */\\n\\nfunction toText(tree, options = {}) {\\n  const children = 'children' in tree ? tree.children : [];\\n  const block = blockOrCaption(tree);\\n  const whitespace = inferWhitespace(tree, {\\n    whitespace: options.whitespace || 'normal',\\n    breakBefore: false,\\n    breakAfter: false\\n  });\\n  /** @type {Array<string | BreakNumber>} */\\n\\n  const results = []; // Treat `text` and `comment` as having normal white-space.\\n  // This deviates from the spec as in the DOM the node\\u2019s `.data` has to be\\n  // returned.\\n  // If you want that behavior use `hast-util-to-string`.\\n  // All other nodes are later handled as if they are `element`s (so the\\n  // algorithm also works on a `root`).\\n  // Nodes without children are treated as a void element, so `doctype` is thus\\n  // ignored.\\n\\n  if (tree.type === 'text' || tree.type === 'comment') {\\n    results.push(...collectText(tree, {\\n      whitespace,\\n      breakBefore: true,\\n      breakAfter: true\\n    }));\\n  } // 1.  If this element is not being rendered, or if the user agent is a\\n  //     non-CSS user agent, then return the same value as the textContent IDL\\n  //     attribute on this element.\\n  //\\n  //     Note: we\\u2019re not supporting stylesheets so we\\u2019re acting as if the node\\n  //     is rendered.\\n  //\\n  //     If you want that behavior use `hast-util-to-string`.\\n  //     Important: we\\u2019ll have to account for this later though.\\n  // 2.  Let results be a new empty list.\\n\\n\\n  let index = -1; // 3.  For each child node node of this element:\\n\\n  while (++index < children.length) {\\n    // 3.1. Let current be the list resulting in running the inner text\\n    //      collection steps with node.\\n    //      Each item in results will either be a JavaScript string or a\\n    //      positive integer (a required line break count).\\n    // 3.2. For each item item in current, append item to results.\\n    results.push( // @ts-expect-error Looks like a parent.\\n    ...innerTextCollection(children[index], tree, {\\n      whitespace,\\n      breakBefore: index ? undefined : block,\\n      breakAfter: index < children.length - 1 ? br(children[index + 1]) : block\\n    }));\\n  } // 4.  Remove any items from results that are the empty string.\\n  // 5.  Remove any runs of consecutive required line break count items at the\\n  //     start or end of results.\\n  // 6.  Replace each remaining run of consecutive required line break count\\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\\n  //     characters as the maximum of the values in the required line break\\n  //     count items.\\n\\n  /** @type {Array<string>} */\\n\\n\\n  const result = [];\\n  /** @type {number | undefined} */\\n\\n  let count;\\n  index = -1;\\n\\n  while (++index < results.length) {\\n    const value = results[index];\\n\\n    if (typeof value === 'number') {\\n      if (count !== undefined && value > count) count = value;\\n    } else if (value) {\\n      if (count !== undefined && count > -1) {\\n        result.push('\\\\n'.repeat(count) || ' ');\\n      }\\n\\n      count = -1;\\n      result.push(value);\\n    }\\n  } // 7.  Return the concatenation of the string items in results.\\n\\n\\n  return result.join('');\\n}\\n/**\\n * <https://html.spec.whatwg.org/#inner-text-collection-steps>\\n *\\n * @param {Node} node\\n * @param {Parent} parent\\n * @param {CollectionInfo} info\\n * @returns {Array<string | BreakNumber>}\\n */\\n\\n\\nfunction innerTextCollection(node, parent, info) {\\n  if (node.type === 'element') {\\n    return collectElement(node, parent, info);\\n  }\\n\\n  if (node.type === 'text') {\\n    return info.whitespace === 'normal' ? collectText(node, info) : collectPreText(node);\\n  }\\n\\n  return [];\\n}\\n/**\\n * Collect an element.\\n *\\n * @param {Element} node\\n *   Element node.\\n * @param {Parent} parent\\n * @param {CollectionInfo} info\\n *   Info on current collection.\\n * @returns {Array<string | BreakNumber>}\\n */\\n\\n\\nfunction collectElement(node, parent, info) {\\n  // First we infer the `white-space` property.\\n  const whitespace = inferWhitespace(node, info);\\n  const children = node.children || [];\\n  let index = -1;\\n  /** @type {Array<string | BreakNumber>} */\\n\\n  let items = []; // We\\u2019re ignoring point 3, and exiting without any content here, because we\\n  // deviated from the spec in `toText` at step 3.\\n\\n  if (notRendered(node)) {\\n    return items;\\n  }\\n  /** @type {BreakNumber | undefined} */\\n\\n\\n  let prefix;\\n  /** @type {BreakNumber | BreakForce | undefined} */\\n\\n  let suffix; // Note: we first detect if there is going to be a break before or after the\\n  // contents, as that changes the white-space handling.\\n  // 2.  If node\\u2019s computed value of `visibility` is not `visible`, then return\\n  //     items.\\n  //\\n  //     Note: Ignored, as everything is visible by default user agent styles.\\n  // 3.  If node is not being rendered, then return items. [...]\\n  //\\n  //     Note: We already did this above.\\n  // See `collectText` for step 4.\\n  // 5.  If node is a `<br>` element, then append a string containing a single\\n  //     U+000A LINE FEED (LF) character to items.\\n\\n  if (br(node)) {\\n    suffix = '\\\\n';\\n  } // 7.  If node\\u2019s computed value of `display` is `table-row`, and node\\u2019s CSS\\n  //     box is not the last `table-row` box of the nearest ancestor `table`\\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\\n  //     character to items.\\n  //\\n  //     See: <https://html.spec.whatwg.org/#tables-2>\\n  //     Note: needs further investigation as this does not account for implicit\\n  //     rows.\\n  else if (row(node) && (0, _unistUtilFindAfter.findAfter)(parent, node, row)) {\\n    suffix = '\\\\n';\\n  } // 8.  If node is a `<p>` element, then append 2 (a required line break count)\\n  //     at the beginning and end of items.\\n  else if (p(node)) {\\n    prefix = 2;\\n    suffix = 2;\\n  } // 9.  If node\\u2019s used value of `display` is block-level or `table-caption`,\\n  //     then append 1 (a required line break count) at the beginning and end of\\n  //     items.\\n  else if (blockOrCaption(node)) {\\n    prefix = 1;\\n    suffix = 1;\\n  } // 1.  Let items be the result of running the inner text collection steps with\\n  //     each child node of node in tree order, and then concatenating the\\n  //     results to a single list.\\n\\n\\n  while (++index < children.length) {\\n    items = items.concat(innerTextCollection(children[index], node, {\\n      whitespace,\\n      breakBefore: index ? undefined : prefix,\\n      breakAfter: index < children.length - 1 ? br(children[index + 1]) : suffix\\n    }));\\n  } // 6.  If node\\u2019s computed value of `display` is `table-cell`, and node\\u2019s CSS\\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\\n  //     (tab) character to items.\\n  //\\n  //     See: <https://html.spec.whatwg.org/#tables-2>\\n\\n\\n  if (cell(node) && (0, _unistUtilFindAfter.findAfter)(parent, node, cell)) {\\n    items.push('\\\\t');\\n  } // Add the pre- and suffix.\\n\\n\\n  if (prefix) items.unshift(prefix);\\n  if (suffix) items.push(suffix);\\n  return items;\\n}\\n/**\\n * 4.  If node is a Text node, then for each CSS text box produced by node,\\n *     in content order, compute the text of the box after application of the\\n *     CSS `white-space` processing rules and `text-transform` rules, set\\n *     items to the list of the resulting strings, and return items.\\n *     The CSS `white-space` processing rules are slightly modified:\\n *     collapsible spaces at the end of lines are always collapsed, but they\\n *     are only removed if the line is the last line of the block, or it ends\\n *     with a br element.\\n *     Soft hyphens should be preserved.\\n *\\n *     Note: See `collectText` and `collectPreText`.\\n *     Note: we don\\u2019t deal with `text-transform`, no element has that by\\n *     default.\\n *\\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\\n *\\n * @param {Text | Comment} node\\n *   Text node.\\n * @param {CollectionInfo} info\\n *   Info on current collection.\\n * @returns {Array<string | BreakNumber>}\\n *   Result.\\n */\\n\\n\\nfunction collectText(node, info) {\\n  const value = String(node.value);\\n  /** @type {Array<string>} */\\n\\n  const lines = [];\\n  /** @type {Array<string | BreakNumber>} */\\n\\n  const result = [];\\n  let start = 0;\\n\\n  while (start <= value.length) {\\n    searchLineFeeds.lastIndex = start;\\n    const match = searchLineFeeds.exec(value);\\n    const end = match && 'index' in match ? match.index : value.length;\\n    lines.push( // Any sequence of collapsible spaces and tabs immediately preceding or\\n    // following a segment break is removed.\\n    trimAndCollapseSpacesAndTabs( // [\\u2026] ignoring bidi formatting characters (characters with the\\n    // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\\n    // they were not there.\\n    value.slice(start, end).replace(/[\\\\u061C\\\\u200E\\\\u200F\\\\u202A-\\\\u202E\\\\u2066-\\\\u2069]/g, ''), start === 0 ? info.breakBefore : true, end === value.length ? info.breakAfter : true));\\n    start = end + 1;\\n  } // Collapsible segment breaks are transformed for rendering according to the\\n  // segment break transformation rules.\\n  // So here we jump to 4.1.2 of [CSSTEXT]:\\n  // Any collapsible segment break immediately following another collapsible\\n  // segment break is removed\\n\\n\\n  let index = -1;\\n  /** @type {BreakNumber | undefined} */\\n\\n  let join;\\n\\n  while (++index < lines.length) {\\n    // *   If the character immediately before or immediately after the segment\\n    //     break is the zero-width space character (U+200B), then the break is\\n    //     removed, leaving behind the zero-width space.\\n    if (lines[index].charCodeAt(lines[index].length - 1) === 0x200b\\n    /* ZWSP */\\n    || index < lines.length - 1 && lines[index + 1].charCodeAt(0) === 0x200b\\n    /* ZWSP */\\n    ) {\\n      result.push(lines[index]);\\n      join = undefined;\\n    } // *   Otherwise, if the East Asian Width property [UAX11] of both the\\n    //     character before and after the segment break is Fullwidth, Wide, or\\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\\n    //     segment break is removed.\\n    //\\n    //     Note: ignored.\\n    // *   Otherwise, if the writing system of the segment break is Chinese,\\n    //     Japanese, or Yi, and the character before or after the segment break\\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\\n    //     has an East Asian Width property of Ambiguous, and the character on\\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\\n    //     and not Hangul, then the segment break is removed.\\n    //\\n    //     Note: ignored.\\n    // *   Otherwise, the segment break is converted to a space (U+0020).\\n    else if (lines[index]) {\\n      if (typeof join === 'number') result.push(join);\\n      result.push(lines[index]);\\n      join = 0;\\n    } else if (index === 0 || index === lines.length - 1) {\\n      // If this line is empty, and it\\u2019s the first or last, add a space.\\n      // Note that this function is only called in normal whitespace, so we\\n      // don\\u2019t worry about `pre`.\\n      result.push(0);\\n    }\\n  }\\n\\n  return result;\\n}\\n/**\\n * Collect a text node as \\u201cpre\\u201d whitespace.\\n *\\n * @param {Text} node\\n *   Text node.\\n * @returns {Array<string | BreakNumber>}\\n *   Result.\\n */\\n\\n\\nfunction collectPreText(node) {\\n  return [String(node.value)];\\n}\\n/**\\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\\n * 4.  Any collapsible space immediately following another collapsible\\n *     space\\u2014even one outside the boundary of the inline containing that\\n *     space, provided both spaces are within the same inline formatting\\n *     context\\u2014is collapsed to have zero advance width. (It is invisible,\\n *     but retains its soft wrap opportunity, if any.)\\n *\\n * @param {string} value\\n *   Value to collapse.\\n * @param {BreakBefore} breakBefore\\n *   Whether there was a break before.\\n * @param {BreakAfter} breakAfter\\n *   Whether there was a break after.\\n * @returns {string}\\n *   Result.\\n */\\n\\n\\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\\n  /** @type {Array<string>} */\\n  const result = [];\\n  let start = 0;\\n  /** @type {number | undefined} */\\n\\n  let end;\\n\\n  while (start < value.length) {\\n    searchTabOrSpaces.lastIndex = start;\\n    const match = searchTabOrSpaces.exec(value);\\n    end = match ? match.index : value.length; // If we\\u2019re not directly after a segment break, but there was white space,\\n    // add an empty value that will be turned into a space.\\n\\n    if (!start && !end && match && !breakBefore) {\\n      result.push('');\\n    }\\n\\n    if (start !== end) {\\n      result.push(value.slice(start, end));\\n    }\\n\\n    start = match ? end + match[0].length : end;\\n  } // If we reached the end, there was trailing white space, and there\\u2019s no\\n  // segment break after this node, add an empty value that will be turned\\n  // into a space.\\n\\n\\n  if (start !== end && !breakAfter) {\\n    result.push('');\\n  }\\n\\n  return result.join(' ');\\n}\\n/**\\n * Figure out the whitespace of a node.\\n *\\n * We don\\u2019t support void elements here (so `nobr wbr` -> `normal` is ignored).\\n *\\n * @param {Node} node\\n *   Node (typically `Element`).\\n * @param {CollectionInfo} info\\n *   Info on current collection.\\n * @returns {Whitespace}\\n *   Applied whitespace.\\n */\\n\\n\\nfunction inferWhitespace(node, info) {\\n  if (node.type === 'element') {\\n    const props = node.properties || {};\\n\\n    switch (node.tagName) {\\n      case 'listing':\\n      case 'plaintext':\\n      case 'xmp':\\n        {\\n          return 'pre';\\n        }\\n\\n      case 'nobr':\\n        {\\n          return 'nowrap';\\n        }\\n\\n      case 'pre':\\n        {\\n          return props.wrap ? 'pre-wrap' : 'pre';\\n        }\\n\\n      case 'td':\\n      case 'th':\\n        {\\n          return props.noWrap ? 'nowrap' : info.whitespace;\\n        }\\n\\n      case 'textarea':\\n        {\\n          return 'pre-wrap';\\n        }\\n\\n      default:\\n    }\\n  }\\n\\n  return info.whitespace;\\n}\\n/** @type {TestFunctionAnything} */\\n\\n\\nfunction hidden(node) {\\n  return Boolean((node.properties || {}).hidden);\\n}\\n/** @type {TestFunctionAnything} */\\n\\n\\nfunction closedDialog(node) {\\n  return node.tagName === 'dialog' && !(node.properties || {}).open;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"innerTextCollection\",\"node\",\"parent\",\"info\",\"type\",\"whitespace\",\"inferWhitespace\",\"children\",\"index\",\"items\",\"notRendered\",\"prefix\",\"br\",\"suffix\",\"row\",\"_unistUtilFindAfter\",\"findAfter\",\"p\",\"blockOrCaption\",\"length\",\"concat\",\"breakBefore\",\"undefined\",\"breakAfter\",\"cell\",\"push\",\"unshift\",\"collectText\",\"String\",\"value\",\"lines\",\"result\",\"start\",\"searchLineFeeds\",\"lastIndex\",\"match\",\"exec\",\"end\",\"slice\",\"replace\",\"searchTabOrSpaces\",\"join\",\"charCodeAt\",\"props\",\"properties\",\"tagName\",\"wrap\",\"noWrap\",\"Object\",\"defineProperty\",\"toText\",\"tree\",\"options\",\"block\",\"results\",\"count\",\"repeat\",\"_hastUtilIsElement\",\"convertElement\",\"hidden\",\"closedDialog\",\"open\"]\n}\n"]