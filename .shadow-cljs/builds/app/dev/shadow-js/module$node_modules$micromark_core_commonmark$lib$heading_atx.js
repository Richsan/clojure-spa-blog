["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-core-commonmark/lib/heading-atx.js"],"~:js","shadow$provide.module$node_modules$micromark_core_commonmark$lib$heading_atx=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.headingAtx=void 0;var _micromarkFactorySpace=require(\"module$node_modules$micromark_factory_space$index\"),_micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\"),_micromarkUtilChunked=require(\"module$node_modules$micromark_util_chunked$index\");exports.headingAtx={name:\"headingAtx\",tokenize:function(effects,\nok,nok){function fenceOpenInside(code){return 35===code&&6>size++?(effects.consume(code),fenceOpenInside):null===code||(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code)?(effects.exit(\"atxHeadingSequence\"),self.interrupt?ok(code):headingBreak(code)):nok(code)}function headingBreak(code){if(35===code)return effects.enter(\"atxHeadingSequence\"),sequence(code);if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.exit(\"atxHeading\"),ok(code);if((0,_micromarkUtilCharacter.markdownSpace)(code))return(0,_micromarkFactorySpace.factorySpace)(effects,\nheadingBreak,\"whitespace\")(code);effects.enter(\"atxHeadingText\");return data(code)}function sequence(code){if(35===code)return effects.consume(code),sequence;effects.exit(\"atxHeadingSequence\");return headingBreak(code)}function data(code){if(null===code||35===code||(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code))return effects.exit(\"atxHeadingText\"),headingBreak(code);effects.consume(code);return data}const self=this;let size=0;return function(code){effects.enter(\"atxHeading\");effects.enter(\"atxHeadingSequence\");\nreturn fenceOpenInside(code)}},resolve:function(events,context){let contentEnd=events.length-2,contentStart=3,content,text;\"whitespace\"===events[contentStart][1].type&&(contentStart+=2);contentEnd-2>contentStart&&\"whitespace\"===events[contentEnd][1].type&&(contentEnd-=2);\"atxHeadingSequence\"===events[contentEnd][1].type&&(contentStart===contentEnd-1||contentEnd-4>contentStart&&\"whitespace\"===events[contentEnd-2][1].type)&&(contentEnd-=contentStart+1===contentEnd?2:4);contentEnd>contentStart&&(content=\n{type:\"atxHeadingText\",start:events[contentStart][1].start,end:events[contentEnd][1].end},text={type:\"chunkText\",start:events[contentStart][1].start,end:events[contentEnd][1].end,contentType:\"text\"},(0,_micromarkUtilChunked.splice)(events,contentStart,contentEnd-contentStart+1,[[\"enter\",content,context],[\"enter\",text,context],[\"exit\",text,context],[\"exit\",content,context]]));return events}}}","~:source","shadow$provide[\"module$node_modules$micromark_core_commonmark$lib$heading_atx\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.headingAtx = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\n\n/** @type {Construct} */\nconst headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n};\n/** @type {Resolver} */\n\nexports.headingAtx = headingAtx;\n\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2;\n  let contentStart = 3;\n  /** @type {Token} */\n\n  let content;\n  /** @type {Token} */\n\n  let text; // Prefix whitespace, part of the opening.\n\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2;\n  } // Suffix whitespace, part of the closing.\n\n\n  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === 'whitespace') {\n    contentEnd -= 2;\n  }\n\n  if (events[contentEnd][1].type === 'atxHeadingSequence' && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === 'whitespace')) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    };\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      // @ts-expect-error Constants are fine to assign.\n      contentType: 'text'\n    };\n    (0, _micromarkUtilChunked.splice)(events, contentStart, contentEnd - contentStart + 1, [['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]]);\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  const self = this;\n  let size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('atxHeading');\n    effects.enter('atxHeadingSequence');\n    return fenceOpenInside(code);\n  }\n  /** @type {State} */\n\n\n  function fenceOpenInside(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code);\n      return fenceOpenInside;\n    }\n\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      effects.exit('atxHeadingSequence');\n      return self.interrupt ? ok(code) : headingBreak(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function headingBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence');\n      return sequence(code);\n    }\n\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('atxHeading');\n      return ok(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      return (0, _micromarkFactorySpace.factorySpace)(effects, headingBreak, 'whitespace')(code);\n    }\n\n    effects.enter('atxHeadingText');\n    return data(code);\n  }\n  /** @type {State} */\n\n\n  function sequence(code) {\n    if (code === 35) {\n      effects.consume(code);\n      return sequence;\n    }\n\n    effects.exit('atxHeadingSequence');\n    return headingBreak(code);\n  }\n  /** @type {State} */\n\n\n  function data(code) {\n    if (code === null || code === 35 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      effects.exit('atxHeadingText');\n      return headingBreak(code);\n    }\n\n    effects.consume(code);\n    return data;\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js","~$module$node_modules$micromark_util_chunked$index","~$module$node_modules$micromark_factory_space$index"]],"~:properties",["^5",["resolve","tokenize","__esModule","name","value","start","headingAtx","type","contentType","end"]],"~:compiled-at",1676665867288,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_core_commonmark$lib$heading_atx.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-core-commonmark/lib/heading-atx.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_core_commonmark$lib$heading_atx\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.headingAtx = void 0;\\n\\nvar _micromarkFactorySpace = require(\\\"micromark-factory-space\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\nvar _micromarkUtilChunked = require(\\\"micromark-util-chunked\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').Resolver} Resolver\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').Token} Token\\n * @typedef {import('micromark-util-types').State} State\\n */\\n\\n/** @type {Construct} */\\nconst headingAtx = {\\n  name: 'headingAtx',\\n  tokenize: tokenizeHeadingAtx,\\n  resolve: resolveHeadingAtx\\n};\\n/** @type {Resolver} */\\n\\nexports.headingAtx = headingAtx;\\n\\nfunction resolveHeadingAtx(events, context) {\\n  let contentEnd = events.length - 2;\\n  let contentStart = 3;\\n  /** @type {Token} */\\n\\n  let content;\\n  /** @type {Token} */\\n\\n  let text; // Prefix whitespace, part of the opening.\\n\\n  if (events[contentStart][1].type === 'whitespace') {\\n    contentStart += 2;\\n  } // Suffix whitespace, part of the closing.\\n\\n\\n  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === 'whitespace') {\\n    contentEnd -= 2;\\n  }\\n\\n  if (events[contentEnd][1].type === 'atxHeadingSequence' && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === 'whitespace')) {\\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;\\n  }\\n\\n  if (contentEnd > contentStart) {\\n    content = {\\n      type: 'atxHeadingText',\\n      start: events[contentStart][1].start,\\n      end: events[contentEnd][1].end\\n    };\\n    text = {\\n      type: 'chunkText',\\n      start: events[contentStart][1].start,\\n      end: events[contentEnd][1].end,\\n      // @ts-expect-error Constants are fine to assign.\\n      contentType: 'text'\\n    };\\n    (0, _micromarkUtilChunked.splice)(events, contentStart, contentEnd - contentStart + 1, [['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]]);\\n  }\\n\\n  return events;\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeHeadingAtx(effects, ok, nok) {\\n  const self = this;\\n  let size = 0;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('atxHeading');\\n    effects.enter('atxHeadingSequence');\\n    return fenceOpenInside(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function fenceOpenInside(code) {\\n    if (code === 35 && size++ < 6) {\\n      effects.consume(code);\\n      return fenceOpenInside;\\n    }\\n\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\\n      effects.exit('atxHeadingSequence');\\n      return self.interrupt ? ok(code) : headingBreak(code);\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function headingBreak(code) {\\n    if (code === 35) {\\n      effects.enter('atxHeadingSequence');\\n      return sequence(code);\\n    }\\n\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.exit('atxHeading');\\n      return ok(code);\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\\n      return (0, _micromarkFactorySpace.factorySpace)(effects, headingBreak, 'whitespace')(code);\\n    }\\n\\n    effects.enter('atxHeadingText');\\n    return data(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function sequence(code) {\\n    if (code === 35) {\\n      effects.consume(code);\\n      return sequence;\\n    }\\n\\n    effects.exit('atxHeadingSequence');\\n    return headingBreak(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function data(code) {\\n    if (code === null || code === 35 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\\n      effects.exit('atxHeadingText');\\n      return headingBreak(code);\\n    }\\n\\n    effects.consume(code);\\n    return data;\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"headingAtx\",\"_micromarkFactorySpace\",\"_micromarkUtilCharacter\",\"_micromarkUtilChunked\",\"name\",\"tokenize\",\"tokenizeHeadingAtx\",\"effects\",\"ok\",\"nok\",\"fenceOpenInside\",\"code\",\"size\",\"consume\",\"markdownLineEndingOrSpace\",\"exit\",\"self\",\"interrupt\",\"headingBreak\",\"enter\",\"sequence\",\"markdownLineEnding\",\"markdownSpace\",\"factorySpace\",\"data\",\"start\",\"resolve\",\"resolveHeadingAtx\",\"events\",\"context\",\"contentEnd\",\"length\",\"contentStart\",\"content\",\"text\",\"type\",\"end\",\"contentType\",\"splice\"]\n}\n"]