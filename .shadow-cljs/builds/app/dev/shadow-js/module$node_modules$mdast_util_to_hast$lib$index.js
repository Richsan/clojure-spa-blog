["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mdast-util-to-hast/lib/index.js"],"~:js","shadow$provide.module$node_modules$mdast_util_to_hast$lib$index=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.toHast=function(tree,options){options=(0,_state.createState)(tree,options);tree=options.one(tree,null);(options=(0,_footer.footer)(options))&&tree.children.push({type:\"text\",value:\"\\n\"},options);return Array.isArray(tree)?{type:\"root\",children:tree}:tree};var _footer=require(\"module$node_modules$mdast_util_to_hast$lib$footer\"),_state=\nrequire(\"module$node_modules$mdast_util_to_hast$lib$state\")}","~:source","shadow$provide[\"module$node_modules$mdast_util_to_hast$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toHast = toHast;\n\nvar _footer = require(\"./footer.js\");\n\nvar _state = require(\"./state.js\");\n\n/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Root} HastRoot\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Root} MdastRoot\n *\n * @typedef {import('./state.js').Options} Options\n */\n\n/**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n */\n\n/**\n * Transform mdast to hast.\n *\n * ##### Notes\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most utilities ignore `raw` nodes but two notable ones don’t:\n *\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\n *     output the raw HTML.\n *     This is typically discouraged as noted by the option name but is useful\n *     if you completely trust authors\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\n *     into standard hast nodes (`element`, `text`, etc).\n *     This is a heavy task as it needs a full HTML parser, but it is the only\n *     way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark, which we follow by default.\n * They are supported by GitHub, so footnotes can be enabled in markdown with\n * `mdast-util-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes, which is hidden for sighted users but shown to\n * assistive technology.\n * When your page is not in English, you must define translated values.\n *\n * Back references use ARIA attributes, but the section label itself uses a\n * heading that is hidden with an `sr-only` class.\n * To show it to sighted users, define different attributes in\n * `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem, as it links footnote calls to footnote\n * definitions on the page through `id` attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * *   when the node has a `value` (and doesn’t have `data.hName`,\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\n *     node\n * *   otherwise, create a `<div>` element (which could be changed with\n *     `data.hName`), with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @param {MdastNodes} tree\n *   mdast tree.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {HastNodes | null | undefined}\n *   hast tree.\n */\n// To do: next major: always return a single `root`.\nfunction toHast(tree, options) {\n  const state = (0, _state.createState)(tree, options);\n  const node = state.one(tree, null);\n  const foot = (0, _footer.footer)(state);\n\n  if (foot) {\n    // @ts-expect-error If there’s a footer, there were definitions, meaning block\n    // content.\n    // So assume `node` is a parent node.\n    node.children.push({\n      type: 'text',\n      value: '\\n'\n    }, foot);\n  } // To do: next major: always return root?\n\n\n  return Array.isArray(node) ? {\n    type: 'root',\n    children: node\n  } : node;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mdast_util_to_hast$lib$state","~$shadow.js","~$module$node_modules$mdast_util_to_hast$lib$footer"]],"~:properties",["^5",["children","__esModule","value","toHast","type"]],"~:compiled-at",1676665867323,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mdast_util_to_hast$lib$index.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,gDAAA,CAAqE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG7GC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,MAAR,CAmGAA,QAAe,CAACC,IAAD,CAAOC,OAAP,CAAgB,CACvBC,OAAAA,CAAQ,GAAIC,MAAOC,CAAAA,WAAX,EAAwBJ,IAAxB,CAA8BC,OAA9B,CACRI,KAAAA,CAAOH,OAAMI,CAAAA,GAAN,CAAUN,IAAV,CAAgB,IAAhB,CAGb,EAFMO,OAEN,CAFa,GAAIC,OAAQC,CAAAA,MAAZ,EAAoBP,OAApB,CAEb,GAIEG,IAAKK,CAAAA,QAASC,CAAAA,IAAd,CAAmB,CACjBC,KAAM,MADW,CAEjBd,MAAO,IAFU,CAAnB,CAGGS,OAHH,CAOF,OAAOM,MAAMC,CAAAA,OAAN,CAAcT,IAAd,CAAA,CAAsB,CAC3BO,KAAM,MADqB,CAE3BF,SAAUL,IAFiB,CAAtB,CAGHA,IAnByB,CAjG/B,KAAIG,QAAUf,OAAA,CAAQ,mDAAR,CAAd,CAEIU;AAASV,OAAA,CAAQ,kDAAR,CAVgG;\",\n\"sources\":[\"node_modules/mdast-util-to-hast/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mdast_util_to_hast$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.toHast = toHast;\\n\\nvar _footer = require(\\\"./footer.js\\\");\\n\\nvar _state = require(\\\"./state.js\\\");\\n\\n/**\\n * @typedef {import('hast').Content} HastContent\\n * @typedef {import('hast').Root} HastRoot\\n *\\n * @typedef {import('mdast').Content} MdastContent\\n * @typedef {import('mdast').Root} MdastRoot\\n *\\n * @typedef {import('./state.js').Options} Options\\n */\\n\\n/**\\n * @typedef {HastRoot | HastContent} HastNodes\\n * @typedef {MdastRoot | MdastContent} MdastNodes\\n */\\n\\n/**\\n * Transform mdast to hast.\\n *\\n * ##### Notes\\n *\\n * ###### HTML\\n *\\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\\n * as semistandard `raw` nodes.\\n * Most utilities ignore `raw` nodes but two notable ones don\\u2019t:\\n *\\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\\n *     output the raw HTML.\\n *     This is typically discouraged as noted by the option name but is useful\\n *     if you completely trust authors\\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\\n *     into standard hast nodes (`element`, `text`, etc).\\n *     This is a heavy task as it needs a full HTML parser, but it is the only\\n *     way to support untrusted content\\n *\\n * ###### Footnotes\\n *\\n * Many options supported here relate to footnotes.\\n * Footnotes are not specified by CommonMark, which we follow by default.\\n * They are supported by GitHub, so footnotes can be enabled in markdown with\\n * `mdast-util-gfm`.\\n *\\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\\n * that explains footnotes, which is hidden for sighted users but shown to\\n * assistive technology.\\n * When your page is not in English, you must define translated values.\\n *\\n * Back references use ARIA attributes, but the section label itself uses a\\n * heading that is hidden with an `sr-only` class.\\n * To show it to sighted users, define different attributes in\\n * `footnoteLabelProperties`.\\n *\\n * ###### Clobbering\\n *\\n * Footnotes introduces a problem, as it links footnote calls to footnote\\n * definitions on the page through `id` attributes generated from user content,\\n * which results in DOM clobbering.\\n *\\n * DOM clobbering is this:\\n *\\n * ```html\\n * <p id=x></p>\\n * <script>alert(x) // `x` now refers to the DOM `p#x` element\\u003c/script>\\n * ```\\n *\\n * Elements by their ID are made available by browsers on the `window` object,\\n * which is a security risk.\\n * Using a prefix solves this problem.\\n *\\n * More information on how to handle clobbering and the prefix is explained in\\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\\n *\\n * ###### Unknown nodes\\n *\\n * Unknown nodes are nodes with a type that isn\\u2019t in `handlers` or `passThrough`.\\n * The default behavior for unknown nodes is:\\n *\\n * *   when the node has a `value` (and doesn\\u2019t have `data.hName`,\\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\\n *     node\\n * *   otherwise, create a `<div>` element (which could be changed with\\n *     `data.hName`), with its children mapped from mdast to hast as well\\n *\\n * This behavior can be changed by passing an `unknownHandler`.\\n *\\n * @param {MdastNodes} tree\\n *   mdast tree.\\n * @param {Options | null | undefined} [options]\\n *   Configuration.\\n * @returns {HastNodes | null | undefined}\\n *   hast tree.\\n */\\n// To do: next major: always return a single `root`.\\nfunction toHast(tree, options) {\\n  const state = (0, _state.createState)(tree, options);\\n  const node = state.one(tree, null);\\n  const foot = (0, _footer.footer)(state);\\n\\n  if (foot) {\\n    // @ts-expect-error If there\\u2019s a footer, there were definitions, meaning block\\n    // content.\\n    // So assume `node` is a parent node.\\n    node.children.push({\\n      type: 'text',\\n      value: '\\\\n'\\n    }, foot);\\n  } // To do: next major: always return root?\\n\\n\\n  return Array.isArray(node) ? {\\n    type: 'root',\\n    children: node\\n  } : node;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"toHast\",\"tree\",\"options\",\"state\",\"_state\",\"createState\",\"node\",\"one\",\"foot\",\"_footer\",\"footer\",\"children\",\"push\",\"type\",\"Array\",\"isArray\"]\n}\n"]