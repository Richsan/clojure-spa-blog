["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-core-commonmark/lib/setext-underline.js"],"~:js","shadow$provide.module$node_modules$micromark_core_commonmark$lib$setext_underline=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.setextUnderline=void 0;var _micromarkFactorySpace=require(\"module$node_modules$micromark_factory_space$index\"),_micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\");exports.setextUnderline={name:\"setextUnderline\",tokenize:function(effects,ok,nok){function closingSequence(code){if(code===\nmarker)return effects.consume(code),closingSequence;effects.exit(\"setextHeadingLineSequence\");return(0,_micromarkFactorySpace.factorySpace)(effects,closingSequenceEnd,\"lineSuffix\")(code)}function closingSequenceEnd(code){return null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code)?(effects.exit(\"setextHeadingLine\"),ok(code)):nok(code)}const self=this;let index=self.events.length,marker,paragraph;for(;index--;)if(\"lineEnding\"!==self.events[index][1].type&&\"linePrefix\"!==self.events[index][1].type&&\n\"content\"!==self.events[index][1].type){paragraph=\"paragraph\"===self.events[index][1].type;break}return function(code){return self.parser.lazy[self.now().line]||!self.interrupt&&!paragraph?nok(code):(effects.enter(\"setextHeadingLine\"),effects.enter(\"setextHeadingLineSequence\"),marker=code,closingSequence(code))}},resolveTo:function(events,context){var index=events.length;let content,text,definition;for(;index--;)if(\"enter\"===events[index][0]){if(\"content\"===events[index][1].type){content=index;break}\"paragraph\"===\nevents[index][1].type&&(text=index)}else\"content\"===events[index][1].type&&events.splice(index,1),definition||\"definition\"!==events[index][1].type||(definition=index);index={type:\"setextHeading\",start:Object.assign({},events[text][1].start),end:Object.assign({},events[events.length-1][1].end)};events[text][1].type=\"setextHeadingText\";definition?(events.splice(text,0,[\"enter\",index,context]),events.splice(definition+1,0,[\"exit\",events[content][1],context]),events[content][1].end=Object.assign({},events[definition][1].end)):\nevents[content][1]=index;events.push([\"exit\",index,context]);return events}}}","~:source","shadow$provide[\"module$node_modules$micromark_core_commonmark$lib$setext_underline\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setextUnderline = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/** @type {Construct} */\nconst setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n};\n/** @type {Resolver} */\n\nexports.setextUnderline = setextUnderline;\n\nfunction resolveToSetextUnderline(events, context) {\n  let index = events.length;\n  /** @type {number|undefined} */\n\n  let content;\n  /** @type {number|undefined} */\n\n  let text;\n  /** @type {number|undefined} */\n\n  let definition; // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index;\n        break;\n      }\n\n      if (events[index][1].type === 'paragraph') {\n        text = index;\n      }\n    } // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1);\n      }\n\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index;\n      }\n    }\n  }\n\n  const heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }; // Change the paragraph to setext heading text.\n\n  events[text][1].type = 'setextHeadingText'; // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context]);\n    events.splice(definition + 1, 0, ['exit', events[content][1], context]);\n    events[content][1].end = Object.assign({}, events[definition][1].end);\n  } else {\n    events[content][1] = heading;\n  } // Add the heading exit at the end.\n\n\n  events.push(['exit', heading, context]);\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {NonNullable<Code>} */\n\n  let marker;\n  /** @type {boolean} */\n\n  let paragraph; // Find an opening.\n\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (self.events[index][1].type !== 'lineEnding' && self.events[index][1].type !== 'linePrefix' && self.events[index][1].type !== 'content') {\n      paragraph = self.events[index][1].type === 'paragraph';\n      break;\n    }\n  }\n\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine');\n      effects.enter('setextHeadingLineSequence');\n      marker = code;\n      return closingSequence(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return closingSequence;\n    }\n\n    effects.exit('setextHeadingLineSequence');\n    return (0, _micromarkFactorySpace.factorySpace)(effects, closingSequenceEnd, 'lineSuffix')(code);\n  }\n  /** @type {State} */\n\n\n  function closingSequenceEnd(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('setextHeadingLine');\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js","~$module$node_modules$micromark_factory_space$index"]],"~:properties",["^5",["resolveTo","tokenize","__esModule","setextUnderline","name","value","start","type","end"]],"~:compiled-at",1676665867297,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_core_commonmark$lib$setext_underline.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-core-commonmark/lib/setext-underline.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_core_commonmark$lib$setext_underline\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.setextUnderline = void 0;\\n\\nvar _micromarkFactorySpace = require(\\\"micromark-factory-space\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').Resolver} Resolver\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').State} State\\n * @typedef {import('micromark-util-types').Code} Code\\n */\\n\\n/** @type {Construct} */\\nconst setextUnderline = {\\n  name: 'setextUnderline',\\n  tokenize: tokenizeSetextUnderline,\\n  resolveTo: resolveToSetextUnderline\\n};\\n/** @type {Resolver} */\\n\\nexports.setextUnderline = setextUnderline;\\n\\nfunction resolveToSetextUnderline(events, context) {\\n  let index = events.length;\\n  /** @type {number|undefined} */\\n\\n  let content;\\n  /** @type {number|undefined} */\\n\\n  let text;\\n  /** @type {number|undefined} */\\n\\n  let definition; // Find the opening of the content.\\n  // It\\u2019ll always exist: we don\\u2019t tokenize if it isn\\u2019t there.\\n\\n  while (index--) {\\n    if (events[index][0] === 'enter') {\\n      if (events[index][1].type === 'content') {\\n        content = index;\\n        break;\\n      }\\n\\n      if (events[index][1].type === 'paragraph') {\\n        text = index;\\n      }\\n    } // Exit\\n    else {\\n      if (events[index][1].type === 'content') {\\n        // Remove the content end (if needed we\\u2019ll add it later)\\n        events.splice(index, 1);\\n      }\\n\\n      if (!definition && events[index][1].type === 'definition') {\\n        definition = index;\\n      }\\n    }\\n  }\\n\\n  const heading = {\\n    type: 'setextHeading',\\n    start: Object.assign({}, events[text][1].start),\\n    end: Object.assign({}, events[events.length - 1][1].end)\\n  }; // Change the paragraph to setext heading text.\\n\\n  events[text][1].type = 'setextHeadingText'; // If we have definitions in the content, we\\u2019ll keep on having content,\\n  // but we need move it.\\n\\n  if (definition) {\\n    events.splice(text, 0, ['enter', heading, context]);\\n    events.splice(definition + 1, 0, ['exit', events[content][1], context]);\\n    events[content][1].end = Object.assign({}, events[definition][1].end);\\n  } else {\\n    events[content][1] = heading;\\n  } // Add the heading exit at the end.\\n\\n\\n  events.push(['exit', heading, context]);\\n  return events;\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeSetextUnderline(effects, ok, nok) {\\n  const self = this;\\n  let index = self.events.length;\\n  /** @type {NonNullable<Code>} */\\n\\n  let marker;\\n  /** @type {boolean} */\\n\\n  let paragraph; // Find an opening.\\n\\n  while (index--) {\\n    // Skip enter/exit of line ending, line prefix, and content.\\n    // We can now either have a definition or a paragraph.\\n    if (self.events[index][1].type !== 'lineEnding' && self.events[index][1].type !== 'linePrefix' && self.events[index][1].type !== 'content') {\\n      paragraph = self.events[index][1].type === 'paragraph';\\n      break;\\n    }\\n  }\\n\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\\n      effects.enter('setextHeadingLine');\\n      effects.enter('setextHeadingLineSequence');\\n      marker = code;\\n      return closingSequence(code);\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function closingSequence(code) {\\n    if (code === marker) {\\n      effects.consume(code);\\n      return closingSequence;\\n    }\\n\\n    effects.exit('setextHeadingLineSequence');\\n    return (0, _micromarkFactorySpace.factorySpace)(effects, closingSequenceEnd, 'lineSuffix')(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function closingSequenceEnd(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.exit('setextHeadingLine');\\n      return ok(code);\\n    }\\n\\n    return nok(code);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"setextUnderline\",\"_micromarkFactorySpace\",\"_micromarkUtilCharacter\",\"name\",\"tokenize\",\"tokenizeSetextUnderline\",\"effects\",\"ok\",\"nok\",\"closingSequence\",\"code\",\"marker\",\"consume\",\"exit\",\"factorySpace\",\"closingSequenceEnd\",\"markdownLineEnding\",\"self\",\"index\",\"events\",\"length\",\"paragraph\",\"type\",\"start\",\"parser\",\"lazy\",\"now\",\"line\",\"interrupt\",\"enter\",\"resolveTo\",\"resolveToSetextUnderline\",\"context\",\"content\",\"text\",\"definition\",\"splice\",\"heading\",\"assign\",\"end\",\"push\"]\n}\n"]