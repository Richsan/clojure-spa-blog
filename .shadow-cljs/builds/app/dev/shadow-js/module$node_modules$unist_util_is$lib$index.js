["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/unist-util-is/lib/index.js"],"~:js","shadow$provide.module$node_modules$unist_util_is$lib$index=function(global,require,module,exports){function anyFactory(tests){const checks=[];let index$jscomp$0=-1;for(;++index$jscomp$0<tests.length;)checks[index$jscomp$0]=convert(tests[index$jscomp$0]);return castFactory(function(...parameters){let index=-1;for(;++index<checks.length;)if(checks[index].call(this,...parameters))return!0;return!1})}function propsFactory(check){return castFactory(function(node){let key;for(key in check)if(node[key]!==\ncheck[key])return!1;return!0})}function typeFactory(check){return castFactory(function(node){return node&&node.type===check})}function castFactory(check){return function(node,...parameters){return!!(node&&\"object\"===typeof node&&\"type\"in node&&check.call(this,node,...parameters))}}function ok(){return!0}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.convert=exports.is=void 0;exports.is=function is(node,test,index,parent,context){test=convert(test);if(void 0!==index&&null!==index&&\n(\"number\"!==typeof index||0>index||index===Number.POSITIVE_INFINITY))throw Error(\"Expected positive finite index\");if(!(void 0===parent||null===parent||is(parent)&&parent.children))throw Error(\"Expected parent node\");if((void 0===parent||null===parent)!==(void 0===index||null===index))throw Error(\"Expected both parent and index\");return node&&node.type&&\"string\"===typeof node.type?!!test.call(context,node,index,parent):!1};const convert=function(test){if(void 0===test||null===test)return ok;if(\"string\"===\ntypeof test)return typeFactory(test);if(\"object\"===typeof test)return Array.isArray(test)?anyFactory(test):propsFactory(test);if(\"function\"===typeof test)return castFactory(test);throw Error(\"Expected function, string, or object as test\");};exports.convert=convert}","~:source","shadow$provide[\"module$node_modules$unist_util_is$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convert = exports.is = void 0;\n\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nconst is =\n/**\n * @param {unknown} [node]\n * @param {Test} [test]\n * @param {number | null | undefined} [index]\n * @param {Parent | null | undefined} [parent]\n * @param {unknown} [context]\n * @returns {boolean}\n */\n// eslint-disable-next-line max-params\nfunction is(node, test, index, parent, context) {\n  const check = convert(test);\n\n  if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\n    throw new Error('Expected positive finite index');\n  }\n\n  if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) {\n    throw new Error('Expected parent node');\n  }\n\n  if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\n    throw new Error('Expected both parent and index');\n  } // @ts-expect-error Looks like a node.\n\n\n  return node && node.type && typeof node.type === 'string' ? Boolean(check.call(context, node, index, parent)) : false;\n};\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\n\n\nexports.is = is;\n\nconst convert =\n/**\n * @param {Test} [test]\n * @returns {AssertAnything}\n */\nfunction (test) {\n  if (test === undefined || test === null) {\n    return ok;\n  }\n\n  if (typeof test === 'string') {\n    return typeFactory(test);\n  }\n\n  if (typeof test === 'object') {\n    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);\n  }\n\n  if (typeof test === 'function') {\n    return castFactory(test);\n  }\n\n  throw new Error('Expected function, string, or object as test');\n};\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\n\n\nexports.convert = convert;\n\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = [];\n  let index = -1;\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index]);\n  }\n\n  return castFactory(any);\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n\n  function any(...parameters) {\n    let index = -1;\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true;\n    }\n\n    return false;\n  }\n}\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\n\n\nfunction propsFactory(check) {\n  return castFactory(all);\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n\n  function all(node) {\n    /** @type {string} */\n    let key;\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false;\n    }\n\n    return true;\n  }\n}\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\n\n\nfunction typeFactory(check) {\n  return castFactory(type);\n  /**\n   * @param {Node} node\n   */\n\n  function type(node) {\n    return node && node.type === check;\n  }\n}\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\n\n\nfunction castFactory(check) {\n  return assertion;\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n\n  function assertion(node, ...parameters) {\n    return Boolean(node && typeof node === 'object' && 'type' in node && // @ts-expect-error: fine.\n    Boolean(check.call(this, node, ...parameters)));\n  }\n}\n\nfunction ok() {\n  return true;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["is","__esModule","convert","value"]],"~:compiled-at",1676665867318,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$unist_util_is$lib$index.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/unist-util-is/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$unist_util_is$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.convert = exports.is = void 0;\\n\\n/**\\n * @typedef {import('unist').Node} Node\\n * @typedef {import('unist').Parent} Parent\\n */\\n\\n/**\\n * @typedef {Record<string, unknown>} Props\\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\\n *   Check for an arbitrary node, unaware of TypeScript inferral.\\n *\\n * @callback TestFunctionAnything\\n *   Check if a node passes a test, unaware of TypeScript inferral.\\n * @param {unknown} this\\n *   The given context.\\n * @param {Node} node\\n *   A node.\\n * @param {number | null | undefined} [index]\\n *   The node\\u2019s position in its parent.\\n * @param {Parent | null | undefined} [parent]\\n *   The node\\u2019s parent.\\n * @returns {boolean | void}\\n *   Whether this node passes the test.\\n */\\n\\n/**\\n * @template {Node} Kind\\n *   Node type.\\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\\n *   Check for a node that can be inferred by TypeScript.\\n */\\n\\n/**\\n * Check if a node passes a certain test.\\n *\\n * @template {Node} Kind\\n *   Node type.\\n * @callback TestFunctionPredicate\\n *   Complex test function for a node that can be inferred by TypeScript.\\n * @param {Node} node\\n *   A node.\\n * @param {number | null | undefined} [index]\\n *   The node\\u2019s position in its parent.\\n * @param {Parent | null | undefined} [parent]\\n *   The node\\u2019s parent.\\n * @returns {node is Kind}\\n *   Whether this node passes the test.\\n */\\n\\n/**\\n * @callback AssertAnything\\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\\n * @param {unknown} [node]\\n *   Anything (typically a node).\\n * @param {number | null | undefined} [index]\\n *   The node\\u2019s position in its parent.\\n * @param {Parent | null | undefined} [parent]\\n *   The node\\u2019s parent.\\n * @returns {boolean}\\n *   Whether this is a node and passes a test.\\n */\\n\\n/**\\n * Check if a node is a node and passes a certain node test.\\n *\\n * @template {Node} Kind\\n *   Node type.\\n * @callback AssertPredicate\\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\\n * @param {unknown} [node]\\n *   Anything (typically a node).\\n * @param {number | null | undefined} [index]\\n *   The node\\u2019s position in its parent.\\n * @param {Parent | null | undefined} [parent]\\n *   The node\\u2019s parent.\\n * @returns {node is Kind}\\n *   Whether this is a node and passes a test.\\n */\\n\\n/**\\n * Check if `node` is a `Node` and whether it passes the given test.\\n *\\n * @param node\\n *   Thing to check, typically `Node`.\\n * @param test\\n *   A check for a specific node.\\n * @param index\\n *   The node\\u2019s position in its parent.\\n * @param parent\\n *   The node\\u2019s parent.\\n * @returns\\n *   Whether `node` is a node and passes a test.\\n */\\nconst is =\\n/**\\n * @param {unknown} [node]\\n * @param {Test} [test]\\n * @param {number | null | undefined} [index]\\n * @param {Parent | null | undefined} [parent]\\n * @param {unknown} [context]\\n * @returns {boolean}\\n */\\n// eslint-disable-next-line max-params\\nfunction is(node, test, index, parent, context) {\\n  const check = convert(test);\\n\\n  if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\\n    throw new Error('Expected positive finite index');\\n  }\\n\\n  if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) {\\n    throw new Error('Expected parent node');\\n  }\\n\\n  if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\\n    throw new Error('Expected both parent and index');\\n  } // @ts-expect-error Looks like a node.\\n\\n\\n  return node && node.type && typeof node.type === 'string' ? Boolean(check.call(context, node, index, parent)) : false;\\n};\\n/**\\n * Generate an assertion from a test.\\n *\\n * Useful if you\\u2019re going to test many nodes, for example when creating a\\n * utility where something else passes a compatible test.\\n *\\n * The created function is a bit faster because it expects valid input only:\\n * a `node`, `index`, and `parent`.\\n *\\n * @param test\\n *   *   when nullish, checks if `node` is a `Node`.\\n *   *   when `string`, works like passing `(node) => node.type === test`.\\n *   *   when `function` checks if function passed the node is true.\\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\\n *   *   when `array`, checks if any one of the subtests pass.\\n * @returns\\n *   An assertion.\\n */\\n\\n\\nexports.is = is;\\n\\nconst convert =\\n/**\\n * @param {Test} [test]\\n * @returns {AssertAnything}\\n */\\nfunction (test) {\\n  if (test === undefined || test === null) {\\n    return ok;\\n  }\\n\\n  if (typeof test === 'string') {\\n    return typeFactory(test);\\n  }\\n\\n  if (typeof test === 'object') {\\n    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);\\n  }\\n\\n  if (typeof test === 'function') {\\n    return castFactory(test);\\n  }\\n\\n  throw new Error('Expected function, string, or object as test');\\n};\\n/**\\n * @param {Array<string | Props | TestFunctionAnything>} tests\\n * @returns {AssertAnything}\\n */\\n\\n\\nexports.convert = convert;\\n\\nfunction anyFactory(tests) {\\n  /** @type {Array<AssertAnything>} */\\n  const checks = [];\\n  let index = -1;\\n\\n  while (++index < tests.length) {\\n    checks[index] = convert(tests[index]);\\n  }\\n\\n  return castFactory(any);\\n  /**\\n   * @this {unknown}\\n   * @param {Array<unknown>} parameters\\n   * @returns {boolean}\\n   */\\n\\n  function any(...parameters) {\\n    let index = -1;\\n\\n    while (++index < checks.length) {\\n      if (checks[index].call(this, ...parameters)) return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n/**\\n * Turn an object into a test for a node with a certain fields.\\n *\\n * @param {Props} check\\n * @returns {AssertAnything}\\n */\\n\\n\\nfunction propsFactory(check) {\\n  return castFactory(all);\\n  /**\\n   * @param {Node} node\\n   * @returns {boolean}\\n   */\\n\\n  function all(node) {\\n    /** @type {string} */\\n    let key;\\n\\n    for (key in check) {\\n      // @ts-expect-error: hush, it sure works as an index.\\n      if (node[key] !== check[key]) return false;\\n    }\\n\\n    return true;\\n  }\\n}\\n/**\\n * Turn a string into a test for a node with a certain type.\\n *\\n * @param {string} check\\n * @returns {AssertAnything}\\n */\\n\\n\\nfunction typeFactory(check) {\\n  return castFactory(type);\\n  /**\\n   * @param {Node} node\\n   */\\n\\n  function type(node) {\\n    return node && node.type === check;\\n  }\\n}\\n/**\\n * Turn a custom test into a test for a node that passes that test.\\n *\\n * @param {TestFunctionAnything} check\\n * @returns {AssertAnything}\\n */\\n\\n\\nfunction castFactory(check) {\\n  return assertion;\\n  /**\\n   * @this {unknown}\\n   * @param {unknown} node\\n   * @param {Array<unknown>} parameters\\n   * @returns {boolean}\\n   */\\n\\n  function assertion(node, ...parameters) {\\n    return Boolean(node && typeof node === 'object' && 'type' in node && // @ts-expect-error: fine.\\n    Boolean(check.call(this, node, ...parameters)));\\n  }\\n}\\n\\nfunction ok() {\\n  return true;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"anyFactory\",\"tests\",\"checks\",\"index\",\"length\",\"convert\",\"castFactory\",\"any\",\"parameters\",\"call\",\"propsFactory\",\"check\",\"all\",\"node\",\"key\",\"typeFactory\",\"type\",\"assertion\",\"ok\",\"Object\",\"defineProperty\",\"value\",\"is\",\"test\",\"parent\",\"context\",\"undefined\",\"Number\",\"POSITIVE_INFINITY\",\"Error\",\"children\",\"Array\",\"isArray\"]\n}\n"]