["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-util-combine-extensions/index.js"],"~:js","shadow$provide.module$node_modules$micromark_util_combine_extensions$index=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.combineExtensions=function(extensions){const all={};let index$jscomp$0=-1;for(;++index$jscomp$0<extensions.length;){let hook=void 0;var all$jscomp$0=all,extension=extensions[index$jscomp$0];for(hook in extension){const left=(hasOwnProperty.call(all$jscomp$0,hook)?all$jscomp$0[hook]:void 0)||(all$jscomp$0[hook]={}),right=extension[hook];\nlet code;for(code in right){hasOwnProperty.call(left,code)||(left[code]=[]);var value=right[code],existing=left[code];value=Array.isArray(value)?value:value?[value]:[];let index=-1;const before=[];for(;++index<value.length;)(\"after\"===value[index].add?existing:before).push(value[index]);(0,_micromarkUtilChunked.splice)(existing,0,0,before)}}}return all};exports.combineHtmlExtensions=function(htmlExtensions){const handlers={};let index=-1;for(;++index<htmlExtensions.length;){let hook=void 0;var all=\nhandlers,extension=htmlExtensions[index];for(hook in extension){const left=(hasOwnProperty.call(all,hook)?all[hook]:void 0)||(all[hook]={}),right=extension[hook];let type;if(right)for(type in right)left[type]=right[type]}}return handlers};var _micromarkUtilChunked=require(\"module$node_modules$micromark_util_chunked$index\");const hasOwnProperty={}.hasOwnProperty}","~:source","shadow$provide[\"module$node_modules$micromark_util_combine_extensions$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.combineExtensions = combineExtensions;\nexports.combineHtmlExtensions = combineHtmlExtensions;\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\n/**\n * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\nconst hasOwnProperty = {}.hasOwnProperty;\n/**\n * Combine several syntax extensions into one.\n *\n * @param {Extension[]} extensions List of syntax extensions.\n * @returns {NormalizedExtension} A single combined extension.\n */\n\nfunction combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  const all = {};\n  let index = -1;\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index]);\n  }\n\n  return all;\n}\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all Extension to merge into.\n * @param {Extension} extension Extension to merge.\n * @returns {void}\n */\n\n\nfunction syntaxExtension(all, extension) {\n  /** @type {string} */\n  let hook;\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;\n    const left = maybe || (all[hook] = {});\n    const right = extension[hook];\n    /** @type {string} */\n\n    let code;\n\n    for (code in right) {\n      if (!hasOwnProperty.call(left, code)) left[code] = [];\n      const value = right[code];\n      constructs( // @ts-expect-error Looks like a list.\n      left[code], Array.isArray(value) ? value : value ? [value] : []);\n    }\n  }\n}\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {unknown[]} existing\n * @param {unknown[]} list\n * @returns {void}\n */\n\n\nfunction constructs(existing, list) {\n  let index = -1;\n  /** @type {unknown[]} */\n\n  const before = [];\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;\n    (list[index].add === 'after' ? existing : before).push(list[index]);\n  }\n\n  (0, _micromarkUtilChunked.splice)(existing, 0, 0, before);\n}\n/**\n * Combine several HTML extensions into one.\n *\n * @param {HtmlExtension[]} htmlExtensions List of HTML extensions.\n * @returns {HtmlExtension} A single combined extension.\n */\n\n\nfunction combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  const handlers = {};\n  let index = -1;\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index]);\n  }\n\n  return handlers;\n}\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all Extension to merge into.\n * @param {HtmlExtension} extension Extension to merge.\n * @returns {void}\n */\n\n\nfunction htmlExtension(all, extension) {\n  /** @type {string} */\n  let hook;\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;\n    const left = maybe || (all[hook] = {});\n    const right = extension[hook];\n    /** @type {string} */\n\n    let type;\n\n    if (right) {\n      for (type in right) {\n        left[type] = right[type];\n      }\n    }\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$micromark_util_chunked$index"]],"~:properties",["^5",["__esModule","value","combineExtensions","combineHtmlExtensions"]],"~:compiled-at",1676665867258,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_util_combine_extensions$index.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,2DAAA,CAAgF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGxHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,iBAAR,CAmBAA,QAA0B,CAACC,UAAD,CAAa,CAErC,MAAMC,IAAM,EACZ,KAAIC,eAAQ,CAAC,CAEb,KAAA,CAAO,EAAEA,cAAT,CAAiBF,UAAWG,CAAAA,MAA5B,CAAA,CAAoC,CAiBpC,IAAIC,KAAAA,IAAAA,EAhBcH,KAAAA,aAAAA,GAAAA,CAAK,UAAAD,UAAA,CAAWE,cAAX,CAkBvB,KAAKE,IAAL,GAAaC,UAAb,CAAwB,CAEtB,MAAMC,MADQC,cAAeC,CAAAA,IAAf,CAAoBP,YAApB,CAAyBG,IAAzB,CAAAK,CAAiCR,YAAA,CAAIG,IAAJ,CAAjCK,CAA6CC,IAAAA,EACrDJ,IAAiBL,YAAA,CAAIG,IAAJ,CAAjBE,CAA6B,EAA7BA,CAAN,CACMK,MAAQN,SAAA,CAAUD,IAAV,CAGd;IAAIQ,IAEJ,KAAKA,IAAL,GAAaD,MAAb,CAAoB,CACbJ,cAAeC,CAAAA,IAAf,CAAoBF,IAApB,CAA0BM,IAA1B,CAAL,GAAsCN,IAAA,CAAKM,IAAL,CAAtC,CAAmD,EAAnD,CACA,KAAMd,MAAQa,KAAA,CAAMC,IAAN,CAAd,CAEA,SAAAN,IAAA,CAAKM,IAAL,CAAY,MAAA,CAAAC,KAAMC,CAAAA,OAAN,CAAchB,KAAd,CAAA,CAAuBA,KAAvB,CAA+BA,KAAA,CAAQ,CAACA,KAAD,CAAR,CAAkB,EAejE,KAAII,MAAQ,CAAC,CAGb,OAAMa,OAAS,EAEf,KAAA,CAAO,EAAEb,KAAT,CAAiBc,KAAKb,CAAAA,MAAtB,CAAA,CAGoDc,CAA7B,OAApB,GAAAD,KAAA,CAAKd,KAAL,CAAYgB,CAAAA,GAAZ,CAA8BC,QAA9B,CAAyCJ,MAAQE,EAAAA,IAAlD,CAAuDD,KAAA,CAAKd,KAAL,CAAvD,CAGF,IAAIkB,qBAAsBC,CAAAA,MAA1B,EAAkCF,QAAlC,CAA4C,CAA5C,CAA+C,CAA/C,CAAkDJ,MAAlD,CA9BsB,CARE,CAnBY,CAIpC,MAAOd,IAT8B,CAlBvCN,QAAQ2B,CAAAA,qBAAR,CA0FAA,QAA8B,CAACC,cAAD,CAAiB,CAE7C,MAAMC,SAAW,EACjB,KAAItB,MAAQ,CAAC,CAEb,KAAA,CAAO,EAAEA,KAAT,CAAiBqB,cAAepB,CAAAA,MAAhC,CAAA,CAAwC,CAiBxC,IAAIC,KAAAA,IAAAA,EAhBYoB,KAAAA;AAAAA,QAAAA,CAAU,UAAAD,cAAA,CAAerB,KAAf,CAkB1B,KAAKE,IAAL,GAAaC,UAAb,CAAwB,CAEtB,MAAMC,MADQC,cAAeC,CAAAA,IAAf,CAAoBP,GAApB,CAAyBG,IAAzB,CAAAK,CAAiCR,GAAA,CAAIG,IAAJ,CAAjCK,CAA6CC,IAAAA,EACrDJ,IAAiBL,GAAA,CAAIG,IAAJ,CAAjBE,CAA6B,EAA7BA,CAAN,CACMK,MAAQN,SAAA,CAAUD,IAAV,CAGd,KAAIqB,IAEJ,IAAId,KAAJ,CACE,IAAKc,IAAL,GAAad,MAAb,CACEL,IAAA,CAAKmB,IAAL,CAAA,CAAad,KAAA,CAAMc,IAAN,CAVK,CAnBgB,CAIxC,MAAOD,SATsC,CAxF/C,KAAIJ,sBAAwB3B,OAAA,CAAQ,kDAAR,CAQ5B,OAAMc,eAAiB,EAAGA,CAAAA,cAjB8F;\",\n\"sources\":[\"node_modules/micromark-util-combine-extensions/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_util_combine_extensions$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.combineExtensions = combineExtensions;\\nexports.combineHtmlExtensions = combineHtmlExtensions;\\n\\nvar _micromarkUtilChunked = require(\\\"micromark-util-chunked\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension\\n * @typedef {import('micromark-util-types').Extension} Extension\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\\n */\\nconst hasOwnProperty = {}.hasOwnProperty;\\n/**\\n * Combine several syntax extensions into one.\\n *\\n * @param {Extension[]} extensions List of syntax extensions.\\n * @returns {NormalizedExtension} A single combined extension.\\n */\\n\\nfunction combineExtensions(extensions) {\\n  /** @type {NormalizedExtension} */\\n  const all = {};\\n  let index = -1;\\n\\n  while (++index < extensions.length) {\\n    syntaxExtension(all, extensions[index]);\\n  }\\n\\n  return all;\\n}\\n/**\\n * Merge `extension` into `all`.\\n *\\n * @param {NormalizedExtension} all Extension to merge into.\\n * @param {Extension} extension Extension to merge.\\n * @returns {void}\\n */\\n\\n\\nfunction syntaxExtension(all, extension) {\\n  /** @type {string} */\\n  let hook;\\n\\n  for (hook in extension) {\\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;\\n    const left = maybe || (all[hook] = {});\\n    const right = extension[hook];\\n    /** @type {string} */\\n\\n    let code;\\n\\n    for (code in right) {\\n      if (!hasOwnProperty.call(left, code)) left[code] = [];\\n      const value = right[code];\\n      constructs( // @ts-expect-error Looks like a list.\\n      left[code], Array.isArray(value) ? value : value ? [value] : []);\\n    }\\n  }\\n}\\n/**\\n * Merge `list` into `existing` (both lists of constructs).\\n * Mutates `existing`.\\n *\\n * @param {unknown[]} existing\\n * @param {unknown[]} list\\n * @returns {void}\\n */\\n\\n\\nfunction constructs(existing, list) {\\n  let index = -1;\\n  /** @type {unknown[]} */\\n\\n  const before = [];\\n\\n  while (++index < list.length) {\\n    // @ts-expect-error Looks like an object.\\n    ;\\n    (list[index].add === 'after' ? existing : before).push(list[index]);\\n  }\\n\\n  (0, _micromarkUtilChunked.splice)(existing, 0, 0, before);\\n}\\n/**\\n * Combine several HTML extensions into one.\\n *\\n * @param {HtmlExtension[]} htmlExtensions List of HTML extensions.\\n * @returns {HtmlExtension} A single combined extension.\\n */\\n\\n\\nfunction combineHtmlExtensions(htmlExtensions) {\\n  /** @type {HtmlExtension} */\\n  const handlers = {};\\n  let index = -1;\\n\\n  while (++index < htmlExtensions.length) {\\n    htmlExtension(handlers, htmlExtensions[index]);\\n  }\\n\\n  return handlers;\\n}\\n/**\\n * Merge `extension` into `all`.\\n *\\n * @param {HtmlExtension} all Extension to merge into.\\n * @param {HtmlExtension} extension Extension to merge.\\n * @returns {void}\\n */\\n\\n\\nfunction htmlExtension(all, extension) {\\n  /** @type {string} */\\n  let hook;\\n\\n  for (hook in extension) {\\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;\\n    const left = maybe || (all[hook] = {});\\n    const right = extension[hook];\\n    /** @type {string} */\\n\\n    let type;\\n\\n    if (right) {\\n      for (type in right) {\\n        left[type] = right[type];\\n      }\\n    }\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"combineExtensions\",\"extensions\",\"all\",\"index\",\"length\",\"hook\",\"extension\",\"left\",\"hasOwnProperty\",\"call\",\"maybe\",\"undefined\",\"right\",\"code\",\"Array\",\"isArray\",\"before\",\"list\",\"push\",\"add\",\"existing\",\"_micromarkUtilChunked\",\"splice\",\"combineHtmlExtensions\",\"htmlExtensions\",\"handlers\",\"type\"]\n}\n"]