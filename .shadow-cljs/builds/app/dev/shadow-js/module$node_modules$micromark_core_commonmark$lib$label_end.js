["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-core-commonmark/lib/label-end.js"],"~:js","shadow$provide.module$node_modules$micromark_core_commonmark$lib$label_end=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.labelEnd=void 0;var _micromarkFactoryDestination=require(\"module$node_modules$micromark_factory_destination$index\"),_micromarkFactoryLabel=require(\"module$node_modules$micromark_factory_label$index\"),_micromarkFactoryTitle=require(\"module$node_modules$micromark_factory_title$index\"),_micromarkFactoryWhitespace=require(\"module$node_modules$micromark_factory_whitespace$index\"),\n_micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\"),_micromarkUtilChunked=require(\"module$node_modules$micromark_util_chunked$index\"),_micromarkUtilNormalizeIdentifier=require(\"module$node_modules$micromark_util_normalize_identifier$index\"),_micromarkUtilResolveAll=require(\"module$node_modules$micromark_util_resolve_all$index\");exports.labelEnd={name:\"labelEnd\",tokenize:function(effects,ok,nok){function afterLabelEnd(code){return 40===code?effects.attempt(resourceConstruct,\nok,defined?ok:balanced)(code):91===code?effects.attempt(fullReferenceConstruct,ok,defined?effects.attempt(collapsedReferenceConstruct,ok,balanced):balanced)(code):defined?ok(code):balanced(code)}function balanced(code){labelStart._balanced=!0;return nok(code)}const self=this;let index=self.events.length,labelStart,defined;for(;index--;)if((\"labelImage\"===self.events[index][1].type||\"labelLink\"===self.events[index][1].type)&&!self.events[index][1]._balanced){labelStart=self.events[index][1];break}return function(code){if(!labelStart)return nok(code);\nif(labelStart._inactive)return balanced(code);defined=self.parser.defined.includes((0,_micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize({start:labelStart.end,end:self.now()})));effects.enter(\"labelEnd\");effects.enter(\"labelMarker\");effects.consume(code);effects.exit(\"labelMarker\");effects.exit(\"labelEnd\");return afterLabelEnd}},resolveTo:function(events,context){var index=events.length;let offset=0;let open,close;for(;index--;){var token=events[index][1];if(open){if(\"link\"===\ntoken.type||\"labelLink\"===token.type&&token._inactive)break;\"enter\"===events[index][0]&&\"labelLink\"===token.type&&(token._inactive=!0)}else if(close){if(\"enter\"===events[index][0]&&(\"labelImage\"===token.type||\"labelLink\"===token.type)&&!token._balanced&&(open=index,\"labelLink\"!==token.type)){offset=2;break}}else\"labelEnd\"===token.type&&(close=index)}token={type:\"labelLink\"===events[open][1].type?\"link\":\"image\",start:Object.assign({},events[open][1].start),end:Object.assign({},events[events.length-\n1][1].end)};const label={type:\"label\",start:Object.assign({},events[open][1].start),end:Object.assign({},events[close][1].end)},text={type:\"labelText\",start:Object.assign({},events[open+offset+2][1].end),end:Object.assign({},events[close-2][1].start)};index=[[\"enter\",token,context],[\"enter\",label,context]];index=(0,_micromarkUtilChunked.push)(index,events.slice(open+1,open+offset+3));index=(0,_micromarkUtilChunked.push)(index,[[\"enter\",text,context]]);index=(0,_micromarkUtilChunked.push)(index,(0,_micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan.null,\nevents.slice(open+offset+4,close-3),context));index=(0,_micromarkUtilChunked.push)(index,[[\"exit\",text,context],events[close-2],events[close-1],[\"exit\",label,context]]);index=(0,_micromarkUtilChunked.push)(index,events.slice(close+1));index=(0,_micromarkUtilChunked.push)(index,[[\"exit\",token,context]]);(0,_micromarkUtilChunked.splice)(events,open,events.length,index);return events},resolveAll:function(events){let index=-1,token;for(;++index<events.length;)if(token=events[index][1],\"labelImage\"===\ntoken.type||\"labelLink\"===token.type||\"labelEnd\"===token.type)events.splice(index+1,\"labelImage\"===token.type?4:2),token.type=\"data\",index++;return events}};const resourceConstruct={tokenize:function(effects,ok,nok){function open(code){return 41===code?end(code):(0,_micromarkFactoryDestination.factoryDestination)(effects,destinationAfter,nok,\"resourceDestination\",\"resourceDestinationLiteral\",\"resourceDestinationLiteralMarker\",\"resourceDestinationRaw\",\"resourceDestinationString\",32)(code)}function destinationAfter(code){return(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code)?\n(0,_micromarkFactoryWhitespace.factoryWhitespace)(effects,between)(code):end(code)}function between(code){return 34===code||39===code||40===code?(0,_micromarkFactoryTitle.factoryTitle)(effects,(0,_micromarkFactoryWhitespace.factoryWhitespace)(effects,end),nok,\"resourceTitle\",\"resourceTitleMarker\",\"resourceTitleString\")(code):end(code)}function end(code){return 41===code?(effects.enter(\"resourceMarker\"),effects.consume(code),effects.exit(\"resourceMarker\"),effects.exit(\"resource\"),ok):nok(code)}return function(code){effects.enter(\"resource\");\neffects.enter(\"resourceMarker\");effects.consume(code);effects.exit(\"resourceMarker\");return(0,_micromarkFactoryWhitespace.factoryWhitespace)(effects,open)}}},fullReferenceConstruct={tokenize:function(effects,ok,nok){function afterLabel(code){return self.parser.defined.includes((0,_micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(self.events[self.events.length-1][1]).slice(1,-1)))?ok(code):nok(code)}const self=this;return function(code){return _micromarkFactoryLabel.factoryLabel.call(self,\neffects,afterLabel,nok,\"reference\",\"referenceMarker\",\"referenceString\")(code)}}},collapsedReferenceConstruct={tokenize:function(effects,ok,nok){function open(code){return 93===code?(effects.enter(\"referenceMarker\"),effects.consume(code),effects.exit(\"referenceMarker\"),effects.exit(\"reference\"),ok):nok(code)}return function(code){effects.enter(\"reference\");effects.enter(\"referenceMarker\");effects.consume(code);effects.exit(\"referenceMarker\");return open}}}}","~:source","shadow$provide[\"module$node_modules$micromark_core_commonmark$lib$label_end\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.labelEnd = void 0;\n\nvar _micromarkFactoryDestination = require(\"micromark-factory-destination\");\n\nvar _micromarkFactoryLabel = require(\"micromark-factory-label\");\n\nvar _micromarkFactoryTitle = require(\"micromark-factory-title\");\n\nvar _micromarkFactoryWhitespace = require(\"micromark-factory-whitespace\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\nvar _micromarkUtilNormalizeIdentifier = require(\"micromark-util-normalize-identifier\");\n\nvar _micromarkUtilResolveAll = require(\"micromark-util-resolve-all\");\n\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/** @type {Construct} */\nconst labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n};\n/** @type {Construct} */\n\nexports.labelEnd = labelEnd;\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n};\n/** @type {Construct} */\n\nconst fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n};\n/** @type {Construct} */\n\nconst collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n};\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  let index = -1;\n  /** @type {Token} */\n\n  let token;\n\n  while (++index < events.length) {\n    token = events[index][1];\n\n    if (token.type === 'labelImage' || token.type === 'labelLink' || token.type === 'labelEnd') {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2);\n      token.type = 'data';\n      index++;\n    }\n  }\n\n  return events;\n}\n/** @type {Resolver} */\n\n\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length;\n  let offset = 0;\n  /** @type {Token} */\n\n  let token;\n  /** @type {number|undefined} */\n\n  let open;\n  /** @type {number|undefined} */\n\n  let close;\n  /** @type {Event[]} */\n\n  let media; // Find an opening.\n\n  while (index--) {\n    token = events[index][1];\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (token.type === 'link' || token.type === 'labelLink' && token._inactive) {\n        break;\n      } // Mark other link openings as inactive, as we can’t have links in\n      // links.\n\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === 'labelImage' || token.type === 'labelLink') && !token._balanced) {\n        open = index;\n\n        if (token.type !== 'labelLink') {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index;\n    }\n  }\n\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  };\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  };\n  media = [['enter', group, context], ['enter', label, context]]; // Opening marker.\n\n  media = (0, _micromarkUtilChunked.push)(media, events.slice(open + 1, open + offset + 3)); // Text open.\n\n  media = (0, _micromarkUtilChunked.push)(media, [['enter', text, context]]); // Between.\n\n  media = (0, _micromarkUtilChunked.push)(media, (0, _micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context)); // Text close, marker close, label close.\n\n  media = (0, _micromarkUtilChunked.push)(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]); // Reference, resource, or so.\n\n  media = (0, _micromarkUtilChunked.push)(media, events.slice(close + 1)); // Media close.\n\n  media = (0, _micromarkUtilChunked.push)(media, [['exit', group, context]]);\n  (0, _micromarkUtilChunked.splice)(events, open, events.length, media);\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {Token} */\n\n  let labelStart;\n  /** @type {boolean} */\n\n  let defined; // Find an opening.\n\n  while (index--) {\n    if ((self.events[index][1].type === 'labelImage' || self.events[index][1].type === 'labelLink') && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code);\n    } // It’s a balanced bracket, but contains a link.\n\n\n    if (labelStart._inactive) return balanced(code);\n    defined = self.parser.defined.includes((0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    })));\n    effects.enter('labelEnd');\n    effects.enter('labelMarker');\n    effects.consume(code);\n    effects.exit('labelMarker');\n    effects.exit('labelEnd');\n    return afterLabelEnd;\n  }\n  /** @type {State} */\n\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(resourceConstruct, ok, defined ? ok : balanced)(code);\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n\n    if (code === 91) {\n      return effects.attempt(fullReferenceConstruct, ok, defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced)(code);\n    } // Shortcut reference: `[asd]`?\n\n\n    return defined ? ok(code) : balanced(code);\n  }\n  /** @type {State} */\n\n\n  function balanced(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('resource');\n    effects.enter('resourceMarker');\n    effects.consume(code);\n    effects.exit('resourceMarker');\n    return (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, open);\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 41) {\n      return end(code);\n    }\n\n    return (0, _micromarkFactoryDestination.factoryDestination)(effects, destinationAfter, nok, 'resourceDestination', 'resourceDestinationLiteral', 'resourceDestinationLiteralMarker', 'resourceDestinationRaw', 'resourceDestinationString', 32)(code);\n  }\n  /** @type {State} */\n\n\n  function destinationAfter(code) {\n    return (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code) ? (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, between)(code) : end(code);\n  }\n  /** @type {State} */\n\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return (0, _micromarkFactoryTitle.factoryTitle)(effects, (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, end), nok, 'resourceTitle', 'resourceTitleMarker', 'resourceTitleString')(code);\n    }\n\n    return end(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker');\n      effects.consume(code);\n      effects.exit('resourceMarker');\n      effects.exit('resource');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    return _micromarkFactoryLabel.factoryLabel.call(self, effects, afterLabel, nok, 'reference', 'referenceMarker', 'referenceString')(code);\n  }\n  /** @type {State} */\n\n\n  function afterLabel(code) {\n    return self.parser.defined.includes((0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('reference');\n    effects.enter('referenceMarker');\n    effects.consume(code);\n    effects.exit('referenceMarker');\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker');\n      effects.consume(code);\n      effects.exit('referenceMarker');\n      effects.exit('reference');\n      return ok;\n    }\n\n    return nok(code);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_normalize_identifier$index","~$module$node_modules$micromark_util_character$index","~$module$node_modules$micromark_util_resolve_all$index","~$shadow.js","~$module$node_modules$micromark_util_chunked$index","~$module$node_modules$micromark_factory_destination$index","~$module$node_modules$micromark_factory_title$index","~$module$node_modules$micromark_factory_whitespace$index","~$module$node_modules$micromark_factory_label$index"]],"~:properties",["^5",["resolveTo","resolveAll","tokenize","__esModule","name","value","_inactive","start","type","labelEnd","_balanced","end"]],"~:compiled-at",1676665867293,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_core_commonmark$lib$label_end.js\",\n\"lineCount\":11,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-core-commonmark/lib/label-end.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_core_commonmark$lib$label_end\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.labelEnd = void 0;\\n\\nvar _micromarkFactoryDestination = require(\\\"micromark-factory-destination\\\");\\n\\nvar _micromarkFactoryLabel = require(\\\"micromark-factory-label\\\");\\n\\nvar _micromarkFactoryTitle = require(\\\"micromark-factory-title\\\");\\n\\nvar _micromarkFactoryWhitespace = require(\\\"micromark-factory-whitespace\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\nvar _micromarkUtilChunked = require(\\\"micromark-util-chunked\\\");\\n\\nvar _micromarkUtilNormalizeIdentifier = require(\\\"micromark-util-normalize-identifier\\\");\\n\\nvar _micromarkUtilResolveAll = require(\\\"micromark-util-resolve-all\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').Resolver} Resolver\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').Event} Event\\n * @typedef {import('micromark-util-types').Token} Token\\n * @typedef {import('micromark-util-types').State} State\\n * @typedef {import('micromark-util-types').Code} Code\\n */\\n\\n/** @type {Construct} */\\nconst labelEnd = {\\n  name: 'labelEnd',\\n  tokenize: tokenizeLabelEnd,\\n  resolveTo: resolveToLabelEnd,\\n  resolveAll: resolveAllLabelEnd\\n};\\n/** @type {Construct} */\\n\\nexports.labelEnd = labelEnd;\\nconst resourceConstruct = {\\n  tokenize: tokenizeResource\\n};\\n/** @type {Construct} */\\n\\nconst fullReferenceConstruct = {\\n  tokenize: tokenizeFullReference\\n};\\n/** @type {Construct} */\\n\\nconst collapsedReferenceConstruct = {\\n  tokenize: tokenizeCollapsedReference\\n};\\n/** @type {Resolver} */\\n\\nfunction resolveAllLabelEnd(events) {\\n  let index = -1;\\n  /** @type {Token} */\\n\\n  let token;\\n\\n  while (++index < events.length) {\\n    token = events[index][1];\\n\\n    if (token.type === 'labelImage' || token.type === 'labelLink' || token.type === 'labelEnd') {\\n      // Remove the marker.\\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2);\\n      token.type = 'data';\\n      index++;\\n    }\\n  }\\n\\n  return events;\\n}\\n/** @type {Resolver} */\\n\\n\\nfunction resolveToLabelEnd(events, context) {\\n  let index = events.length;\\n  let offset = 0;\\n  /** @type {Token} */\\n\\n  let token;\\n  /** @type {number|undefined} */\\n\\n  let open;\\n  /** @type {number|undefined} */\\n\\n  let close;\\n  /** @type {Event[]} */\\n\\n  let media; // Find an opening.\\n\\n  while (index--) {\\n    token = events[index][1];\\n\\n    if (open) {\\n      // If we see another link, or inactive link label, we\\u2019ve been here before.\\n      if (token.type === 'link' || token.type === 'labelLink' && token._inactive) {\\n        break;\\n      } // Mark other link openings as inactive, as we can\\u2019t have links in\\n      // links.\\n\\n\\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\\n        token._inactive = true;\\n      }\\n    } else if (close) {\\n      if (events[index][0] === 'enter' && (token.type === 'labelImage' || token.type === 'labelLink') && !token._balanced) {\\n        open = index;\\n\\n        if (token.type !== 'labelLink') {\\n          offset = 2;\\n          break;\\n        }\\n      }\\n    } else if (token.type === 'labelEnd') {\\n      close = index;\\n    }\\n  }\\n\\n  const group = {\\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\\n    start: Object.assign({}, events[open][1].start),\\n    end: Object.assign({}, events[events.length - 1][1].end)\\n  };\\n  const label = {\\n    type: 'label',\\n    start: Object.assign({}, events[open][1].start),\\n    end: Object.assign({}, events[close][1].end)\\n  };\\n  const text = {\\n    type: 'labelText',\\n    start: Object.assign({}, events[open + offset + 2][1].end),\\n    end: Object.assign({}, events[close - 2][1].start)\\n  };\\n  media = [['enter', group, context], ['enter', label, context]]; // Opening marker.\\n\\n  media = (0, _micromarkUtilChunked.push)(media, events.slice(open + 1, open + offset + 3)); // Text open.\\n\\n  media = (0, _micromarkUtilChunked.push)(media, [['enter', text, context]]); // Between.\\n\\n  media = (0, _micromarkUtilChunked.push)(media, (0, _micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context)); // Text close, marker close, label close.\\n\\n  media = (0, _micromarkUtilChunked.push)(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]); // Reference, resource, or so.\\n\\n  media = (0, _micromarkUtilChunked.push)(media, events.slice(close + 1)); // Media close.\\n\\n  media = (0, _micromarkUtilChunked.push)(media, [['exit', group, context]]);\\n  (0, _micromarkUtilChunked.splice)(events, open, events.length, media);\\n  return events;\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeLabelEnd(effects, ok, nok) {\\n  const self = this;\\n  let index = self.events.length;\\n  /** @type {Token} */\\n\\n  let labelStart;\\n  /** @type {boolean} */\\n\\n  let defined; // Find an opening.\\n\\n  while (index--) {\\n    if ((self.events[index][1].type === 'labelImage' || self.events[index][1].type === 'labelLink') && !self.events[index][1]._balanced) {\\n      labelStart = self.events[index][1];\\n      break;\\n    }\\n  }\\n\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    if (!labelStart) {\\n      return nok(code);\\n    } // It\\u2019s a balanced bracket, but contains a link.\\n\\n\\n    if (labelStart._inactive) return balanced(code);\\n    defined = self.parser.defined.includes((0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize({\\n      start: labelStart.end,\\n      end: self.now()\\n    })));\\n    effects.enter('labelEnd');\\n    effects.enter('labelMarker');\\n    effects.consume(code);\\n    effects.exit('labelMarker');\\n    effects.exit('labelEnd');\\n    return afterLabelEnd;\\n  }\\n  /** @type {State} */\\n\\n\\n  function afterLabelEnd(code) {\\n    // Resource: `[asd](fgh)`.\\n    if (code === 40) {\\n      return effects.attempt(resourceConstruct, ok, defined ? ok : balanced)(code);\\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\\n\\n\\n    if (code === 91) {\\n      return effects.attempt(fullReferenceConstruct, ok, defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced)(code);\\n    } // Shortcut reference: `[asd]`?\\n\\n\\n    return defined ? ok(code) : balanced(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function balanced(code) {\\n    labelStart._balanced = true;\\n    return nok(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeResource(effects, ok, nok) {\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('resource');\\n    effects.enter('resourceMarker');\\n    effects.consume(code);\\n    effects.exit('resourceMarker');\\n    return (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, open);\\n  }\\n  /** @type {State} */\\n\\n\\n  function open(code) {\\n    if (code === 41) {\\n      return end(code);\\n    }\\n\\n    return (0, _micromarkFactoryDestination.factoryDestination)(effects, destinationAfter, nok, 'resourceDestination', 'resourceDestinationLiteral', 'resourceDestinationLiteralMarker', 'resourceDestinationRaw', 'resourceDestinationString', 32)(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function destinationAfter(code) {\\n    return (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code) ? (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, between)(code) : end(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function between(code) {\\n    if (code === 34 || code === 39 || code === 40) {\\n      return (0, _micromarkFactoryTitle.factoryTitle)(effects, (0, _micromarkFactoryWhitespace.factoryWhitespace)(effects, end), nok, 'resourceTitle', 'resourceTitleMarker', 'resourceTitleString')(code);\\n    }\\n\\n    return end(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function end(code) {\\n    if (code === 41) {\\n      effects.enter('resourceMarker');\\n      effects.consume(code);\\n      effects.exit('resourceMarker');\\n      effects.exit('resource');\\n      return ok;\\n    }\\n\\n    return nok(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeFullReference(effects, ok, nok) {\\n  const self = this;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    return _micromarkFactoryLabel.factoryLabel.call(self, effects, afterLabel, nok, 'reference', 'referenceMarker', 'referenceString')(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function afterLabel(code) {\\n    return self.parser.defined.includes((0, _micromarkUtilNormalizeIdentifier.normalizeIdentifier)(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeCollapsedReference(effects, ok, nok) {\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('reference');\\n    effects.enter('referenceMarker');\\n    effects.consume(code);\\n    effects.exit('referenceMarker');\\n    return open;\\n  }\\n  /** @type {State} */\\n\\n\\n  function open(code) {\\n    if (code === 93) {\\n      effects.enter('referenceMarker');\\n      effects.consume(code);\\n      effects.exit('referenceMarker');\\n      effects.exit('reference');\\n      return ok;\\n    }\\n\\n    return nok(code);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"labelEnd\",\"_micromarkFactoryDestination\",\"_micromarkFactoryLabel\",\"_micromarkFactoryTitle\",\"_micromarkFactoryWhitespace\",\"_micromarkUtilCharacter\",\"_micromarkUtilChunked\",\"_micromarkUtilNormalizeIdentifier\",\"_micromarkUtilResolveAll\",\"name\",\"tokenize\",\"tokenizeLabelEnd\",\"effects\",\"ok\",\"nok\",\"afterLabelEnd\",\"code\",\"attempt\",\"resourceConstruct\",\"defined\",\"balanced\",\"fullReferenceConstruct\",\"collapsedReferenceConstruct\",\"labelStart\",\"_balanced\",\"self\",\"index\",\"events\",\"length\",\"type\",\"start\",\"_inactive\",\"parser\",\"includes\",\"normalizeIdentifier\",\"sliceSerialize\",\"end\",\"now\",\"enter\",\"consume\",\"exit\",\"resolveTo\",\"resolveToLabelEnd\",\"context\",\"offset\",\"open\",\"close\",\"token\",\"group\",\"assign\",\"label\",\"text\",\"media\",\"push\",\"slice\",\"resolveAll\",\"constructs\",\"insideSpan\",\"null\",\"splice\",\"resolveAllLabelEnd\",\"tokenizeResource\",\"factoryDestination\",\"destinationAfter\",\"markdownLineEndingOrSpace\",\"factoryWhitespace\",\"between\",\"factoryTitle\",\"tokenizeFullReference\",\"afterLabel\",\"factoryLabel\",\"call\",\"tokenizeCollapsedReference\"]\n}\n"]