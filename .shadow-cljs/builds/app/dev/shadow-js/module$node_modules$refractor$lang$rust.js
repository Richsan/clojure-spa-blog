["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/rust.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$rust=function(global,require,module,exports){function rust(Prism$jscomp$0){(function(Prism){for(var multilineComment=/\\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*)|<self>)*\\*\\//.source,i=0;2>i;i++)multilineComment=multilineComment.replace(/<self>/g,function(){return multilineComment});multilineComment=multilineComment.replace(/<self>/g,function(){return/[^\\s\\S]/.source});Prism.languages.rust={comment:[{pattern:RegExp(/(^|[^\\\\])/.source+multilineComment),lookbehind:!0,\ngreedy:!0},{pattern:/(^|[^\\\\:])\\/\\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/b?\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|b?r(#*)\"(?:[^\"]|\"(?!\\1))*\"\\1/,greedy:!0},char:{pattern:/b?'(?:\\\\(?:x[0-7][\\da-fA-F]|u\\{(?:[\\da-fA-F]_*){1,6}\\}|.)|[^\\\\\\r\\n\\t'])'/,greedy:!0},attribute:{pattern:/#!?\\[(?:[^\\[\\]\"]|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\")*\\]/,greedy:!0,alias:\"attr-name\",inside:{string:null}},\"closure-params\":{pattern:/([=(,:]\\s*|\\bmove\\s*)\\|[^|]*\\||\\|[^|]*\\|(?=\\s*(?:\\{|->))/,lookbehind:!0,greedy:!0,inside:{\"closure-punctuation\":{pattern:/^\\||\\|$/,\nalias:\"punctuation\"},rest:null}},\"lifetime-annotation\":{pattern:/'\\w+/,alias:\"symbol\"},\"fragment-specifier\":{pattern:/(\\$\\w+:)[a-z]+/,lookbehind:!0,alias:\"punctuation\"},variable:/\\$\\w+/,\"function-definition\":{pattern:/(\\bfn\\s+)\\w+/,lookbehind:!0,alias:\"function\"},\"type-definition\":{pattern:/(\\b(?:enum|struct|trait|type|union)\\s+)\\w+/,lookbehind:!0,alias:\"class-name\"},\"module-declaration\":[{pattern:/(\\b(?:crate|mod)\\s+)[a-z][a-z_\\d]*/,lookbehind:!0,alias:\"namespace\"},{pattern:/(\\b(?:crate|self|super)\\s*)::\\s*[a-z][a-z_\\d]*\\b(?:\\s*::(?:\\s*[a-z][a-z_\\d]*\\s*::)*)?/,\nlookbehind:!0,alias:\"namespace\",inside:{punctuation:/::/}}],keyword:[/\\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/,/\\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\\b/],function:/\\b[a-z_]\\w*(?=\\s*(?:::\\s*<|\\())/,macro:{pattern:/\\b\\w+!/,alias:\"property\"},\nconstant:/\\b[A-Z_][A-Z_\\d]+\\b/,\"class-name\":/\\b[A-Z]\\w*\\b/,namespace:{pattern:/(?:\\b[a-z][a-z_\\d]*\\s*::\\s*)*\\b[a-z][a-z_\\d]*\\s*::(?!\\s*<)/,inside:{punctuation:/::/}},number:/\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\\b/,boolean:/\\b(?:false|true)\\b/,punctuation:/->|\\.\\.=|\\.{1,3}|::|[{}[\\];(),:]/,operator:/[-+*\\/%!^]=?|=[=>]?|&[&=]?|\\|[|=]?|<<?=?|>>?=?|[@?]/};Prism.languages.rust[\"closure-params\"].inside.rest=\nPrism.languages.rust;Prism.languages.rust.attribute.inside.string=Prism.languages.rust.string})(Prism$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=rust;rust.displayName=\"rust\";rust.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$rust\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rust;\n// @ts-nocheck\nrust.displayName = 'rust';\nrust.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction rust(Prism) {\n  ;\n\n  (function (Prism) {\n    var multilineComment = /\\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*)|<self>)*\\*\\//.source;\n\n    for (var i = 0; i < 2; i++) {\n      // support 4 levels of nested comments\n      multilineComment = multilineComment.replace(/<self>/g, function () {\n        return multilineComment;\n      });\n    }\n\n    multilineComment = multilineComment.replace(/<self>/g, function () {\n      return /[^\\s\\S]/.source;\n    });\n    Prism.languages.rust = {\n      comment: [{\n        pattern: RegExp(/(^|[^\\\\])/.source + multilineComment),\n        lookbehind: true,\n        greedy: true\n      }, {\n        pattern: /(^|[^\\\\:])\\/\\/.*/,\n        lookbehind: true,\n        greedy: true\n      }],\n      string: {\n        pattern: /b?\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|b?r(#*)\"(?:[^\"]|\"(?!\\1))*\"\\1/,\n        greedy: true\n      },\n      char: {\n        pattern: /b?'(?:\\\\(?:x[0-7][\\da-fA-F]|u\\{(?:[\\da-fA-F]_*){1,6}\\}|.)|[^\\\\\\r\\n\\t'])'/,\n        greedy: true\n      },\n      attribute: {\n        pattern: /#!?\\[(?:[^\\[\\]\"]|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\")*\\]/,\n        greedy: true,\n        alias: 'attr-name',\n        inside: {\n          string: null // see below\n\n        }\n      },\n      // Closure params should not be confused with bitwise OR |\n      'closure-params': {\n        pattern: /([=(,:]\\s*|\\bmove\\s*)\\|[^|]*\\||\\|[^|]*\\|(?=\\s*(?:\\{|->))/,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          'closure-punctuation': {\n            pattern: /^\\||\\|$/,\n            alias: 'punctuation'\n          },\n          rest: null // see below\n\n        }\n      },\n      'lifetime-annotation': {\n        pattern: /'\\w+/,\n        alias: 'symbol'\n      },\n      'fragment-specifier': {\n        pattern: /(\\$\\w+:)[a-z]+/,\n        lookbehind: true,\n        alias: 'punctuation'\n      },\n      variable: /\\$\\w+/,\n      'function-definition': {\n        pattern: /(\\bfn\\s+)\\w+/,\n        lookbehind: true,\n        alias: 'function'\n      },\n      'type-definition': {\n        pattern: /(\\b(?:enum|struct|trait|type|union)\\s+)\\w+/,\n        lookbehind: true,\n        alias: 'class-name'\n      },\n      'module-declaration': [{\n        pattern: /(\\b(?:crate|mod)\\s+)[a-z][a-z_\\d]*/,\n        lookbehind: true,\n        alias: 'namespace'\n      }, {\n        pattern: /(\\b(?:crate|self|super)\\s*)::\\s*[a-z][a-z_\\d]*\\b(?:\\s*::(?:\\s*[a-z][a-z_\\d]*\\s*::)*)?/,\n        lookbehind: true,\n        alias: 'namespace',\n        inside: {\n          punctuation: /::/\n        }\n      }],\n      keyword: [// https://github.com/rust-lang/reference/blob/master/src/keywords.md\n      /\\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/, // primitives and str\n      // https://doc.rust-lang.org/stable/rust-by-example/primitives.html\n      /\\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\\b/],\n      // functions can technically start with an upper-case letter, but this will introduce a lot of false positives\n      // and Rust's naming conventions recommend snake_case anyway.\n      // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html\n      function: /\\b[a-z_]\\w*(?=\\s*(?:::\\s*<|\\())/,\n      macro: {\n        pattern: /\\b\\w+!/,\n        alias: 'property'\n      },\n      constant: /\\b[A-Z_][A-Z_\\d]+\\b/,\n      'class-name': /\\b[A-Z]\\w*\\b/,\n      namespace: {\n        pattern: /(?:\\b[a-z][a-z_\\d]*\\s*::\\s*)*\\b[a-z][a-z_\\d]*\\s*::(?!\\s*<)/,\n        inside: {\n          punctuation: /::/\n        }\n      },\n      // Hex, oct, bin, dec numbers with visual separators and type suffix\n      number: /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\\b/,\n      boolean: /\\b(?:false|true)\\b/,\n      punctuation: /->|\\.\\.=|\\.{1,3}|::|[{}[\\];(),:]/,\n      operator: /[-+*\\/%!^]=?|=[=>]?|&[&=]?|\\|[|=]?|<<?=?|>>?=?|[@?]/\n    };\n    Prism.languages.rust['closure-params'].inside.rest = Prism.languages.rust;\n    Prism.languages.rust['attribute'].inside['string'] = Prism.languages.rust['string'];\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["boolean","punctuation","string","aliases","rust","constant","operator","displayName","__esModule","attribute","rest","lookbehind","value","char","variable","keyword","number","greedy","function","pattern","inside","alias","namespace","comment","default","macro"]],"~:compiled-at",1676841365375,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$rust.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lang/rust.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$rust\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = rust;\\n// @ts-nocheck\\nrust.displayName = 'rust';\\nrust.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction rust(Prism) {\\n  ;\\n\\n  (function (Prism) {\\n    var multilineComment = /\\\\/\\\\*(?:[^*/]|\\\\*(?!\\\\/)|\\\\/(?!\\\\*)|<self>)*\\\\*\\\\//.source;\\n\\n    for (var i = 0; i < 2; i++) {\\n      // support 4 levels of nested comments\\n      multilineComment = multilineComment.replace(/<self>/g, function () {\\n        return multilineComment;\\n      });\\n    }\\n\\n    multilineComment = multilineComment.replace(/<self>/g, function () {\\n      return /[^\\\\s\\\\S]/.source;\\n    });\\n    Prism.languages.rust = {\\n      comment: [{\\n        pattern: RegExp(/(^|[^\\\\\\\\])/.source + multilineComment),\\n        lookbehind: true,\\n        greedy: true\\n      }, {\\n        pattern: /(^|[^\\\\\\\\:])\\\\/\\\\/.*/,\\n        lookbehind: true,\\n        greedy: true\\n      }],\\n      string: {\\n        pattern: /b?\\\"(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\\\\"])*\\\"|b?r(#*)\\\"(?:[^\\\"]|\\\"(?!\\\\1))*\\\"\\\\1/,\\n        greedy: true\\n      },\\n      char: {\\n        pattern: /b?'(?:\\\\\\\\(?:x[0-7][\\\\da-fA-F]|u\\\\{(?:[\\\\da-fA-F]_*){1,6}\\\\}|.)|[^\\\\\\\\\\\\r\\\\n\\\\t'])'/,\\n        greedy: true\\n      },\\n      attribute: {\\n        pattern: /#!?\\\\[(?:[^\\\\[\\\\]\\\"]|\\\"(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\\\\"])*\\\")*\\\\]/,\\n        greedy: true,\\n        alias: 'attr-name',\\n        inside: {\\n          string: null // see below\\n\\n        }\\n      },\\n      // Closure params should not be confused with bitwise OR |\\n      'closure-params': {\\n        pattern: /([=(,:]\\\\s*|\\\\bmove\\\\s*)\\\\|[^|]*\\\\||\\\\|[^|]*\\\\|(?=\\\\s*(?:\\\\{|->))/,\\n        lookbehind: true,\\n        greedy: true,\\n        inside: {\\n          'closure-punctuation': {\\n            pattern: /^\\\\||\\\\|$/,\\n            alias: 'punctuation'\\n          },\\n          rest: null // see below\\n\\n        }\\n      },\\n      'lifetime-annotation': {\\n        pattern: /'\\\\w+/,\\n        alias: 'symbol'\\n      },\\n      'fragment-specifier': {\\n        pattern: /(\\\\$\\\\w+:)[a-z]+/,\\n        lookbehind: true,\\n        alias: 'punctuation'\\n      },\\n      variable: /\\\\$\\\\w+/,\\n      'function-definition': {\\n        pattern: /(\\\\bfn\\\\s+)\\\\w+/,\\n        lookbehind: true,\\n        alias: 'function'\\n      },\\n      'type-definition': {\\n        pattern: /(\\\\b(?:enum|struct|trait|type|union)\\\\s+)\\\\w+/,\\n        lookbehind: true,\\n        alias: 'class-name'\\n      },\\n      'module-declaration': [{\\n        pattern: /(\\\\b(?:crate|mod)\\\\s+)[a-z][a-z_\\\\d]*/,\\n        lookbehind: true,\\n        alias: 'namespace'\\n      }, {\\n        pattern: /(\\\\b(?:crate|self|super)\\\\s*)::\\\\s*[a-z][a-z_\\\\d]*\\\\b(?:\\\\s*::(?:\\\\s*[a-z][a-z_\\\\d]*\\\\s*::)*)?/,\\n        lookbehind: true,\\n        alias: 'namespace',\\n        inside: {\\n          punctuation: /::/\\n        }\\n      }],\\n      keyword: [// https://github.com/rust-lang/reference/blob/master/src/keywords.md\\n      /\\\\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\\\b/, // primitives and str\\n      // https://doc.rust-lang.org/stable/rust-by-example/primitives.html\\n      /\\\\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\\\\b/],\\n      // functions can technically start with an upper-case letter, but this will introduce a lot of false positives\\n      // and Rust's naming conventions recommend snake_case anyway.\\n      // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html\\n      function: /\\\\b[a-z_]\\\\w*(?=\\\\s*(?:::\\\\s*<|\\\\())/,\\n      macro: {\\n        pattern: /\\\\b\\\\w+!/,\\n        alias: 'property'\\n      },\\n      constant: /\\\\b[A-Z_][A-Z_\\\\d]+\\\\b/,\\n      'class-name': /\\\\b[A-Z]\\\\w*\\\\b/,\\n      namespace: {\\n        pattern: /(?:\\\\b[a-z][a-z_\\\\d]*\\\\s*::\\\\s*)*\\\\b[a-z][a-z_\\\\d]*\\\\s*::(?!\\\\s*<)/,\\n        inside: {\\n          punctuation: /::/\\n        }\\n      },\\n      // Hex, oct, bin, dec numbers with visual separators and type suffix\\n      number: /\\\\b(?:0x[\\\\dA-Fa-f](?:_?[\\\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\\\\d(?:_?\\\\d)*)?\\\\.)?\\\\d(?:_?\\\\d)*(?:[Ee][+-]?\\\\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\\\\b/,\\n      boolean: /\\\\b(?:false|true)\\\\b/,\\n      punctuation: /->|\\\\.\\\\.=|\\\\.{1,3}|::|[{}[\\\\];(),:]/,\\n      operator: /[-+*\\\\/%!^]=?|=[=>]?|&[&=]?|\\\\|[|=]?|<<?=?|>>?=?|[@?]/\\n    };\\n    Prism.languages.rust['closure-params'].inside.rest = Prism.languages.rust;\\n    Prism.languages.rust['attribute'].inside['string'] = Prism.languages.rust['string'];\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"rust\",\"Prism\",\"multilineComment\",\"source\",\"i\",\"replace\",\"languages\",\"comment\",\"pattern\",\"RegExp\",\"lookbehind\",\"greedy\",\"string\",\"char\",\"attribute\",\"alias\",\"inside\",\"rest\",\"variable\",\"punctuation\",\"keyword\",\"function\",\"macro\",\"constant\",\"namespace\",\"number\",\"boolean\",\"operator\",\"Object\",\"defineProperty\",\"value\",\"default\",\"displayName\",\"aliases\"]\n}\n"]