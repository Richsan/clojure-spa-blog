["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/remark-rehype/lib/index.js"],"~:js","shadow$provide.module$node_modules$remark_rehype$lib$index=function(global,require,module,exports){function bridge(destination,options){return(node,file,next)=>{destination.run((0,_mdastUtilToHast.toHast)(node,options),file,error=>{next(error)})}}function mutate(options){return node=>(0,_mdastUtilToHast.toHast)(node,options)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=void 0;var _mdastUtilToHast=require(\"module$node_modules$mdast_util_to_hast$index\");exports.default=function(destination,\noptions){return destination&&\"run\"in destination?bridge(destination,options):mutate(destination||options)}}","~:source","shadow$provide[\"module$node_modules$remark_rehype$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _mdastUtilToHast = require(\"mdast-util-to-hast\");\n\n/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('mdast-util-to-hast').Options} Options\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\n *\n * @typedef {import('mdast-util-to-hast')} DoNotTouchAsThisImportIncludesRawInTree\n */\n// Note: the `<MdastRoot, HastRoot>` overload doesn’t seem to work :'(\n\n/**\n * Plugin that turns markdown into HTML to support rehype.\n *\n * *   If a destination processor is given, that processor runs with a new HTML\n *     (hast) tree (bridge-mode).\n *     As the given processor runs with a hast tree, and rehype plugins support\n *     hast, that means rehype plugins can be used with the given processor.\n *     The hast tree is discarded in the end.\n *     It’s highly unlikely that you want to do this.\n * *   The common case is to not pass a destination processor, in which case the\n *     current processor continues running with a new HTML (hast) tree\n *     (mutate-mode).\n *     As the current processor continues with a hast tree, and rehype plugins\n *     support hast, that means rehype plugins can be used after\n *     `remark-rehype`.\n *     It’s likely that this is what you want to do.\n *\n * @param destination\n *   Optional unified processor.\n * @param options\n *   Options passed to `mdast-util-to-hast`.\n */\nconst remarkRehype = function (destination, options) {\n  return destination && 'run' in destination ? bridge(destination, options) : mutate(destination || options);\n};\n\nvar _default = remarkRehype;\n/**\n * Bridge-mode.\n * Runs the destination with the new hast tree.\n *\n * @type {import('unified').Plugin<[Processor, Options?], MdastRoot>}\n */\n\nexports.default = _default;\n\nfunction bridge(destination, options) {\n  return (node, file, next) => {\n    destination.run((0, _mdastUtilToHast.toHast)(node, options), file, error => {\n      next(error);\n    });\n  };\n}\n/**\n * Mutate-mode.\n * Further plugins run on the hast tree.\n *\n * @type {import('unified').Plugin<[Options?]|void[], MdastRoot, HastRoot>}\n */\n\n\nfunction mutate(options) {\n  // @ts-expect-error: assume a corresponding node is returned by `toHast`.\n  return node => (0, _mdastUtilToHast.toHast)(node, options);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$mdast_util_to_hast$index"]],"~:properties",["^5",["__esModule","value","default"]],"~:compiled-at",1676665867323,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$remark_rehype$lib$index.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,2CAAA,CAAgE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAwDxGC,QAASA,OAAM,CAACC,WAAD,CAAcC,OAAd,CAAuB,CACpC,MAAO,CAACC,IAAD,CAAOC,IAAP,CAAaC,IAAb,CAAA,EAAsB,CAC3BJ,WAAYK,CAAAA,GAAZ,CAAgB,GAAIC,gBAAiBC,CAAAA,MAArB,EAA6BL,IAA7B,CAAmCD,OAAnC,CAAhB,CAA6DE,IAA7D,CAAmEK,KAAA,EAAS,CAC1EJ,IAAA,CAAKI,KAAL,CAD0E,CAA5E,CAD2B,CADO,CAetCC,QAASA,OAAM,CAACR,OAAD,CAAU,CAEvB,MAAOC,KAAA,EAAQ,GAAII,gBAAiBC,CAAAA,MAArB,EAA6BL,IAA7B,CAAmCD,OAAnC,CAFQ,CApEzBS,MAAOC,CAAAA,cAAP,CAAsBb,OAAtB,CAA+B,YAA/B,CAA6C,CAC3Cc,MAAO,CAAA,CADoC,CAA7C,CAGAd,QAAQe,CAAAA,OAAR,CAAkB,IAAK,EAEvB,KAAIP,iBAAmBV,OAAA,CAAQ,8CAAR,CA8CvBE,QAAQe,CAAAA,OAAR,CAZqBC,QAAS,CAACd,WAAD;AAAcC,OAAd,CAAuB,CACnD,MAAOD,YAAA,EAAe,KAAf,EAAwBA,YAAxB,CAAsCD,MAAA,CAAOC,WAAP,CAAoBC,OAApB,CAAtC,CAAqEQ,MAAA,CAAOT,WAAP,EAAsBC,OAAtB,CADzB,CA1CmD;\",\n\"sources\":[\"node_modules/remark-rehype/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$remark_rehype$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = void 0;\\n\\nvar _mdastUtilToHast = require(\\\"mdast-util-to-hast\\\");\\n\\n/**\\n * @typedef {import('hast').Root} HastRoot\\n * @typedef {import('mdast').Root} MdastRoot\\n * @typedef {import('mdast-util-to-hast').Options} Options\\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\\n *\\n * @typedef {import('mdast-util-to-hast')} DoNotTouchAsThisImportIncludesRawInTree\\n */\\n// Note: the `<MdastRoot, HastRoot>` overload doesn\\u2019t seem to work :'(\\n\\n/**\\n * Plugin that turns markdown into HTML to support rehype.\\n *\\n * *   If a destination processor is given, that processor runs with a new HTML\\n *     (hast) tree (bridge-mode).\\n *     As the given processor runs with a hast tree, and rehype plugins support\\n *     hast, that means rehype plugins can be used with the given processor.\\n *     The hast tree is discarded in the end.\\n *     It\\u2019s highly unlikely that you want to do this.\\n * *   The common case is to not pass a destination processor, in which case the\\n *     current processor continues running with a new HTML (hast) tree\\n *     (mutate-mode).\\n *     As the current processor continues with a hast tree, and rehype plugins\\n *     support hast, that means rehype plugins can be used after\\n *     `remark-rehype`.\\n *     It\\u2019s likely that this is what you want to do.\\n *\\n * @param destination\\n *   Optional unified processor.\\n * @param options\\n *   Options passed to `mdast-util-to-hast`.\\n */\\nconst remarkRehype = function (destination, options) {\\n  return destination && 'run' in destination ? bridge(destination, options) : mutate(destination || options);\\n};\\n\\nvar _default = remarkRehype;\\n/**\\n * Bridge-mode.\\n * Runs the destination with the new hast tree.\\n *\\n * @type {import('unified').Plugin<[Processor, Options?], MdastRoot>}\\n */\\n\\nexports.default = _default;\\n\\nfunction bridge(destination, options) {\\n  return (node, file, next) => {\\n    destination.run((0, _mdastUtilToHast.toHast)(node, options), file, error => {\\n      next(error);\\n    });\\n  };\\n}\\n/**\\n * Mutate-mode.\\n * Further plugins run on the hast tree.\\n *\\n * @type {import('unified').Plugin<[Options?]|void[], MdastRoot, HastRoot>}\\n */\\n\\n\\nfunction mutate(options) {\\n  // @ts-expect-error: assume a corresponding node is returned by `toHast`.\\n  return node => (0, _mdastUtilToHast.toHast)(node, options);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"bridge\",\"destination\",\"options\",\"node\",\"file\",\"next\",\"run\",\"_mdastUtilToHast\",\"toHast\",\"error\",\"mutate\",\"Object\",\"defineProperty\",\"value\",\"default\",\"remarkRehype\"]\n}\n"]