["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mdast-util-gfm-table/lib/index.js"],"~:js","shadow$provide.module$node_modules$mdast_util_gfm_table$lib$index=function(global,require,module,exports){function exit(token){this.exit(token)}function enterCell(token){this.enter({type:\"tableCell\",children:[]},token)}function replace($0,$1){return\"|\"===$1?$1:$0}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.gfmTableToMarkdown=function(options){function handleTableCell(node,_,context,safeOptions){_=context.enter(\"tableCell\");const subexit=context.enter(\"phrasing\");node=(0,_containerPhrasing.containerPhrasing)(node,\ncontext,{...safeOptions,before:around,after:around});subexit();_();return node}function serializeData(matrix,align){return(0,_markdownTable.markdownTable)(matrix,{align,alignDelimiters,padding,stringLength})}function handleTableRowAsData(node,context,safeOptions){const children=node.children;let index=-1;const result=[],subexit=context.enter(\"tableRow\");for(;++index<children.length;)result[index]=handleTableCell(children[index],node,context,safeOptions);subexit();return result}options=options||{};\nconst padding=options.tableCellPadding,alignDelimiters=options.tablePipeAlign,stringLength=options.stringLength,around=padding?\" \":\"|\";return{unsafe:[{character:\"\\r\",inConstruct:\"tableCell\"},{character:\"\\n\",inConstruct:\"tableCell\"},{atBreak:!0,character:\"|\",after:\"[\\t :-]\"},{character:\"|\",inConstruct:\"tableCell\"},{atBreak:!0,character:\":\",after:\"-\"},{atBreak:!0,character:\"-\",after:\"[:|-]\"}],handlers:{table:function(node,_,context,safeOptions){_=node.children;let index=-1;const result=[],subexit=context.enter(\"table\");\nfor(;++index<_.length;)result[index]=handleTableRowAsData(_[index],context,safeOptions);subexit();return serializeData(result,node.align)},tableRow:function(node,_,context,safeOptions){node=handleTableRowAsData(node,context,safeOptions);node=serializeData([node]);return node.slice(0,node.indexOf(\"\\n\"))},tableCell:handleTableCell,inlineCode:function(node,parent,context){node=(0,_inlineCode.inlineCode)(node,parent,context);context.stack.includes(\"tableCell\")&&(node=node.replace(/\\|/g,\"\\\\$\\x26\"));return node}}}};\nexports.gfmTableFromMarkdown=void 0;var _containerPhrasing=require(\"module$node_modules$mdast_util_to_markdown$lib$util$container_phrasing\"),_inlineCode=require(\"module$node_modules$mdast_util_to_markdown$lib$handle$inline_code\"),_markdownTable=require(\"module$node_modules$markdown_table$index\");exports.gfmTableFromMarkdown={enter:{table:function(token){this.enter({type:\"table\",align:token._align.map(d=>\"none\"===d?null:d),children:[]},token);this.setData(\"inTable\",!0)},tableData:enterCell,tableHeader:enterCell,\ntableRow:function(token){this.enter({type:\"tableRow\",children:[]},token)}},exit:{codeText:function(token){let value=this.resume();this.getData(\"inTable\")&&(value=value.replace(/\\\\([\\\\|])/g,replace));this.stack[this.stack.length-1].value=value;this.exit(token)},table:function(token){this.exit(token);this.setData(\"inTable\")},tableData:exit,tableHeader:exit,tableRow:exit}}}","~:source","shadow$provide[\"module$node_modules$mdast_util_gfm_table$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gfmTableToMarkdown = gfmTableToMarkdown;\nexports.gfmTableFromMarkdown = void 0;\n\nvar _containerPhrasing = require(\"mdast-util-to-markdown/lib/util/container-phrasing.js\");\n\nvar _inlineCode = require(\"mdast-util-to-markdown/lib/handle/inline-code.js\");\n\nvar _markdownTable = require(\"markdown-table\");\n\n/**\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').InlineCode} InlineCode\n *\n * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext\n * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells.\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters.\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells\n */\n// To do: next major: use `state` and `state` utilities from `mdast-util-to-markdown`.\n// To do: next major: use `defaultHandlers.inlineCode`.\n// To do: next major: expose functions.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM tables.\n *\n * @type {FromMarkdownExtension}\n */\nconst gfmTableFromMarkdown = {\n  enter: {\n    table: enterTable,\n    tableData: enterCell,\n    tableHeader: enterCell,\n    tableRow: enterRow\n  },\n  exit: {\n    codeText: exitCodeText,\n    table: exitTable,\n    tableData: exit,\n    tableHeader: exit,\n    tableRow: exit\n  }\n};\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\n\nexports.gfmTableFromMarkdown = gfmTableFromMarkdown;\n\nfunction enterTable(token) {\n  /** @type {Array<'left' | 'right' | 'center' | 'none'>} */\n  // @ts-expect-error: `align` is custom.\n  const align = token._align;\n  this.enter({\n    type: 'table',\n    align: align.map(d => d === 'none' ? null : d),\n    children: []\n  }, token);\n  this.setData('inTable', true);\n}\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\n\n\nfunction exitTable(token) {\n  this.exit(token);\n  this.setData('inTable');\n}\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\n\n\nfunction enterRow(token) {\n  this.enter({\n    type: 'tableRow',\n    children: []\n  }, token);\n}\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\n\n\nfunction exit(token) {\n  this.exit(token);\n}\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\n\n\nfunction enterCell(token) {\n  this.enter({\n    type: 'tableCell',\n    children: []\n  }, token);\n} // Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\n\n\nfunction exitCodeText(token) {\n  let value = this.resume();\n\n  if (this.getData('inTable')) {\n    value = value.replace(/\\\\([\\\\|])/g, replace);\n  }\n\n  const node = this.stack[this.stack.length - 1];\n  node.value = value;\n  this.exit(token);\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\n\n\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0;\n}\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */\n\n\nfunction gfmTableToMarkdown(options) {\n  const settings = options || {};\n  const padding = settings.tableCellPadding;\n  const alignDelimiters = settings.tablePipeAlign;\n  const stringLength = settings.stringLength;\n  const around = padding ? ' ' : '|';\n  return {\n    unsafe: [{\n      character: '\\r',\n      inConstruct: 'tableCell'\n    }, {\n      character: '\\n',\n      inConstruct: 'tableCell'\n    }, // A pipe, when followed by a tab or space (padding), or a dash or colon\n    // (unpadded delimiter row), could result in a table.\n    {\n      atBreak: true,\n      character: '|',\n      after: '[\\t :-]'\n    }, // A pipe in a cell must be encoded.\n    {\n      character: '|',\n      inConstruct: 'tableCell'\n    }, // A colon must be followed by a dash, in which case it could start a\n    // delimiter row.\n    {\n      atBreak: true,\n      character: ':',\n      after: '-'\n    }, // A delimiter row can also start with a dash, when followed by more\n    // dashes, a colon, or a pipe.\n    // This is a stricter version than the built in check for lists, thematic\n    // breaks, and setex heading underlines though:\n    // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n    {\n      atBreak: true,\n      character: '-',\n      after: '[:|-]'\n    }],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  };\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n\n  function handleTable(node, _, context, safeOptions) {\n    return serializeData(handleTableAsData(node, context, safeOptions), node.align);\n  }\n  /**\n   * This function isn’t really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n\n\n  function handleTableRow(node, _, context, safeOptions) {\n    const row = handleTableRowAsData(node, context, safeOptions);\n    const value = serializeData([row]); // `markdown-table` will always add an align row\n\n    return value.slice(0, value.indexOf('\\n'));\n  }\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n\n\n  function handleTableCell(node, _, context, safeOptions) {\n    const exit = context.enter('tableCell');\n    const subexit = context.enter('phrasing');\n    const value = (0, _containerPhrasing.containerPhrasing)(node, context, { ...safeOptions,\n      before: around,\n      after: around\n    });\n    subexit();\n    exit();\n    return value;\n  }\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */\n\n\n  function serializeData(matrix, align) {\n    return (0, _markdownTable.markdownTable)(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    });\n  }\n  /**\n   * @param {Table} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n\n\n  function handleTableAsData(node, context, safeOptions) {\n    const children = node.children;\n    let index = -1;\n    /** @type {Array<Array<string>>} */\n\n    const result = [];\n    const subexit = context.enter('table');\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(children[index], context, safeOptions);\n    }\n\n    subexit();\n    return result;\n  }\n  /**\n   * @param {TableRow} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n\n\n  function handleTableRowAsData(node, context, safeOptions) {\n    const children = node.children;\n    let index = -1;\n    /** @type {Array<string>} */\n\n    const result = [];\n    const subexit = context.enter('tableRow');\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(children[index], node, context, safeOptions);\n    }\n\n    subexit();\n    return result;\n  }\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n\n\n  function inlineCodeWithTable(node, parent, context) {\n    let value = (0, _inlineCode.inlineCode)(node, parent, context);\n\n    if (context.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&');\n    }\n\n    return value;\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$markdown_table$index","~$module$node_modules$mdast_util_to_markdown$lib$handle$inline_code","~$module$node_modules$mdast_util_to_markdown$lib$util$container_phrasing","~$shadow.js"]],"~:properties",["^5",["table","align","after","handlers","children","inlineCode","__esModule","padding","unsafe","tableData","value","character","stringLength","codeText","inConstruct","atBreak","tableRow","type","tableCell","exit","gfmTableToMarkdown","alignDelimiters","before","gfmTableFromMarkdown","enter","tableHeader"]],"~:compiled-at",1676841365343,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mdast_util_gfm_table$lib$index.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mdast-util-gfm-table/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mdast_util_gfm_table$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.gfmTableToMarkdown = gfmTableToMarkdown;\\nexports.gfmTableFromMarkdown = void 0;\\n\\nvar _containerPhrasing = require(\\\"mdast-util-to-markdown/lib/util/container-phrasing.js\\\");\\n\\nvar _inlineCode = require(\\\"mdast-util-to-markdown/lib/handle/inline-code.js\\\");\\n\\nvar _markdownTable = require(\\\"markdown-table\\\");\\n\\n/**\\n * @typedef {import('mdast').Table} Table\\n * @typedef {import('mdast').TableRow} TableRow\\n * @typedef {import('mdast').TableCell} TableCell\\n * @typedef {import('mdast').InlineCode} InlineCode\\n *\\n * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions\\n *\\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\\n *\\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\\n * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext\\n * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions\\n */\\n\\n/**\\n * @typedef Options\\n *   Configuration.\\n * @property {boolean | null | undefined} [tableCellPadding=true]\\n *   Whether to add a space of padding between delimiters and cells.\\n * @property {boolean | null | undefined} [tablePipeAlign=true]\\n *   Whether to align the delimiters.\\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\\n *   Function to detect the length of table cell content, used when aligning\\n *   the delimiters between cells\\n */\\n// To do: next major: use `state` and `state` utilities from `mdast-util-to-markdown`.\\n// To do: next major: use `defaultHandlers.inlineCode`.\\n// To do: next major: expose functions.\\n\\n/**\\n * Extension for `mdast-util-from-markdown` to enable GFM tables.\\n *\\n * @type {FromMarkdownExtension}\\n */\\nconst gfmTableFromMarkdown = {\\n  enter: {\\n    table: enterTable,\\n    tableData: enterCell,\\n    tableHeader: enterCell,\\n    tableRow: enterRow\\n  },\\n  exit: {\\n    codeText: exitCodeText,\\n    table: exitTable,\\n    tableData: exit,\\n    tableHeader: exit,\\n    tableRow: exit\\n  }\\n};\\n/**\\n * @this {CompileContext}\\n * @type {FromMarkdownHandle}\\n */\\n\\nexports.gfmTableFromMarkdown = gfmTableFromMarkdown;\\n\\nfunction enterTable(token) {\\n  /** @type {Array<'left' | 'right' | 'center' | 'none'>} */\\n  // @ts-expect-error: `align` is custom.\\n  const align = token._align;\\n  this.enter({\\n    type: 'table',\\n    align: align.map(d => d === 'none' ? null : d),\\n    children: []\\n  }, token);\\n  this.setData('inTable', true);\\n}\\n/**\\n * @this {CompileContext}\\n * @type {FromMarkdownHandle}\\n */\\n\\n\\nfunction exitTable(token) {\\n  this.exit(token);\\n  this.setData('inTable');\\n}\\n/**\\n * @this {CompileContext}\\n * @type {FromMarkdownHandle}\\n */\\n\\n\\nfunction enterRow(token) {\\n  this.enter({\\n    type: 'tableRow',\\n    children: []\\n  }, token);\\n}\\n/**\\n * @this {CompileContext}\\n * @type {FromMarkdownHandle}\\n */\\n\\n\\nfunction exit(token) {\\n  this.exit(token);\\n}\\n/**\\n * @this {CompileContext}\\n * @type {FromMarkdownHandle}\\n */\\n\\n\\nfunction enterCell(token) {\\n  this.enter({\\n    type: 'tableCell',\\n    children: []\\n  }, token);\\n} // Overwrite the default code text data handler to unescape escaped pipes when\\n// they are in tables.\\n\\n/**\\n * @this {CompileContext}\\n * @type {FromMarkdownHandle}\\n */\\n\\n\\nfunction exitCodeText(token) {\\n  let value = this.resume();\\n\\n  if (this.getData('inTable')) {\\n    value = value.replace(/\\\\\\\\([\\\\\\\\|])/g, replace);\\n  }\\n\\n  const node = this.stack[this.stack.length - 1];\\n  node.value = value;\\n  this.exit(token);\\n}\\n/**\\n * @param {string} $0\\n * @param {string} $1\\n * @returns {string}\\n */\\n\\n\\nfunction replace($0, $1) {\\n  // Pipes work, backslashes don\\u2019t (but can\\u2019t escape pipes).\\n  return $1 === '|' ? $1 : $0;\\n}\\n/**\\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\\n * markdown.\\n *\\n * @param {Options | null | undefined} [options]\\n *   Configuration.\\n * @returns {ToMarkdownExtension}\\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\\n */\\n\\n\\nfunction gfmTableToMarkdown(options) {\\n  const settings = options || {};\\n  const padding = settings.tableCellPadding;\\n  const alignDelimiters = settings.tablePipeAlign;\\n  const stringLength = settings.stringLength;\\n  const around = padding ? ' ' : '|';\\n  return {\\n    unsafe: [{\\n      character: '\\\\r',\\n      inConstruct: 'tableCell'\\n    }, {\\n      character: '\\\\n',\\n      inConstruct: 'tableCell'\\n    }, // A pipe, when followed by a tab or space (padding), or a dash or colon\\n    // (unpadded delimiter row), could result in a table.\\n    {\\n      atBreak: true,\\n      character: '|',\\n      after: '[\\\\t :-]'\\n    }, // A pipe in a cell must be encoded.\\n    {\\n      character: '|',\\n      inConstruct: 'tableCell'\\n    }, // A colon must be followed by a dash, in which case it could start a\\n    // delimiter row.\\n    {\\n      atBreak: true,\\n      character: ':',\\n      after: '-'\\n    }, // A delimiter row can also start with a dash, when followed by more\\n    // dashes, a colon, or a pipe.\\n    // This is a stricter version than the built in check for lists, thematic\\n    // breaks, and setex heading underlines though:\\n    // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\\n    {\\n      atBreak: true,\\n      character: '-',\\n      after: '[:|-]'\\n    }],\\n    handlers: {\\n      table: handleTable,\\n      tableRow: handleTableRow,\\n      tableCell: handleTableCell,\\n      inlineCode: inlineCodeWithTable\\n    }\\n  };\\n  /**\\n   * @type {ToMarkdownHandle}\\n   * @param {Table} node\\n   */\\n\\n  function handleTable(node, _, context, safeOptions) {\\n    return serializeData(handleTableAsData(node, context, safeOptions), node.align);\\n  }\\n  /**\\n   * This function isn\\u2019t really used normally, because we handle rows at the\\n   * table level.\\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\\n   *\\n   * @type {ToMarkdownHandle}\\n   * @param {TableRow} node\\n   */\\n\\n\\n  function handleTableRow(node, _, context, safeOptions) {\\n    const row = handleTableRowAsData(node, context, safeOptions);\\n    const value = serializeData([row]); // `markdown-table` will always add an align row\\n\\n    return value.slice(0, value.indexOf('\\\\n'));\\n  }\\n  /**\\n   * @type {ToMarkdownHandle}\\n   * @param {TableCell} node\\n   */\\n\\n\\n  function handleTableCell(node, _, context, safeOptions) {\\n    const exit = context.enter('tableCell');\\n    const subexit = context.enter('phrasing');\\n    const value = (0, _containerPhrasing.containerPhrasing)(node, context, { ...safeOptions,\\n      before: around,\\n      after: around\\n    });\\n    subexit();\\n    exit();\\n    return value;\\n  }\\n  /**\\n   * @param {Array<Array<string>>} matrix\\n   * @param {Array<string | null | undefined> | null | undefined} [align]\\n   */\\n\\n\\n  function serializeData(matrix, align) {\\n    return (0, _markdownTable.markdownTable)(matrix, {\\n      align,\\n      // @ts-expect-error: `markdown-table` types should support `null`.\\n      alignDelimiters,\\n      // @ts-expect-error: `markdown-table` types should support `null`.\\n      padding,\\n      // @ts-expect-error: `markdown-table` types should support `null`.\\n      stringLength\\n    });\\n  }\\n  /**\\n   * @param {Table} node\\n   * @param {ToMarkdownContext} context\\n   * @param {SafeOptions} safeOptions\\n   */\\n\\n\\n  function handleTableAsData(node, context, safeOptions) {\\n    const children = node.children;\\n    let index = -1;\\n    /** @type {Array<Array<string>>} */\\n\\n    const result = [];\\n    const subexit = context.enter('table');\\n\\n    while (++index < children.length) {\\n      result[index] = handleTableRowAsData(children[index], context, safeOptions);\\n    }\\n\\n    subexit();\\n    return result;\\n  }\\n  /**\\n   * @param {TableRow} node\\n   * @param {ToMarkdownContext} context\\n   * @param {SafeOptions} safeOptions\\n   */\\n\\n\\n  function handleTableRowAsData(node, context, safeOptions) {\\n    const children = node.children;\\n    let index = -1;\\n    /** @type {Array<string>} */\\n\\n    const result = [];\\n    const subexit = context.enter('tableRow');\\n\\n    while (++index < children.length) {\\n      // Note: the positional info as used here is incorrect.\\n      // Making it correct would be impossible due to aligning cells?\\n      // And it would need copy/pasting `markdown-table` into this project.\\n      result[index] = handleTableCell(children[index], node, context, safeOptions);\\n    }\\n\\n    subexit();\\n    return result;\\n  }\\n  /**\\n   * @type {ToMarkdownHandle}\\n   * @param {InlineCode} node\\n   */\\n\\n\\n  function inlineCodeWithTable(node, parent, context) {\\n    let value = (0, _inlineCode.inlineCode)(node, parent, context);\\n\\n    if (context.stack.includes('tableCell')) {\\n      value = value.replace(/\\\\|/g, '\\\\\\\\$&');\\n    }\\n\\n    return value;\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"exit\",\"token\",\"enterCell\",\"enter\",\"type\",\"children\",\"replace\",\"$0\",\"$1\",\"Object\",\"defineProperty\",\"value\",\"gfmTableToMarkdown\",\"options\",\"handleTableCell\",\"node\",\"_\",\"context\",\"safeOptions\",\"subexit\",\"_containerPhrasing\",\"containerPhrasing\",\"before\",\"around\",\"after\",\"serializeData\",\"matrix\",\"align\",\"_markdownTable\",\"markdownTable\",\"alignDelimiters\",\"padding\",\"stringLength\",\"handleTableRowAsData\",\"index\",\"result\",\"length\",\"settings\",\"tableCellPadding\",\"tablePipeAlign\",\"unsafe\",\"character\",\"inConstruct\",\"atBreak\",\"handlers\",\"table\",\"handleTable\",\"tableRow\",\"handleTableRow\",\"row\",\"slice\",\"indexOf\",\"tableCell\",\"inlineCode\",\"inlineCodeWithTable\",\"parent\",\"_inlineCode\",\"stack\",\"includes\",\"gfmTableFromMarkdown\",\"enterTable\",\"_align\",\"map\",\"d\",\"setData\",\"tableData\",\"tableHeader\",\"enterRow\",\"codeText\",\"exitCodeText\",\"resume\",\"getData\",\"exitTable\"]\n}\n"]