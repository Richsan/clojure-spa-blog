["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@uiw/react-md-editor/lib/utils/markdownUtils.js"],"~:js","shadow$provide.module$node_modules$$uiw$react_md_editor$lib$utils$markdownUtils=function(global,require,module,exports){function getSurroundingWord(text,position){if(!text)throw Error(\"Argument 'text' should be truthy\");for(var isWordDelimiter=function(c){return\" \"===c||10===c.charCodeAt(0)},start=0,end=text.length,i=position;-1<i-1;i--)if(isWordDelimiter(text[i-1])){start=i;break}for(;position<text.length;position++)if(isWordDelimiter(text[position])){end=position;break}return{start,end}}Object.defineProperty(exports,\n\"__esModule\",{value:!0});exports.getBreaksNeededForEmptyLineAfter=function(){var text=0<arguments.length&&void 0!==arguments[0]?arguments[0]:\"\",startPosition=1<arguments.length?arguments[1]:void 0;if(startPosition===text.length-1)return 0;for(var neededBreaks=2,isInLastLine=!0;startPosition<text.length&&0<=neededBreaks;startPosition++)switch(text.charCodeAt(startPosition)){case 32:continue;case 10:neededBreaks--;isInLastLine=!1;break;default:return neededBreaks}return isInLastLine?0:neededBreaks};\nexports.getBreaksNeededForEmptyLineBefore=function(){var text=0<arguments.length&&void 0!==arguments[0]?arguments[0]:\"\",startPosition=1<arguments.length?arguments[1]:void 0;if(0===startPosition)return 0;var neededBreaks=2,isInFirstLine=!0;for(--startPosition;0<=startPosition&&0<=neededBreaks;startPosition--)switch(text.charCodeAt(startPosition)){case 32:continue;case 10:neededBreaks--;isInFirstLine=!1;break;default:return neededBreaks}return isInFirstLine?0:neededBreaks};exports.getSurroundingWord=\ngetSurroundingWord;exports.selectWord=function(_ref){var text=_ref.text;_ref=_ref.selection;return text&&text.length&&_ref.start===_ref.end?getSurroundingWord(text,_ref.start):_ref}}","~:source","shadow$provide[\"module$node_modules$$uiw$react_md_editor$lib$utils$markdownUtils\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBreaksNeededForEmptyLineAfter = getBreaksNeededForEmptyLineAfter;\nexports.getBreaksNeededForEmptyLineBefore = getBreaksNeededForEmptyLineBefore;\nexports.getSurroundingWord = getSurroundingWord;\nexports.selectWord = selectWord;\nfunction selectWord(_ref) {\n  var text = _ref.text,\n    selection = _ref.selection;\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nfunction getBreaksNeededForEmptyLineBefore() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var startPosition = arguments.length > 1 ? arguments[1] : undefined;\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nfunction getBreaksNeededForEmptyLineAfter() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var startPosition = arguments.length > 1 ? arguments[1] : undefined;\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\nfunction getSurroundingWord(text, position) {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n  var isWordDelimiter = function isWordDelimiter(c) {\n    return c === ' ' || c.charCodeAt(0) === 10;\n  };\n\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n  var start = 0;\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n  var end = text.length;\n\n  // iterate to the left\n  for (var i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  }\n\n  // iterate to the right\n  for (var _i = position; _i < text.length; _i++) {\n    if (isWordDelimiter(text[_i])) {\n      end = _i;\n      break;\n    }\n  }\n  return {\n    start: start,\n    end: end\n  };\n}\n//# sourceMappingURL=markdownUtils.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["getBreaksNeededForEmptyLineBefore","__esModule","getSurroundingWord","value","start","selectWord","getBreaksNeededForEmptyLineAfter","end"]],"~:compiled-at",1676841365508,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$uiw$react_md_editor$lib$utils$markdownUtils.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@uiw/react-md-editor/lib/utils/markdownUtils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$uiw$react_md_editor$lib$utils$markdownUtils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.getBreaksNeededForEmptyLineAfter = getBreaksNeededForEmptyLineAfter;\\nexports.getBreaksNeededForEmptyLineBefore = getBreaksNeededForEmptyLineBefore;\\nexports.getSurroundingWord = getSurroundingWord;\\nexports.selectWord = selectWord;\\nfunction selectWord(_ref) {\\n  var text = _ref.text,\\n    selection = _ref.selection;\\n  if (text && text.length && selection.start === selection.end) {\\n    // the user is pointing to a word\\n    return getSurroundingWord(text, selection.start);\\n  }\\n  return selection;\\n}\\n\\n/**\\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\\n *  to make sure there's an empty line between 'startPosition' and the previous text\\n */\\nfunction getBreaksNeededForEmptyLineBefore() {\\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\\n  var startPosition = arguments.length > 1 ? arguments[1] : undefined;\\n  if (startPosition === 0) return 0;\\n\\n  // rules:\\n  // - If we're in the first line, no breaks are needed\\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\\n  //      may need to insert 0, 1 or 2 breaks\\n\\n  var neededBreaks = 2;\\n  var isInFirstLine = true;\\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\\n    switch (text.charCodeAt(i)) {\\n      case 32:\\n        // blank space\\n        continue;\\n      case 10:\\n        // line break\\n        neededBreaks--;\\n        isInFirstLine = false;\\n        break;\\n      default:\\n        return neededBreaks;\\n    }\\n  }\\n  return isInFirstLine ? 0 : neededBreaks;\\n}\\n\\n/**\\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\\n *  to make sure there's an empty line between 'startPosition' and the next text\\n */\\nfunction getBreaksNeededForEmptyLineAfter() {\\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\\n  var startPosition = arguments.length > 1 ? arguments[1] : undefined;\\n  if (startPosition === text.length - 1) return 0;\\n\\n  // rules:\\n  // - If we're in the first line, no breaks are needed\\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\\n  //      may need to insert 0, 1 or 2 breaks\\n\\n  var neededBreaks = 2;\\n  var isInLastLine = true;\\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\\n    switch (text.charCodeAt(i)) {\\n      case 32:\\n        continue;\\n      case 10:\\n        {\\n          neededBreaks--;\\n          isInLastLine = false;\\n          break;\\n        }\\n      default:\\n        return neededBreaks;\\n    }\\n  }\\n  return isInLastLine ? 0 : neededBreaks;\\n}\\nfunction getSurroundingWord(text, position) {\\n  if (!text) throw Error(\\\"Argument 'text' should be truthy\\\");\\n  var isWordDelimiter = function isWordDelimiter(c) {\\n    return c === ' ' || c.charCodeAt(0) === 10;\\n  };\\n\\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\\n  var start = 0;\\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\\n  var end = text.length;\\n\\n  // iterate to the left\\n  for (var i = position; i - 1 > -1; i--) {\\n    if (isWordDelimiter(text[i - 1])) {\\n      start = i;\\n      break;\\n    }\\n  }\\n\\n  // iterate to the right\\n  for (var _i = position; _i < text.length; _i++) {\\n    if (isWordDelimiter(text[_i])) {\\n      end = _i;\\n      break;\\n    }\\n  }\\n  return {\\n    start: start,\\n    end: end\\n  };\\n}\\n//# sourceMappingURL=markdownUtils.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getSurroundingWord\",\"text\",\"position\",\"Error\",\"isWordDelimiter\",\"c\",\"charCodeAt\",\"start\",\"end\",\"length\",\"i\",\"_i\",\"Object\",\"defineProperty\",\"value\",\"getBreaksNeededForEmptyLineAfter\",\"arguments\",\"undefined\",\"startPosition\",\"neededBreaks\",\"isInLastLine\",\"getBreaksNeededForEmptyLineBefore\",\"isInFirstLine\",\"selectWord\",\"_ref\",\"selection\"]\n}\n"]