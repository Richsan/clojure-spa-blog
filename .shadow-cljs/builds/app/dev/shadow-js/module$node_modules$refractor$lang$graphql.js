["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/graphql.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$graphql=function(global,require,module,exports){function graphql(Prism){Prism.languages.graphql={comment:/#.*/,description:{pattern:/(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,greedy:!0,alias:\"string\",inside:{\"language-markdown\":{pattern:/(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,lookbehind:!0,inside:Prism.languages.markdown}}},string:{pattern:/\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,greedy:!0},number:/(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\nboolean:/\\b(?:false|true)\\b/,variable:/\\$[a-z_]\\w*/i,directive:{pattern:/@[a-z_]\\w*/i,alias:\"function\"},\"attr-name\":{pattern:/\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,greedy:!0},\"atom-input\":{pattern:/\\b[A-Z]\\w*Input\\b/,alias:\"class-name\"},scalar:/\\b(?:Boolean|Float|ID|Int|String)\\b/,constant:/\\b[A-Z][A-Z_\\d]*\\b/,\"class-name\":{pattern:/(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,lookbehind:!0},fragment:{pattern:/(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\nlookbehind:!0,alias:\"function\"},\"definition-mutation\":{pattern:/(\\bmutation\\s+)[a-zA-Z_]\\w*/,lookbehind:!0,alias:\"function\"},\"definition-query\":{pattern:/(\\bquery\\s+)[a-zA-Z_]\\w*/,lookbehind:!0,alias:\"function\"},keyword:/\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,operator:/[!=|&]|\\.{3}/,\"property-query\":/\\w+(?=\\s*\\()/,object:/\\w+(?=\\s*\\{)/,punctuation:/[!(){}\\[\\]:=,]/,property:/\\w+/};Prism.hooks.add(\"after-tokenize\",\nfunction(env){function isTokenType(types,offset){offset=offset||0;for(var i=0;i<types.length;i++){var token=validTokens[currentIndex+(i+offset)];if(!token||token.type!==types[i])return!1}return!0}function findClosingBracket(open,close){for(var stackHeight=1,i=currentIndex;i<validTokens.length;i++){var token=validTokens[i],content=token.content;if(\"punctuation\"===token.type&&\"string\"===typeof content)if(open.test(content))stackHeight++;else if(close.test(content)&&(stackHeight--,0===stackHeight))return i}return-1}\nfunction addAlias(token,alias){var aliases=token.alias;aliases?Array.isArray(aliases)||(token.alias=aliases=[aliases]):token.alias=aliases=[];aliases.push(alias)}if(\"graphql\"===env.language)for(var validTokens=env.tokens.filter(function(token){return\"string\"!==typeof token&&\"comment\"!==token.type&&\"scalar\"!==token.type}),currentIndex=0;currentIndex<validTokens.length;)if(env=validTokens[currentIndex++],\"keyword\"===env.type&&\"mutation\"===env.content){env=[];if(isTokenType([\"definition-mutation\",\"punctuation\"])&&\n\"(\"===validTokens[currentIndex+1].content){currentIndex+=2;var definitionEnd=findClosingBracket(/^\\($/,/^\\)$/);if(-1===definitionEnd)continue;for(;currentIndex<definitionEnd;currentIndex++){var t=validTokens[currentIndex+0];\"variable\"===t.type&&(addAlias(t,\"variable-input\"),env.push(t.content))}currentIndex=definitionEnd+1}if(isTokenType([\"punctuation\",\"property-query\"])&&\"{\"===validTokens[currentIndex+0].content&&(currentIndex++,addAlias(validTokens[currentIndex+0],\"property-mutation\"),0<env.length&&\n(definitionEnd=findClosingBracket(/^\\{$/,/^\\}$/),-1!==definitionEnd)))for(t=currentIndex;t<definitionEnd;t++){var varToken=validTokens[t];\"variable\"===varToken.type&&0<=env.indexOf(varToken.content)&&addAlias(varToken,\"variable-input\")}}})}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=graphql;graphql.displayName=\"graphql\";graphql.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$graphql\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = graphql;\n// @ts-nocheck\ngraphql.displayName = 'graphql';\ngraphql.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction graphql(Prism) {\n  Prism.languages.graphql = {\n    comment: /#.*/,\n    description: {\n      pattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n      greedy: true,\n      alias: 'string',\n      inside: {\n        'language-markdown': {\n          pattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n          lookbehind: true,\n          inside: Prism.languages.markdown\n        }\n      }\n    },\n    string: {\n      pattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n      greedy: true\n    },\n    number: /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n    boolean: /\\b(?:false|true)\\b/,\n    variable: /\\$[a-z_]\\w*/i,\n    directive: {\n      pattern: /@[a-z_]\\w*/i,\n      alias: 'function'\n    },\n    'attr-name': {\n      pattern: /\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n      greedy: true\n    },\n    'atom-input': {\n      pattern: /\\b[A-Z]\\w*Input\\b/,\n      alias: 'class-name'\n    },\n    scalar: /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n    constant: /\\b[A-Z][A-Z_\\d]*\\b/,\n    'class-name': {\n      pattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n      lookbehind: true\n    },\n    fragment: {\n      pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n      lookbehind: true,\n      alias: 'function'\n    },\n    'definition-mutation': {\n      pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n      lookbehind: true,\n      alias: 'function'\n    },\n    'definition-query': {\n      pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n      lookbehind: true,\n      alias: 'function'\n    },\n    keyword: /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n    operator: /[!=|&]|\\.{3}/,\n    'property-query': /\\w+(?=\\s*\\()/,\n    object: /\\w+(?=\\s*\\{)/,\n    punctuation: /[!(){}\\[\\]:=,]/,\n    property: /\\w+/\n  };\n  Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n    if (env.language !== 'graphql') {\n      return;\n    }\n    /**\n     * get the graphql token stream that we want to customize\n     *\n     * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n     * @type {Token[]}\n     */\n\n\n    var validTokens = env.tokens.filter(function (token) {\n      return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n    });\n    var currentIndex = 0;\n    /**\n     * Returns whether the token relative to the current index has the given type.\n     *\n     * @param {number} offset\n     * @returns {Token | undefined}\n     */\n\n    function getToken(offset) {\n      return validTokens[currentIndex + offset];\n    }\n    /**\n     * Returns whether the token relative to the current index has the given type.\n     *\n     * @param {readonly string[]} types\n     * @param {number} [offset=0]\n     * @returns {boolean}\n     */\n\n\n    function isTokenType(types, offset) {\n      offset = offset || 0;\n\n      for (var i = 0; i < types.length; i++) {\n        var token = getToken(i + offset);\n\n        if (!token || token.type !== types[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Returns the index of the closing bracket to an opening bracket.\n     *\n     * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n     *\n     * If no closing bracket could be found, `-1` will be returned.\n     *\n     * @param {RegExp} open\n     * @param {RegExp} close\n     * @returns {number}\n     */\n\n\n    function findClosingBracket(open, close) {\n      var stackHeight = 1;\n\n      for (var i = currentIndex; i < validTokens.length; i++) {\n        var token = validTokens[i];\n        var content = token.content;\n\n        if (token.type === 'punctuation' && typeof content === 'string') {\n          if (open.test(content)) {\n            stackHeight++;\n          } else if (close.test(content)) {\n            stackHeight--;\n\n            if (stackHeight === 0) {\n              return i;\n            }\n          }\n        }\n      }\n\n      return -1;\n    }\n    /**\n     * Adds an alias to the given token.\n     *\n     * @param {Token} token\n     * @param {string} alias\n     * @returns {void}\n     */\n\n\n    function addAlias(token, alias) {\n      var aliases = token.alias;\n\n      if (!aliases) {\n        token.alias = aliases = [];\n      } else if (!Array.isArray(aliases)) {\n        token.alias = aliases = [aliases];\n      }\n\n      aliases.push(alias);\n    }\n\n    for (; currentIndex < validTokens.length;) {\n      var startToken = validTokens[currentIndex++]; // add special aliases for mutation tokens\n\n      if (startToken.type === 'keyword' && startToken.content === 'mutation') {\n        // any array of the names of all input variables (if any)\n        var inputVariables = [];\n\n        if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n          // definition\n          currentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n          var definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\n          if (definitionEnd === -1) {\n            continue;\n          } // find all input variables\n\n\n          for (; currentIndex < definitionEnd; currentIndex++) {\n            var t = getToken(0);\n\n            if (t.type === 'variable') {\n              addAlias(t, 'variable-input');\n              inputVariables.push(t.content);\n            }\n          }\n\n          currentIndex = definitionEnd + 1;\n        }\n\n        if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n          currentIndex++; // skip opening bracket\n\n          addAlias(getToken(0), 'property-mutation');\n\n          if (inputVariables.length > 0) {\n            var mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\n            if (mutationEnd === -1) {\n              continue;\n            } // give references to input variables a special alias\n\n\n            for (var i = currentIndex; i < mutationEnd; i++) {\n              var varToken = validTokens[i];\n\n              if (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n                addAlias(varToken, 'variable-input');\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["boolean","object","punctuation","string","aliases","scalar","constant","directive","operator","displayName","__esModule","fragment","graphql","lookbehind","value","variable","keyword","number","greedy","property","pattern","inside","alias","comment","default","description"]],"~:compiled-at",1676841365417,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$graphql.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lang/graphql.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$graphql\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = graphql;\\n// @ts-nocheck\\ngraphql.displayName = 'graphql';\\ngraphql.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction graphql(Prism) {\\n  Prism.languages.graphql = {\\n    comment: /#.*/,\\n    description: {\\n      pattern: /(?:\\\"\\\"\\\"(?:[^\\\"]|(?!\\\"\\\"\\\")\\\")*\\\"\\\"\\\"|\\\"(?:\\\\\\\\.|[^\\\\\\\\\\\"\\\\r\\\\n])*\\\")(?=\\\\s*[a-z_])/i,\\n      greedy: true,\\n      alias: 'string',\\n      inside: {\\n        'language-markdown': {\\n          pattern: /(^\\\"(?:\\\"\\\")?)(?!\\\\1)[\\\\s\\\\S]+(?=\\\\1$)/,\\n          lookbehind: true,\\n          inside: Prism.languages.markdown\\n        }\\n      }\\n    },\\n    string: {\\n      pattern: /\\\"\\\"\\\"(?:[^\\\"]|(?!\\\"\\\"\\\")\\\")*\\\"\\\"\\\"|\\\"(?:\\\\\\\\.|[^\\\\\\\\\\\"\\\\r\\\\n])*\\\"/,\\n      greedy: true\\n    },\\n    number: /(?:\\\\B-|\\\\b)\\\\d+(?:\\\\.\\\\d+)?(?:e[+-]?\\\\d+)?\\\\b/i,\\n    boolean: /\\\\b(?:false|true)\\\\b/,\\n    variable: /\\\\$[a-z_]\\\\w*/i,\\n    directive: {\\n      pattern: /@[a-z_]\\\\w*/i,\\n      alias: 'function'\\n    },\\n    'attr-name': {\\n      pattern: /\\\\b[a-z_]\\\\w*(?=\\\\s*(?:\\\\((?:[^()\\\"]|\\\"(?:\\\\\\\\.|[^\\\\\\\\\\\"\\\\r\\\\n])*\\\")*\\\\))?:)/i,\\n      greedy: true\\n    },\\n    'atom-input': {\\n      pattern: /\\\\b[A-Z]\\\\w*Input\\\\b/,\\n      alias: 'class-name'\\n    },\\n    scalar: /\\\\b(?:Boolean|Float|ID|Int|String)\\\\b/,\\n    constant: /\\\\b[A-Z][A-Z_\\\\d]*\\\\b/,\\n    'class-name': {\\n      pattern: /(\\\\b(?:enum|implements|interface|on|scalar|type|union)\\\\s+|&\\\\s*|:\\\\s*|\\\\[)[A-Z_]\\\\w*/,\\n      lookbehind: true\\n    },\\n    fragment: {\\n      pattern: /(\\\\bfragment\\\\s+|\\\\.{3}\\\\s*(?!on\\\\b))[a-zA-Z_]\\\\w*/,\\n      lookbehind: true,\\n      alias: 'function'\\n    },\\n    'definition-mutation': {\\n      pattern: /(\\\\bmutation\\\\s+)[a-zA-Z_]\\\\w*/,\\n      lookbehind: true,\\n      alias: 'function'\\n    },\\n    'definition-query': {\\n      pattern: /(\\\\bquery\\\\s+)[a-zA-Z_]\\\\w*/,\\n      lookbehind: true,\\n      alias: 'function'\\n    },\\n    keyword: /\\\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\\\b/,\\n    operator: /[!=|&]|\\\\.{3}/,\\n    'property-query': /\\\\w+(?=\\\\s*\\\\()/,\\n    object: /\\\\w+(?=\\\\s*\\\\{)/,\\n    punctuation: /[!(){}\\\\[\\\\]:=,]/,\\n    property: /\\\\w+/\\n  };\\n  Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\\n    if (env.language !== 'graphql') {\\n      return;\\n    }\\n    /**\\n     * get the graphql token stream that we want to customize\\n     *\\n     * @typedef {InstanceType<import(\\\"./prism-core\\\")[\\\"Token\\\"]>} Token\\n     * @type {Token[]}\\n     */\\n\\n\\n    var validTokens = env.tokens.filter(function (token) {\\n      return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\\n    });\\n    var currentIndex = 0;\\n    /**\\n     * Returns whether the token relative to the current index has the given type.\\n     *\\n     * @param {number} offset\\n     * @returns {Token | undefined}\\n     */\\n\\n    function getToken(offset) {\\n      return validTokens[currentIndex + offset];\\n    }\\n    /**\\n     * Returns whether the token relative to the current index has the given type.\\n     *\\n     * @param {readonly string[]} types\\n     * @param {number} [offset=0]\\n     * @returns {boolean}\\n     */\\n\\n\\n    function isTokenType(types, offset) {\\n      offset = offset || 0;\\n\\n      for (var i = 0; i < types.length; i++) {\\n        var token = getToken(i + offset);\\n\\n        if (!token || token.type !== types[i]) {\\n          return false;\\n        }\\n      }\\n\\n      return true;\\n    }\\n    /**\\n     * Returns the index of the closing bracket to an opening bracket.\\n     *\\n     * It is assumed that `token[currentIndex - 1]` is an opening bracket.\\n     *\\n     * If no closing bracket could be found, `-1` will be returned.\\n     *\\n     * @param {RegExp} open\\n     * @param {RegExp} close\\n     * @returns {number}\\n     */\\n\\n\\n    function findClosingBracket(open, close) {\\n      var stackHeight = 1;\\n\\n      for (var i = currentIndex; i < validTokens.length; i++) {\\n        var token = validTokens[i];\\n        var content = token.content;\\n\\n        if (token.type === 'punctuation' && typeof content === 'string') {\\n          if (open.test(content)) {\\n            stackHeight++;\\n          } else if (close.test(content)) {\\n            stackHeight--;\\n\\n            if (stackHeight === 0) {\\n              return i;\\n            }\\n          }\\n        }\\n      }\\n\\n      return -1;\\n    }\\n    /**\\n     * Adds an alias to the given token.\\n     *\\n     * @param {Token} token\\n     * @param {string} alias\\n     * @returns {void}\\n     */\\n\\n\\n    function addAlias(token, alias) {\\n      var aliases = token.alias;\\n\\n      if (!aliases) {\\n        token.alias = aliases = [];\\n      } else if (!Array.isArray(aliases)) {\\n        token.alias = aliases = [aliases];\\n      }\\n\\n      aliases.push(alias);\\n    }\\n\\n    for (; currentIndex < validTokens.length;) {\\n      var startToken = validTokens[currentIndex++]; // add special aliases for mutation tokens\\n\\n      if (startToken.type === 'keyword' && startToken.content === 'mutation') {\\n        // any array of the names of all input variables (if any)\\n        var inputVariables = [];\\n\\n        if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\\n          // definition\\n          currentIndex += 2; // skip 'definition-mutation' and 'punctuation'\\n\\n          var definitionEnd = findClosingBracket(/^\\\\($/, /^\\\\)$/);\\n\\n          if (definitionEnd === -1) {\\n            continue;\\n          } // find all input variables\\n\\n\\n          for (; currentIndex < definitionEnd; currentIndex++) {\\n            var t = getToken(0);\\n\\n            if (t.type === 'variable') {\\n              addAlias(t, 'variable-input');\\n              inputVariables.push(t.content);\\n            }\\n          }\\n\\n          currentIndex = definitionEnd + 1;\\n        }\\n\\n        if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\\n          currentIndex++; // skip opening bracket\\n\\n          addAlias(getToken(0), 'property-mutation');\\n\\n          if (inputVariables.length > 0) {\\n            var mutationEnd = findClosingBracket(/^\\\\{$/, /^\\\\}$/);\\n\\n            if (mutationEnd === -1) {\\n              continue;\\n            } // give references to input variables a special alias\\n\\n\\n            for (var i = currentIndex; i < mutationEnd; i++) {\\n              var varToken = validTokens[i];\\n\\n              if (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\\n                addAlias(varToken, 'variable-input');\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  });\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"graphql\",\"Prism\",\"languages\",\"comment\",\"description\",\"pattern\",\"greedy\",\"alias\",\"inside\",\"lookbehind\",\"markdown\",\"string\",\"number\",\"boolean\",\"variable\",\"directive\",\"scalar\",\"constant\",\"fragment\",\"keyword\",\"operator\",\"object\",\"punctuation\",\"property\",\"hooks\",\"add\",\"afterTokenizeGraphql\",\"env\",\"isTokenType\",\"types\",\"offset\",\"i\",\"length\",\"token\",\"validTokens\",\"currentIndex\",\"type\",\"findClosingBracket\",\"open\",\"close\",\"stackHeight\",\"content\",\"test\",\"addAlias\",\"aliases\",\"Array\",\"isArray\",\"push\",\"language\",\"tokens\",\"filter\",\"startToken\",\"inputVariables\",\"definitionEnd\",\"t\",\"mutationEnd\",\"varToken\",\"indexOf\",\"Object\",\"defineProperty\",\"value\",\"default\",\"displayName\"]\n}\n"]