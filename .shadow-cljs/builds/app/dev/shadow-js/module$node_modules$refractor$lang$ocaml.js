["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/ocaml.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$ocaml=function(global,require,module,exports){function ocaml(Prism){Prism.languages.ocaml={comment:{pattern:/\\(\\*[\\s\\S]*?\\*\\)/,greedy:!0},char:{pattern:/'(?:[^\\\\\\r\\n']|\\\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,greedy:!0},string:[{pattern:/\"(?:\\\\(?:[\\s\\S]|\\r\\n)|[^\\\\\\r\\n\"])*\"/,greedy:!0},{pattern:/\\{([a-z_]*)\\|[\\s\\S]*?\\|\\1\\}/,greedy:!0}],number:[/\\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\\b/i,/\\b0x[a-f0-9][a-f0-9_]*(?:\\.[a-f0-9_]*)?(?:p[+-]?\\d[\\d_]*)?(?!\\w)/i,/\\b\\d[\\d_]*(?:\\.[\\d_]*)?(?:e[+-]?\\d[\\d_]*)?(?!\\w)/i],\ndirective:{pattern:/\\B#\\w+/,alias:\"property\"},label:{pattern:/\\B~\\w+/,alias:\"property\"},\"type-variable\":{pattern:/\\B'\\w+/,alias:\"function\"},variant:{pattern:/`\\w+/,alias:\"symbol\"},keyword:/\\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\\b/,boolean:/\\b(?:false|true)\\b/,\n\"operator-like-punctuation\":{pattern:/\\[[<>|]|[>|]\\]|\\{<|>\\}/,alias:\"punctuation\"},operator:/\\.[.~]|:[=>]|[=<>@^|&+\\-*\\/$%!?~][!$%&*+\\-.\\/:<=>?@^|~]*|\\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\\b/,punctuation:/;;|::|[(){}\\[\\].,:;#]|\\b_\\b/}}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=ocaml;ocaml.displayName=\"ocaml\";ocaml.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$ocaml\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ocaml;\n// @ts-nocheck\nocaml.displayName = 'ocaml';\nocaml.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction ocaml(Prism) {\n  // https://ocaml.org/manual/lex.html\n  Prism.languages.ocaml = {\n    comment: {\n      pattern: /\\(\\*[\\s\\S]*?\\*\\)/,\n      greedy: true\n    },\n    char: {\n      pattern: /'(?:[^\\\\\\r\\n']|\\\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,\n      greedy: true\n    },\n    string: [{\n      pattern: /\"(?:\\\\(?:[\\s\\S]|\\r\\n)|[^\\\\\\r\\n\"])*\"/,\n      greedy: true\n    }, {\n      pattern: /\\{([a-z_]*)\\|[\\s\\S]*?\\|\\1\\}/,\n      greedy: true\n    }],\n    number: [// binary and octal\n    /\\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\\b/i, // hexadecimal\n    /\\b0x[a-f0-9][a-f0-9_]*(?:\\.[a-f0-9_]*)?(?:p[+-]?\\d[\\d_]*)?(?!\\w)/i, // decimal\n    /\\b\\d[\\d_]*(?:\\.[\\d_]*)?(?:e[+-]?\\d[\\d_]*)?(?!\\w)/i],\n    directive: {\n      pattern: /\\B#\\w+/,\n      alias: 'property'\n    },\n    label: {\n      pattern: /\\B~\\w+/,\n      alias: 'property'\n    },\n    'type-variable': {\n      pattern: /\\B'\\w+/,\n      alias: 'function'\n    },\n    variant: {\n      pattern: /`\\w+/,\n      alias: 'symbol'\n    },\n    // For the list of keywords and operators,\n    // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84\n    keyword: /\\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\\b/,\n    boolean: /\\b(?:false|true)\\b/,\n    'operator-like-punctuation': {\n      pattern: /\\[[<>|]|[>|]\\]|\\{<|>\\}/,\n      alias: 'punctuation'\n    },\n    // Custom operators are allowed\n    operator: /\\.[.~]|:[=>]|[=<>@^|&+\\-*\\/$%!?~][!$%&*+\\-.\\/:<=>?@^|~]*|\\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\\b/,\n    punctuation: /;;|::|[(){}\\[\\].,:;#]|\\b_\\b/\n  };\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["boolean","ocaml","punctuation","string","aliases","directive","operator","displayName","label","__esModule","value","char","keyword","number","greedy","pattern","alias","comment","default","variant"]],"~:compiled-at",1676841365441,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$ocaml.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,wCAAA,CAA6D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAYrGC,QAASA,MAAK,CAACC,KAAD,CAAQ,CAEpBA,KAAMC,CAAAA,SAAUF,CAAAA,KAAhB,CAAwB,CACtBG,QAAS,CACPC,QAAS,kBADF,CAEPC,OAAQ,CAAA,CAFD,CADa,CAKtBC,KAAM,CACJF,QAAS,8CADL,CAEJC,OAAQ,CAAA,CAFJ,CALgB,CAStBE,OAAQ,CAAC,CACPH,QAAS,qCADF,CAEPC,OAAQ,CAAA,CAFD,CAAD,CAGL,CACDD,QAAS,6BADR,CAEDC,OAAQ,CAAA,CAFP,CAHK,CATc,CAgBtBG,OAAQ,CACR,sCADQ,CAER,mEAFQ,CAGR,mDAHQ,CAhBc;AAoBtBC,UAAW,CACTL,QAAS,QADA,CAETM,MAAO,UAFE,CApBW,CAwBtBC,MAAO,CACLP,QAAS,QADJ,CAELM,MAAO,UAFF,CAxBe,CA4BtB,gBAAiB,CACfN,QAAS,QADM,CAEfM,MAAO,UAFQ,CA5BK,CAgCtBE,QAAS,CACPR,QAAS,MADF,CAEPM,MAAO,QAFA,CAhCa,CAsCtBG,QAAS,+RAtCa,CAuCtBC,QAAS,oBAvCa;AAwCtB,4BAA6B,CAC3BV,QAAS,wBADkB,CAE3BM,MAAO,aAFoB,CAxCP,CA6CtBK,SAAU,uGA7CY,CA8CtBC,YAAa,6BA9CS,CAFJ,CATtBC,MAAOC,CAAAA,cAAP,CAAsBnB,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CoB,MAAO,CAAA,CADoC,CAA7C,CAGApB,QAAQqB,CAAAA,OAAR,CAAkBpB,KAElBA,MAAMqB,CAAAA,WAAN,CAAoB,OACpBrB,MAAMsB,CAAAA,OAAN,CAAgB,EATqF;\",\n\"sources\":[\"node_modules/refractor/lang/ocaml.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$ocaml\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = ocaml;\\n// @ts-nocheck\\nocaml.displayName = 'ocaml';\\nocaml.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction ocaml(Prism) {\\n  // https://ocaml.org/manual/lex.html\\n  Prism.languages.ocaml = {\\n    comment: {\\n      pattern: /\\\\(\\\\*[\\\\s\\\\S]*?\\\\*\\\\)/,\\n      greedy: true\\n    },\\n    char: {\\n      pattern: /'(?:[^\\\\\\\\\\\\r\\\\n']|\\\\\\\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,\\n      greedy: true\\n    },\\n    string: [{\\n      pattern: /\\\"(?:\\\\\\\\(?:[\\\\s\\\\S]|\\\\r\\\\n)|[^\\\\\\\\\\\\r\\\\n\\\"])*\\\"/,\\n      greedy: true\\n    }, {\\n      pattern: /\\\\{([a-z_]*)\\\\|[\\\\s\\\\S]*?\\\\|\\\\1\\\\}/,\\n      greedy: true\\n    }],\\n    number: [// binary and octal\\n    /\\\\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\\\\b/i, // hexadecimal\\n    /\\\\b0x[a-f0-9][a-f0-9_]*(?:\\\\.[a-f0-9_]*)?(?:p[+-]?\\\\d[\\\\d_]*)?(?!\\\\w)/i, // decimal\\n    /\\\\b\\\\d[\\\\d_]*(?:\\\\.[\\\\d_]*)?(?:e[+-]?\\\\d[\\\\d_]*)?(?!\\\\w)/i],\\n    directive: {\\n      pattern: /\\\\B#\\\\w+/,\\n      alias: 'property'\\n    },\\n    label: {\\n      pattern: /\\\\B~\\\\w+/,\\n      alias: 'property'\\n    },\\n    'type-variable': {\\n      pattern: /\\\\B'\\\\w+/,\\n      alias: 'function'\\n    },\\n    variant: {\\n      pattern: /`\\\\w+/,\\n      alias: 'symbol'\\n    },\\n    // For the list of keywords and operators,\\n    // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84\\n    keyword: /\\\\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\\\\b/,\\n    boolean: /\\\\b(?:false|true)\\\\b/,\\n    'operator-like-punctuation': {\\n      pattern: /\\\\[[<>|]|[>|]\\\\]|\\\\{<|>\\\\}/,\\n      alias: 'punctuation'\\n    },\\n    // Custom operators are allowed\\n    operator: /\\\\.[.~]|:[=>]|[=<>@^|&+\\\\-*\\\\/$%!?~][!$%&*+\\\\-.\\\\/:<=>?@^|~]*|\\\\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\\\\b/,\\n    punctuation: /;;|::|[(){}\\\\[\\\\].,:;#]|\\\\b_\\\\b/\\n  };\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"ocaml\",\"Prism\",\"languages\",\"comment\",\"pattern\",\"greedy\",\"char\",\"string\",\"number\",\"directive\",\"alias\",\"label\",\"variant\",\"keyword\",\"boolean\",\"operator\",\"punctuation\",\"Object\",\"defineProperty\",\"value\",\"default\",\"displayName\",\"aliases\"]\n}\n"]