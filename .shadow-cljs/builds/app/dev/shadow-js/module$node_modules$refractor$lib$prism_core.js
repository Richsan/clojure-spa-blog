["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lib/prism-core.js"],"~:js","shadow$provide.module$node_modules$refractor$lib$prism_core=function(global,require,module,exports){function Token(type,content,alias,matchedStr){this.type=type;this.content=content;this.alias=alias;this.length=(matchedStr||\"\").length|0}function matchPattern(pattern,pos,text,lookbehind){pattern.lastIndex=pos;(pattern=pattern.exec(text))&&lookbehind&&pattern[1]&&(lookbehind=pattern[1].length,pattern.index+=lookbehind,pattern[0]=pattern[0].slice(lookbehind));return pattern}function matchGrammar(text,\ntokenList,grammar,startNode,startPos,rematch){for(var token in grammar)if(grammar.hasOwnProperty(token)&&grammar[token]){var patterns=grammar[token];patterns=Array.isArray(patterns)?patterns:[patterns];for(var j=0;j<patterns.length;++j){if(rematch&&rematch.cause==token+\",\"+j)return;var patternObj=patterns[j],inside=patternObj.inside,lookbehind=!!patternObj.lookbehind,greedy=!!patternObj.greedy,alias=patternObj.alias;if(greedy&&!patternObj.pattern.global){var flags=patternObj.pattern.toString().match(/[imsuy]*$/)[0];\npatternObj.pattern=RegExp(patternObj.pattern.source,flags+\"g\")}patternObj=patternObj.pattern||patternObj;var currentNode=startNode.next;for(flags=startPos;currentNode!==tokenList.tail&&!(rematch&&flags>=rematch.reach);flags+=currentNode.value.length,currentNode=currentNode.next){var str=currentNode.value;if(tokenList.length>text.length)return;if(!(str instanceof Token)){var removeCount=1;if(greedy){var match=matchPattern(patternObj,flags,text,lookbehind);if(!match||match.index>=text.length)break;\nvar from=match.index;str=match.index+match[0].length;var p=flags;for(p+=currentNode.value.length;from>=p;)currentNode=currentNode.next,p+=currentNode.value.length;flags=p-=currentNode.value.length;if(currentNode.value instanceof Token)continue;for(from=currentNode;from!==tokenList.tail&&(p<str||\"string\"===typeof from.value);from=from.next)removeCount++,p+=from.value.length;removeCount--;str=text.slice(flags,p);match.index-=flags}else if(match=matchPattern(patternObj,0,str,lookbehind),!match)continue;\nfrom=match.index;match=match[0];p=str.slice(0,from);from=str.slice(from+match.length);str=flags+str.length;rematch&&str>rematch.reach&&(rematch.reach=str);currentNode=currentNode.prev;p&&(currentNode=addAfter(tokenList,currentNode,p),flags+=p.length);p=tokenList;for(var node=currentNode,next=node.next,i=0;i<removeCount&&next!==p.tail;i++)next=next.next;node.next=next;next.prev=node;p.length-=i;match=new Token(token,inside?_.tokenize(match,inside):match,alias,match);currentNode=addAfter(tokenList,\ncurrentNode,match);from&&addAfter(tokenList,currentNode,from);1<removeCount&&(removeCount={cause:token+\",\"+j,reach:str},matchGrammar(text,tokenList,grammar,currentNode.prev,flags,removeCount),rematch&&removeCount.reach>rematch.reach&&(rematch.reach=removeCount.reach))}}}}}function LinkedList(){var head={value:null,prev:null,next:null},tail={value:null,prev:head,next:null};head.next=tail;this.head=head;this.tail=tail;this.length=0}function addAfter(list,node,value){var next=node.next;value={value,\nprev:node,next};node.next=value;next.prev=value;list.length++;return value}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.Prism=void 0;var uniqueId=0;global={};var _={util:{type:function(o){return Object.prototype.toString.call(o).slice(8,-1)},objId:function(obj){obj.__id||Object.defineProperty(obj,\"__id\",{value:++uniqueId});return obj.__id},clone:function deepClone(o,visited){visited=visited||{};switch(_.util.type(o)){case \"Object\":var id=_.util.objId(o);if(visited[id])return visited[id];\nvar clone={};visited[id]=clone;for(var key in o)o.hasOwnProperty(key)&&(clone[key]=deepClone(o[key],visited));return clone;case \"Array\":id=_.util.objId(o);if(visited[id])return visited[id];clone=[];visited[id]=clone;o.forEach(function(v,i){clone[i]=deepClone(v,visited)});return clone;default:return o}}},languages:{plain:global,plaintext:global,text:global,txt:global,extend:function(id,redef){id=_.util.clone(_.languages[id]);for(var key in redef)id[key]=redef[key];return id},insertBefore:function(inside,\nbefore,insert,root){root=root||_.languages;var grammar=root[inside],ret={},token;for(token in grammar)if(grammar.hasOwnProperty(token)){if(token==before)for(var newToken in insert)insert.hasOwnProperty(newToken)&&(ret[newToken]=insert[newToken]);insert.hasOwnProperty(token)||(ret[token]=grammar[token])}var old=root[inside];root[inside]=ret;_.languages.DFS(_.languages,function(key,value){value===old&&key!=inside&&(this[key]=ret)});return ret},DFS:function DFS(o,callback,type,visited){visited=visited||\n{};var objId=_.util.objId,i;for(i in o)if(o.hasOwnProperty(i)){callback.call(o,i,o[i],type||i);var property=o[i],propertyType=_.util.type(property);\"Object\"!==propertyType||visited[objId(property)]?\"Array\"!==propertyType||visited[objId(property)]||(visited[objId(property)]=!0,DFS(property,callback,i,visited)):(visited[objId(property)]=!0,DFS(property,callback,null,visited))}}},plugins:{},highlight:function(text,grammar,language){text={code:text,grammar,language};_.hooks.run(\"before-tokenize\",text);\nif(!text.grammar)throw Error('The language \"'+text.language+'\" has no grammar.');text.tokens=_.tokenize(text.code,text.grammar);_.hooks.run(\"after-tokenize\",text);return Token.stringify(_.util.encode(text.tokens),text.language)},tokenize:function(text,grammar){var rest=grammar.rest;if(rest){for(var token in rest)grammar[token]=rest[token];delete grammar.rest}rest=new LinkedList;addAfter(rest,rest.head,text);matchGrammar(text,rest,grammar,rest.head,0);text=[];for(grammar=rest.head.next;grammar!==rest.tail;)text.push(grammar.value),\ngrammar=grammar.next;return text},hooks:{all:{},add:function(name,callback){var hooks=_.hooks.all;hooks[name]=hooks[name]||[];hooks[name].push(callback)},run:function(name,env){if((name=_.hooks.all[name])&&name.length)for(var i=0,callback;callback=name[i++];)callback(env)}},Token};exports.Prism=_}","~:source","shadow$provide[\"module$node_modules$refractor$lib$prism_core\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Prism = void 0;\n// @ts-nocheck\n// This is a slimmed down version of `prism-core.js`, to remove globals,\n// document, workers, `util.encode`, `Token.stringify`\n// Private helper vars\nvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\nvar uniqueId = 0; // The grammar object for plaintext\n\nvar plainTextGrammar = {};\nvar _ = {\n  /**\n   * A namespace for utility methods.\n   *\n   * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n   * change or disappear at any time.\n   *\n   * @namespace\n   * @memberof Prism\n   */\n  util: {\n    /**\n     * Returns the name of the type of the given value.\n     *\n     * @param {any} o\n     * @returns {string}\n     * @example\n     * type(null)      === 'Null'\n     * type(undefined) === 'Undefined'\n     * type(123)       === 'Number'\n     * type('foo')     === 'String'\n     * type(true)      === 'Boolean'\n     * type([1, 2])    === 'Array'\n     * type({})        === 'Object'\n     * type(String)    === 'Function'\n     * type(/abc+/)    === 'RegExp'\n     */\n    type: function (o) {\n      return Object.prototype.toString.call(o).slice(8, -1);\n    },\n\n    /**\n     * Returns a unique number for the given object. Later calls will still return the same number.\n     *\n     * @param {Object} obj\n     * @returns {number}\n     */\n    objId: function (obj) {\n      if (!obj['__id']) {\n        Object.defineProperty(obj, '__id', {\n          value: ++uniqueId\n        });\n      }\n\n      return obj['__id'];\n    },\n\n    /**\n     * Creates a deep clone of the given object.\n     *\n     * The main intended use of this function is to clone language definitions.\n     *\n     * @param {T} o\n     * @param {Record<number, any>} [visited]\n     * @returns {T}\n     * @template T\n     */\n    clone: function deepClone(o, visited) {\n      visited = visited || {};\n      var clone;\n      var id;\n\n      switch (_.util.type(o)) {\n        case 'Object':\n          id = _.util.objId(o);\n\n          if (visited[id]) {\n            return visited[id];\n          }\n\n          clone = {};\n          visited[id] = clone;\n\n          for (var key in o) {\n            if (o.hasOwnProperty(key)) {\n              clone[key] = deepClone(o[key], visited);\n            }\n          }\n\n          return clone;\n\n        case 'Array':\n          id = _.util.objId(o);\n\n          if (visited[id]) {\n            return visited[id];\n          }\n\n          clone = [];\n          visited[id] = clone;\n          o.forEach(function (v, i) {\n            clone[i] = deepClone(v, visited);\n          });\n          return clone;\n\n        default:\n          return o;\n      }\n    }\n  },\n\n  /**\n   * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n   *\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  languages: {\n    /**\n     * The grammar for plain, unformatted text.\n     */\n    plain: plainTextGrammar,\n    plaintext: plainTextGrammar,\n    text: plainTextGrammar,\n    txt: plainTextGrammar,\n\n    /**\n     * Creates a deep copy of the language with the given id and appends the given tokens.\n     *\n     * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n     * will be overwritten at its original position.\n     *\n     * ## Best practices\n     *\n     * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n     * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n     * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n     *\n     * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n     * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n     *\n     * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n     * @param {Grammar} redef The new tokens to append.\n     * @returns {Grammar} The new language created.\n     * @public\n     * @example\n     * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n     *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n     *     // at its original position\n     *     'comment': { ... },\n     *     // CSS doesn't have a 'color' token, so this token will be appended\n     *     'color': /\\b(?:red|green|blue)\\b/\n     * });\n     */\n    extend: function (id, redef) {\n      var lang = _.util.clone(_.languages[id]);\n\n      for (var key in redef) {\n        lang[key] = redef[key];\n      }\n\n      return lang;\n    },\n\n    /**\n     * Inserts tokens _before_ another token in a language definition or any other grammar.\n     *\n     * ## Usage\n     *\n     * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n     * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n     * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n     * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n     * this:\n     *\n     * ```js\n     * Prism.languages.markup.style = {\n     *     // token\n     * };\n     * ```\n     *\n     * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n     * before existing tokens. For the CSS example above, you would use it like this:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'cdata', {\n     *     'style': {\n     *         // token\n     *     }\n     * });\n     * ```\n     *\n     * ## Special cases\n     *\n     * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n     * will be ignored.\n     *\n     * This behavior can be used to insert tokens after `before`:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'comment', {\n     *     'comment': Prism.languages.markup.comment,\n     *     // tokens after 'comment'\n     * });\n     * ```\n     *\n     * ## Limitations\n     *\n     * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n     * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n     * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n     * deleting properties which is necessary to insert at arbitrary positions.\n     *\n     * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n     * Instead, it will create a new object and replace all references to the target object with the new one. This\n     * can be done without temporarily deleting properties, so the iteration order is well-defined.\n     *\n     * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n     * you hold the target object in a variable, then the value of the variable will not change.\n     *\n     * ```js\n     * var oldMarkup = Prism.languages.markup;\n     * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n     *\n     * assert(oldMarkup !== Prism.languages.markup);\n     * assert(newMarkup === Prism.languages.markup);\n     * ```\n     *\n     * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n     * object to be modified.\n     * @param {string} before The key to insert before.\n     * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n     * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n     * object to be modified.\n     *\n     * Defaults to `Prism.languages`.\n     * @returns {Grammar} The new grammar object.\n     * @public\n     */\n    insertBefore: function (inside, before, insert, root) {\n      root = root || _.languages;\n      var grammar = root[inside];\n      /** @type {Grammar} */\n\n      var ret = {};\n\n      for (var token in grammar) {\n        if (grammar.hasOwnProperty(token)) {\n          if (token == before) {\n            for (var newToken in insert) {\n              if (insert.hasOwnProperty(newToken)) {\n                ret[newToken] = insert[newToken];\n              }\n            }\n          } // Do not insert token which also occur in insert. See #1525\n\n\n          if (!insert.hasOwnProperty(token)) {\n            ret[token] = grammar[token];\n          }\n        }\n      }\n\n      var old = root[inside];\n      root[inside] = ret; // Update references in other language definitions\n\n      _.languages.DFS(_.languages, function (key, value) {\n        if (value === old && key != inside) {\n          this[key] = ret;\n        }\n      });\n\n      return ret;\n    },\n    // Traverse a language definition with Depth First Search\n    DFS: function DFS(o, callback, type, visited) {\n      visited = visited || {};\n      var objId = _.util.objId;\n\n      for (var i in o) {\n        if (o.hasOwnProperty(i)) {\n          callback.call(o, i, o[i], type || i);\n          var property = o[i];\n\n          var propertyType = _.util.type(property);\n\n          if (propertyType === 'Object' && !visited[objId(property)]) {\n            visited[objId(property)] = true;\n            DFS(property, callback, null, visited);\n          } else if (propertyType === 'Array' && !visited[objId(property)]) {\n            visited[objId(property)] = true;\n            DFS(property, callback, i, visited);\n          }\n        }\n      }\n    }\n  },\n  plugins: {},\n\n  /**\n   * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n   * and the language definitions to use, and returns a string with the HTML produced.\n   *\n   * The following hooks will be run:\n   * 1. `before-tokenize`\n   * 2. `after-tokenize`\n   * 3. `wrap`: On each {@link Token}.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @param {string} language The name of the language definition passed to `grammar`.\n   * @returns {string} The highlighted HTML.\n   * @memberof Prism\n   * @public\n   * @example\n   * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n   */\n  highlight: function (text, grammar, language) {\n    var env = {\n      code: text,\n      grammar: grammar,\n      language: language\n    };\n\n    _.hooks.run('before-tokenize', env);\n\n    if (!env.grammar) {\n      throw new Error('The language \"' + env.language + '\" has no grammar.');\n    }\n\n    env.tokens = _.tokenize(env.code, env.grammar);\n\n    _.hooks.run('after-tokenize', env);\n\n    return Token.stringify(_.util.encode(env.tokens), env.language);\n  },\n\n  /**\n   * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n   * and the language definitions to use, and returns an array with the tokenized code.\n   *\n   * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n   *\n   * This method could be useful in other contexts as well, as a very crude parser.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @returns {TokenStream} An array of strings and tokens, a token stream.\n   * @memberof Prism\n   * @public\n   * @example\n   * let code = `var foo = 0;`;\n   * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n   * tokens.forEach(token => {\n   *     if (token instanceof Prism.Token && token.type === 'number') {\n   *         console.log(`Found numeric literal: ${token.content}`);\n   *     }\n   * });\n   */\n  tokenize: function (text, grammar) {\n    var rest = grammar.rest;\n\n    if (rest) {\n      for (var token in rest) {\n        grammar[token] = rest[token];\n      }\n\n      delete grammar.rest;\n    }\n\n    var tokenList = new LinkedList();\n    addAfter(tokenList, tokenList.head, text);\n    matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n    return toArray(tokenList);\n  },\n\n  /**\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  hooks: {\n    all: {},\n\n    /**\n     * Adds the given callback to the list of callbacks for the given hook.\n     *\n     * The callback will be invoked when the hook it is registered for is run.\n     * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n     *\n     * One callback function can be registered to multiple hooks and the same hook multiple times.\n     *\n     * @param {string} name The name of the hook.\n     * @param {HookCallback} callback The callback function which is given environment variables.\n     * @public\n     */\n    add: function (name, callback) {\n      var hooks = _.hooks.all;\n      hooks[name] = hooks[name] || [];\n      hooks[name].push(callback);\n    },\n\n    /**\n     * Runs a hook invoking all registered callbacks with the given environment variables.\n     *\n     * Callbacks will be invoked synchronously and in the order in which they were registered.\n     *\n     * @param {string} name The name of the hook.\n     * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n     * @public\n     */\n    run: function (name, env) {\n      var callbacks = _.hooks.all[name];\n\n      if (!callbacks || !callbacks.length) {\n        return;\n      }\n\n      for (var i = 0, callback; callback = callbacks[i++];) {\n        callback(env);\n      }\n    }\n  },\n  Token: Token\n}; // Typescript note:\n// The following can be used to import the Token type in JSDoc:\n//\n//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n/**\n * Creates a new token.\n *\n * @param {string} type See {@link Token#type type}\n * @param {string | TokenStream} content See {@link Token#content content}\n * @param {string|string[]} [alias] The alias(es) of the token.\n * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n * @class\n * @global\n * @public\n */\n\nfunction Token(type, content, alias, matchedStr) {\n  /**\n   * The type of the token.\n   *\n   * This is usually the key of a pattern in a {@link Grammar}.\n   *\n   * @type {string}\n   * @see GrammarToken\n   * @public\n   */\n  this.type = type;\n  /**\n   * The strings or tokens contained by this token.\n   *\n   * This will be a token stream if the pattern matched also defined an `inside` grammar.\n   *\n   * @type {string | TokenStream}\n   * @public\n   */\n\n  this.content = content;\n  /**\n   * The alias(es) of the token.\n   *\n   * @type {string|string[]}\n   * @see GrammarToken\n   * @public\n   */\n\n  this.alias = alias; // Copy of the full string this token was created from\n\n  this.length = (matchedStr || '').length | 0;\n}\n/**\n * A token stream is an array of strings and {@link Token Token} objects.\n *\n * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n * them.\n *\n * 1. No adjacent strings.\n * 2. No empty strings.\n *\n *    The only exception here is the token stream that only contains the empty string and nothing else.\n *\n * @typedef {Array<string | Token>} TokenStream\n * @global\n * @public\n */\n\n/**\n * @param {RegExp} pattern\n * @param {number} pos\n * @param {string} text\n * @param {boolean} lookbehind\n * @returns {RegExpExecArray | null}\n */\n\n\nfunction matchPattern(pattern, pos, text, lookbehind) {\n  pattern.lastIndex = pos;\n  var match = pattern.exec(text);\n\n  if (match && lookbehind && match[1]) {\n    // change the match to remove the text matched by the Prism lookbehind group\n    var lookbehindLength = match[1].length;\n    match.index += lookbehindLength;\n    match[0] = match[0].slice(lookbehindLength);\n  }\n\n  return match;\n}\n/**\n * @param {string} text\n * @param {LinkedList<string | Token>} tokenList\n * @param {any} grammar\n * @param {LinkedListNode<string | Token>} startNode\n * @param {number} startPos\n * @param {RematchOptions} [rematch]\n * @returns {void}\n * @private\n *\n * @typedef RematchOptions\n * @property {string} cause\n * @property {number} reach\n */\n\n\nfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n  for (var token in grammar) {\n    if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n      continue;\n    }\n\n    var patterns = grammar[token];\n    patterns = Array.isArray(patterns) ? patterns : [patterns];\n\n    for (var j = 0; j < patterns.length; ++j) {\n      if (rematch && rematch.cause == token + ',' + j) {\n        return;\n      }\n\n      var patternObj = patterns[j];\n      var inside = patternObj.inside;\n      var lookbehind = !!patternObj.lookbehind;\n      var greedy = !!patternObj.greedy;\n      var alias = patternObj.alias;\n\n      if (greedy && !patternObj.pattern.global) {\n        // Without the global flag, lastIndex won't work\n        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n        patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n      }\n      /** @type {RegExp} */\n\n\n      var pattern = patternObj.pattern || patternObj;\n\n      for ( // iterate the token list and keep track of the current token/string position\n      var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {\n        if (rematch && pos >= rematch.reach) {\n          break;\n        }\n\n        var str = currentNode.value;\n\n        if (tokenList.length > text.length) {\n          // Something went terribly wrong, ABORT, ABORT!\n          return;\n        }\n\n        if (str instanceof Token) {\n          continue;\n        }\n\n        var removeCount = 1; // this is the to parameter of removeBetween\n\n        var match;\n\n        if (greedy) {\n          match = matchPattern(pattern, pos, text, lookbehind);\n\n          if (!match || match.index >= text.length) {\n            break;\n          }\n\n          var from = match.index;\n          var to = match.index + match[0].length;\n          var p = pos; // find the node that contains the match\n\n          p += currentNode.value.length;\n\n          while (from >= p) {\n            currentNode = currentNode.next;\n            p += currentNode.value.length;\n          } // adjust pos (and p)\n\n\n          p -= currentNode.value.length;\n          pos = p; // the current node is a Token, then the match starts inside another Token, which is invalid\n\n          if (currentNode.value instanceof Token) {\n            continue;\n          } // find the last node which is affected by this match\n\n\n          for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {\n            removeCount++;\n            p += k.value.length;\n          }\n\n          removeCount--; // replace with the new match\n\n          str = text.slice(pos, p);\n          match.index -= pos;\n        } else {\n          match = matchPattern(pattern, 0, str, lookbehind);\n\n          if (!match) {\n            continue;\n          }\n        } // eslint-disable-next-line no-redeclare\n\n\n        var from = match.index;\n        var matchStr = match[0];\n        var before = str.slice(0, from);\n        var after = str.slice(from + matchStr.length);\n        var reach = pos + str.length;\n\n        if (rematch && reach > rematch.reach) {\n          rematch.reach = reach;\n        }\n\n        var removeFrom = currentNode.prev;\n\n        if (before) {\n          removeFrom = addAfter(tokenList, removeFrom, before);\n          pos += before.length;\n        }\n\n        removeRange(tokenList, removeFrom, removeCount);\n        var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n        currentNode = addAfter(tokenList, removeFrom, wrapped);\n\n        if (after) {\n          addAfter(tokenList, currentNode, after);\n        }\n\n        if (removeCount > 1) {\n          // at least one Token object was removed, so we have to do some rematching\n          // this can only happen if the current pattern is greedy\n\n          /** @type {RematchOptions} */\n          var nestedRematch = {\n            cause: token + ',' + j,\n            reach: reach\n          };\n          matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch); // the reach might have been extended because of the rematching\n\n          if (rematch && nestedRematch.reach > rematch.reach) {\n            rematch.reach = nestedRematch.reach;\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * @typedef LinkedListNode\n * @property {T} value\n * @property {LinkedListNode<T> | null} prev The previous node.\n * @property {LinkedListNode<T> | null} next The next node.\n * @template T\n * @private\n */\n\n/**\n * @template T\n * @private\n */\n\n\nfunction LinkedList() {\n  /** @type {LinkedListNode<T>} */\n  var head = {\n    value: null,\n    prev: null,\n    next: null\n  };\n  /** @type {LinkedListNode<T>} */\n\n  var tail = {\n    value: null,\n    prev: head,\n    next: null\n  };\n  head.next = tail;\n  /** @type {LinkedListNode<T>} */\n\n  this.head = head;\n  /** @type {LinkedListNode<T>} */\n\n  this.tail = tail;\n  this.length = 0;\n}\n/**\n * Adds a new node with the given value to the list.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {T} value\n * @returns {LinkedListNode<T>} The added node.\n * @template T\n */\n\n\nfunction addAfter(list, node, value) {\n  // assumes that node != list.tail && values.length >= 0\n  var next = node.next;\n  var newNode = {\n    value: value,\n    prev: node,\n    next: next\n  };\n  node.next = newNode;\n  next.prev = newNode;\n  list.length++;\n  return newNode;\n}\n/**\n * Removes `count` nodes after the given node. The given node will not be removed.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {number} count\n * @template T\n */\n\n\nfunction removeRange(list, node, count) {\n  var next = node.next;\n\n  for (var i = 0; i < count && next !== list.tail; i++) {\n    next = next.next;\n  }\n\n  node.next = next;\n  next.prev = node;\n  list.length -= i;\n}\n/**\n * @param {LinkedList<T>} list\n * @returns {T[]}\n * @template T\n */\n\n\nfunction toArray(list) {\n  var array = [];\n  var node = list.head.next;\n\n  while (node !== list.tail) {\n    array.push(node.value);\n    node = node.next;\n  }\n\n  return array;\n}\n\nconst Prism = _; // some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */\n\nexports.Prism = Prism;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["tail","grammar","__id","next","tokenize","index","util","__esModule","lastIndex","run","Prism","reach","insertBefore","cause","value","prev","text","languages","content","plain","length","head","DFS","pattern","type","objId","txt","plaintext","clone","extend","add","alias","all","highlight","language","Token","code","plugins","hooks","tokens"]],"~:compiled-at",1676841365382,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lib$prism_core.js\",\n\"lineCount\":12,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lib/prism-core.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lib$prism_core\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.Prism = void 0;\\n// @ts-nocheck\\n// This is a slimmed down version of `prism-core.js`, to remove globals,\\n// document, workers, `util.encode`, `Token.stringify`\\n// Private helper vars\\nvar lang = /(?:^|\\\\s)lang(?:uage)?-([\\\\w-]+)(?=\\\\s|$)/i;\\nvar uniqueId = 0; // The grammar object for plaintext\\n\\nvar plainTextGrammar = {};\\nvar _ = {\\n  /**\\n   * A namespace for utility methods.\\n   *\\n   * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\\n   * change or disappear at any time.\\n   *\\n   * @namespace\\n   * @memberof Prism\\n   */\\n  util: {\\n    /**\\n     * Returns the name of the type of the given value.\\n     *\\n     * @param {any} o\\n     * @returns {string}\\n     * @example\\n     * type(null)      === 'Null'\\n     * type(undefined) === 'Undefined'\\n     * type(123)       === 'Number'\\n     * type('foo')     === 'String'\\n     * type(true)      === 'Boolean'\\n     * type([1, 2])    === 'Array'\\n     * type({})        === 'Object'\\n     * type(String)    === 'Function'\\n     * type(/abc+/)    === 'RegExp'\\n     */\\n    type: function (o) {\\n      return Object.prototype.toString.call(o).slice(8, -1);\\n    },\\n\\n    /**\\n     * Returns a unique number for the given object. Later calls will still return the same number.\\n     *\\n     * @param {Object} obj\\n     * @returns {number}\\n     */\\n    objId: function (obj) {\\n      if (!obj['__id']) {\\n        Object.defineProperty(obj, '__id', {\\n          value: ++uniqueId\\n        });\\n      }\\n\\n      return obj['__id'];\\n    },\\n\\n    /**\\n     * Creates a deep clone of the given object.\\n     *\\n     * The main intended use of this function is to clone language definitions.\\n     *\\n     * @param {T} o\\n     * @param {Record<number, any>} [visited]\\n     * @returns {T}\\n     * @template T\\n     */\\n    clone: function deepClone(o, visited) {\\n      visited = visited || {};\\n      var clone;\\n      var id;\\n\\n      switch (_.util.type(o)) {\\n        case 'Object':\\n          id = _.util.objId(o);\\n\\n          if (visited[id]) {\\n            return visited[id];\\n          }\\n\\n          clone = {};\\n          visited[id] = clone;\\n\\n          for (var key in o) {\\n            if (o.hasOwnProperty(key)) {\\n              clone[key] = deepClone(o[key], visited);\\n            }\\n          }\\n\\n          return clone;\\n\\n        case 'Array':\\n          id = _.util.objId(o);\\n\\n          if (visited[id]) {\\n            return visited[id];\\n          }\\n\\n          clone = [];\\n          visited[id] = clone;\\n          o.forEach(function (v, i) {\\n            clone[i] = deepClone(v, visited);\\n          });\\n          return clone;\\n\\n        default:\\n          return o;\\n      }\\n    }\\n  },\\n\\n  /**\\n   * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\\n   *\\n   * @namespace\\n   * @memberof Prism\\n   * @public\\n   */\\n  languages: {\\n    /**\\n     * The grammar for plain, unformatted text.\\n     */\\n    plain: plainTextGrammar,\\n    plaintext: plainTextGrammar,\\n    text: plainTextGrammar,\\n    txt: plainTextGrammar,\\n\\n    /**\\n     * Creates a deep copy of the language with the given id and appends the given tokens.\\n     *\\n     * If a token in `redef` also appears in the copied language, then the existing token in the copied language\\n     * will be overwritten at its original position.\\n     *\\n     * ## Best practices\\n     *\\n     * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\\n     * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\\n     * understand the language definition because, normally, the order of tokens matters in Prism grammars.\\n     *\\n     * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\\n     * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\\n     *\\n     * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\\n     * @param {Grammar} redef The new tokens to append.\\n     * @returns {Grammar} The new language created.\\n     * @public\\n     * @example\\n     * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\\n     *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\\n     *     // at its original position\\n     *     'comment': { ... },\\n     *     // CSS doesn't have a 'color' token, so this token will be appended\\n     *     'color': /\\\\b(?:red|green|blue)\\\\b/\\n     * });\\n     */\\n    extend: function (id, redef) {\\n      var lang = _.util.clone(_.languages[id]);\\n\\n      for (var key in redef) {\\n        lang[key] = redef[key];\\n      }\\n\\n      return lang;\\n    },\\n\\n    /**\\n     * Inserts tokens _before_ another token in a language definition or any other grammar.\\n     *\\n     * ## Usage\\n     *\\n     * This helper method makes it easy to modify existing languages. For example, the CSS language definition\\n     * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\\n     * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\\n     * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\\n     * this:\\n     *\\n     * ```js\\n     * Prism.languages.markup.style = {\\n     *     // token\\n     * };\\n     * ```\\n     *\\n     * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\\n     * before existing tokens. For the CSS example above, you would use it like this:\\n     *\\n     * ```js\\n     * Prism.languages.insertBefore('markup', 'cdata', {\\n     *     'style': {\\n     *         // token\\n     *     }\\n     * });\\n     * ```\\n     *\\n     * ## Special cases\\n     *\\n     * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\\n     * will be ignored.\\n     *\\n     * This behavior can be used to insert tokens after `before`:\\n     *\\n     * ```js\\n     * Prism.languages.insertBefore('markup', 'comment', {\\n     *     'comment': Prism.languages.markup.comment,\\n     *     // tokens after 'comment'\\n     * });\\n     * ```\\n     *\\n     * ## Limitations\\n     *\\n     * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\\n     * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\\n     * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\\n     * deleting properties which is necessary to insert at arbitrary positions.\\n     *\\n     * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\\n     * Instead, it will create a new object and replace all references to the target object with the new one. This\\n     * can be done without temporarily deleting properties, so the iteration order is well-defined.\\n     *\\n     * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\\n     * you hold the target object in a variable, then the value of the variable will not change.\\n     *\\n     * ```js\\n     * var oldMarkup = Prism.languages.markup;\\n     * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\\n     *\\n     * assert(oldMarkup !== Prism.languages.markup);\\n     * assert(newMarkup === Prism.languages.markup);\\n     * ```\\n     *\\n     * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\\n     * object to be modified.\\n     * @param {string} before The key to insert before.\\n     * @param {Grammar} insert An object containing the key-value pairs to be inserted.\\n     * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\\n     * object to be modified.\\n     *\\n     * Defaults to `Prism.languages`.\\n     * @returns {Grammar} The new grammar object.\\n     * @public\\n     */\\n    insertBefore: function (inside, before, insert, root) {\\n      root = root || _.languages;\\n      var grammar = root[inside];\\n      /** @type {Grammar} */\\n\\n      var ret = {};\\n\\n      for (var token in grammar) {\\n        if (grammar.hasOwnProperty(token)) {\\n          if (token == before) {\\n            for (var newToken in insert) {\\n              if (insert.hasOwnProperty(newToken)) {\\n                ret[newToken] = insert[newToken];\\n              }\\n            }\\n          } // Do not insert token which also occur in insert. See #1525\\n\\n\\n          if (!insert.hasOwnProperty(token)) {\\n            ret[token] = grammar[token];\\n          }\\n        }\\n      }\\n\\n      var old = root[inside];\\n      root[inside] = ret; // Update references in other language definitions\\n\\n      _.languages.DFS(_.languages, function (key, value) {\\n        if (value === old && key != inside) {\\n          this[key] = ret;\\n        }\\n      });\\n\\n      return ret;\\n    },\\n    // Traverse a language definition with Depth First Search\\n    DFS: function DFS(o, callback, type, visited) {\\n      visited = visited || {};\\n      var objId = _.util.objId;\\n\\n      for (var i in o) {\\n        if (o.hasOwnProperty(i)) {\\n          callback.call(o, i, o[i], type || i);\\n          var property = o[i];\\n\\n          var propertyType = _.util.type(property);\\n\\n          if (propertyType === 'Object' && !visited[objId(property)]) {\\n            visited[objId(property)] = true;\\n            DFS(property, callback, null, visited);\\n          } else if (propertyType === 'Array' && !visited[objId(property)]) {\\n            visited[objId(property)] = true;\\n            DFS(property, callback, i, visited);\\n          }\\n        }\\n      }\\n    }\\n  },\\n  plugins: {},\\n\\n  /**\\n   * Low-level function, only use if you know what you\\u2019re doing. It accepts a string of text as input\\n   * and the language definitions to use, and returns a string with the HTML produced.\\n   *\\n   * The following hooks will be run:\\n   * 1. `before-tokenize`\\n   * 2. `after-tokenize`\\n   * 3. `wrap`: On each {@link Token}.\\n   *\\n   * @param {string} text A string with the code to be highlighted.\\n   * @param {Grammar} grammar An object containing the tokens to use.\\n   *\\n   * Usually a language definition like `Prism.languages.markup`.\\n   * @param {string} language The name of the language definition passed to `grammar`.\\n   * @returns {string} The highlighted HTML.\\n   * @memberof Prism\\n   * @public\\n   * @example\\n   * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\\n   */\\n  highlight: function (text, grammar, language) {\\n    var env = {\\n      code: text,\\n      grammar: grammar,\\n      language: language\\n    };\\n\\n    _.hooks.run('before-tokenize', env);\\n\\n    if (!env.grammar) {\\n      throw new Error('The language \\\"' + env.language + '\\\" has no grammar.');\\n    }\\n\\n    env.tokens = _.tokenize(env.code, env.grammar);\\n\\n    _.hooks.run('after-tokenize', env);\\n\\n    return Token.stringify(_.util.encode(env.tokens), env.language);\\n  },\\n\\n  /**\\n   * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\\n   * and the language definitions to use, and returns an array with the tokenized code.\\n   *\\n   * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\\n   *\\n   * This method could be useful in other contexts as well, as a very crude parser.\\n   *\\n   * @param {string} text A string with the code to be highlighted.\\n   * @param {Grammar} grammar An object containing the tokens to use.\\n   *\\n   * Usually a language definition like `Prism.languages.markup`.\\n   * @returns {TokenStream} An array of strings and tokens, a token stream.\\n   * @memberof Prism\\n   * @public\\n   * @example\\n   * let code = `var foo = 0;`;\\n   * let tokens = Prism.tokenize(code, Prism.languages.javascript);\\n   * tokens.forEach(token => {\\n   *     if (token instanceof Prism.Token && token.type === 'number') {\\n   *         console.log(`Found numeric literal: ${token.content}`);\\n   *     }\\n   * });\\n   */\\n  tokenize: function (text, grammar) {\\n    var rest = grammar.rest;\\n\\n    if (rest) {\\n      for (var token in rest) {\\n        grammar[token] = rest[token];\\n      }\\n\\n      delete grammar.rest;\\n    }\\n\\n    var tokenList = new LinkedList();\\n    addAfter(tokenList, tokenList.head, text);\\n    matchGrammar(text, tokenList, grammar, tokenList.head, 0);\\n    return toArray(tokenList);\\n  },\\n\\n  /**\\n   * @namespace\\n   * @memberof Prism\\n   * @public\\n   */\\n  hooks: {\\n    all: {},\\n\\n    /**\\n     * Adds the given callback to the list of callbacks for the given hook.\\n     *\\n     * The callback will be invoked when the hook it is registered for is run.\\n     * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\\n     *\\n     * One callback function can be registered to multiple hooks and the same hook multiple times.\\n     *\\n     * @param {string} name The name of the hook.\\n     * @param {HookCallback} callback The callback function which is given environment variables.\\n     * @public\\n     */\\n    add: function (name, callback) {\\n      var hooks = _.hooks.all;\\n      hooks[name] = hooks[name] || [];\\n      hooks[name].push(callback);\\n    },\\n\\n    /**\\n     * Runs a hook invoking all registered callbacks with the given environment variables.\\n     *\\n     * Callbacks will be invoked synchronously and in the order in which they were registered.\\n     *\\n     * @param {string} name The name of the hook.\\n     * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\\n     * @public\\n     */\\n    run: function (name, env) {\\n      var callbacks = _.hooks.all[name];\\n\\n      if (!callbacks || !callbacks.length) {\\n        return;\\n      }\\n\\n      for (var i = 0, callback; callback = callbacks[i++];) {\\n        callback(env);\\n      }\\n    }\\n  },\\n  Token: Token\\n}; // Typescript note:\\n// The following can be used to import the Token type in JSDoc:\\n//\\n//   @typedef {InstanceType<import(\\\"./prism-core\\\")[\\\"Token\\\"]>} Token\\n\\n/**\\n * Creates a new token.\\n *\\n * @param {string} type See {@link Token#type type}\\n * @param {string | TokenStream} content See {@link Token#content content}\\n * @param {string|string[]} [alias] The alias(es) of the token.\\n * @param {string} [matchedStr=\\\"\\\"] A copy of the full string this token was created from.\\n * @class\\n * @global\\n * @public\\n */\\n\\nfunction Token(type, content, alias, matchedStr) {\\n  /**\\n   * The type of the token.\\n   *\\n   * This is usually the key of a pattern in a {@link Grammar}.\\n   *\\n   * @type {string}\\n   * @see GrammarToken\\n   * @public\\n   */\\n  this.type = type;\\n  /**\\n   * The strings or tokens contained by this token.\\n   *\\n   * This will be a token stream if the pattern matched also defined an `inside` grammar.\\n   *\\n   * @type {string | TokenStream}\\n   * @public\\n   */\\n\\n  this.content = content;\\n  /**\\n   * The alias(es) of the token.\\n   *\\n   * @type {string|string[]}\\n   * @see GrammarToken\\n   * @public\\n   */\\n\\n  this.alias = alias; // Copy of the full string this token was created from\\n\\n  this.length = (matchedStr || '').length | 0;\\n}\\n/**\\n * A token stream is an array of strings and {@link Token Token} objects.\\n *\\n * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\\n * them.\\n *\\n * 1. No adjacent strings.\\n * 2. No empty strings.\\n *\\n *    The only exception here is the token stream that only contains the empty string and nothing else.\\n *\\n * @typedef {Array<string | Token>} TokenStream\\n * @global\\n * @public\\n */\\n\\n/**\\n * @param {RegExp} pattern\\n * @param {number} pos\\n * @param {string} text\\n * @param {boolean} lookbehind\\n * @returns {RegExpExecArray | null}\\n */\\n\\n\\nfunction matchPattern(pattern, pos, text, lookbehind) {\\n  pattern.lastIndex = pos;\\n  var match = pattern.exec(text);\\n\\n  if (match && lookbehind && match[1]) {\\n    // change the match to remove the text matched by the Prism lookbehind group\\n    var lookbehindLength = match[1].length;\\n    match.index += lookbehindLength;\\n    match[0] = match[0].slice(lookbehindLength);\\n  }\\n\\n  return match;\\n}\\n/**\\n * @param {string} text\\n * @param {LinkedList<string | Token>} tokenList\\n * @param {any} grammar\\n * @param {LinkedListNode<string | Token>} startNode\\n * @param {number} startPos\\n * @param {RematchOptions} [rematch]\\n * @returns {void}\\n * @private\\n *\\n * @typedef RematchOptions\\n * @property {string} cause\\n * @property {number} reach\\n */\\n\\n\\nfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\\n  for (var token in grammar) {\\n    if (!grammar.hasOwnProperty(token) || !grammar[token]) {\\n      continue;\\n    }\\n\\n    var patterns = grammar[token];\\n    patterns = Array.isArray(patterns) ? patterns : [patterns];\\n\\n    for (var j = 0; j < patterns.length; ++j) {\\n      if (rematch && rematch.cause == token + ',' + j) {\\n        return;\\n      }\\n\\n      var patternObj = patterns[j];\\n      var inside = patternObj.inside;\\n      var lookbehind = !!patternObj.lookbehind;\\n      var greedy = !!patternObj.greedy;\\n      var alias = patternObj.alias;\\n\\n      if (greedy && !patternObj.pattern.global) {\\n        // Without the global flag, lastIndex won't work\\n        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\\n        patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\\n      }\\n      /** @type {RegExp} */\\n\\n\\n      var pattern = patternObj.pattern || patternObj;\\n\\n      for ( // iterate the token list and keep track of the current token/string position\\n      var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {\\n        if (rematch && pos >= rematch.reach) {\\n          break;\\n        }\\n\\n        var str = currentNode.value;\\n\\n        if (tokenList.length > text.length) {\\n          // Something went terribly wrong, ABORT, ABORT!\\n          return;\\n        }\\n\\n        if (str instanceof Token) {\\n          continue;\\n        }\\n\\n        var removeCount = 1; // this is the to parameter of removeBetween\\n\\n        var match;\\n\\n        if (greedy) {\\n          match = matchPattern(pattern, pos, text, lookbehind);\\n\\n          if (!match || match.index >= text.length) {\\n            break;\\n          }\\n\\n          var from = match.index;\\n          var to = match.index + match[0].length;\\n          var p = pos; // find the node that contains the match\\n\\n          p += currentNode.value.length;\\n\\n          while (from >= p) {\\n            currentNode = currentNode.next;\\n            p += currentNode.value.length;\\n          } // adjust pos (and p)\\n\\n\\n          p -= currentNode.value.length;\\n          pos = p; // the current node is a Token, then the match starts inside another Token, which is invalid\\n\\n          if (currentNode.value instanceof Token) {\\n            continue;\\n          } // find the last node which is affected by this match\\n\\n\\n          for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {\\n            removeCount++;\\n            p += k.value.length;\\n          }\\n\\n          removeCount--; // replace with the new match\\n\\n          str = text.slice(pos, p);\\n          match.index -= pos;\\n        } else {\\n          match = matchPattern(pattern, 0, str, lookbehind);\\n\\n          if (!match) {\\n            continue;\\n          }\\n        } // eslint-disable-next-line no-redeclare\\n\\n\\n        var from = match.index;\\n        var matchStr = match[0];\\n        var before = str.slice(0, from);\\n        var after = str.slice(from + matchStr.length);\\n        var reach = pos + str.length;\\n\\n        if (rematch && reach > rematch.reach) {\\n          rematch.reach = reach;\\n        }\\n\\n        var removeFrom = currentNode.prev;\\n\\n        if (before) {\\n          removeFrom = addAfter(tokenList, removeFrom, before);\\n          pos += before.length;\\n        }\\n\\n        removeRange(tokenList, removeFrom, removeCount);\\n        var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\\n        currentNode = addAfter(tokenList, removeFrom, wrapped);\\n\\n        if (after) {\\n          addAfter(tokenList, currentNode, after);\\n        }\\n\\n        if (removeCount > 1) {\\n          // at least one Token object was removed, so we have to do some rematching\\n          // this can only happen if the current pattern is greedy\\n\\n          /** @type {RematchOptions} */\\n          var nestedRematch = {\\n            cause: token + ',' + j,\\n            reach: reach\\n          };\\n          matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch); // the reach might have been extended because of the rematching\\n\\n          if (rematch && nestedRematch.reach > rematch.reach) {\\n            rematch.reach = nestedRematch.reach;\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n/**\\n * @typedef LinkedListNode\\n * @property {T} value\\n * @property {LinkedListNode<T> | null} prev The previous node.\\n * @property {LinkedListNode<T> | null} next The next node.\\n * @template T\\n * @private\\n */\\n\\n/**\\n * @template T\\n * @private\\n */\\n\\n\\nfunction LinkedList() {\\n  /** @type {LinkedListNode<T>} */\\n  var head = {\\n    value: null,\\n    prev: null,\\n    next: null\\n  };\\n  /** @type {LinkedListNode<T>} */\\n\\n  var tail = {\\n    value: null,\\n    prev: head,\\n    next: null\\n  };\\n  head.next = tail;\\n  /** @type {LinkedListNode<T>} */\\n\\n  this.head = head;\\n  /** @type {LinkedListNode<T>} */\\n\\n  this.tail = tail;\\n  this.length = 0;\\n}\\n/**\\n * Adds a new node with the given value to the list.\\n *\\n * @param {LinkedList<T>} list\\n * @param {LinkedListNode<T>} node\\n * @param {T} value\\n * @returns {LinkedListNode<T>} The added node.\\n * @template T\\n */\\n\\n\\nfunction addAfter(list, node, value) {\\n  // assumes that node != list.tail && values.length >= 0\\n  var next = node.next;\\n  var newNode = {\\n    value: value,\\n    prev: node,\\n    next: next\\n  };\\n  node.next = newNode;\\n  next.prev = newNode;\\n  list.length++;\\n  return newNode;\\n}\\n/**\\n * Removes `count` nodes after the given node. The given node will not be removed.\\n *\\n * @param {LinkedList<T>} list\\n * @param {LinkedListNode<T>} node\\n * @param {number} count\\n * @template T\\n */\\n\\n\\nfunction removeRange(list, node, count) {\\n  var next = node.next;\\n\\n  for (var i = 0; i < count && next !== list.tail; i++) {\\n    next = next.next;\\n  }\\n\\n  node.next = next;\\n  next.prev = node;\\n  list.length -= i;\\n}\\n/**\\n * @param {LinkedList<T>} list\\n * @returns {T[]}\\n * @template T\\n */\\n\\n\\nfunction toArray(list) {\\n  var array = [];\\n  var node = list.head.next;\\n\\n  while (node !== list.tail) {\\n    array.push(node.value);\\n    node = node.next;\\n  }\\n\\n  return array;\\n}\\n\\nconst Prism = _; // some additional documentation/types\\n\\n/**\\n * The expansion of a simple `RegExp` literal to support additional properties.\\n *\\n * @typedef GrammarToken\\n * @property {RegExp} pattern The regular expression of the token.\\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\\n * @property {boolean} [greedy=false] Whether the token is greedy.\\n * @property {string|string[]} [alias] An optional alias or list of aliases.\\n * @property {Grammar} [inside] The nested grammar of this token.\\n *\\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\\n *\\n * This can be used to make nested and even recursive language definitions.\\n *\\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\\n * each another.\\n * @global\\n * @public\\n */\\n\\n/**\\n * @typedef Grammar\\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\\n * @global\\n * @public\\n */\\n\\n/**\\n * A function which will invoked after an element was successfully highlighted.\\n *\\n * @callback HighlightCallback\\n * @param {Element} element The element successfully highlighted.\\n * @returns {void}\\n * @global\\n * @public\\n */\\n\\n/**\\n * @callback HookCallback\\n * @param {Object<string, any>} env The environment variables of the hook.\\n * @returns {void}\\n * @global\\n * @public\\n */\\n\\nexports.Prism = Prism;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Token\",\"type\",\"content\",\"alias\",\"matchedStr\",\"length\",\"matchPattern\",\"pattern\",\"pos\",\"text\",\"lookbehind\",\"lastIndex\",\"match\",\"exec\",\"lookbehindLength\",\"index\",\"slice\",\"matchGrammar\",\"tokenList\",\"grammar\",\"startNode\",\"startPos\",\"rematch\",\"token\",\"hasOwnProperty\",\"patterns\",\"Array\",\"isArray\",\"j\",\"cause\",\"patternObj\",\"inside\",\"greedy\",\"flags\",\"toString\",\"RegExp\",\"source\",\"currentNode\",\"next\",\"tail\",\"reach\",\"value\",\"str\",\"removeCount\",\"from\",\"to\",\"p\",\"k\",\"matchStr\",\"before\",\"after\",\"removeFrom\",\"prev\",\"addAfter\",\"node\",\"i\",\"list\",\"wrapped\",\"_\",\"tokenize\",\"nestedRematch\",\"LinkedList\",\"head\",\"newNode\",\"Object\",\"defineProperty\",\"Prism\",\"uniqueId\",\"plainTextGrammar\",\"util\",\"o\",\"prototype\",\"call\",\"objId\",\"obj\",\"clone\",\"deepClone\",\"visited\",\"id\",\"key\",\"forEach\",\"v\",\"languages\",\"plain\",\"plaintext\",\"txt\",\"extend\",\"redef\",\"lang\",\"insertBefore\",\"insert\",\"root\",\"ret\",\"newToken\",\"old\",\"DFS\",\"callback\",\"property\",\"propertyType\",\"plugins\",\"highlight\",\"language\",\"env\",\"code\",\"hooks\",\"run\",\"Error\",\"tokens\",\"stringify\",\"encode\",\"rest\",\"array\",\"push\",\"all\",\"add\",\"name\",\"callbacks\"]\n}\n"]