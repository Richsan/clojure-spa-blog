["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hast-util-select/lib/index.js"],"~:js","shadow$provide.module$node_modules$hast_util_select$lib$index=function(global,require,module,exports){function createState(selector,tree,space){return{rootQuery:(0,_walk.queryToSelectors)((0,_parse.parse)(selector)),results:[],scopeElements:tree?\"root\"===tree.type?tree.children:[tree]:[],one:!1,shallow:!1,found:!1,schema:\"svg\"===space?_propertyInformation.svg:_propertyInformation.html,language:void 0,direction:\"ltr\",editableOrEditingHost:!1,typeIndex:void 0,elementIndex:void 0,typeCount:void 0,elementCount:void 0}}\nObject.defineProperty(exports,\"__esModule\",{value:!0});exports.matches=function(selector,node,space){selector=createState(selector,node,space);selector.one=!0;selector.shallow=!0;(0,_walk.walk)(selector,node||void 0);return 0<selector.results.length};exports.select=function(selector,tree,space){selector=createState(selector,tree,space);selector.one=!0;(0,_walk.walk)(selector,tree||void 0);return selector.results[0]||null};exports.selectAll=function(selector,tree,space){selector=createState(selector,\ntree,space);(0,_walk.walk)(selector,tree||void 0);return selector.results};var _propertyInformation=require(\"module$node_modules$property_information$index\"),_walk=require(\"module$node_modules$hast_util_select$lib$walk\"),_parse=require(\"module$node_modules$hast_util_select$lib$parse\")}","~:source","shadow$provide[\"module$node_modules$hast_util_select$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matches = matches;\nexports.select = select;\nexports.selectAll = selectAll;\n\nvar _propertyInformation = require(\"property-information\");\n\nvar _walk = require(\"./walk.js\");\n\nvar _parse = require(\"./parse.js\");\n\n/**\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Space} Space\n * @typedef {import('./types.js').SelectState} SelectState\n */\n\n/**\n * Check that the given `node` matches `selector`.\n *\n * This only checks the element itself, not the surrounding tree.\n * Thus, nesting in selectors is not supported (`p b`, `p > b`), neither are\n * selectors like `:first-child`, etc.\n * This only checks that the given element matches the selector.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [node]\n *   Node that might match `selector`, should be an element.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {boolean}\n *   Whether `node` matches `selector`.\n */\nfunction matches(selector, node, space) {\n  const state = createState(selector, node, space);\n  state.one = true;\n  state.shallow = true;\n  (0, _walk.walk)(state, node || undefined);\n  return state.results.length > 0;\n}\n/**\n * Select the first element that matches `selector` in the given `tree`.\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {Element | null}\n *   First element in `tree` that matches `selector` or `null` if nothing is\n *   found.\n *   This could be `tree` itself.\n */\n\n\nfunction select(selector, tree, space) {\n  const state = createState(selector, tree, space);\n  state.one = true;\n  (0, _walk.walk)(state, tree || undefined); // To do in major: return `undefined` instead.\n\n  return state.results[0] || null;\n}\n/**\n * Select all elements that match `selector` in the given `tree`.\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {Array<Element>}\n *   Elements in `tree` that match `selector`.\n *   This could include `tree` itself.\n */\n\n\nfunction selectAll(selector, tree, space) {\n  const state = createState(selector, tree, space);\n  (0, _walk.walk)(state, tree || undefined);\n  return state.results;\n}\n/**\n * @param {string} selector\n *   Tree to search.\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {SelectState} SelectState\n */\n\n\nfunction createState(selector, tree, space) {\n  return {\n    // State of the query.\n    rootQuery: (0, _walk.queryToSelectors)((0, _parse.parse)(selector)),\n    results: [],\n    // @ts-expect-error assume elements.\n    scopeElements: tree ? tree.type === 'root' ? tree.children : [tree] : [],\n    one: false,\n    shallow: false,\n    found: false,\n    // State in the tree.\n    schema: space === 'svg' ? _propertyInformation.svg : _propertyInformation.html,\n    language: undefined,\n    direction: 'ltr',\n    editableOrEditingHost: false,\n    typeIndex: undefined,\n    elementIndex: undefined,\n    typeCount: undefined,\n    elementCount: undefined\n  };\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$property_information$index","~$module$node_modules$hast_util_select$lib$parse","~$shadow.js","~$module$node_modules$hast_util_select$lib$walk"]],"~:properties",["^5",["elementIndex","rootQuery","typeCount","found","__esModule","schema","selectAll","results","typeIndex","elementCount","value","direction","select","matches","one","editableOrEditingHost","scopeElements","language","shallow"]],"~:compiled-at",1676841365503,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hast_util_select$lib$index.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,8CAAA,CAAmE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAuG3GC,QAASA,YAAW,CAACC,QAAD,CAAWC,IAAX,CAAiBC,KAAjB,CAAwB,CAC1C,MAAO,CAELC,UAAW,GAAIC,KAAMC,CAAAA,gBAAV,EAA4B,GAAIC,MAAOC,CAAAA,KAAX,EAAkBP,QAAlB,CAA5B,CAFN,CAGLQ,QAAS,EAHJ,CAKLC,cAAeR,IAAA,CAAqB,MAAd,GAAAA,IAAKS,CAAAA,IAAL,CAAuBT,IAAKU,CAAAA,QAA5B,CAAuC,CAACV,IAAD,CAA9C,CAAuD,EALjE,CAMLW,IAAK,CAAA,CANA,CAOLC,QAAS,CAAA,CAPJ,CAQLC,MAAO,CAAA,CARF,CAULC,OAAkB,KAAV,GAAAb,KAAA,CAAkBc,oBAAqBC,CAAAA,GAAvC,CAA6CD,oBAAqBE,CAAAA,IAVrE,CAWLC,SAAUC,IAAAA,EAXL,CAYLC,UAAW,KAZN,CAaLC,sBAAuB,CAAA,CAblB,CAcLC,UAAWH,IAAAA,EAdN,CAeLI,aAAcJ,IAAAA,EAfT,CAgBLK,UAAWL,IAAAA,EAhBN,CAiBLM,aAAcN,IAAAA,EAjBT,CADmC;AApG5CO,MAAOC,CAAAA,cAAP,CAAsB9B,OAAtB,CAA+B,YAA/B,CAA6C,CAC3C+B,MAAO,CAAA,CADoC,CAA7C,CAGA/B,QAAQgC,CAAAA,OAAR,CAkCAA,QAAgB,CAAC9B,QAAD,CAAW+B,IAAX,CAAiB7B,KAAjB,CAAwB,CAChC8B,QAAAA,CAAQjC,WAAA,CAAYC,QAAZ,CAAsB+B,IAAtB,CAA4B7B,KAA5B,CACd8B,SAAMpB,CAAAA,GAAN,CAAY,CAAA,CACZoB,SAAMnB,CAAAA,OAAN,CAAgB,CAAA,CAChB,IAAIT,KAAM6B,CAAAA,IAAV,EAAgBD,QAAhB,CAAuBD,IAAvB,EAA+BX,IAAAA,EAA/B,CACA,OAA8B,EAA9B,CAAOY,QAAMxB,CAAAA,OAAQ0B,CAAAA,MALiB,CAjCxCpC,QAAQqC,CAAAA,MAAR,CAyDAA,QAAe,CAACnC,QAAD,CAAWC,IAAX,CAAiBC,KAAjB,CAAwB,CAC/B8B,QAAAA,CAAQjC,WAAA,CAAYC,QAAZ,CAAsBC,IAAtB,CAA4BC,KAA5B,CACd8B,SAAMpB,CAAAA,GAAN,CAAY,CAAA,CACZ,IAAIR,KAAM6B,CAAAA,IAAV,EAAgBD,QAAhB,CAAuB/B,IAAvB,EAA+BmB,IAAAA,EAA/B,CAEA,OAAOY,SAAMxB,CAAAA,OAAN,CAAc,CAAd,CAAP,EAA2B,IALU,CAxDvCV,QAAQsC,CAAAA,SAAR,CA+EAA,QAAkB,CAACpC,QAAD,CAAWC,IAAX,CAAiBC,KAAjB,CAAwB,CAClC8B,QAAAA,CAAQjC,WAAA,CAAYC,QAAZ;AAAsBC,IAAtB,CAA4BC,KAA5B,CACd,IAAIE,KAAM6B,CAAAA,IAAV,EAAgBD,QAAhB,CAAuB/B,IAAvB,EAA+BmB,IAAAA,EAA/B,CACA,OAAOY,SAAMxB,CAAAA,OAH2B,CA7E1C,KAAIQ,qBAAuBpB,OAAA,CAAQ,gDAAR,CAA3B,CAEIQ,MAAQR,OAAA,CAAQ,+CAAR,CAFZ,CAIIU,OAASV,OAAA,CAAQ,gDAAR,CAd8F;\",\n\"sources\":[\"node_modules/hast-util-select/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hast_util_select$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.matches = matches;\\nexports.select = select;\\nexports.selectAll = selectAll;\\n\\nvar _propertyInformation = require(\\\"property-information\\\");\\n\\nvar _walk = require(\\\"./walk.js\\\");\\n\\nvar _parse = require(\\\"./parse.js\\\");\\n\\n/**\\n * @typedef {import('./types.js').Element} Element\\n * @typedef {import('./types.js').Node} Node\\n * @typedef {import('./types.js').Space} Space\\n * @typedef {import('./types.js').SelectState} SelectState\\n */\\n\\n/**\\n * Check that the given `node` matches `selector`.\\n *\\n * This only checks the element itself, not the surrounding tree.\\n * Thus, nesting in selectors is not supported (`p b`, `p > b`), neither are\\n * selectors like `:first-child`, etc.\\n * This only checks that the given element matches the selector.\\n *\\n * @param {string} selector\\n *   CSS selector, such as (`h1`, `a, b`).\\n * @param {Node | null | undefined} [node]\\n *   Node that might match `selector`, should be an element.\\n * @param {Space | null | undefined} [space='html']\\n *   Name of namespace (`'svg'` or `'html'`).\\n * @returns {boolean}\\n *   Whether `node` matches `selector`.\\n */\\nfunction matches(selector, node, space) {\\n  const state = createState(selector, node, space);\\n  state.one = true;\\n  state.shallow = true;\\n  (0, _walk.walk)(state, node || undefined);\\n  return state.results.length > 0;\\n}\\n/**\\n * Select the first element that matches `selector` in the given `tree`.\\n * Searches the tree in *preorder*.\\n *\\n * @param {string} selector\\n *   CSS selector, such as (`h1`, `a, b`).\\n * @param {Node | null | undefined} [tree]\\n *   Tree to search.\\n * @param {Space | null | undefined} [space='html']\\n *   Name of namespace (`'svg'` or `'html'`).\\n * @returns {Element | null}\\n *   First element in `tree` that matches `selector` or `null` if nothing is\\n *   found.\\n *   This could be `tree` itself.\\n */\\n\\n\\nfunction select(selector, tree, space) {\\n  const state = createState(selector, tree, space);\\n  state.one = true;\\n  (0, _walk.walk)(state, tree || undefined); // To do in major: return `undefined` instead.\\n\\n  return state.results[0] || null;\\n}\\n/**\\n * Select all elements that match `selector` in the given `tree`.\\n * Searches the tree in *preorder*.\\n *\\n * @param {string} selector\\n *   CSS selector, such as (`h1`, `a, b`).\\n * @param {Node | null | undefined} [tree]\\n *   Tree to search.\\n * @param {Space | null | undefined} [space='html']\\n *   Name of namespace (`'svg'` or `'html'`).\\n * @returns {Array<Element>}\\n *   Elements in `tree` that match `selector`.\\n *   This could include `tree` itself.\\n */\\n\\n\\nfunction selectAll(selector, tree, space) {\\n  const state = createState(selector, tree, space);\\n  (0, _walk.walk)(state, tree || undefined);\\n  return state.results;\\n}\\n/**\\n * @param {string} selector\\n *   Tree to search.\\n * @param {Node | null | undefined} [tree]\\n *   Tree to search.\\n * @param {Space | null | undefined} [space='html']\\n *   Name of namespace (`'svg'` or `'html'`).\\n * @returns {SelectState} SelectState\\n */\\n\\n\\nfunction createState(selector, tree, space) {\\n  return {\\n    // State of the query.\\n    rootQuery: (0, _walk.queryToSelectors)((0, _parse.parse)(selector)),\\n    results: [],\\n    // @ts-expect-error assume elements.\\n    scopeElements: tree ? tree.type === 'root' ? tree.children : [tree] : [],\\n    one: false,\\n    shallow: false,\\n    found: false,\\n    // State in the tree.\\n    schema: space === 'svg' ? _propertyInformation.svg : _propertyInformation.html,\\n    language: undefined,\\n    direction: 'ltr',\\n    editableOrEditingHost: false,\\n    typeIndex: undefined,\\n    elementIndex: undefined,\\n    typeCount: undefined,\\n    elementCount: undefined\\n  };\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"createState\",\"selector\",\"tree\",\"space\",\"rootQuery\",\"_walk\",\"queryToSelectors\",\"_parse\",\"parse\",\"results\",\"scopeElements\",\"type\",\"children\",\"one\",\"shallow\",\"found\",\"schema\",\"_propertyInformation\",\"svg\",\"html\",\"language\",\"undefined\",\"direction\",\"editableOrEditingHost\",\"typeIndex\",\"elementIndex\",\"typeCount\",\"elementCount\",\"Object\",\"defineProperty\",\"value\",\"matches\",\"node\",\"state\",\"walk\",\"length\",\"select\",\"selectAll\"]\n}\n"]