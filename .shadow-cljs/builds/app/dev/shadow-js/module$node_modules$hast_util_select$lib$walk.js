["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hast-util-select/lib/walk.js"],"~:js","shadow$provide.module$node_modules$hast_util_select$lib$walk=function(global,require,module,exports){function one(state,currentRules,node,index,parent){var nestResult={directChild:void 0,descendant:void 0,adjacentSibling:void 0,generalSibling:void 0};const exit=(0,_enterState.enterState)(state,node);if(\"element\"===node.type){nestResult=combine(currentRules,state.rootQuery.selectors);currentRules={directChild:void 0,descendant:void 0,adjacentSibling:void 0,generalSibling:void 0};for(var selectorIndex=\n-1;++selectorIndex<nestResult.length;){var ruleSet=nestResult[selectorIndex];if(state.one&&state.found)break;if(state.shallow&&ruleSet.rule.rule)throw Error(\"Expected selector without nesting\");if((0,_test.test)(ruleSet.rule,node,index,parent,state)){var nest=ruleSet.rule.rule;nest?add(currentRules,\"+\"===nest.nestingOperator?\"adjacentSibling\":\"~\"===nest.nestingOperator?\"generalSibling\":\"\\x3e\"===nest.nestingOperator?\"directChild\":\"descendant\",{type:\"ruleSet\",rule:nest}):(state.found=!0,state.results.includes(node)||\nstate.results.push(node))}null===ruleSet.rule.nestingOperator?add(currentRules,\"descendant\",ruleSet):\"~\"===ruleSet.rule.nestingOperator&&add(currentRules,\"generalSibling\",ruleSet)}nestResult=currentRules}if(\"children\"in node&&!state.shallow&&(!state.one||!state.found)){index=combine(nestResult.descendant,nestResult.directChild);parent=-1;currentRules={count:0,types:new Map};for(selectorIndex={count:0,types:new Map};++parent<node.children.length;)count$jscomp$0(currentRules,node.children[parent]);\nfor(parent=-1;++parent<node.children.length;){ruleSet=node.children[parent];nest=\"element\"===ruleSet.type?ruleSet.tagName.toUpperCase():void 0;state.elementIndex=selectorIndex.count;state.typeIndex=nest?selectorIndex.types.get(nest)||0:0;state.elementCount=currentRules.count;state.typeCount=nest?currentRules.types.get(nest):0;if(\"children\"in ruleSet){var fromSibling=combine(index,fromSibling);fromSibling=one(state,fromSibling,node.children[parent],parent,node);fromSibling=combine(fromSibling.generalSibling,\nfromSibling.adjacentSibling)}if(state.one&&state.found)break;count$jscomp$0(selectorIndex,node.children[parent])}}exit();return nestResult}function combine(left,right){return left&&right&&0<left.length&&0<right.length?[...left,...right]:left&&0<left.length?left:right&&0<right.length?right:empty}function add(nest,field,rule){const list=nest[field];list?list.push(rule):nest[field]=[rule]}function count$jscomp$0(counts,node){if(\"element\"===node.type){node=node.tagName.toUpperCase();const count=(counts.types.get(node)||\n0)+1;counts.count++;counts.types.set(node,count)}}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.queryToSelectors=function(query){return null===query?{type:\"selectors\",selectors:[]}:\"ruleSet\"===query.type?{type:\"selectors\",selectors:[query]}:query};exports.walk=function(state,tree){tree&&one(state,[],tree,void 0,void 0)};var _enterState=require(\"module$node_modules$hast_util_select$lib$enter_state\"),_test=require(\"module$node_modules$hast_util_select$lib$test\");const empty=[]}","~:source","shadow$provide[\"module$node_modules$hast_util_select$lib$walk\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.queryToSelectors = queryToSelectors;\nexports.walk = walk;\n\nvar _enterState = require(\"./enter-state.js\");\n\nvar _test = require(\"./test.js\");\n\n/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Selectors} Selectors\n *\n * @typedef Nest\n *   Rule sets by nesting.\n * @property {Array<RuleSet> | undefined} descendant\n *   `a b`\n * @property {Array<RuleSet> | undefined} directChild\n *   `a > b`\n * @property {Array<RuleSet> | undefined} adjacentSibling\n *   `a + b`\n * @property {Array<RuleSet> | undefined} generalSibling\n *   `a ~ b`\n *\n * @typedef Counts\n *   Info on elements in a parent.\n * @property {number} count\n *   Number of elements.\n * @property {Map<string, number>} types\n *   Number of elements by tag name.\n */\n\n/** @type {Array<never>} */\nconst empty = [];\n/**\n * Turn a query into a uniform object.\n *\n * @param {Selectors | RuleSet | null} query\n * @returns {Selectors}\n */\n\nfunction queryToSelectors(query) {\n  if (query === null) {\n    return {\n      type: 'selectors',\n      selectors: []\n    };\n  }\n\n  if (query.type === 'ruleSet') {\n    return {\n      type: 'selectors',\n      selectors: [query]\n    };\n  }\n\n  return query;\n}\n/**\n * Walk a tree.\n *\n * @param {SelectState} state\n * @param {Node | undefined} tree\n */\n\n\nfunction walk(state, tree) {\n  if (tree) {\n    one(state, [], tree, undefined, undefined);\n  }\n}\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Array<RuleSet>} currentRules\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @returns {Nest}\n */\n\n\nfunction one(state, currentRules, node, index, parent) {\n  /** @type {Nest} */\n  let nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  };\n  const exit = (0, _enterState.enterState)(state, node);\n\n  if (node.type === 'element') {\n    nestResult = applySelectors(state, // Try the root rules for this element too.\n    combine(currentRules, state.rootQuery.selectors), node, index, parent);\n  } // If this is a parent, and we want to delve into them, and we haven’t found\n  // our single result yet.\n\n\n  if ('children' in node && !state.shallow && !(state.one && state.found)) {\n    all(state, nestResult, node);\n  }\n\n  exit();\n  return nestResult;\n}\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Nest} nest\n * @param {Parent} node\n * @returns {void}\n */\n\n\nfunction all(state, nest, node) {\n  const fromParent = combine(nest.descendant, nest.directChild);\n  /** @type {Array<RuleSet> | undefined} */\n\n  let fromSibling;\n  let index = -1;\n  /**\n   * Total counts.\n   * @type {Counts}\n   */\n\n  const total = {\n    count: 0,\n    types: new Map()\n  };\n  /**\n   * Counts of previous siblings.\n   * @type {Counts}\n   */\n\n  const before = {\n    count: 0,\n    types: new Map()\n  };\n\n  while (++index < node.children.length) {\n    count(total, node.children[index]);\n  }\n\n  index = -1;\n\n  while (++index < node.children.length) {\n    const child = node.children[index]; // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n\n    const name = child.type === 'element' ? child.tagName.toUpperCase() : undefined; // Before counting further elements:\n\n    state.elementIndex = before.count;\n    state.typeIndex = name ? before.types.get(name) || 0 : 0; // After counting all elements.\n\n    state.elementCount = total.count;\n    state.typeCount = name ? total.types.get(name) : 0; // Only apply if this is a parent, this should be an element, but we check\n    // for parents so that we delve into custom nodes too.\n\n    if ('children' in child) {\n      const forSibling = combine(fromParent, fromSibling);\n      const nest = one(state, forSibling, node.children[index], index, node);\n      fromSibling = combine(nest.generalSibling, nest.adjacentSibling);\n    } // We found one thing, and one is enough.\n\n\n    if (state.one && state.found) {\n      break;\n    }\n\n    count(before, node.children[index]);\n  }\n}\n/**\n * Apply selectors to an element.\n *\n * @param {SelectState} state\n *   Current state.\n * @param {Array<RuleSet>} rules\n *   Rules to apply.\n * @param {Element} node\n *   Element to apply rules to.\n * @param {number | undefined} index\n *   Index of node in parent.\n * @param {Parent | undefined} parent\n *   Parent of node.\n * @returns {Nest}\n *   Further rules.\n */\n\n\nfunction applySelectors(state, rules, node, index, parent) {\n  /** @type {Nest} */\n  const nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  };\n  let selectorIndex = -1;\n\n  while (++selectorIndex < rules.length) {\n    const ruleSet = rules[selectorIndex]; // We found one thing, and one is enough.\n\n    if (state.one && state.found) {\n      break;\n    } // When shallow, we don’t allow nested rules.\n    // Idea: we could allow a stack of parents?\n    // Might get quite complex though.\n\n\n    if (state.shallow && ruleSet.rule.rule) {\n      throw new Error('Expected selector without nesting');\n    } // If this rule matches:\n\n\n    if ((0, _test.test)(ruleSet.rule, node, index, parent, state)) {\n      const nest = ruleSet.rule.rule; // Are there more?\n\n      if (nest) {\n        /** @type {RuleSet} */\n        const rule = {\n          type: 'ruleSet',\n          rule: nest\n        };\n        /** @type {keyof Nest} */\n\n        const label = nest.nestingOperator === '+' ? 'adjacentSibling' : nest.nestingOperator === '~' ? 'generalSibling' : nest.nestingOperator === '>' ? 'directChild' : 'descendant';\n        add(nestResult, label, rule);\n      } else {\n        // We have a match!\n        state.found = true;\n\n        if (!state.results.includes(node)) {\n          state.results.push(node);\n        }\n      }\n    } // Descendant.\n\n\n    if (ruleSet.rule.nestingOperator === null) {\n      add(nestResult, 'descendant', ruleSet);\n    } // Adjacent.\n    else if (ruleSet.rule.nestingOperator === '~') {\n      add(nestResult, 'generalSibling', ruleSet);\n    } // Drop top-level nesting (`undefined`), direct child (`>`), adjacent sibling (`+`).\n\n  }\n\n  return nestResult;\n}\n/**\n * Combine two lists, if needed.\n *\n * This is optimized to create as few lists as possible.\n *\n * @param {Array<RuleSet> | undefined} left\n * @param {Array<RuleSet> | undefined} right\n * @returns {Array<RuleSet>}\n */\n\n\nfunction combine(left, right) {\n  return left && right && left.length > 0 && right.length > 0 ? [...left, ...right] : left && left.length > 0 ? left : right && right.length > 0 ? right : empty;\n}\n/**\n * Add a rule to a nesting map.\n *\n * @param {Nest} nest\n * @param {keyof Nest} field\n * @param {RuleSet} rule\n */\n\n\nfunction add(nest, field, rule) {\n  const list = nest[field];\n\n  if (list) {\n    list.push(rule);\n  } else {\n    nest[field] = [rule];\n  }\n}\n/**\n * Count a node.\n *\n * @param {Counts} counts\n *   Counts.\n * @param {Node} node\n *   Node (we’re looking for elements).\n * @returns {void}\n *   Nothing.\n */\n\n\nfunction count(counts, node) {\n  if (node.type === 'element') {\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name = node.tagName.toUpperCase();\n    const count = (counts.types.get(name) || 0) + 1;\n    counts.count++;\n    counts.types.set(name, count);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$hast_util_select$lib$test","~$module$node_modules$hast_util_select$lib$enter_state"]],"~:properties",["^5",["generalSibling","elementIndex","rule","descendant","typeCount","found","__esModule","types","count","selectors","typeIndex","elementCount","value","directChild","walk","type","queryToSelectors","adjacentSibling"]],"~:compiled-at",1676841365499,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hast_util_select$lib$walk.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/hast-util-select/lib/walk.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hast_util_select$lib$walk\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.queryToSelectors = queryToSelectors;\\nexports.walk = walk;\\n\\nvar _enterState = require(\\\"./enter-state.js\\\");\\n\\nvar _test = require(\\\"./test.js\\\");\\n\\n/**\\n * @typedef {import('./types.js').Node} Node\\n * @typedef {import('./types.js').Element} Element\\n * @typedef {import('./types.js').Parent} Parent\\n * @typedef {import('./types.js').RuleSet} RuleSet\\n * @typedef {import('./types.js').SelectState} SelectState\\n * @typedef {import('./types.js').Selectors} Selectors\\n *\\n * @typedef Nest\\n *   Rule sets by nesting.\\n * @property {Array<RuleSet> | undefined} descendant\\n *   `a b`\\n * @property {Array<RuleSet> | undefined} directChild\\n *   `a > b`\\n * @property {Array<RuleSet> | undefined} adjacentSibling\\n *   `a + b`\\n * @property {Array<RuleSet> | undefined} generalSibling\\n *   `a ~ b`\\n *\\n * @typedef Counts\\n *   Info on elements in a parent.\\n * @property {number} count\\n *   Number of elements.\\n * @property {Map<string, number>} types\\n *   Number of elements by tag name.\\n */\\n\\n/** @type {Array<never>} */\\nconst empty = [];\\n/**\\n * Turn a query into a uniform object.\\n *\\n * @param {Selectors | RuleSet | null} query\\n * @returns {Selectors}\\n */\\n\\nfunction queryToSelectors(query) {\\n  if (query === null) {\\n    return {\\n      type: 'selectors',\\n      selectors: []\\n    };\\n  }\\n\\n  if (query.type === 'ruleSet') {\\n    return {\\n      type: 'selectors',\\n      selectors: [query]\\n    };\\n  }\\n\\n  return query;\\n}\\n/**\\n * Walk a tree.\\n *\\n * @param {SelectState} state\\n * @param {Node | undefined} tree\\n */\\n\\n\\nfunction walk(state, tree) {\\n  if (tree) {\\n    one(state, [], tree, undefined, undefined);\\n  }\\n}\\n/**\\n * Check a node.\\n *\\n * @param {SelectState} state\\n * @param {Array<RuleSet>} currentRules\\n * @param {Node} node\\n * @param {number | undefined} index\\n * @param {Parent | undefined} parent\\n * @returns {Nest}\\n */\\n\\n\\nfunction one(state, currentRules, node, index, parent) {\\n  /** @type {Nest} */\\n  let nestResult = {\\n    directChild: undefined,\\n    descendant: undefined,\\n    adjacentSibling: undefined,\\n    generalSibling: undefined\\n  };\\n  const exit = (0, _enterState.enterState)(state, node);\\n\\n  if (node.type === 'element') {\\n    nestResult = applySelectors(state, // Try the root rules for this element too.\\n    combine(currentRules, state.rootQuery.selectors), node, index, parent);\\n  } // If this is a parent, and we want to delve into them, and we haven\\u2019t found\\n  // our single result yet.\\n\\n\\n  if ('children' in node && !state.shallow && !(state.one && state.found)) {\\n    all(state, nestResult, node);\\n  }\\n\\n  exit();\\n  return nestResult;\\n}\\n/**\\n * Check a node.\\n *\\n * @param {SelectState} state\\n * @param {Nest} nest\\n * @param {Parent} node\\n * @returns {void}\\n */\\n\\n\\nfunction all(state, nest, node) {\\n  const fromParent = combine(nest.descendant, nest.directChild);\\n  /** @type {Array<RuleSet> | undefined} */\\n\\n  let fromSibling;\\n  let index = -1;\\n  /**\\n   * Total counts.\\n   * @type {Counts}\\n   */\\n\\n  const total = {\\n    count: 0,\\n    types: new Map()\\n  };\\n  /**\\n   * Counts of previous siblings.\\n   * @type {Counts}\\n   */\\n\\n  const before = {\\n    count: 0,\\n    types: new Map()\\n  };\\n\\n  while (++index < node.children.length) {\\n    count(total, node.children[index]);\\n  }\\n\\n  index = -1;\\n\\n  while (++index < node.children.length) {\\n    const child = node.children[index]; // Uppercase to prevent prototype polution, injecting `constructor` or so.\\n    // Normalize because HTML is insensitive.\\n\\n    const name = child.type === 'element' ? child.tagName.toUpperCase() : undefined; // Before counting further elements:\\n\\n    state.elementIndex = before.count;\\n    state.typeIndex = name ? before.types.get(name) || 0 : 0; // After counting all elements.\\n\\n    state.elementCount = total.count;\\n    state.typeCount = name ? total.types.get(name) : 0; // Only apply if this is a parent, this should be an element, but we check\\n    // for parents so that we delve into custom nodes too.\\n\\n    if ('children' in child) {\\n      const forSibling = combine(fromParent, fromSibling);\\n      const nest = one(state, forSibling, node.children[index], index, node);\\n      fromSibling = combine(nest.generalSibling, nest.adjacentSibling);\\n    } // We found one thing, and one is enough.\\n\\n\\n    if (state.one && state.found) {\\n      break;\\n    }\\n\\n    count(before, node.children[index]);\\n  }\\n}\\n/**\\n * Apply selectors to an element.\\n *\\n * @param {SelectState} state\\n *   Current state.\\n * @param {Array<RuleSet>} rules\\n *   Rules to apply.\\n * @param {Element} node\\n *   Element to apply rules to.\\n * @param {number | undefined} index\\n *   Index of node in parent.\\n * @param {Parent | undefined} parent\\n *   Parent of node.\\n * @returns {Nest}\\n *   Further rules.\\n */\\n\\n\\nfunction applySelectors(state, rules, node, index, parent) {\\n  /** @type {Nest} */\\n  const nestResult = {\\n    directChild: undefined,\\n    descendant: undefined,\\n    adjacentSibling: undefined,\\n    generalSibling: undefined\\n  };\\n  let selectorIndex = -1;\\n\\n  while (++selectorIndex < rules.length) {\\n    const ruleSet = rules[selectorIndex]; // We found one thing, and one is enough.\\n\\n    if (state.one && state.found) {\\n      break;\\n    } // When shallow, we don\\u2019t allow nested rules.\\n    // Idea: we could allow a stack of parents?\\n    // Might get quite complex though.\\n\\n\\n    if (state.shallow && ruleSet.rule.rule) {\\n      throw new Error('Expected selector without nesting');\\n    } // If this rule matches:\\n\\n\\n    if ((0, _test.test)(ruleSet.rule, node, index, parent, state)) {\\n      const nest = ruleSet.rule.rule; // Are there more?\\n\\n      if (nest) {\\n        /** @type {RuleSet} */\\n        const rule = {\\n          type: 'ruleSet',\\n          rule: nest\\n        };\\n        /** @type {keyof Nest} */\\n\\n        const label = nest.nestingOperator === '+' ? 'adjacentSibling' : nest.nestingOperator === '~' ? 'generalSibling' : nest.nestingOperator === '>' ? 'directChild' : 'descendant';\\n        add(nestResult, label, rule);\\n      } else {\\n        // We have a match!\\n        state.found = true;\\n\\n        if (!state.results.includes(node)) {\\n          state.results.push(node);\\n        }\\n      }\\n    } // Descendant.\\n\\n\\n    if (ruleSet.rule.nestingOperator === null) {\\n      add(nestResult, 'descendant', ruleSet);\\n    } // Adjacent.\\n    else if (ruleSet.rule.nestingOperator === '~') {\\n      add(nestResult, 'generalSibling', ruleSet);\\n    } // Drop top-level nesting (`undefined`), direct child (`>`), adjacent sibling (`+`).\\n\\n  }\\n\\n  return nestResult;\\n}\\n/**\\n * Combine two lists, if needed.\\n *\\n * This is optimized to create as few lists as possible.\\n *\\n * @param {Array<RuleSet> | undefined} left\\n * @param {Array<RuleSet> | undefined} right\\n * @returns {Array<RuleSet>}\\n */\\n\\n\\nfunction combine(left, right) {\\n  return left && right && left.length > 0 && right.length > 0 ? [...left, ...right] : left && left.length > 0 ? left : right && right.length > 0 ? right : empty;\\n}\\n/**\\n * Add a rule to a nesting map.\\n *\\n * @param {Nest} nest\\n * @param {keyof Nest} field\\n * @param {RuleSet} rule\\n */\\n\\n\\nfunction add(nest, field, rule) {\\n  const list = nest[field];\\n\\n  if (list) {\\n    list.push(rule);\\n  } else {\\n    nest[field] = [rule];\\n  }\\n}\\n/**\\n * Count a node.\\n *\\n * @param {Counts} counts\\n *   Counts.\\n * @param {Node} node\\n *   Node (we\\u2019re looking for elements).\\n * @returns {void}\\n *   Nothing.\\n */\\n\\n\\nfunction count(counts, node) {\\n  if (node.type === 'element') {\\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\\n    // Normalize because HTML is insensitive.\\n    const name = node.tagName.toUpperCase();\\n    const count = (counts.types.get(name) || 0) + 1;\\n    counts.count++;\\n    counts.types.set(name, count);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"one\",\"state\",\"currentRules\",\"node\",\"index\",\"parent\",\"nestResult\",\"directChild\",\"undefined\",\"descendant\",\"adjacentSibling\",\"generalSibling\",\"exit\",\"_enterState\",\"enterState\",\"type\",\"combine\",\"rootQuery\",\"selectors\",\"selectorIndex\",\"rules\",\"length\",\"ruleSet\",\"found\",\"shallow\",\"rule\",\"Error\",\"_test\",\"test\",\"nest\",\"add\",\"label\",\"nestingOperator\",\"results\",\"includes\",\"push\",\"fromParent\",\"total\",\"count\",\"types\",\"Map\",\"before\",\"children\",\"child\",\"name\",\"tagName\",\"toUpperCase\",\"elementIndex\",\"typeIndex\",\"get\",\"elementCount\",\"typeCount\",\"forSibling\",\"fromSibling\",\"left\",\"right\",\"empty\",\"field\",\"list\",\"counts\",\"set\",\"Object\",\"defineProperty\",\"value\",\"queryToSelectors\",\"query\",\"walk\",\"tree\"]\n}\n"]