["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-core-commonmark/lib/code-fenced.js"],"~:js","shadow$provide.module$node_modules$micromark_core_commonmark$lib$code_fenced=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.codeFenced=void 0;var _micromarkFactorySpace=require(\"module$node_modules$micromark_factory_space$index\"),_micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\");exports.codeFenced={name:\"codeFenced\",tokenize:function(effects$jscomp$0,ok$jscomp$0,nok$jscomp$0){function sequenceOpen(code){if(code===\nmarker)return effects$jscomp$0.consume(code),sizeOpen++,sequenceOpen;effects$jscomp$0.exit(\"codeFencedFenceSequence\");return 3>sizeOpen?nok$jscomp$0(code):(0,_micromarkFactorySpace.factorySpace)(effects$jscomp$0,infoOpen,\"whitespace\")(code)}function infoOpen(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return openAfter(code);effects$jscomp$0.enter(\"codeFencedFenceInfo\");effects$jscomp$0.enter(\"chunkString\",{contentType:\"string\"});return info(code)}function info(code){if(null===\ncode||(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code))return effects$jscomp$0.exit(\"chunkString\"),effects$jscomp$0.exit(\"codeFencedFenceInfo\"),(0,_micromarkFactorySpace.factorySpace)(effects$jscomp$0,infoAfter,\"whitespace\")(code);if(96===code&&code===marker)return nok$jscomp$0(code);effects$jscomp$0.consume(code);return info}function infoAfter(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return openAfter(code);effects$jscomp$0.enter(\"codeFencedFenceMeta\");\neffects$jscomp$0.enter(\"chunkString\",{contentType:\"string\"});return meta(code)}function meta(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects$jscomp$0.exit(\"chunkString\"),effects$jscomp$0.exit(\"codeFencedFenceMeta\"),openAfter(code);if(96===code&&code===marker)return nok$jscomp$0(code);effects$jscomp$0.consume(code);return meta}function openAfter(code){effects$jscomp$0.exit(\"codeFencedFence\");return self$jscomp$0.interrupt?ok$jscomp$0(code):contentStart(code)}\nfunction contentStart(code){if(null===code)return after(code);if((0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects$jscomp$0.attempt(nonLazyLine,effects$jscomp$0.attempt(closingFenceConstruct,after,initialPrefix?(0,_micromarkFactorySpace.factorySpace)(effects$jscomp$0,contentStart,\"linePrefix\",initialPrefix+1):contentStart),after)(code);effects$jscomp$0.enter(\"codeFlowValue\");return contentContinue(code)}function contentContinue(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects$jscomp$0.exit(\"codeFlowValue\"),\ncontentStart(code);effects$jscomp$0.consume(code);return contentContinue}function after(code){effects$jscomp$0.exit(\"codeFenced\");return ok$jscomp$0(code)}const self$jscomp$0=this,closingFenceConstruct={tokenize:function(effects,ok,nok){function closingSequence(code){if(code===marker)return effects.consume(code),size++,closingSequence;if(size<sizeOpen)return nok(code);effects.exit(\"codeFencedFenceSequence\");return(0,_micromarkFactorySpace.factorySpace)(effects,closingSequenceEnd,\"whitespace\")(code)}\nfunction closingSequenceEnd(code){return null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code)?(effects.exit(\"codeFencedFence\"),ok(code)):nok(code)}let size=0;return(0,_micromarkFactorySpace.factorySpace)(effects,function(code){effects.enter(\"codeFencedFence\");effects.enter(\"codeFencedFenceSequence\");return closingSequence(code)},\"linePrefix\",this.parser.constructs.disable.null.includes(\"codeIndented\")?void 0:4)},partial:!0},nonLazyLine={tokenize:function(effects,ok,nok){function lineStart(code){return self.parser.lazy[self.now().line]?\nnok(code):ok(code)}const self=this;return function(code){effects.enter(\"lineEnding\");effects.consume(code);effects.exit(\"lineEnding\");return lineStart}},partial:!0},tail=this.events[this.events.length-1],initialPrefix=tail&&\"linePrefix\"===tail[1].type?tail[2].sliceSerialize(tail[1],!0).length:0;let sizeOpen=0,marker;return function(code){effects$jscomp$0.enter(\"codeFenced\");effects$jscomp$0.enter(\"codeFencedFence\");effects$jscomp$0.enter(\"codeFencedFenceSequence\");marker=code;return sequenceOpen(code)}},\nconcrete:!0}}","~:source","shadow$provide[\"module$node_modules$micromark_core_commonmark$lib$code_fenced\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.codeFenced = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/** @type {Construct} */\nconst codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n};\n/** @type {Tokenizer} */\n\nexports.codeFenced = codeFenced;\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this;\n  /** @type {Construct} */\n\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  };\n  /** @type {Construct} */\n\n  const nonLazyLine = {\n    tokenize: tokenizeNonLazyLine,\n    partial: true\n  };\n  const tail = this.events[this.events.length - 1];\n  const initialPrefix = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  /** @type {NonNullable<Code>} */\n\n  let marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeFenced');\n    effects.enter('codeFencedFence');\n    effects.enter('codeFencedFenceSequence');\n    marker = code;\n    return sequenceOpen(code);\n  }\n  /** @type {State} */\n\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n\n    effects.exit('codeFencedFenceSequence');\n    return sizeOpen < 3 ? nok(code) : (0, _micromarkFactorySpace.factorySpace)(effects, infoOpen, 'whitespace')(code);\n  }\n  /** @type {State} */\n\n\n  function infoOpen(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return openAfter(code);\n    }\n\n    effects.enter('codeFencedFenceInfo');\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return info(code);\n  }\n  /** @type {State} */\n\n\n  function info(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      effects.exit('chunkString');\n      effects.exit('codeFencedFenceInfo');\n      return (0, _micromarkFactorySpace.factorySpace)(effects, infoAfter, 'whitespace')(code);\n    }\n\n    if (code === 96 && code === marker) return nok(code);\n    effects.consume(code);\n    return info;\n  }\n  /** @type {State} */\n\n\n  function infoAfter(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return openAfter(code);\n    }\n\n    effects.enter('codeFencedFenceMeta');\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return meta(code);\n  }\n  /** @type {State} */\n\n\n  function meta(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('chunkString');\n      effects.exit('codeFencedFenceMeta');\n      return openAfter(code);\n    }\n\n    if (code === 96 && code === marker) return nok(code);\n    effects.consume(code);\n    return meta;\n  }\n  /** @type {State} */\n\n\n  function openAfter(code) {\n    effects.exit('codeFencedFence');\n    return self.interrupt ? ok(code) : contentStart(code);\n  }\n  /** @type {State} */\n\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return effects.attempt(nonLazyLine, effects.attempt(closingFenceConstruct, after, initialPrefix ? (0, _micromarkFactorySpace.factorySpace)(effects, contentStart, 'linePrefix', initialPrefix + 1) : contentStart), after)(code);\n    }\n\n    effects.enter('codeFlowValue');\n    return contentContinue(code);\n  }\n  /** @type {State} */\n\n\n  function contentContinue(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('codeFlowValue');\n      return contentStart(code);\n    }\n\n    effects.consume(code);\n    return contentContinue;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    effects.exit('codeFenced');\n    return ok(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    const self = this;\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return lineStart;\n    }\n    /** @type {State} */\n\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n    }\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    return (0, _micromarkFactorySpace.factorySpace)(effects, closingSequenceStart, 'linePrefix', this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n    /** @type {State} */\n\n    function closingSequenceStart(code) {\n      effects.enter('codeFencedFence');\n      effects.enter('codeFencedFenceSequence');\n      return closingSequence(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      }\n\n      if (size < sizeOpen) return nok(code);\n      effects.exit('codeFencedFenceSequence');\n      return (0, _micromarkFactorySpace.factorySpace)(effects, closingSequenceEnd, 'whitespace')(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequenceEnd(code) {\n      if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n        effects.exit('codeFencedFence');\n        return ok(code);\n      }\n\n      return nok(code);\n    }\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js","~$module$node_modules$micromark_factory_space$index"]],"~:properties",["^5",["partial","tokenize","concrete","__esModule","name","value","codeFenced","contentType"]],"~:compiled-at",1676665867280,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_core_commonmark$lib$code_fenced.js\",\n\"lineCount\":9,\n\"mappings\":\"AAAAA,cAAA,CAAA,6DAAA,CAAkF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG1HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,UAAR,CAAqB,IAAK,EAE1B,KAAIC,uBAAyBP,OAAA,CAAQ,mDAAR,CAA7B,CAEIQ,wBAA0BR,OAAA,CAAQ,oDAAR,CAiB9BE,QAAQI,CAAAA,UAAR,CAPmBA,CACjBG,KAAM,YADWH,CAEjBI,SAOFC,QAA2B,CAACC,gBAAD,CAAUC,WAAV,CAAcC,YAAd,CAAmB,CAiC5CC,QAASA,aAAY,CAACC,IAAD,CAAO,CAC1B,GAAIA,IAAJ;AAAaC,MAAb,CAGE,MAFAL,iBAAQM,CAAAA,OAAR,CAAgBF,IAAhB,CAEOD,CADPI,QAAA,EACOJ,CAAAA,YAGTH,iBAAQQ,CAAAA,IAAR,CAAa,yBAAb,CACA,OAAkB,EAAX,CAAAD,QAAA,CAAeL,YAAA,CAAIE,IAAJ,CAAf,CAA2B,GAAIT,sBAAuBc,CAAAA,YAA3B,EAAyCT,gBAAzC,CAAkDU,QAAlD,CAA4D,YAA5D,CAAA,CAA0EN,IAA1E,CARR,CAa5BM,QAASA,SAAQ,CAACN,IAAD,CAAO,CACtB,GAAa,IAAb,GAAIA,IAAJ,EAAqB,GAAIR,uBAAwBe,CAAAA,kBAA5B,EAAgDP,IAAhD,CAArB,CACE,MAAOQ,UAAA,CAAUR,IAAV,CAGTJ,iBAAQa,CAAAA,KAAR,CAAc,qBAAd,CACAb,iBAAQa,CAAAA,KAAR,CAAc,aAAd,CAA6B,CAC3BC,YAAa,QADc,CAA7B,CAGA,OAAOC,KAAA,CAAKX,IAAL,CATe,CAcxBW,QAASA,KAAI,CAACX,IAAD,CAAO,CAClB,GAAa,IAAb;AAAIA,IAAJ,EAAqB,GAAIR,uBAAwBoB,CAAAA,yBAA5B,EAAuDZ,IAAvD,CAArB,CAGE,MAFAJ,iBAAQQ,CAAAA,IAAR,CAAa,aAAb,CAEO,CADPR,gBAAQQ,CAAAA,IAAR,CAAa,qBAAb,CACO,CAAA,GAAIb,sBAAuBc,CAAAA,YAA3B,EAAyCT,gBAAzC,CAAkDiB,SAAlD,CAA6D,YAA7D,CAAA,CAA2Eb,IAA3E,CAGT,IAAa,EAAb,GAAIA,IAAJ,EAAmBA,IAAnB,GAA4BC,MAA5B,CAAoC,MAAOH,aAAA,CAAIE,IAAJ,CAC3CJ,iBAAQM,CAAAA,OAAR,CAAgBF,IAAhB,CACA,OAAOW,KATW,CAcpBE,QAASA,UAAS,CAACb,IAAD,CAAO,CACvB,GAAa,IAAb,GAAIA,IAAJ,EAAqB,GAAIR,uBAAwBe,CAAAA,kBAA5B,EAAgDP,IAAhD,CAArB,CACE,MAAOQ,UAAA,CAAUR,IAAV,CAGTJ,iBAAQa,CAAAA,KAAR,CAAc,qBAAd,CACAb;gBAAQa,CAAAA,KAAR,CAAc,aAAd,CAA6B,CAC3BC,YAAa,QADc,CAA7B,CAGA,OAAOI,KAAA,CAAKd,IAAL,CATgB,CAczBc,QAASA,KAAI,CAACd,IAAD,CAAO,CAClB,GAAa,IAAb,GAAIA,IAAJ,EAAqB,GAAIR,uBAAwBe,CAAAA,kBAA5B,EAAgDP,IAAhD,CAArB,CAGE,MAFAJ,iBAAQQ,CAAAA,IAAR,CAAa,aAAb,CAEO,CADPR,gBAAQQ,CAAAA,IAAR,CAAa,qBAAb,CACO,CAAAI,SAAA,CAAUR,IAAV,CAGT,IAAa,EAAb,GAAIA,IAAJ,EAAmBA,IAAnB,GAA4BC,MAA5B,CAAoC,MAAOH,aAAA,CAAIE,IAAJ,CAC3CJ,iBAAQM,CAAAA,OAAR,CAAgBF,IAAhB,CACA,OAAOc,KATW,CAcpBN,QAASA,UAAS,CAACR,IAAD,CAAO,CACvBJ,gBAAQQ,CAAAA,IAAR,CAAa,iBAAb,CACA,OAAOW,cAAKC,CAAAA,SAAL,CAAiBnB,WAAA,CAAGG,IAAH,CAAjB,CAA4BiB,YAAA,CAAajB,IAAb,CAFZ;AAOzBiB,QAASA,aAAY,CAACjB,IAAD,CAAO,CAC1B,GAAa,IAAb,GAAIA,IAAJ,CACE,MAAOkB,MAAA,CAAMlB,IAAN,CAGT,IAAI,GAAIR,uBAAwBe,CAAAA,kBAA5B,EAAgDP,IAAhD,CAAJ,CACE,MAAOJ,iBAAQuB,CAAAA,OAAR,CAAgBC,WAAhB,CAA6BxB,gBAAQuB,CAAAA,OAAR,CAAgBE,qBAAhB,CAAuCH,KAAvC,CAA8CI,aAAA,CAAgB,GAAI/B,sBAAuBc,CAAAA,YAA3B,EAAyCT,gBAAzC,CAAkDqB,YAAlD,CAAgE,YAAhE,CAA8EK,aAA9E,CAA8F,CAA9F,CAAhB,CAAmHL,YAAjK,CAA7B,CAA6MC,KAA7M,CAAA,CAAoNlB,IAApN,CAGTJ,iBAAQa,CAAAA,KAAR,CAAc,eAAd,CACA,OAAOc,gBAAA,CAAgBvB,IAAhB,CAVmB,CAe5BuB,QAASA,gBAAe,CAACvB,IAAD,CAAO,CAC7B,GAAa,IAAb,GAAIA,IAAJ,EAAqB,GAAIR,uBAAwBe,CAAAA,kBAA5B,EAAgDP,IAAhD,CAArB,CAEE,MADAJ,iBAAQQ,CAAAA,IAAR,CAAa,eAAb,CACO;AAAAa,YAAA,CAAajB,IAAb,CAGTJ,iBAAQM,CAAAA,OAAR,CAAgBF,IAAhB,CACA,OAAOuB,gBAPsB,CAY/BL,QAASA,MAAK,CAAClB,IAAD,CAAO,CACnBJ,gBAAQQ,CAAAA,IAAR,CAAa,YAAb,CACA,OAAOP,YAAA,CAAGG,IAAH,CAFY,CAvIrB,MAAMe,cAAO,IAAb,CAGMM,sBAAwB,CAC5B3B,SA+JF8B,QAA6B,CAAC5B,OAAD,CAAUC,EAAV,CAAcC,GAAd,CAAmB,CAa9C2B,QAASA,gBAAe,CAACzB,IAAD,CAAO,CAC7B,GAAIA,IAAJ,GAAaC,MAAb,CAGE,MAFAL,QAAQM,CAAAA,OAAR,CAAgBF,IAAhB,CAEOyB,CADPC,IAAA,EACOD,CAAAA,eAGT,IAAIC,IAAJ,CAAWvB,QAAX,CAAqB,MAAOL,IAAA,CAAIE,IAAJ,CAC5BJ,QAAQQ,CAAAA,IAAR,CAAa,yBAAb,CACA,OAAO,GAAIb,sBAAuBc,CAAAA,YAA3B,EAAyCT,OAAzC,CAAkD+B,kBAAlD,CAAsE,YAAtE,CAAA,CAAoF3B,IAApF,CATsB;AAc/B2B,QAASA,mBAAkB,CAAC3B,IAAD,CAAO,CAChC,MAAa,KAAb,GAAIA,IAAJ,EAAqB,GAAIR,uBAAwBe,CAAAA,kBAA5B,EAAgDP,IAAhD,CAArB,EACEJ,OAAQQ,CAAAA,IAAR,CAAa,iBAAb,CACO,CAAAP,EAAA,CAAGG,IAAH,CAFT,EAKOF,GAAA,CAAIE,IAAJ,CANyB,CA1BlC,IAAI0B,KAAO,CACX,OAAO,GAAInC,sBAAuBc,CAAAA,YAA3B,EAAyCT,OAAzC,CAGPgC,QAA6B,CAAC5B,IAAD,CAAO,CAClCJ,OAAQa,CAAAA,KAAR,CAAc,iBAAd,CACAb,QAAQa,CAAAA,KAAR,CAAc,yBAAd,CACA,OAAOgB,gBAAA,CAAgBzB,IAAhB,CAH2B,CAH7B,CAAwE,YAAxE,CAAsF,IAAK6B,CAAAA,MAAOC,CAAAA,UAAWC,CAAAA,OAAQC,CAAAA,IAAKC,CAAAA,QAApC,CAA6C,cAA7C,CAAA,CAA+DC,IAAAA,EAA/D,CAA2E,CAAjK,CAFuC,CAhKlB,CAE5BC,QAAS,CAAA,CAFmB,CAH9B,CASMf,YAAc,CAClB1B,SAoIF0C,QAA4B,CAACxC,OAAD,CAAUC,EAAV,CAAcC,GAAd,CAAmB,CAc7CuC,QAASA,UAAS,CAACrC,IAAD,CAAO,CACvB,MAAOe,KAAKc,CAAAA,MAAOS,CAAAA,IAAZ,CAAiBvB,IAAKwB,CAAAA,GAAL,EAAWC,CAAAA,IAA5B,CAAA;AAAoC1C,GAAA,CAAIE,IAAJ,CAApC,CAAgDH,EAAA,CAAGG,IAAH,CADhC,CAbzB,MAAMe,KAAO,IACb,OAGA0B,SAAc,CAACzC,IAAD,CAAO,CACnBJ,OAAQa,CAAAA,KAAR,CAAc,YAAd,CACAb,QAAQM,CAAAA,OAAR,CAAgBF,IAAhB,CACAJ,QAAQQ,CAAAA,IAAR,CAAa,YAAb,CACA,OAAOiC,UAJY,CALwB,CArI3B,CAElBF,QAAS,CAAA,CAFS,CATpB,CAaMO,KAAO,IAAKC,CAAAA,MAAL,CAAY,IAAKA,CAAAA,MAAOC,CAAAA,MAAxB,CAAiC,CAAjC,CAbb,CAcMtB,cAAgBoB,IAAA,EAAyB,YAAzB,GAAQA,IAAA,CAAK,CAAL,CAAQG,CAAAA,IAAhB,CAAwCH,IAAA,CAAK,CAAL,CAAQI,CAAAA,cAAR,CAAuBJ,IAAA,CAAK,CAAL,CAAvB,CAAgC,CAAA,CAAhC,CAAsCE,CAAAA,MAA9E,CAAuF,CAC7G,KAAIzC,SAAW,CAAf,CAGIF,MACJ,OAGAwC,SAAc,CAACzC,IAAD,CAAO,CACnBJ,gBAAQa,CAAAA,KAAR,CAAc,YAAd,CACAb,iBAAQa,CAAAA,KAAR,CAAc,iBAAd,CACAb,iBAAQa,CAAAA,KAAR,CAAc,yBAAd,CACAR,OAAA,CAASD,IACT,OAAOD,aAAA,CAAaC,IAAb,CALY,CAvBuB,CAT3BV;AAGjByD,SAAU,CAAA,CAHOzD,CApBuG;\",\n\"sources\":[\"node_modules/micromark-core-commonmark/lib/code-fenced.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_core_commonmark$lib$code_fenced\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.codeFenced = void 0;\\n\\nvar _micromarkFactorySpace = require(\\\"micromark-factory-space\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').State} State\\n * @typedef {import('micromark-util-types').Code} Code\\n */\\n\\n/** @type {Construct} */\\nconst codeFenced = {\\n  name: 'codeFenced',\\n  tokenize: tokenizeCodeFenced,\\n  concrete: true\\n};\\n/** @type {Tokenizer} */\\n\\nexports.codeFenced = codeFenced;\\n\\nfunction tokenizeCodeFenced(effects, ok, nok) {\\n  const self = this;\\n  /** @type {Construct} */\\n\\n  const closingFenceConstruct = {\\n    tokenize: tokenizeClosingFence,\\n    partial: true\\n  };\\n  /** @type {Construct} */\\n\\n  const nonLazyLine = {\\n    tokenize: tokenizeNonLazyLine,\\n    partial: true\\n  };\\n  const tail = this.events[this.events.length - 1];\\n  const initialPrefix = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\\n  let sizeOpen = 0;\\n  /** @type {NonNullable<Code>} */\\n\\n  let marker;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('codeFenced');\\n    effects.enter('codeFencedFence');\\n    effects.enter('codeFencedFenceSequence');\\n    marker = code;\\n    return sequenceOpen(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function sequenceOpen(code) {\\n    if (code === marker) {\\n      effects.consume(code);\\n      sizeOpen++;\\n      return sequenceOpen;\\n    }\\n\\n    effects.exit('codeFencedFenceSequence');\\n    return sizeOpen < 3 ? nok(code) : (0, _micromarkFactorySpace.factorySpace)(effects, infoOpen, 'whitespace')(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function infoOpen(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      return openAfter(code);\\n    }\\n\\n    effects.enter('codeFencedFenceInfo');\\n    effects.enter('chunkString', {\\n      contentType: 'string'\\n    });\\n    return info(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function info(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\\n      effects.exit('chunkString');\\n      effects.exit('codeFencedFenceInfo');\\n      return (0, _micromarkFactorySpace.factorySpace)(effects, infoAfter, 'whitespace')(code);\\n    }\\n\\n    if (code === 96 && code === marker) return nok(code);\\n    effects.consume(code);\\n    return info;\\n  }\\n  /** @type {State} */\\n\\n\\n  function infoAfter(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      return openAfter(code);\\n    }\\n\\n    effects.enter('codeFencedFenceMeta');\\n    effects.enter('chunkString', {\\n      contentType: 'string'\\n    });\\n    return meta(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function meta(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.exit('chunkString');\\n      effects.exit('codeFencedFenceMeta');\\n      return openAfter(code);\\n    }\\n\\n    if (code === 96 && code === marker) return nok(code);\\n    effects.consume(code);\\n    return meta;\\n  }\\n  /** @type {State} */\\n\\n\\n  function openAfter(code) {\\n    effects.exit('codeFencedFence');\\n    return self.interrupt ? ok(code) : contentStart(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function contentStart(code) {\\n    if (code === null) {\\n      return after(code);\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      return effects.attempt(nonLazyLine, effects.attempt(closingFenceConstruct, after, initialPrefix ? (0, _micromarkFactorySpace.factorySpace)(effects, contentStart, 'linePrefix', initialPrefix + 1) : contentStart), after)(code);\\n    }\\n\\n    effects.enter('codeFlowValue');\\n    return contentContinue(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function contentContinue(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.exit('codeFlowValue');\\n      return contentStart(code);\\n    }\\n\\n    effects.consume(code);\\n    return contentContinue;\\n  }\\n  /** @type {State} */\\n\\n\\n  function after(code) {\\n    effects.exit('codeFenced');\\n    return ok(code);\\n  }\\n  /** @type {Tokenizer} */\\n\\n\\n  function tokenizeNonLazyLine(effects, ok, nok) {\\n    const self = this;\\n    return start;\\n    /** @type {State} */\\n\\n    function start(code) {\\n      effects.enter('lineEnding');\\n      effects.consume(code);\\n      effects.exit('lineEnding');\\n      return lineStart;\\n    }\\n    /** @type {State} */\\n\\n\\n    function lineStart(code) {\\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\\n    }\\n  }\\n  /** @type {Tokenizer} */\\n\\n\\n  function tokenizeClosingFence(effects, ok, nok) {\\n    let size = 0;\\n    return (0, _micromarkFactorySpace.factorySpace)(effects, closingSequenceStart, 'linePrefix', this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\\n    /** @type {State} */\\n\\n    function closingSequenceStart(code) {\\n      effects.enter('codeFencedFence');\\n      effects.enter('codeFencedFenceSequence');\\n      return closingSequence(code);\\n    }\\n    /** @type {State} */\\n\\n\\n    function closingSequence(code) {\\n      if (code === marker) {\\n        effects.consume(code);\\n        size++;\\n        return closingSequence;\\n      }\\n\\n      if (size < sizeOpen) return nok(code);\\n      effects.exit('codeFencedFenceSequence');\\n      return (0, _micromarkFactorySpace.factorySpace)(effects, closingSequenceEnd, 'whitespace')(code);\\n    }\\n    /** @type {State} */\\n\\n\\n    function closingSequenceEnd(code) {\\n      if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n        effects.exit('codeFencedFence');\\n        return ok(code);\\n      }\\n\\n      return nok(code);\\n    }\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"codeFenced\",\"_micromarkFactorySpace\",\"_micromarkUtilCharacter\",\"name\",\"tokenize\",\"tokenizeCodeFenced\",\"effects\",\"ok\",\"nok\",\"sequenceOpen\",\"code\",\"marker\",\"consume\",\"sizeOpen\",\"exit\",\"factorySpace\",\"infoOpen\",\"markdownLineEnding\",\"openAfter\",\"enter\",\"contentType\",\"info\",\"markdownLineEndingOrSpace\",\"infoAfter\",\"meta\",\"self\",\"interrupt\",\"contentStart\",\"after\",\"attempt\",\"nonLazyLine\",\"closingFenceConstruct\",\"initialPrefix\",\"contentContinue\",\"tokenizeClosingFence\",\"closingSequence\",\"size\",\"closingSequenceEnd\",\"closingSequenceStart\",\"parser\",\"constructs\",\"disable\",\"null\",\"includes\",\"undefined\",\"partial\",\"tokenizeNonLazyLine\",\"lineStart\",\"lazy\",\"now\",\"line\",\"start\",\"tail\",\"events\",\"length\",\"type\",\"sliceSerialize\",\"concrete\"]\n}\n"]