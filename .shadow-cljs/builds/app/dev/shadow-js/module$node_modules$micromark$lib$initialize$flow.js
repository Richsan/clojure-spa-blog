["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark/lib/initialize/flow.js"],"~:js","shadow$provide.module$node_modules$micromark$lib$initialize$flow=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.flow=void 0;var _micromarkCoreCommonmark=require(\"module$node_modules$micromark_core_commonmark$index\"),_micromarkFactorySpace=require(\"module$node_modules$micromark_factory_space$index\");require(\"module$node_modules$micromark_util_character$index\");exports.flow={tokenize:function(effects){function afterConstruct(code){if(null===code)effects.consume(code);\nelse return effects.enter(\"lineEnding\"),effects.consume(code),effects.exit(\"lineEnding\"),self.currentConstruct=void 0,initial}const self=this,initial=effects.attempt(_micromarkCoreCommonmark.blankLine,function(code){if(null===code)effects.consume(code);else return effects.enter(\"lineEndingBlank\"),effects.consume(code),effects.exit(\"lineEndingBlank\"),self.currentConstruct=void 0,initial},effects.attempt(this.parser.constructs.flowInitial,afterConstruct,(0,_micromarkFactorySpace.factorySpace)(effects,\neffects.attempt(this.parser.constructs.flow,afterConstruct,effects.attempt(_micromarkCoreCommonmark.content,afterConstruct)),\"linePrefix\")));return initial}}}","~:source","shadow$provide[\"module$node_modules$micromark$lib$initialize$flow\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flow = void 0;\n\nvar _micromarkCoreCommonmark = require(\"micromark-core-commonmark\");\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').State} State\n */\n\n/** @type {InitialConstruct} */\nconst flow = {\n  tokenize: initializeFlow\n};\n/** @type {Initializer} */\n\nexports.flow = flow;\n\nfunction initializeFlow(effects) {\n  const self = this;\n  const initial = effects.attempt( // Try to parse a blank line.\n  _micromarkCoreCommonmark.blankLine, atBlankEnding, // Try to parse initial flow (essentially, only code).\n  effects.attempt(this.parser.constructs.flowInitial, afterConstruct, (0, _micromarkFactorySpace.factorySpace)(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(_micromarkCoreCommonmark.content, afterConstruct)), 'linePrefix')));\n  return initial;\n  /** @type {State} */\n\n  function atBlankEnding(code) {\n    if (code === null) {\n      effects.consume(code);\n      return;\n    }\n\n    effects.enter('lineEndingBlank');\n    effects.consume(code);\n    effects.exit('lineEndingBlank');\n    self.currentConstruct = undefined;\n    return initial;\n  }\n  /** @type {State} */\n\n\n  function afterConstruct(code) {\n    if (code === null) {\n      effects.consume(code);\n      return;\n    }\n\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    self.currentConstruct = undefined;\n    return initial;\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js","~$module$node_modules$micromark_factory_space$index","~$module$node_modules$micromark_core_commonmark$index"]],"~:properties",["^5",["tokenize","__esModule","value","currentConstruct","flow"]],"~:compiled-at",1676665867298,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark$lib$initialize$flow.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,iDAAA,CAAsE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG9GC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,IAAR,CAAe,IAAK,EAEpB,KAAIC,yBAA2BP,OAAA,CAAQ,qDAAR,CAA/B,CAEIQ,uBAAyBR,OAAA,CAAQ,mDAAR,CAECA,QAAA,CAAQ,oDAAR,CAc9BE,QAAQI,CAAAA,IAAR,CALaA,CACXG,SAMFC,QAAuB,CAACC,OAAD,CAAU,CAuB/BC,QAASA,eAAc,CAACC,IAAD,CAAO,CAC5B,GAAa,IAAb,GAAIA,IAAJ,CACEF,OAAQG,CAAAA,OAAR,CAAgBD,IAAhB,CADF;IASA,OAJAF,QAAQI,CAAAA,KAAR,CAAc,YAAd,CAIOC,CAHPL,OAAQG,CAAAA,OAAR,CAAgBD,IAAhB,CAGOG,CAFPL,OAAQM,CAAAA,IAAR,CAAa,YAAb,CAEOD,CADPE,IAAKC,CAAAA,gBACEH,CADiBI,IAAAA,EACjBJ,CAAAA,OAVqB,CAtB9B,MAAME,KAAO,IAAb,CACMF,QAAUL,OAAQU,CAAAA,OAAR,CAChBd,wBAAyBe,CAAAA,SADT,CAMhBC,QAAsB,CAACV,IAAD,CAAO,CAC3B,GAAa,IAAb,GAAIA,IAAJ,CACEF,OAAQG,CAAAA,OAAR,CAAgBD,IAAhB,CADF,KASA,OAJAF,QAAQI,CAAAA,KAAR,CAAc,iBAAd,CAIOC,CAHPL,OAAQG,CAAAA,OAAR,CAAgBD,IAAhB,CAGOG,CAFPL,OAAQM,CAAAA,IAAR,CAAa,iBAAb,CAEOD,CADPE,IAAKC,CAAAA,gBACEH,CADiBI,IAAAA,EACjBJ,CAAAA,OAVoB,CANb,CAEhBL,OAAQU,CAAAA,OAAR,CAAgB,IAAKG,CAAAA,MAAOC,CAAAA,UAAWC,CAAAA,WAAvC,CAAoDd,cAApD,CAAoE,GAAIJ,sBAAuBmB,CAAAA,YAA3B,EAAyChB,OAAzC;AAAkDA,OAAQU,CAAAA,OAAR,CAAgB,IAAKG,CAAAA,MAAOC,CAAAA,UAAWnB,CAAAA,IAAvC,CAA6CM,cAA7C,CAA6DD,OAAQU,CAAAA,OAAR,CAAgBd,wBAAyBqB,CAAAA,OAAzC,CAAkDhB,cAAlD,CAA7D,CAAlD,CAAmL,YAAnL,CAApE,CAFgB,CAGhB,OAAOI,QALwB,CAPpBV,CArBiG;\",\n\"sources\":[\"node_modules/micromark/lib/initialize/flow.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark$lib$initialize$flow\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.flow = void 0;\\n\\nvar _micromarkCoreCommonmark = require(\\\"micromark-core-commonmark\\\");\\n\\nvar _micromarkFactorySpace = require(\\\"micromark-factory-space\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\\n * @typedef {import('micromark-util-types').Initializer} Initializer\\n * @typedef {import('micromark-util-types').State} State\\n */\\n\\n/** @type {InitialConstruct} */\\nconst flow = {\\n  tokenize: initializeFlow\\n};\\n/** @type {Initializer} */\\n\\nexports.flow = flow;\\n\\nfunction initializeFlow(effects) {\\n  const self = this;\\n  const initial = effects.attempt( // Try to parse a blank line.\\n  _micromarkCoreCommonmark.blankLine, atBlankEnding, // Try to parse initial flow (essentially, only code).\\n  effects.attempt(this.parser.constructs.flowInitial, afterConstruct, (0, _micromarkFactorySpace.factorySpace)(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(_micromarkCoreCommonmark.content, afterConstruct)), 'linePrefix')));\\n  return initial;\\n  /** @type {State} */\\n\\n  function atBlankEnding(code) {\\n    if (code === null) {\\n      effects.consume(code);\\n      return;\\n    }\\n\\n    effects.enter('lineEndingBlank');\\n    effects.consume(code);\\n    effects.exit('lineEndingBlank');\\n    self.currentConstruct = undefined;\\n    return initial;\\n  }\\n  /** @type {State} */\\n\\n\\n  function afterConstruct(code) {\\n    if (code === null) {\\n      effects.consume(code);\\n      return;\\n    }\\n\\n    effects.enter('lineEnding');\\n    effects.consume(code);\\n    effects.exit('lineEnding');\\n    self.currentConstruct = undefined;\\n    return initial;\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"flow\",\"_micromarkCoreCommonmark\",\"_micromarkFactorySpace\",\"tokenize\",\"initializeFlow\",\"effects\",\"afterConstruct\",\"code\",\"consume\",\"enter\",\"initial\",\"exit\",\"self\",\"currentConstruct\",\"undefined\",\"attempt\",\"blankLine\",\"atBlankEnding\",\"parser\",\"constructs\",\"flowInitial\",\"factorySpace\",\"content\"]\n}\n"]