["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/parse5/lib/parser/formatting-element-list.js"],"~:js","shadow$provide.module$node_modules$parse5$lib$parser$formatting_element_list=function(global,require,module,exports){class FormattingElementList{constructor(treeAdapter){this.length=0;this.entries=[];this.treeAdapter=treeAdapter;this.bookmark=null}_getNoahArkConditionCandidates(newElement){const candidates=[];if(3<=this.length){const neAttrsLength=this.treeAdapter.getAttrList(newElement).length,neTagName=this.treeAdapter.getTagName(newElement);newElement=this.treeAdapter.getNamespaceURI(newElement);\nfor(let i=this.length-1;0<=i;i--){var entry=this.entries[i];if(entry.type===FormattingElementList.MARKER_ENTRY)break;entry=entry.element;const elementAttrs=this.treeAdapter.getAttrList(entry);this.treeAdapter.getTagName(entry)===neTagName&&this.treeAdapter.getNamespaceURI(entry)===newElement&&elementAttrs.length===neAttrsLength&&candidates.push({idx:i,attrs:elementAttrs})}}return 3>candidates.length?[]:candidates}_ensureNoahArkCondition(newElement){const candidates=this._getNoahArkConditionCandidates(newElement);\nvar cLength=candidates.length;if(cLength){var neAttrs=this.treeAdapter.getAttrList(newElement);newElement=neAttrs.length;const neAttrsMap=Object.create(null);for(var i=0;i<newElement;i++){var neAttr=neAttrs[i];neAttrsMap[neAttr.name]=neAttr.value}for(neAttrs=0;neAttrs<newElement;neAttrs++)for(i=0;i<cLength;i++)if(neAttr=candidates[i].attrs[neAttrs],neAttrsMap[neAttr.name]!==neAttr.value&&(candidates.splice(i,1),cLength--),3>candidates.length)return;for(--cLength;2<=cLength;cLength--)this.entries.splice(candidates[cLength].idx,\n1),this.length--}}insertMarker(){this.entries.push({type:FormattingElementList.MARKER_ENTRY});this.length++}pushElement(element,token){this._ensureNoahArkCondition(element);this.entries.push({type:FormattingElementList.ELEMENT_ENTRY,element,token});this.length++}insertElementAfterBookmark(element,token){let bookmarkIdx=this.length-1;for(;0<=bookmarkIdx&&this.entries[bookmarkIdx]!==this.bookmark;bookmarkIdx--);this.entries.splice(bookmarkIdx+1,0,{type:FormattingElementList.ELEMENT_ENTRY,element,token});\nthis.length++}removeEntry(entry){for(let i=this.length-1;0<=i;i--)if(this.entries[i]===entry){this.entries.splice(i,1);this.length--;break}}clearToLastMarker(){for(;this.length;){const entry=this.entries.pop();this.length--;if(entry.type===FormattingElementList.MARKER_ENTRY)break}}getElementEntryInScopeWithTagName(tagName){for(let i=this.length-1;0<=i;i--){const entry=this.entries[i];if(entry.type===FormattingElementList.MARKER_ENTRY)break;if(this.treeAdapter.getTagName(entry.element)===tagName)return entry}return null}getElementEntry(element){for(let i=\nthis.length-1;0<=i;i--){const entry=this.entries[i];if(entry.type===FormattingElementList.ELEMENT_ENTRY&&entry.element===element)return entry}return null}}FormattingElementList.MARKER_ENTRY=\"MARKER_ENTRY\";FormattingElementList.ELEMENT_ENTRY=\"ELEMENT_ENTRY\";module.exports=FormattingElementList}","~:source","shadow$provide[\"module$node_modules$parse5$lib$parser$formatting_element_list\"] = function(global,require,module,exports) {\n'use strict';\n\n//Const\nconst NOAH_ARK_CAPACITY = 3;\n\n//List of formatting elements\nclass FormattingElementList {\n    constructor(treeAdapter) {\n        this.length = 0;\n        this.entries = [];\n        this.treeAdapter = treeAdapter;\n        this.bookmark = null;\n    }\n\n    //Noah Ark's condition\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n    //lightweight heuristics without thorough attributes check.\n    _getNoahArkConditionCandidates(newElement) {\n        const candidates = [];\n\n        if (this.length >= NOAH_ARK_CAPACITY) {\n            const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n            const neTagName = this.treeAdapter.getTagName(newElement);\n            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n\n            for (let i = this.length - 1; i >= 0; i--) {\n                const entry = this.entries[i];\n\n                if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                    break;\n                }\n\n                const element = entry.element;\n                const elementAttrs = this.treeAdapter.getAttrList(element);\n\n                const isCandidate =\n                    this.treeAdapter.getTagName(element) === neTagName &&\n                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&\n                    elementAttrs.length === neAttrsLength;\n\n                if (isCandidate) {\n                    candidates.push({ idx: i, attrs: elementAttrs });\n                }\n            }\n        }\n\n        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n    }\n\n    _ensureNoahArkCondition(newElement) {\n        const candidates = this._getNoahArkConditionCandidates(newElement);\n        let cLength = candidates.length;\n\n        if (cLength) {\n            const neAttrs = this.treeAdapter.getAttrList(newElement);\n            const neAttrsLength = neAttrs.length;\n            const neAttrsMap = Object.create(null);\n\n            //NOTE: build attrs map for the new element so we can perform fast lookups\n            for (let i = 0; i < neAttrsLength; i++) {\n                const neAttr = neAttrs[i];\n\n                neAttrsMap[neAttr.name] = neAttr.value;\n            }\n\n            for (let i = 0; i < neAttrsLength; i++) {\n                for (let j = 0; j < cLength; j++) {\n                    const cAttr = candidates[j].attrs[i];\n\n                    if (neAttrsMap[cAttr.name] !== cAttr.value) {\n                        candidates.splice(j, 1);\n                        cLength--;\n                    }\n\n                    if (candidates.length < NOAH_ARK_CAPACITY) {\n                        return;\n                    }\n                }\n            }\n\n            //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n            for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {\n                this.entries.splice(candidates[i].idx, 1);\n                this.length--;\n            }\n        }\n    }\n\n    //Mutations\n    insertMarker() {\n        this.entries.push({ type: FormattingElementList.MARKER_ENTRY });\n        this.length++;\n    }\n\n    pushElement(element, token) {\n        this._ensureNoahArkCondition(element);\n\n        this.entries.push({\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    insertElementAfterBookmark(element, token) {\n        let bookmarkIdx = this.length - 1;\n\n        for (; bookmarkIdx >= 0; bookmarkIdx--) {\n            if (this.entries[bookmarkIdx] === this.bookmark) {\n                break;\n            }\n        }\n\n        this.entries.splice(bookmarkIdx + 1, 0, {\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    removeEntry(entry) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            if (this.entries[i] === entry) {\n                this.entries.splice(i, 1);\n                this.length--;\n                break;\n            }\n        }\n    }\n\n    clearToLastMarker() {\n        while (this.length) {\n            const entry = this.entries.pop();\n\n            this.length--;\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                break;\n            }\n        }\n    }\n\n    //Search\n    getElementEntryInScopeWithTagName(tagName) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                return null;\n            }\n\n            if (this.treeAdapter.getTagName(entry.element) === tagName) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n\n    getElementEntry(element) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n}\n\n//Entry types\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\n\nmodule.exports = FormattingElementList;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["attrs","token","ELEMENT_ENTRY","MARKER_ENTRY","element","bookmark","length","entries","type","idx","treeAdapter"]],"~:compiled-at",1676667638408,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$parse5$lib$parser$formatting_element_list.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/parse5/lib/parser/formatting-element-list.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$parse5$lib$parser$formatting_element_list\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\n//Const\\nconst NOAH_ARK_CAPACITY = 3;\\n\\n//List of formatting elements\\nclass FormattingElementList {\\n    constructor(treeAdapter) {\\n        this.length = 0;\\n        this.entries = [];\\n        this.treeAdapter = treeAdapter;\\n        this.bookmark = null;\\n    }\\n\\n    //Noah Ark's condition\\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\\n    //lightweight heuristics without thorough attributes check.\\n    _getNoahArkConditionCandidates(newElement) {\\n        const candidates = [];\\n\\n        if (this.length >= NOAH_ARK_CAPACITY) {\\n            const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\\n            const neTagName = this.treeAdapter.getTagName(newElement);\\n            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\\n\\n            for (let i = this.length - 1; i >= 0; i--) {\\n                const entry = this.entries[i];\\n\\n                if (entry.type === FormattingElementList.MARKER_ENTRY) {\\n                    break;\\n                }\\n\\n                const element = entry.element;\\n                const elementAttrs = this.treeAdapter.getAttrList(element);\\n\\n                const isCandidate =\\n                    this.treeAdapter.getTagName(element) === neTagName &&\\n                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&\\n                    elementAttrs.length === neAttrsLength;\\n\\n                if (isCandidate) {\\n                    candidates.push({ idx: i, attrs: elementAttrs });\\n                }\\n            }\\n        }\\n\\n        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\\n    }\\n\\n    _ensureNoahArkCondition(newElement) {\\n        const candidates = this._getNoahArkConditionCandidates(newElement);\\n        let cLength = candidates.length;\\n\\n        if (cLength) {\\n            const neAttrs = this.treeAdapter.getAttrList(newElement);\\n            const neAttrsLength = neAttrs.length;\\n            const neAttrsMap = Object.create(null);\\n\\n            //NOTE: build attrs map for the new element so we can perform fast lookups\\n            for (let i = 0; i < neAttrsLength; i++) {\\n                const neAttr = neAttrs[i];\\n\\n                neAttrsMap[neAttr.name] = neAttr.value;\\n            }\\n\\n            for (let i = 0; i < neAttrsLength; i++) {\\n                for (let j = 0; j < cLength; j++) {\\n                    const cAttr = candidates[j].attrs[i];\\n\\n                    if (neAttrsMap[cAttr.name] !== cAttr.value) {\\n                        candidates.splice(j, 1);\\n                        cLength--;\\n                    }\\n\\n                    if (candidates.length < NOAH_ARK_CAPACITY) {\\n                        return;\\n                    }\\n                }\\n            }\\n\\n            //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\\n            for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {\\n                this.entries.splice(candidates[i].idx, 1);\\n                this.length--;\\n            }\\n        }\\n    }\\n\\n    //Mutations\\n    insertMarker() {\\n        this.entries.push({ type: FormattingElementList.MARKER_ENTRY });\\n        this.length++;\\n    }\\n\\n    pushElement(element, token) {\\n        this._ensureNoahArkCondition(element);\\n\\n        this.entries.push({\\n            type: FormattingElementList.ELEMENT_ENTRY,\\n            element: element,\\n            token: token\\n        });\\n\\n        this.length++;\\n    }\\n\\n    insertElementAfterBookmark(element, token) {\\n        let bookmarkIdx = this.length - 1;\\n\\n        for (; bookmarkIdx >= 0; bookmarkIdx--) {\\n            if (this.entries[bookmarkIdx] === this.bookmark) {\\n                break;\\n            }\\n        }\\n\\n        this.entries.splice(bookmarkIdx + 1, 0, {\\n            type: FormattingElementList.ELEMENT_ENTRY,\\n            element: element,\\n            token: token\\n        });\\n\\n        this.length++;\\n    }\\n\\n    removeEntry(entry) {\\n        for (let i = this.length - 1; i >= 0; i--) {\\n            if (this.entries[i] === entry) {\\n                this.entries.splice(i, 1);\\n                this.length--;\\n                break;\\n            }\\n        }\\n    }\\n\\n    clearToLastMarker() {\\n        while (this.length) {\\n            const entry = this.entries.pop();\\n\\n            this.length--;\\n\\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\\n                break;\\n            }\\n        }\\n    }\\n\\n    //Search\\n    getElementEntryInScopeWithTagName(tagName) {\\n        for (let i = this.length - 1; i >= 0; i--) {\\n            const entry = this.entries[i];\\n\\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\\n                return null;\\n            }\\n\\n            if (this.treeAdapter.getTagName(entry.element) === tagName) {\\n                return entry;\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    getElementEntry(element) {\\n        for (let i = this.length - 1; i >= 0; i--) {\\n            const entry = this.entries[i];\\n\\n            if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\\n                return entry;\\n            }\\n        }\\n\\n        return null;\\n    }\\n}\\n\\n//Entry types\\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\\n\\nmodule.exports = FormattingElementList;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"FormattingElementList\",\"constructor\",\"treeAdapter\",\"length\",\"entries\",\"bookmark\",\"_getNoahArkConditionCandidates\",\"newElement\",\"candidates\",\"NOAH_ARK_CAPACITY\",\"neAttrsLength\",\"getAttrList\",\"neTagName\",\"getTagName\",\"neNamespaceURI\",\"getNamespaceURI\",\"i\",\"entry\",\"type\",\"MARKER_ENTRY\",\"element\",\"elementAttrs\",\"push\",\"idx\",\"attrs\",\"_ensureNoahArkCondition\",\"cLength\",\"neAttrs\",\"neAttrsMap\",\"Object\",\"create\",\"neAttr\",\"name\",\"value\",\"j\",\"cAttr\",\"splice\",\"insertMarker\",\"pushElement\",\"token\",\"ELEMENT_ENTRY\",\"insertElementAfterBookmark\",\"bookmarkIdx\",\"removeEntry\",\"clearToLastMarker\",\"pop\",\"getElementEntryInScopeWithTagName\",\"tagName\",\"getElementEntry\"]\n}\n"]