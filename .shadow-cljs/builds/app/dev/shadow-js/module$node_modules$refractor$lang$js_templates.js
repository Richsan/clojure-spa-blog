["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/js-templates.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$js_templates=function(global,require,module,exports){function jsTemplates(Prism$jscomp$0){Prism$jscomp$0.register(_javascript.default);(function(Prism){function createTemplate(language,tag){if(Prism.languages[language])return{pattern:RegExp(\"((?:\"+tag+\")\\\\s*)\"+templateLiteralPattern),lookbehind:!0,greedy:!0,inside:{\"template-punctuation\":{pattern:/^`|`$/,alias:\"string\"},\"embedded-code\":{pattern:/[\\s\\S]+/,alias:language}}}}function getPlaceholder(counter,\nlanguage){return\"___\"+language.toUpperCase()+\"_\"+counter+\"___\"}function tokenizeWithHooks(code,grammar,language){code={code,grammar,language};Prism.hooks.run(\"before-tokenize\",code);code.tokens=Prism.tokenize(code.code,code.grammar);Prism.hooks.run(\"after-tokenize\",code);return code.tokens}function tokenizeEmbedded(code,grammar,language){function walkTokens(tokens){for(var i=0;i<tokens.length&&!(placeholderCounter>=placeholders.length);i++){var token=tokens[i];if(\"string\"===typeof token||\"string\"===\ntypeof token.content){var placeholder=placeholders[placeholderCounter],s=\"string\"===typeof token?token:token.content,index=s.indexOf(placeholder);if(-1!==index){++placeholderCounter;var before=s.substring(0,index);var middle=placeholderMap[placeholder];var tempGrammar={};tempGrammar[\"interpolation-punctuation\"]=interpolationPunctuationObject;tempGrammar=Prism.tokenize(middle,tempGrammar);if(3===tempGrammar.length){var args=[1,1];args.push.apply(args,tokenizeWithHooks(tempGrammar[1],Prism.languages.javascript,\n\"javascript\"));tempGrammar.splice.apply(tempGrammar,args)}middle=new Prism.Token(\"interpolation\",tempGrammar,interpolationObject.alias,middle);s=s.substring(index+placeholder.length);placeholder=[];before&&placeholder.push(before);placeholder.push(middle);s&&(before=[s],walkTokens(before),placeholder.push.apply(placeholder,before));\"string\"===typeof token?(tokens.splice.apply(tokens,[i,1].concat(placeholder)),i+=placeholder.length-1):token.content=placeholder}}else token=token.content,Array.isArray(token)?\nwalkTokens(token):walkTokens([token])}}var placeholderCounter=0,placeholderMap={},embeddedCode=Prism.tokenize(code,{interpolation:{pattern:RegExp(interpolationPattern),lookbehind:!0}}).map(function(token){if(\"string\"===typeof token)return token;token=token.content;for(var placeholder;-1!==code.indexOf(placeholder=getPlaceholder(placeholderCounter++,language)););placeholderMap[placeholder]=token;return placeholder}).join(\"\");grammar=tokenizeWithHooks(embeddedCode,grammar,language);var placeholders=\nObject.keys(placeholderMap);placeholderCounter=0;walkTokens(grammar);return new Prism.Token(language,grammar,\"language-\"+language,code)}function stringContent(value){return\"string\"===typeof value?value:Array.isArray(value)?value.map(stringContent).join(\"\"):stringContent(value.content)}var templateString=Prism.languages.javascript[\"template-string\"],templateLiteralPattern=templateString.pattern.source,interpolationObject=templateString.inside.interpolation,interpolationPunctuationObject=interpolationObject.inside[\"interpolation-punctuation\"],\ninterpolationPattern=interpolationObject.pattern.source;Prism.languages.javascript[\"template-string\"]=[createTemplate(\"css\",/\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),createTemplate(\"html\",/\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),createTemplate(\"svg\",/\\bsvg/.source),createTemplate(\"markdown\",/\\b(?:markdown|md)/.source),createTemplate(\"graphql\",/\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),createTemplate(\"sql\",\n/\\bsql/.source),templateString].filter(Boolean);var supportedLanguages={javascript:!0,js:!0,typescript:!0,ts:!0,jsx:!0,tsx:!0};Prism.hooks.add(\"after-tokenize\",function(env){function findTemplateStrings(tokens){for(var i=0,l=tokens.length;i<l;i++){var token=tokens[i];if(\"string\"!==typeof token){var content=token.content;if(Array.isArray(content))if(\"template-string\"===token.type){var embedded=content[1];if(3===content.length&&\"string\"!==typeof embedded&&\"embedded-code\"===embedded.type){token=stringContent(embedded);\nembedded=embedded.alias;embedded=Array.isArray(embedded)?embedded[0]:embedded;var grammar=Prism.languages[embedded];grammar&&(content[1]=tokenizeEmbedded(token,grammar,embedded))}}else findTemplateStrings(content);else\"string\"!==typeof content&&findTemplateStrings([content])}}}env.language in supportedLanguages&&findTemplateStrings(env.tokens)})})(Prism$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=jsTemplates;var _javascript=function(obj){return obj&&obj.__esModule?\nobj:{default:obj}}(require(\"module$node_modules$refractor$lang$javascript\"));jsTemplates.displayName=\"js-templates\";jsTemplates.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$js_templates\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = jsTemplates;\n\nvar _javascript = _interopRequireDefault(require(\"./javascript.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// @ts-nocheck\njsTemplates.displayName = 'js-templates';\njsTemplates.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction jsTemplates(Prism) {\n  Prism.register(_javascript.default);\n\n  (function (Prism) {\n    var templateString = Prism.languages.javascript['template-string']; // see the pattern in prism-javascript.js\n\n    var templateLiteralPattern = templateString.pattern.source;\n    var interpolationObject = templateString.inside['interpolation'];\n    var interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n    var interpolationPattern = interpolationObject.pattern.source;\n    /**\n     * Creates a new pattern to match a template string with a special tag.\n     *\n     * This will return `undefined` if there is no grammar with the given language id.\n     *\n     * @param {string} language The language id of the embedded language. E.g. `markdown`.\n     * @param {string} tag The regex pattern to match the tag.\n     * @returns {object | undefined}\n     * @example\n     * createTemplate('css', /\\bcss/.source);\n     */\n\n    function createTemplate(language, tag) {\n      if (!Prism.languages[language]) {\n        return undefined;\n      }\n\n      return {\n        pattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          'template-punctuation': {\n            pattern: /^`|`$/,\n            alias: 'string'\n          },\n          'embedded-code': {\n            pattern: /[\\s\\S]+/,\n            alias: language\n          }\n        }\n      };\n    }\n\n    Prism.languages.javascript['template-string'] = [// styled-jsx:\n    //   css`a { color: #25F; }`\n    // styled-components:\n    //   styled.h1`color: red;`\n    createTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), // html`<p></p>`\n    // div.innerHTML = `<p></p>`\n    createTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source), // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n    createTemplate('svg', /\\bsvg/.source), // md`# h1`, markdown`## h2`\n    createTemplate('markdown', /\\b(?:markdown|md)/.source), // gql`...`, graphql`...`, graphql.experimental`...`\n    createTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source), // sql`...`\n    createTemplate('sql', /\\bsql/.source), // vanilla template string\n    templateString].filter(Boolean);\n    /**\n     * Returns a specific placeholder literal for the given language.\n     *\n     * @param {number} counter\n     * @param {string} language\n     * @returns {string}\n     */\n\n    function getPlaceholder(counter, language) {\n      return '___' + language.toUpperCase() + '_' + counter + '___';\n    }\n    /**\n     * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n     *\n     * @param {string} code\n     * @param {any} grammar\n     * @param {string} language\n     * @returns {(string|Token)[]}\n     */\n\n\n    function tokenizeWithHooks(code, grammar, language) {\n      var env = {\n        code: code,\n        grammar: grammar,\n        language: language\n      };\n      Prism.hooks.run('before-tokenize', env);\n      env.tokens = Prism.tokenize(env.code, env.grammar);\n      Prism.hooks.run('after-tokenize', env);\n      return env.tokens;\n    }\n    /**\n     * Returns the token of the given JavaScript interpolation expression.\n     *\n     * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n     * @returns {Token}\n     */\n\n\n    function tokenizeInterpolationExpression(expression) {\n      var tempGrammar = {};\n      tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n      /** @type {Array} */\n\n      var tokens = Prism.tokenize(expression, tempGrammar);\n\n      if (tokens.length === 3) {\n        /**\n         * The token array will look like this\n         * [\n         *     [\"interpolation-punctuation\", \"${\"]\n         *     \"...\" // JavaScript expression of the interpolation\n         *     [\"interpolation-punctuation\", \"}\"]\n         * ]\n         */\n        var args = [1, 1];\n        args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n        tokens.splice.apply(tokens, args);\n      }\n\n      return new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n    }\n    /**\n     * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n     *\n     * This function has 3 phases:\n     *\n     * 1. Replace all JavaScript interpolation expression with a placeholder.\n     *    The placeholder will have the syntax of a identify of the target language.\n     * 2. Tokenize the code with placeholders.\n     * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n     *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n     *    tokenized as two tokens by the grammar of the embedded language.\n     *\n     * @param {string} code\n     * @param {object} grammar\n     * @param {string} language\n     * @returns {Token}\n     */\n\n\n    function tokenizeEmbedded(code, grammar, language) {\n      // 1. First filter out all interpolations\n      // because they might be escaped, we need a lookbehind, so we use Prism\n\n      /** @type {(Token|string)[]} */\n      var _tokens = Prism.tokenize(code, {\n        interpolation: {\n          pattern: RegExp(interpolationPattern),\n          lookbehind: true\n        }\n      }); // replace all interpolations with a placeholder which is not in the code already\n\n\n      var placeholderCounter = 0;\n      /** @type {Object<string, string>} */\n\n      var placeholderMap = {};\n\n      var embeddedCode = _tokens.map(function (token) {\n        if (typeof token === 'string') {\n          return token;\n        } else {\n          var interpolationExpression = token.content;\n          var placeholder;\n\n          while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) {\n            /* noop */\n          }\n\n          placeholderMap[placeholder] = interpolationExpression;\n          return placeholder;\n        }\n      }).join(''); // 2. Tokenize the embedded code\n\n\n      var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language); // 3. Re-insert the interpolation\n\n      var placeholders = Object.keys(placeholderMap);\n      placeholderCounter = 0;\n      /**\n       *\n       * @param {(Token|string)[]} tokens\n       * @returns {void}\n       */\n\n      function walkTokens(tokens) {\n        for (var i = 0; i < tokens.length; i++) {\n          if (placeholderCounter >= placeholders.length) {\n            return;\n          }\n\n          var token = tokens[i];\n\n          if (typeof token === 'string' || typeof token.content === 'string') {\n            var placeholder = placeholders[placeholderCounter];\n            var s = typeof token === 'string' ? token :\n            /** @type {string} */\n            token.content;\n            var index = s.indexOf(placeholder);\n\n            if (index !== -1) {\n              ++placeholderCounter;\n              var before = s.substring(0, index);\n              var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n              var after = s.substring(index + placeholder.length);\n              var replacement = [];\n\n              if (before) {\n                replacement.push(before);\n              }\n\n              replacement.push(middle);\n\n              if (after) {\n                var afterTokens = [after];\n                walkTokens(afterTokens);\n                replacement.push.apply(replacement, afterTokens);\n              }\n\n              if (typeof token === 'string') {\n                tokens.splice.apply(tokens, [i, 1].concat(replacement));\n                i += replacement.length - 1;\n              } else {\n                token.content = replacement;\n              }\n            }\n          } else {\n            var content = token.content;\n\n            if (Array.isArray(content)) {\n              walkTokens(content);\n            } else {\n              walkTokens([content]);\n            }\n          }\n        }\n      }\n\n      walkTokens(embeddedTokens);\n      return new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n    }\n    /**\n     * The languages for which JS templating will handle tagged template literals.\n     *\n     * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n     */\n\n\n    var supportedLanguages = {\n      javascript: true,\n      js: true,\n      typescript: true,\n      ts: true,\n      jsx: true,\n      tsx: true\n    };\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (!(env.language in supportedLanguages)) {\n        return;\n      }\n      /**\n       * Finds and tokenizes all template strings with an embedded languages.\n       *\n       * @param {(Token | string)[]} tokens\n       * @returns {void}\n       */\n\n\n      function findTemplateStrings(tokens) {\n        for (var i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i];\n\n          if (typeof token === 'string') {\n            continue;\n          }\n\n          var content = token.content;\n\n          if (!Array.isArray(content)) {\n            if (typeof content !== 'string') {\n              findTemplateStrings([content]);\n            }\n\n            continue;\n          }\n\n          if (token.type === 'template-string') {\n            /**\n             * A JavaScript template-string token will look like this:\n             *\n             * [\"template-string\", [\n             *     [\"template-punctuation\", \"`\"],\n             *     (\n             *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n             *         or\n             *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n             *                                  It also has an alias which is the language of the embedded code.\n             *     ),\n             *     [\"template-punctuation\", \"`\"]\n             * ]]\n             */\n            var embedded = content[1];\n\n            if (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n              // get string content\n              var code = stringContent(embedded);\n              var alias = embedded.alias;\n              var language = Array.isArray(alias) ? alias[0] : alias;\n              var grammar = Prism.languages[language];\n\n              if (!grammar) {\n                // the embedded language isn't registered.\n                continue;\n              }\n\n              content[1] = tokenizeEmbedded(code, grammar, language);\n            }\n          } else {\n            findTemplateStrings(content);\n          }\n        }\n      }\n\n      findTemplateStrings(env.tokens);\n    });\n    /**\n     * Returns the string content of a token or token stream.\n     *\n     * @param {string | Token | (string | Token)[]} value\n     * @returns {string}\n     */\n\n    function stringContent(value) {\n      if (typeof value === 'string') {\n        return value;\n      } else if (Array.isArray(value)) {\n        return value.map(stringContent).join('');\n      } else {\n        return stringContent(value.content);\n      }\n    }\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$refractor$lang$javascript","~$shadow.js"]],"~:properties",["^5",["js","grammar","ts","aliases","displayName","__esModule","lookbehind","jsx","typescript","value","content","greedy","pattern","inside","alias","javascript","language","tsx","interpolation","default","code","tokens"]],"~:compiled-at",1676841365427,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$js_templates.js\",\n\"lineCount\":10,\n\"mappings\":\"AAAAA,cAAA,CAAA,+CAAA,CAAoE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAiB5GC,QAASA,YAAW,CAACC,cAAD,CAAQ,CAC1BA,cAAMC,CAAAA,QAAN,CAAeC,WAAYC,CAAAA,OAA3B,CAEC,UAAS,CAACH,KAAD,CAAQ,CAmBhBI,QAASA,eAAc,CAACC,QAAD,CAAWC,GAAX,CAAgB,CACrC,GAAKN,KAAMO,CAAAA,SAAN,CAAgBF,QAAhB,CAAL,CAIA,MAAO,CACLG,QAASC,MAAA,CAAO,MAAP,CAAgBH,GAAhB,CAAsB,QAAtB,CAAiCI,sBAAjC,CADJ,CAELC,WAAY,CAAA,CAFP,CAGLC,OAAQ,CAAA,CAHH,CAILC,OAAQ,CACN,uBAAwB,CACtBL,QAAS,OADa,CAEtBM,MAAO,QAFe,CADlB,CAKN,gBAAiB,CACfN,QAAS,SADM,CAEfM,MAAOT,QAFQ,CALX,CAJH,CAL8B,CA0CvCU,QAASA,eAAc,CAACC,OAAD;AAAUX,QAAV,CAAoB,CACzC,MAAO,KAAP,CAAeA,QAASY,CAAAA,WAAT,EAAf,CAAwC,GAAxC,CAA8CD,OAA9C,CAAwD,KADf,CAa3CE,QAASA,kBAAiB,CAACC,IAAD,CAAOC,OAAP,CAAgBf,QAAhB,CAA0B,CAC9CgB,IAAAA,CAAM,CACFF,IADE,CAECC,OAFD,CAGEf,QAHF,CAKVL,MAAMsB,CAAAA,KAAMC,CAAAA,GAAZ,CAAgB,iBAAhB,CAAmCF,IAAnC,CACAA,KAAIG,CAAAA,MAAJ,CAAaxB,KAAMyB,CAAAA,QAAN,CAAeJ,IAAIF,CAAAA,IAAnB,CAAyBE,IAAID,CAAAA,OAA7B,CACbpB,MAAMsB,CAAAA,KAAMC,CAAAA,GAAZ,CAAgB,gBAAhB,CAAkCF,IAAlC,CACA,OAAOA,KAAIG,CAAAA,MATuC,CA6DpDE,QAASA,iBAAgB,CAACP,IAAD,CAAOC,OAAP,CAAgBf,QAAhB,CAA0B,CA6CjDsB,QAASA,WAAU,CAACH,MAAD,CAAS,CAC1B,IAAK,IAAII,EAAI,CAAb,CAAgBA,CAAhB,CAAoBJ,MAAOK,CAAAA,MAA3B,EACM,EAAAC,kBAAA,EAAsBC,YAAaF,CAAAA,MAAnC,CADN,CAAmCD,CAAA,EAAnC,CAAwC,CAKtC,IAAII,MAAQR,MAAA,CAAOI,CAAP,CAEZ,IAAqB,QAArB,GAAI,MAAOI,MAAX,EAA0D,QAA1D;AAAiC,MAAOA,MAAMC,CAAAA,OAA9C,CAAoE,CAClE,IAAIC,YAAcH,YAAA,CAAaD,kBAAb,CAAlB,CACIK,EAAqB,QAAjB,GAAA,MAAOH,MAAP,CAA4BA,KAA5B,CAERA,KAAMC,CAAAA,OAHN,CAIIG,MAAQD,CAAEE,CAAAA,OAAF,CAAUH,WAAV,CAEZ,IAAc,CAAC,CAAf,GAAIE,KAAJ,CAAkB,CAChB,EAAEN,kBACF,KAAIQ,OAASH,CAAEI,CAAAA,SAAF,CAAY,CAAZ,CAAeH,KAAf,CACgC,KAAA,OAAAI,cAAA,CAAeN,WAAf,CAxGrD,KAAIO,YAAc,EAClBA,YAAA,CAAY,2BAAZ,CAAA,CAA2CC,8BAGvClB,YAAAA,CAASxB,KAAMyB,CAAAA,QAAN,CAAekB,MAAf,CAA2BF,WAA3B,CAEb,IAAsB,CAAtB,GAAIjB,WAAOK,CAAAA,MAAX,CAAyB,CASvB,IAAIe,KAAO,CAAC,CAAD,CAAI,CAAJ,CACXA,KAAKC,CAAAA,IAAKC,CAAAA,KAAV,CAAgBF,IAAhB,CAAsB1B,iBAAA,CAAkBM,WAAA,CAAO,CAAP,CAAlB,CAA6BxB,KAAMO,CAAAA,SAAUwC,CAAAA,UAA7C;AAAyD,YAAzD,CAAtB,CACAvB,YAAOwB,CAAAA,MAAOF,CAAAA,KAAd,CAAoBtB,WAApB,CAA4BoB,IAA5B,CAXuB,CAczB,MAAA,CAAO,IAAI5C,KAAMiD,CAAAA,KAAV,CAAgB,eAAhB,CAAiCzB,WAAjC,CAAyC0B,mBAAoBpC,CAAAA,KAA7D,CAAoE6B,MAApE,CAqFKQ,EAAAA,CAAQhB,CAAEI,CAAAA,SAAF,CAAYH,KAAZ,CAAoBF,WAAYL,CAAAA,MAAhC,CACRuB,YAAAA,CAAc,EAEdd,OAAJ,EACEc,WAAYP,CAAAA,IAAZ,CAAiBP,MAAjB,CAGFc,YAAYP,CAAAA,IAAZ,CAAiBQ,MAAjB,CAEIF,EAAJ,GACMG,MAEJ,CAFkB,CAACH,CAAD,CAElB,CADAxB,UAAA,CAAW2B,MAAX,CACA,CAAAF,WAAYP,CAAAA,IAAKC,CAAAA,KAAjB,CAAuBM,WAAvB,CAAoCE,MAApC,CAHF,CAMqB,SAArB,GAAI,MAAOtB,MAAX,EACER,MAAOwB,CAAAA,MAAOF,CAAAA,KAAd,CAAoBtB,MAApB,CAA4B,CAACI,CAAD,CAAI,CAAJ,CAAO2B,CAAAA,MAAP,CAAcH,WAAd,CAA5B,CACA,CAAAxB,CAAA,EAAKwB,WAAYvB,CAAAA,MAAjB,CAA0B,CAF5B,EAIEG,KAAMC,CAAAA,OAJR,CAIkBmB,WAvBF,CAPgD,CAApE,IAkCMnB,MAEJ,CAFcD,KAAMC,CAAAA,OAEpB,CAAIuB,KAAMC,CAAAA,OAAN,CAAcxB,KAAd,CAAJ;AACEN,UAAA,CAAWM,KAAX,CADF,CAGEN,UAAA,CAAW,CAACM,KAAD,CAAX,CA9CkC,CADd,CAhC5B,IAAIH,mBAAqB,CAAzB,CAGIU,eAAiB,EAHrB,CAKIkB,aAbU1D,KAAMyB,CAAAA,QAANkC,CAAexC,IAAfwC,CAAqB,CACjCC,cAAe,CACbpD,QAASC,MAAA,CAAOoD,oBAAP,CADI,CAEblD,WAAY,CAAA,CAFC,CADkB,CAArBgD,CAaaG,CAAAA,GAAR,CAAY,QAAS,CAAC9B,KAAD,CAAQ,CAC9C,GAAqB,QAArB,GAAI,MAAOA,MAAX,CACE,MAAOA,MAEH+B,MAAAA,CAA0B/B,KAAMC,CAAAA,OAGpC,KAFA,IAAIC,WAEJ,CAAsF,CAAC,CAAvF,GAAOf,IAAKkB,CAAAA,OAAL,CAAaH,WAAb,CAA2BnB,cAAA,CAAee,kBAAA,EAAf,CAAqCzB,QAArC,CAA3B,CAAP,CAAA,EAIAmC,cAAA,CAAeN,WAAf,CAAA,CAA8B6B,KAC9B,OAAO7B,YAZqC,CAA7B,CAchB8B,CAAAA,IAdgB,CAcX,EAdW,CAiBfC,QAAAA,CAAiB/C,iBAAA,CAAkBwC,YAAlB,CAAgCtC,OAAhC,CAAyCf,QAAzC,CAErB,KAAI0B;AAAemC,MAAOC,CAAAA,IAAP,CAAY3B,cAAZ,CACnBV,mBAAA,CAAqB,CA4DrBH,WAAA,CAAWsC,OAAX,CACA,OAAO,KAAIjE,KAAMiD,CAAAA,KAAV,CAAgB5C,QAAhB,CAA0B4D,OAA1B,CAA0C,WAA1C,CAAwD5D,QAAxD,CAAkEc,IAAlE,CAnG0C,CAgMnDiD,QAASA,cAAa,CAACC,KAAD,CAAQ,CAC5B,MAAqB,QAArB,GAAI,MAAOA,MAAX,CACSA,KADT,CAEWb,KAAMC,CAAAA,OAAN,CAAcY,KAAd,CAAJ,CACEA,KAAMP,CAAAA,GAAN,CAAUM,aAAV,CAAyBJ,CAAAA,IAAzB,CAA8B,EAA9B,CADF,CAGEI,aAAA,CAAcC,KAAMpC,CAAAA,OAApB,CANmB,CAtU9B,IAAIqC,eAAiBtE,KAAMO,CAAAA,SAAUwC,CAAAA,UAAhB,CAA2B,iBAA3B,CAArB,CAEIrC,uBAAyB4D,cAAe9D,CAAAA,OAAQ+D,CAAAA,MAFpD,CAGIrB,oBAAsBoB,cAAezD,CAAAA,MAAf,CAAA,aAH1B,CAII6B,+BAAiCQ,mBAAoBrC,CAAAA,MAApB,CAA2B,2BAA3B,CAJrC;AAKIgD,qBAAuBX,mBAAoB1C,CAAAA,OAAQ+D,CAAAA,MAmCvDvE,MAAMO,CAAAA,SAAUwC,CAAAA,UAAhB,CAA2B,iBAA3B,CAAA,CAAgD,CAIhD3C,cAAA,CAAe,KAAf,CAAsB,yHAA0HmE,CAAAA,MAAhJ,CAJgD,CAMhDnE,cAAA,CAAe,MAAf,CAAuB,wCAAyCmE,CAAAA,MAAhE,CANgD,CAOhDnE,cAAA,CAAe,KAAf,CAAsB,OAAQmE,CAAAA,MAA9B,CAPgD,CAQhDnE,cAAA,CAAe,UAAf,CAA2B,mBAAoBmE,CAAAA,MAA/C,CARgD,CAShDnE,cAAA,CAAe,SAAf,CAA0B,4CAA6CmE,CAAAA,MAAvE,CATgD,CAUhDnE,cAAA,CAAe,KAAf;AAAsB,OAAQmE,CAAAA,MAA9B,CAVgD,CAWhDD,cAXgD,CAWhCE,CAAAA,MAXgC,CAWzBC,OAXyB,CA0MhD,KAAIC,mBAAqB,CACvB3B,WAAY,CAAA,CADW,CAEvB4B,GAAI,CAAA,CAFmB,CAGvBC,WAAY,CAAA,CAHW,CAIvBC,GAAI,CAAA,CAJmB,CAKvBC,IAAK,CAAA,CALkB,CAMvBC,IAAK,CAAA,CANkB,CAQzB/E,MAAMsB,CAAAA,KAAM0D,CAAAA,GAAZ,CAAgB,gBAAhB,CAAkC,QAAS,CAAC3D,GAAD,CAAM,CAY/C4D,QAASA,oBAAmB,CAACzD,MAAD,CAAS,CACnC,IADmC,IAC1BI,EAAI,CADsB,CACnBsD,EAAI1D,MAAOK,CAAAA,MAA3B,CAAmCD,CAAnC,CAAuCsD,CAAvC,CAA0CtD,CAAA,EAA1C,CAA+C,CAC7C,IAAII,MAAQR,MAAA,CAAOI,CAAP,CAEZ,IAAqB,QAArB,GAAI,MAAOI,MAAX,CAAA,CAIA,IAAIC,QAAUD,KAAMC,CAAAA,OAEpB,IAAKuB,KAAMC,CAAAA,OAAN,CAAcxB,OAAd,CAAL,CAQA,GAAmB,iBAAnB,GAAID,KAAMmD,CAAAA,IAAV,CAAsC,CAepC,IAAIC,SAAWnD,OAAA,CAAQ,CAAR,CAEf,IAAuB,CAAvB,GAAIA,OAAQJ,CAAAA,MAAZ,EAAgD,QAAhD,GAA4B,MAAOuD,SAAnC,EAA8E,eAA9E,GAA4DA,QAASD,CAAAA,IAArE,CAA+F,CAEzFhE,KAAAA,CAAOiD,aAAA,CAAcgB,QAAd,CACPtE;QAAAA,CAAQsE,QAAStE,CAAAA,KACjBT,SAAAA,CAAWmD,KAAMC,CAAAA,OAAN,CAAc3C,QAAd,CAAA,CAAuBA,QAAA,CAAM,CAAN,CAAvB,CAAkCA,QACjD,KAAIM,QAAUpB,KAAMO,CAAAA,SAAN,CAAgBF,QAAhB,CAETe,QAAL,GAKAa,OAAA,CAAQ,CAAR,CALA,CAKaP,gBAAA,CAAiBP,KAAjB,CAAuBC,OAAvB,CAAgCf,QAAhC,CALb,CAP6F,CAjB3D,CAAtC,IAgCE4E,oBAAA,CAAoBhD,OAApB,CAxCF,KACyB,QAAvB,GAAI,MAAOA,QAAX,EACEgD,mBAAA,CAAoB,CAAChD,OAAD,CAApB,CARJ,CAH6C,CADZ,CAX/BZ,GAAIhB,CAAAA,QAAV,GAAsBqE,mBAAtB,EAkEAO,mBAAA,CAAoB5D,GAAIG,CAAAA,MAAxB,CAnE+C,CAAjD,CA3PgB,CAAjB,CAAD,CAgVGxB,cAhVH,CAH0B,CAd5BkE,MAAOmB,CAAAA,cAAP,CAAsBvF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CuE,MAAO,CAAA,CADoC,CAA7C,CAGAvE,QAAQK,CAAAA,OAAR,CAAkBJ,WAElB,KAAIG,YAEJoF,QAA+B,CAACC,GAAD,CAAM,CAAE,MAAOA,IAAA,EAAOA,GAAIC,CAAAA,UAAX;AAAwBD,GAAxB,CAA8B,CAAEpF,QAASoF,GAAX,CAAvC,CAFnB,CAAuB3F,OAAA,CAAQ,+CAAR,CAAvB,CAKlBG,YAAY0F,CAAAA,WAAZ,CAA0B,cAC1B1F,YAAY2F,CAAAA,OAAZ,CAAsB,EAdsF;\",\n\"sources\":[\"node_modules/refractor/lang/js-templates.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$js_templates\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = jsTemplates;\\n\\nvar _javascript = _interopRequireDefault(require(\\\"./javascript.js\\\"));\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n// @ts-nocheck\\njsTemplates.displayName = 'js-templates';\\njsTemplates.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction jsTemplates(Prism) {\\n  Prism.register(_javascript.default);\\n\\n  (function (Prism) {\\n    var templateString = Prism.languages.javascript['template-string']; // see the pattern in prism-javascript.js\\n\\n    var templateLiteralPattern = templateString.pattern.source;\\n    var interpolationObject = templateString.inside['interpolation'];\\n    var interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\\n    var interpolationPattern = interpolationObject.pattern.source;\\n    /**\\n     * Creates a new pattern to match a template string with a special tag.\\n     *\\n     * This will return `undefined` if there is no grammar with the given language id.\\n     *\\n     * @param {string} language The language id of the embedded language. E.g. `markdown`.\\n     * @param {string} tag The regex pattern to match the tag.\\n     * @returns {object | undefined}\\n     * @example\\n     * createTemplate('css', /\\\\bcss/.source);\\n     */\\n\\n    function createTemplate(language, tag) {\\n      if (!Prism.languages[language]) {\\n        return undefined;\\n      }\\n\\n      return {\\n        pattern: RegExp('((?:' + tag + ')\\\\\\\\s*)' + templateLiteralPattern),\\n        lookbehind: true,\\n        greedy: true,\\n        inside: {\\n          'template-punctuation': {\\n            pattern: /^`|`$/,\\n            alias: 'string'\\n          },\\n          'embedded-code': {\\n            pattern: /[\\\\s\\\\S]+/,\\n            alias: language\\n          }\\n        }\\n      };\\n    }\\n\\n    Prism.languages.javascript['template-string'] = [// styled-jsx:\\n    //   css`a { color: #25F; }`\\n    // styled-components:\\n    //   styled.h1`color: red;`\\n    createTemplate('css', /\\\\b(?:styled(?:\\\\([^)]*\\\\))?(?:\\\\s*\\\\.\\\\s*\\\\w+(?:\\\\([^)]*\\\\))*)*|css(?:\\\\s*\\\\.\\\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), // html`<p></p>`\\n    // div.innerHTML = `<p></p>`\\n    createTemplate('html', /\\\\bhtml|\\\\.\\\\s*(?:inner|outer)HTML\\\\s*\\\\+?=/.source), // svg`<path fill=\\\"#fff\\\" d=\\\"M55.37 ...\\\"/>`\\n    createTemplate('svg', /\\\\bsvg/.source), // md`# h1`, markdown`## h2`\\n    createTemplate('markdown', /\\\\b(?:markdown|md)/.source), // gql`...`, graphql`...`, graphql.experimental`...`\\n    createTemplate('graphql', /\\\\b(?:gql|graphql(?:\\\\s*\\\\.\\\\s*experimental)?)/.source), // sql`...`\\n    createTemplate('sql', /\\\\bsql/.source), // vanilla template string\\n    templateString].filter(Boolean);\\n    /**\\n     * Returns a specific placeholder literal for the given language.\\n     *\\n     * @param {number} counter\\n     * @param {string} language\\n     * @returns {string}\\n     */\\n\\n    function getPlaceholder(counter, language) {\\n      return '___' + language.toUpperCase() + '_' + counter + '___';\\n    }\\n    /**\\n     * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\\n     *\\n     * @param {string} code\\n     * @param {any} grammar\\n     * @param {string} language\\n     * @returns {(string|Token)[]}\\n     */\\n\\n\\n    function tokenizeWithHooks(code, grammar, language) {\\n      var env = {\\n        code: code,\\n        grammar: grammar,\\n        language: language\\n      };\\n      Prism.hooks.run('before-tokenize', env);\\n      env.tokens = Prism.tokenize(env.code, env.grammar);\\n      Prism.hooks.run('after-tokenize', env);\\n      return env.tokens;\\n    }\\n    /**\\n     * Returns the token of the given JavaScript interpolation expression.\\n     *\\n     * @param {string} expression The code of the expression. E.g. `\\\"${42}\\\"`\\n     * @returns {Token}\\n     */\\n\\n\\n    function tokenizeInterpolationExpression(expression) {\\n      var tempGrammar = {};\\n      tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\\n      /** @type {Array} */\\n\\n      var tokens = Prism.tokenize(expression, tempGrammar);\\n\\n      if (tokens.length === 3) {\\n        /**\\n         * The token array will look like this\\n         * [\\n         *     [\\\"interpolation-punctuation\\\", \\\"${\\\"]\\n         *     \\\"...\\\" // JavaScript expression of the interpolation\\n         *     [\\\"interpolation-punctuation\\\", \\\"}\\\"]\\n         * ]\\n         */\\n        var args = [1, 1];\\n        args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\\n        tokens.splice.apply(tokens, args);\\n      }\\n\\n      return new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\\n    }\\n    /**\\n     * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\\n     *\\n     * This function has 3 phases:\\n     *\\n     * 1. Replace all JavaScript interpolation expression with a placeholder.\\n     *    The placeholder will have the syntax of a identify of the target language.\\n     * 2. Tokenize the code with placeholders.\\n     * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\\n     *    The insertion only works if a placeholder hasn't been \\\"ripped apart\\\" meaning that the placeholder has been\\n     *    tokenized as two tokens by the grammar of the embedded language.\\n     *\\n     * @param {string} code\\n     * @param {object} grammar\\n     * @param {string} language\\n     * @returns {Token}\\n     */\\n\\n\\n    function tokenizeEmbedded(code, grammar, language) {\\n      // 1. First filter out all interpolations\\n      // because they might be escaped, we need a lookbehind, so we use Prism\\n\\n      /** @type {(Token|string)[]} */\\n      var _tokens = Prism.tokenize(code, {\\n        interpolation: {\\n          pattern: RegExp(interpolationPattern),\\n          lookbehind: true\\n        }\\n      }); // replace all interpolations with a placeholder which is not in the code already\\n\\n\\n      var placeholderCounter = 0;\\n      /** @type {Object<string, string>} */\\n\\n      var placeholderMap = {};\\n\\n      var embeddedCode = _tokens.map(function (token) {\\n        if (typeof token === 'string') {\\n          return token;\\n        } else {\\n          var interpolationExpression = token.content;\\n          var placeholder;\\n\\n          while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) {\\n            /* noop */\\n          }\\n\\n          placeholderMap[placeholder] = interpolationExpression;\\n          return placeholder;\\n        }\\n      }).join(''); // 2. Tokenize the embedded code\\n\\n\\n      var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language); // 3. Re-insert the interpolation\\n\\n      var placeholders = Object.keys(placeholderMap);\\n      placeholderCounter = 0;\\n      /**\\n       *\\n       * @param {(Token|string)[]} tokens\\n       * @returns {void}\\n       */\\n\\n      function walkTokens(tokens) {\\n        for (var i = 0; i < tokens.length; i++) {\\n          if (placeholderCounter >= placeholders.length) {\\n            return;\\n          }\\n\\n          var token = tokens[i];\\n\\n          if (typeof token === 'string' || typeof token.content === 'string') {\\n            var placeholder = placeholders[placeholderCounter];\\n            var s = typeof token === 'string' ? token :\\n            /** @type {string} */\\n            token.content;\\n            var index = s.indexOf(placeholder);\\n\\n            if (index !== -1) {\\n              ++placeholderCounter;\\n              var before = s.substring(0, index);\\n              var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\\n              var after = s.substring(index + placeholder.length);\\n              var replacement = [];\\n\\n              if (before) {\\n                replacement.push(before);\\n              }\\n\\n              replacement.push(middle);\\n\\n              if (after) {\\n                var afterTokens = [after];\\n                walkTokens(afterTokens);\\n                replacement.push.apply(replacement, afterTokens);\\n              }\\n\\n              if (typeof token === 'string') {\\n                tokens.splice.apply(tokens, [i, 1].concat(replacement));\\n                i += replacement.length - 1;\\n              } else {\\n                token.content = replacement;\\n              }\\n            }\\n          } else {\\n            var content = token.content;\\n\\n            if (Array.isArray(content)) {\\n              walkTokens(content);\\n            } else {\\n              walkTokens([content]);\\n            }\\n          }\\n        }\\n      }\\n\\n      walkTokens(embeddedTokens);\\n      return new Prism.Token(language, embeddedTokens, 'language-' + language, code);\\n    }\\n    /**\\n     * The languages for which JS templating will handle tagged template literals.\\n     *\\n     * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\\n     */\\n\\n\\n    var supportedLanguages = {\\n      javascript: true,\\n      js: true,\\n      typescript: true,\\n      ts: true,\\n      jsx: true,\\n      tsx: true\\n    };\\n    Prism.hooks.add('after-tokenize', function (env) {\\n      if (!(env.language in supportedLanguages)) {\\n        return;\\n      }\\n      /**\\n       * Finds and tokenizes all template strings with an embedded languages.\\n       *\\n       * @param {(Token | string)[]} tokens\\n       * @returns {void}\\n       */\\n\\n\\n      function findTemplateStrings(tokens) {\\n        for (var i = 0, l = tokens.length; i < l; i++) {\\n          var token = tokens[i];\\n\\n          if (typeof token === 'string') {\\n            continue;\\n          }\\n\\n          var content = token.content;\\n\\n          if (!Array.isArray(content)) {\\n            if (typeof content !== 'string') {\\n              findTemplateStrings([content]);\\n            }\\n\\n            continue;\\n          }\\n\\n          if (token.type === 'template-string') {\\n            /**\\n             * A JavaScript template-string token will look like this:\\n             *\\n             * [\\\"template-string\\\", [\\n             *     [\\\"template-punctuation\\\", \\\"`\\\"],\\n             *     (\\n             *         An array of \\\"string\\\" and \\\"interpolation\\\" tokens. This is the simple string case.\\n             *         or\\n             *         [\\\"embedded-code\\\", \\\"...\\\"] This is the token containing the embedded code.\\n             *                                  It also has an alias which is the language of the embedded code.\\n             *     ),\\n             *     [\\\"template-punctuation\\\", \\\"`\\\"]\\n             * ]]\\n             */\\n            var embedded = content[1];\\n\\n            if (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\\n              // get string content\\n              var code = stringContent(embedded);\\n              var alias = embedded.alias;\\n              var language = Array.isArray(alias) ? alias[0] : alias;\\n              var grammar = Prism.languages[language];\\n\\n              if (!grammar) {\\n                // the embedded language isn't registered.\\n                continue;\\n              }\\n\\n              content[1] = tokenizeEmbedded(code, grammar, language);\\n            }\\n          } else {\\n            findTemplateStrings(content);\\n          }\\n        }\\n      }\\n\\n      findTemplateStrings(env.tokens);\\n    });\\n    /**\\n     * Returns the string content of a token or token stream.\\n     *\\n     * @param {string | Token | (string | Token)[]} value\\n     * @returns {string}\\n     */\\n\\n    function stringContent(value) {\\n      if (typeof value === 'string') {\\n        return value;\\n      } else if (Array.isArray(value)) {\\n        return value.map(stringContent).join('');\\n      } else {\\n        return stringContent(value.content);\\n      }\\n    }\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"jsTemplates\",\"Prism\",\"register\",\"_javascript\",\"default\",\"createTemplate\",\"language\",\"tag\",\"languages\",\"pattern\",\"RegExp\",\"templateLiteralPattern\",\"lookbehind\",\"greedy\",\"inside\",\"alias\",\"getPlaceholder\",\"counter\",\"toUpperCase\",\"tokenizeWithHooks\",\"code\",\"grammar\",\"env\",\"hooks\",\"run\",\"tokens\",\"tokenize\",\"tokenizeEmbedded\",\"walkTokens\",\"i\",\"length\",\"placeholderCounter\",\"placeholders\",\"token\",\"content\",\"placeholder\",\"s\",\"index\",\"indexOf\",\"before\",\"substring\",\"placeholderMap\",\"tempGrammar\",\"interpolationPunctuationObject\",\"expression\",\"args\",\"push\",\"apply\",\"javascript\",\"splice\",\"Token\",\"interpolationObject\",\"after\",\"replacement\",\"middle\",\"afterTokens\",\"concat\",\"Array\",\"isArray\",\"embeddedCode\",\"_tokens\",\"interpolation\",\"interpolationPattern\",\"map\",\"interpolationExpression\",\"join\",\"embeddedTokens\",\"Object\",\"keys\",\"stringContent\",\"value\",\"templateString\",\"source\",\"filter\",\"Boolean\",\"supportedLanguages\",\"js\",\"typescript\",\"ts\",\"jsx\",\"tsx\",\"add\",\"findTemplateStrings\",\"l\",\"type\",\"embedded\",\"defineProperty\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"displayName\",\"aliases\"]\n}\n"]