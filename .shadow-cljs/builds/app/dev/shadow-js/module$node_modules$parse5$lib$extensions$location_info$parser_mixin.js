["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/parse5/lib/extensions/location-info/parser-mixin.js"],"~:js","shadow$provide.module$node_modules$parse5$lib$extensions$location_info$parser_mixin=function(global,require,module,exports){const Mixin=require(\"module$node_modules$parse5$lib$utils$mixin\"),Tokenizer=require(\"module$node_modules$parse5$lib$tokenizer$index\"),LocationInfoTokenizerMixin=require(\"module$node_modules$parse5$lib$extensions$location_info$tokenizer_mixin\"),LocationInfoOpenElementStackMixin=require(\"module$node_modules$parse5$lib$extensions$location_info$open_element_stack_mixin\"),$=require(\"module$node_modules$parse5$lib$common$html\").TAG_NAMES;\nclass LocationInfoParserMixin extends Mixin{constructor(parser){super(parser);this.parser=parser;this.treeAdapter=this.parser.treeAdapter;this.currentToken=this.lastFosterParentingLocation=this.lastStartTagToken=this.posTracker=null}_setStartLocation(element){let loc=null;this.lastStartTagToken&&(loc=Object.assign({},this.lastStartTagToken.location),loc.startTag=this.lastStartTagToken.location);this.treeAdapter.setNodeSourceCodeLocation(element,loc)}_setEndLocation(element,closingToken){if(this.treeAdapter.getNodeSourceCodeLocation(element)&&\nclosingToken.location){const ctLoc=closingToken.location,tn=this.treeAdapter.getTagName(element),endLoc={};closingToken.type===Tokenizer.END_TAG_TOKEN&&tn===closingToken.tagName?(endLoc.endTag=Object.assign({},ctLoc),endLoc.endLine=ctLoc.endLine,endLoc.endCol=ctLoc.endCol,endLoc.endOffset=ctLoc.endOffset):(endLoc.endLine=ctLoc.startLine,endLoc.endCol=ctLoc.startCol,endLoc.endOffset=ctLoc.startOffset);this.treeAdapter.updateNodeSourceCodeLocation(element,endLoc)}}_getOverriddenMethods(mxn,orig){return{_bootstrap(document,\nfragmentContext){orig._bootstrap.call(this,document,fragmentContext);mxn.lastStartTagToken=null;mxn.lastFosterParentingLocation=null;mxn.currentToken=null;document=Mixin.install(this.tokenizer,LocationInfoTokenizerMixin);mxn.posTracker=document.posTracker;Mixin.install(this.openElements,LocationInfoOpenElementStackMixin,{onItemPop:function(element){mxn._setEndLocation(element,mxn.currentToken)}})},_runParsingLoop(scriptHandler){orig._runParsingLoop.call(this,scriptHandler);for(scriptHandler=this.openElements.stackTop;0<=\nscriptHandler;scriptHandler--)mxn._setEndLocation(this.openElements.items[scriptHandler],mxn.currentToken)},_processTokenInForeignContent(token){mxn.currentToken=token;orig._processTokenInForeignContent.call(this,token)},_processToken(token){mxn.currentToken=token;orig._processToken.call(this,token);if(token.type===Tokenizer.END_TAG_TOKEN&&(token.tagName===$.HTML||token.tagName===$.BODY&&this.openElements.hasInScope($.BODY)))for(let i=this.openElements.stackTop;0<=i;i--){const element=this.openElements.items[i];\nif(this.treeAdapter.getTagName(element)===token.tagName){mxn._setEndLocation(element,token);break}}},_setDocumentType(token){orig._setDocumentType.call(this,token);const documentChildren=this.treeAdapter.getChildNodes(this.document),cnLength=documentChildren.length;for(let i=0;i<cnLength;i++){const node=documentChildren[i];if(this.treeAdapter.isDocumentTypeNode(node)){this.treeAdapter.setNodeSourceCodeLocation(node,token.location);break}}},_attachElementToTree(element){mxn._setStartLocation(element);\nmxn.lastStartTagToken=null;orig._attachElementToTree.call(this,element)},_appendElement(token,namespaceURI){mxn.lastStartTagToken=token;orig._appendElement.call(this,token,namespaceURI)},_insertElement(token,namespaceURI){mxn.lastStartTagToken=token;orig._insertElement.call(this,token,namespaceURI)},_insertTemplate(token){mxn.lastStartTagToken=token;orig._insertTemplate.call(this,token);token=this.treeAdapter.getTemplateContent(this.openElements.current);this.treeAdapter.setNodeSourceCodeLocation(token,\nnull)},_insertFakeRootElement(){orig._insertFakeRootElement.call(this);this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current,null)},_appendCommentNode(token,parent){orig._appendCommentNode.call(this,token,parent);parent=this.treeAdapter.getChildNodes(parent);this.treeAdapter.setNodeSourceCodeLocation(parent[parent.length-1],token.location)},_findFosterParentingLocation(){mxn.lastFosterParentingLocation=orig._findFosterParentingLocation.call(this);return mxn.lastFosterParentingLocation},\n_insertCharacters(token){orig._insertCharacters.call(this,token);var hasFosterParent=this._shouldFosterParentOnInsertion(),siblings=this.treeAdapter.getChildNodes(hasFosterParent&&mxn.lastFosterParentingLocation.parent||this.openElements.currentTmplContent||this.openElements.current);hasFosterParent=hasFosterParent&&mxn.lastFosterParentingLocation.beforeElement?siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement)-1:siblings.length-1;siblings=siblings[hasFosterParent];if(this.treeAdapter.getNodeSourceCodeLocation(siblings)){const {endLine,\nendCol,endOffset}=token.location;this.treeAdapter.updateNodeSourceCodeLocation(siblings,{endLine,endCol,endOffset})}else this.treeAdapter.setNodeSourceCodeLocation(siblings,token.location)}}}}module.exports=LocationInfoParserMixin}","~:source","shadow$provide[\"module$node_modules$parse5$lib$extensions$location_info$parser_mixin\"] = function(global,require,module,exports) {\n'use strict';\n\nconst Mixin = require('../../utils/mixin');\nconst Tokenizer = require('../../tokenizer');\nconst LocationInfoTokenizerMixin = require('./tokenizer-mixin');\nconst LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\nconst HTML = require('../../common/html');\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\n\nclass LocationInfoParserMixin extends Mixin {\n    constructor(parser) {\n        super(parser);\n\n        this.parser = parser;\n        this.treeAdapter = this.parser.treeAdapter;\n        this.posTracker = null;\n        this.lastStartTagToken = null;\n        this.lastFosterParentingLocation = null;\n        this.currentToken = null;\n    }\n\n    _setStartLocation(element) {\n        let loc = null;\n\n        if (this.lastStartTagToken) {\n            loc = Object.assign({}, this.lastStartTagToken.location);\n            loc.startTag = this.lastStartTagToken.location;\n        }\n\n        this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n    }\n\n    _setEndLocation(element, closingToken) {\n        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n        if (loc) {\n            if (closingToken.location) {\n                const ctLoc = closingToken.location;\n                const tn = this.treeAdapter.getTagName(element);\n\n                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n                const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n                const endLoc = {};\n                if (isClosingEndTag) {\n                    endLoc.endTag = Object.assign({}, ctLoc);\n                    endLoc.endLine = ctLoc.endLine;\n                    endLoc.endCol = ctLoc.endCol;\n                    endLoc.endOffset = ctLoc.endOffset;\n                } else {\n                    endLoc.endLine = ctLoc.startLine;\n                    endLoc.endCol = ctLoc.startCol;\n                    endLoc.endOffset = ctLoc.startOffset;\n                }\n\n                this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);\n            }\n        }\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        return {\n            _bootstrap(document, fragmentContext) {\n                orig._bootstrap.call(this, document, fragmentContext);\n\n                mxn.lastStartTagToken = null;\n                mxn.lastFosterParentingLocation = null;\n                mxn.currentToken = null;\n\n                const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n\n                mxn.posTracker = tokenizerMixin.posTracker;\n\n                Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n                    onItemPop: function(element) {\n                        mxn._setEndLocation(element, mxn.currentToken);\n                    }\n                });\n            },\n\n            _runParsingLoop(scriptHandler) {\n                orig._runParsingLoop.call(this, scriptHandler);\n\n                // NOTE: generate location info for elements\n                // that remains on open element stack\n                for (let i = this.openElements.stackTop; i >= 0; i--) {\n                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n                }\n            },\n\n            //Token processing\n            _processTokenInForeignContent(token) {\n                mxn.currentToken = token;\n                orig._processTokenInForeignContent.call(this, token);\n            },\n\n            _processToken(token) {\n                mxn.currentToken = token;\n                orig._processToken.call(this, token);\n\n                //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n                //their end location explicitly.\n                const requireExplicitUpdate =\n                    token.type === Tokenizer.END_TAG_TOKEN &&\n                    (token.tagName === $.HTML || (token.tagName === $.BODY && this.openElements.hasInScope($.BODY)));\n\n                if (requireExplicitUpdate) {\n                    for (let i = this.openElements.stackTop; i >= 0; i--) {\n                        const element = this.openElements.items[i];\n\n                        if (this.treeAdapter.getTagName(element) === token.tagName) {\n                            mxn._setEndLocation(element, token);\n                            break;\n                        }\n                    }\n                }\n            },\n\n            //Doctype\n            _setDocumentType(token) {\n                orig._setDocumentType.call(this, token);\n\n                const documentChildren = this.treeAdapter.getChildNodes(this.document);\n                const cnLength = documentChildren.length;\n\n                for (let i = 0; i < cnLength; i++) {\n                    const node = documentChildren[i];\n\n                    if (this.treeAdapter.isDocumentTypeNode(node)) {\n                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n                        break;\n                    }\n                }\n            },\n\n            //Elements\n            _attachElementToTree(element) {\n                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n                //So we will use token location stored in this methods for the element.\n                mxn._setStartLocation(element);\n                mxn.lastStartTagToken = null;\n                orig._attachElementToTree.call(this, element);\n            },\n\n            _appendElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._appendElement.call(this, token, namespaceURI);\n            },\n\n            _insertElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._insertElement.call(this, token, namespaceURI);\n            },\n\n            _insertTemplate(token) {\n                mxn.lastStartTagToken = token;\n                orig._insertTemplate.call(this, token);\n\n                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n\n                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n            },\n\n            _insertFakeRootElement() {\n                orig._insertFakeRootElement.call(this);\n                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n            },\n\n            //Comments\n            _appendCommentNode(token, parent) {\n                orig._appendCommentNode.call(this, token, parent);\n\n                const children = this.treeAdapter.getChildNodes(parent);\n                const commentNode = children[children.length - 1];\n\n                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n            },\n\n            //Text\n            _findFosterParentingLocation() {\n                //NOTE: store last foster parenting location, so we will be able to find inserted text\n                //in case of foster parenting\n                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n\n                return mxn.lastFosterParentingLocation;\n            },\n\n            _insertCharacters(token) {\n                orig._insertCharacters.call(this, token);\n\n                const hasFosterParent = this._shouldFosterParentOnInsertion();\n\n                const parent =\n                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||\n                    this.openElements.currentTmplContent ||\n                    this.openElements.current;\n\n                const siblings = this.treeAdapter.getChildNodes(parent);\n\n                const textNodeIdx =\n                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement\n                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1\n                        : siblings.length - 1;\n\n                const textNode = siblings[textNodeIdx];\n\n                //NOTE: if we have location assigned by another token, then just update end position\n                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n                if (tnLoc) {\n                    const { endLine, endCol, endOffset } = token.location;\n                    this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });\n                } else {\n                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n                }\n            }\n        };\n    }\n}\n\nmodule.exports = LocationInfoParserMixin;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$parse5$lib$extensions$location_info$open_element_stack_mixin","~$module$node_modules$parse5$lib$extensions$location_info$tokenizer_mixin","~$module$node_modules$parse5$lib$common$html","~$module$node_modules$parse5$lib$tokenizer$index","~$module$node_modules$parse5$lib$utils$mixin","~$shadow.js"]],"~:properties",["^5",["currentToken","parser","endLine","endTag","endOffset","onItemPop","lastStartTagToken","posTracker","lastFosterParentingLocation","treeAdapter","startTag","endCol"]],"~:compiled-at",1676667638415,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$parse5$lib$extensions$location_info$parser_mixin.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/parse5/lib/extensions/location-info/parser-mixin.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$parse5$lib$extensions$location_info$parser_mixin\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nconst Mixin = require('../../utils/mixin');\\nconst Tokenizer = require('../../tokenizer');\\nconst LocationInfoTokenizerMixin = require('./tokenizer-mixin');\\nconst LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\\nconst HTML = require('../../common/html');\\n\\n//Aliases\\nconst $ = HTML.TAG_NAMES;\\n\\nclass LocationInfoParserMixin extends Mixin {\\n    constructor(parser) {\\n        super(parser);\\n\\n        this.parser = parser;\\n        this.treeAdapter = this.parser.treeAdapter;\\n        this.posTracker = null;\\n        this.lastStartTagToken = null;\\n        this.lastFosterParentingLocation = null;\\n        this.currentToken = null;\\n    }\\n\\n    _setStartLocation(element) {\\n        let loc = null;\\n\\n        if (this.lastStartTagToken) {\\n            loc = Object.assign({}, this.lastStartTagToken.location);\\n            loc.startTag = this.lastStartTagToken.location;\\n        }\\n\\n        this.treeAdapter.setNodeSourceCodeLocation(element, loc);\\n    }\\n\\n    _setEndLocation(element, closingToken) {\\n        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);\\n\\n        if (loc) {\\n            if (closingToken.location) {\\n                const ctLoc = closingToken.location;\\n                const tn = this.treeAdapter.getTagName(element);\\n\\n                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\\n                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\\n                const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\\n                const endLoc = {};\\n                if (isClosingEndTag) {\\n                    endLoc.endTag = Object.assign({}, ctLoc);\\n                    endLoc.endLine = ctLoc.endLine;\\n                    endLoc.endCol = ctLoc.endCol;\\n                    endLoc.endOffset = ctLoc.endOffset;\\n                } else {\\n                    endLoc.endLine = ctLoc.startLine;\\n                    endLoc.endCol = ctLoc.startCol;\\n                    endLoc.endOffset = ctLoc.startOffset;\\n                }\\n\\n                this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);\\n            }\\n        }\\n    }\\n\\n    _getOverriddenMethods(mxn, orig) {\\n        return {\\n            _bootstrap(document, fragmentContext) {\\n                orig._bootstrap.call(this, document, fragmentContext);\\n\\n                mxn.lastStartTagToken = null;\\n                mxn.lastFosterParentingLocation = null;\\n                mxn.currentToken = null;\\n\\n                const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\\n\\n                mxn.posTracker = tokenizerMixin.posTracker;\\n\\n                Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\\n                    onItemPop: function(element) {\\n                        mxn._setEndLocation(element, mxn.currentToken);\\n                    }\\n                });\\n            },\\n\\n            _runParsingLoop(scriptHandler) {\\n                orig._runParsingLoop.call(this, scriptHandler);\\n\\n                // NOTE: generate location info for elements\\n                // that remains on open element stack\\n                for (let i = this.openElements.stackTop; i >= 0; i--) {\\n                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\\n                }\\n            },\\n\\n            //Token processing\\n            _processTokenInForeignContent(token) {\\n                mxn.currentToken = token;\\n                orig._processTokenInForeignContent.call(this, token);\\n            },\\n\\n            _processToken(token) {\\n                mxn.currentToken = token;\\n                orig._processToken.call(this, token);\\n\\n                //NOTE: <body> and <html> are never popped from the stack, so we need to updated\\n                //their end location explicitly.\\n                const requireExplicitUpdate =\\n                    token.type === Tokenizer.END_TAG_TOKEN &&\\n                    (token.tagName === $.HTML || (token.tagName === $.BODY && this.openElements.hasInScope($.BODY)));\\n\\n                if (requireExplicitUpdate) {\\n                    for (let i = this.openElements.stackTop; i >= 0; i--) {\\n                        const element = this.openElements.items[i];\\n\\n                        if (this.treeAdapter.getTagName(element) === token.tagName) {\\n                            mxn._setEndLocation(element, token);\\n                            break;\\n                        }\\n                    }\\n                }\\n            },\\n\\n            //Doctype\\n            _setDocumentType(token) {\\n                orig._setDocumentType.call(this, token);\\n\\n                const documentChildren = this.treeAdapter.getChildNodes(this.document);\\n                const cnLength = documentChildren.length;\\n\\n                for (let i = 0; i < cnLength; i++) {\\n                    const node = documentChildren[i];\\n\\n                    if (this.treeAdapter.isDocumentTypeNode(node)) {\\n                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\\n                        break;\\n                    }\\n                }\\n            },\\n\\n            //Elements\\n            _attachElementToTree(element) {\\n                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\\n                //So we will use token location stored in this methods for the element.\\n                mxn._setStartLocation(element);\\n                mxn.lastStartTagToken = null;\\n                orig._attachElementToTree.call(this, element);\\n            },\\n\\n            _appendElement(token, namespaceURI) {\\n                mxn.lastStartTagToken = token;\\n                orig._appendElement.call(this, token, namespaceURI);\\n            },\\n\\n            _insertElement(token, namespaceURI) {\\n                mxn.lastStartTagToken = token;\\n                orig._insertElement.call(this, token, namespaceURI);\\n            },\\n\\n            _insertTemplate(token) {\\n                mxn.lastStartTagToken = token;\\n                orig._insertTemplate.call(this, token);\\n\\n                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\\n\\n                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\\n            },\\n\\n            _insertFakeRootElement() {\\n                orig._insertFakeRootElement.call(this);\\n                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\\n            },\\n\\n            //Comments\\n            _appendCommentNode(token, parent) {\\n                orig._appendCommentNode.call(this, token, parent);\\n\\n                const children = this.treeAdapter.getChildNodes(parent);\\n                const commentNode = children[children.length - 1];\\n\\n                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\\n            },\\n\\n            //Text\\n            _findFosterParentingLocation() {\\n                //NOTE: store last foster parenting location, so we will be able to find inserted text\\n                //in case of foster parenting\\n                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\\n\\n                return mxn.lastFosterParentingLocation;\\n            },\\n\\n            _insertCharacters(token) {\\n                orig._insertCharacters.call(this, token);\\n\\n                const hasFosterParent = this._shouldFosterParentOnInsertion();\\n\\n                const parent =\\n                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||\\n                    this.openElements.currentTmplContent ||\\n                    this.openElements.current;\\n\\n                const siblings = this.treeAdapter.getChildNodes(parent);\\n\\n                const textNodeIdx =\\n                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement\\n                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1\\n                        : siblings.length - 1;\\n\\n                const textNode = siblings[textNodeIdx];\\n\\n                //NOTE: if we have location assigned by another token, then just update end position\\n                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\\n\\n                if (tnLoc) {\\n                    const { endLine, endCol, endOffset } = token.location;\\n                    this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });\\n                } else {\\n                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\\n                }\\n            }\\n        };\\n    }\\n}\\n\\nmodule.exports = LocationInfoParserMixin;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Mixin\",\"Tokenizer\",\"LocationInfoTokenizerMixin\",\"LocationInfoOpenElementStackMixin\",\"$\",\"HTML\",\"TAG_NAMES\",\"LocationInfoParserMixin\",\"constructor\",\"parser\",\"treeAdapter\",\"currentToken\",\"lastFosterParentingLocation\",\"lastStartTagToken\",\"posTracker\",\"_setStartLocation\",\"element\",\"loc\",\"Object\",\"assign\",\"location\",\"startTag\",\"setNodeSourceCodeLocation\",\"_setEndLocation\",\"closingToken\",\"getNodeSourceCodeLocation\",\"ctLoc\",\"tn\",\"getTagName\",\"endLoc\",\"type\",\"END_TAG_TOKEN\",\"tagName\",\"endTag\",\"endLine\",\"endCol\",\"endOffset\",\"startLine\",\"startCol\",\"startOffset\",\"updateNodeSourceCodeLocation\",\"_getOverriddenMethods\",\"mxn\",\"orig\",\"_bootstrap\",\"document\",\"fragmentContext\",\"call\",\"tokenizerMixin\",\"install\",\"tokenizer\",\"openElements\",\"onItemPop\",\"_runParsingLoop\",\"scriptHandler\",\"i\",\"stackTop\",\"items\",\"_processTokenInForeignContent\",\"token\",\"_processToken\",\"BODY\",\"hasInScope\",\"_setDocumentType\",\"documentChildren\",\"getChildNodes\",\"cnLength\",\"length\",\"node\",\"isDocumentTypeNode\",\"_attachElementToTree\",\"_appendElement\",\"namespaceURI\",\"_insertElement\",\"_insertTemplate\",\"tmplContent\",\"getTemplateContent\",\"current\",\"_insertFakeRootElement\",\"_appendCommentNode\",\"parent\",\"children\",\"commentNode\",\"_findFosterParentingLocation\",\"_insertCharacters\",\"hasFosterParent\",\"_shouldFosterParentOnInsertion\",\"siblings\",\"currentTmplContent\",\"textNodeIdx\",\"beforeElement\",\"indexOf\",\"textNode\",\"tnLoc\"]\n}\n"]