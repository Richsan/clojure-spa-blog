["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hast-util-select/lib/attribute.js"],"~:js","shadow$provide.module$node_modules$hast_util_select$lib$attribute=function(global,require,module,exports){function normalizeValue(value,info){return\"boolean\"===typeof value?info.attribute:Array.isArray(value)?(info.commaSeparated?_commaSeparatedTokens.stringify:_spaceSeparatedTokens.stringify)(value):String(value)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.attribute=function(query,element,schema){query=query.attrs;let index=-1;for(;++index<query.length;)if(!handle(query[index],\nelement,(0,_propertyInformation.find)(schema,query[index].name)))return!1;return!0};var _commaSeparatedTokens=require(\"module$node_modules$comma_separated_tokens$index\"),_hastUtilHasProperty=require(\"module$node_modules$hast_util_has_property$index\"),_propertyInformation=require(\"module$node_modules$property_information$index\"),_spaceSeparatedTokens=require(\"module$node_modules$space_separated_tokens$index\");const handle=(0,require(\"module$node_modules$zwitch$index\").zwitch)(\"operator\",{unknown:function(query){throw Error(\"Unknown operator `\"+\nquery.operator+\"`\");},invalid:function(_,element,info){return(0,_hastUtilHasProperty.hasProperty)(element,info.property)},handlers:{\"\\x3d\":function(query,element,info){return!(!(0,_hastUtilHasProperty.hasProperty)(element,info.property)||!element.properties||normalizeValue(element.properties[info.property],info)!==query.value)},\"~\\x3d\":function(query,element,info){const value=element.properties&&element.properties[info.property];return!info.commaSeparated&&value&&\"object\"===typeof value&&query.value&&\nvalue.includes(query.value)||(0,_hastUtilHasProperty.hasProperty)(element,info.property)&&normalizeValue(value,info)===query.value},\"|\\x3d\":function(query,element,info){const value=normalizeValue(element.properties&&element.properties[info.property],info);return!(!(0,_hastUtilHasProperty.hasProperty)(element,info.property)||!query.value||value!==query.value&&(value.slice(0,query.value.length)!==query.value||\"-\"!==value.charAt(query.value.length)))},\"^\\x3d\":function(query,element,info){return!!((0,_hastUtilHasProperty.hasProperty)(element,\ninfo.property)&&element.properties&&query.value&&normalizeValue(element.properties[info.property],info).slice(0,query.value.length)===query.value)},\"$\\x3d\":function(query,element,info){return!!((0,_hastUtilHasProperty.hasProperty)(element,info.property)&&element.properties&&query.value&&normalizeValue(element.properties[info.property],info).slice(-query.value.length)===query.value)},\"*\\x3d\":function(query,element,info){return!!((0,_hastUtilHasProperty.hasProperty)(element,info.property)&&element.properties&&\nquery.value&&normalizeValue(element.properties[info.property],info).includes(query.value))}}})}","~:source","shadow$provide[\"module$node_modules$hast_util_select$lib$attribute\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attribute = attribute;\n\nvar _commaSeparatedTokens = require(\"comma-separated-tokens\");\n\nvar _hastUtilHasProperty = require(\"hast-util-has-property\");\n\nvar _propertyInformation = require(\"property-information\");\n\nvar _spaceSeparatedTokens = require(\"space-separated-tokens\");\n\nvar _zwitch = require(\"zwitch\");\n\n/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleAttr} RuleAttr\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Schema} Schema\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').PropertyValue} PropertyValue\n */\n\n/** @type {(query: RuleAttr, element: Element, info: Info) => boolean} */\nconst handle = (0, _zwitch.zwitch)('operator', {\n  unknown: unknownOperator,\n  // @ts-expect-error: hush.\n  invalid: exists,\n  handlers: {\n    '=': exact,\n    '~=': spaceSeparatedList,\n    '|=': exactOrPrefix,\n    '^=': begins,\n    '$=': ends,\n    '*=': contains\n  }\n});\n/**\n * @param {Rule} query\n * @param {Element} element\n * @param {Schema} schema\n * @returns {boolean}\n */\n\nfunction attribute(query, element, schema) {\n  const attrs = query.attrs;\n  let index = -1;\n\n  while (++index < attrs.length) {\n    if (!handle(attrs[index], element, (0, _propertyInformation.find)(schema, attrs[index].name))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Check whether an attribute exists.\n *\n * `[attr]`\n *\n * @param {RuleAttr} _\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction exists(_, element, info) {\n  return (0, _hastUtilHasProperty.hasProperty)(element, info.property);\n}\n/**\n * Check whether an attribute has an exact value.\n *\n * `[attr=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction exact(query, element, info) {\n  return Boolean((0, _hastUtilHasProperty.hasProperty)(element, info.property) && element.properties && normalizeValue(element.properties[info.property], info) === query.value);\n}\n/**\n * Check whether an attribute, interpreted as a space-separated list, contains\n * a value.\n *\n * `[attr~=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction spaceSeparatedList(query, element, info) {\n  const value = element.properties && element.properties[info.property];\n  return (// If this is a space-separated list, and the query is contained in it, return\n    // true.\n    !info.commaSeparated && value && typeof value === 'object' && query.value && value.includes(query.value) || (0, _hastUtilHasProperty.hasProperty)(element, info.property) && normalizeValue(value, info) === query.value\n  );\n}\n/**\n * Check whether an attribute has a substring as either the exact value or a\n * prefix.\n *\n * `[attr|=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction exactOrPrefix(query, element, info) {\n  const value = normalizeValue(element.properties && element.properties[info.property], info);\n  return Boolean((0, _hastUtilHasProperty.hasProperty)(element, info.property) && query.value && (value === query.value || value.slice(0, query.value.length) === query.value && value.charAt(query.value.length) === '-'));\n}\n/**\n * Check whether an attribute has a substring as its start.\n *\n * `[attr^=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction begins(query, element, info) {\n  return Boolean((0, _hastUtilHasProperty.hasProperty)(element, info.property) && element.properties && query.value && normalizeValue(element.properties[info.property], info).slice(0, query.value.length) === query.value);\n}\n/**\n * Check whether an attribute has a substring as its end.\n *\n * `[attr$=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction ends(query, element, info) {\n  return Boolean((0, _hastUtilHasProperty.hasProperty)(element, info.property) && element.properties && query.value && normalizeValue(element.properties[info.property], info).slice(-query.value.length) === query.value);\n}\n/**\n * Check whether an attribute contains a substring.\n *\n * `[attr*=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction contains(query, element, info) {\n  return Boolean((0, _hastUtilHasProperty.hasProperty)(element, info.property) && element.properties && query.value && normalizeValue(element.properties[info.property], info).includes(query.value));\n} // Shouldnâ€™t be called, Parser throws an error instead.\n\n/**\n * @param {unknown} query\n * @returns {never}\n */\n\n/* c8 ignore next 4 */\n\n\nfunction unknownOperator(query) {\n  // @ts-expect-error: `operator` guaranteed.\n  throw new Error('Unknown operator `' + query.operator + '`');\n}\n/**\n * Stringify a hast value back to its HTML form.\n *\n * @param {PropertyValue} value\n * @param {Info} info\n * @returns {string}\n */\n\n\nfunction normalizeValue(value, info) {\n  if (typeof value === 'boolean') {\n    return info.attribute;\n  }\n\n  if (Array.isArray(value)) {\n    return (info.commaSeparated ? _commaSeparatedTokens.stringify : _spaceSeparatedTokens.stringify)(value);\n  }\n\n  return String(value);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$property_information$index","~$shadow.js","~$module$node_modules$space_separated_tokens$index","~$module$node_modules$comma_separated_tokens$index","~$module$node_modules$zwitch$index","~$module$node_modules$hast_util_has_property$index"]],"~:properties",["^5",["handlers","__esModule","attribute","invalid","value","unknown"]],"~:compiled-at",1676841365493,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hast_util_select$lib$attribute.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/hast-util-select/lib/attribute.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hast_util_select$lib$attribute\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.attribute = attribute;\\n\\nvar _commaSeparatedTokens = require(\\\"comma-separated-tokens\\\");\\n\\nvar _hastUtilHasProperty = require(\\\"hast-util-has-property\\\");\\n\\nvar _propertyInformation = require(\\\"property-information\\\");\\n\\nvar _spaceSeparatedTokens = require(\\\"space-separated-tokens\\\");\\n\\nvar _zwitch = require(\\\"zwitch\\\");\\n\\n/**\\n * @typedef {import('./types.js').Rule} Rule\\n * @typedef {import('./types.js').RuleAttr} RuleAttr\\n * @typedef {import('./types.js').Element} Element\\n * @typedef {import('./types.js').Schema} Schema\\n * @typedef {import('./types.js').Info} Info\\n * @typedef {import('./types.js').PropertyValue} PropertyValue\\n */\\n\\n/** @type {(query: RuleAttr, element: Element, info: Info) => boolean} */\\nconst handle = (0, _zwitch.zwitch)('operator', {\\n  unknown: unknownOperator,\\n  // @ts-expect-error: hush.\\n  invalid: exists,\\n  handlers: {\\n    '=': exact,\\n    '~=': spaceSeparatedList,\\n    '|=': exactOrPrefix,\\n    '^=': begins,\\n    '$=': ends,\\n    '*=': contains\\n  }\\n});\\n/**\\n * @param {Rule} query\\n * @param {Element} element\\n * @param {Schema} schema\\n * @returns {boolean}\\n */\\n\\nfunction attribute(query, element, schema) {\\n  const attrs = query.attrs;\\n  let index = -1;\\n\\n  while (++index < attrs.length) {\\n    if (!handle(attrs[index], element, (0, _propertyInformation.find)(schema, attrs[index].name))) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n/**\\n * Check whether an attribute exists.\\n *\\n * `[attr]`\\n *\\n * @param {RuleAttr} _\\n * @param {Element} element\\n * @param {Info} info\\n * @returns {boolean}\\n */\\n\\n\\nfunction exists(_, element, info) {\\n  return (0, _hastUtilHasProperty.hasProperty)(element, info.property);\\n}\\n/**\\n * Check whether an attribute has an exact value.\\n *\\n * `[attr=value]`\\n *\\n * @param {RuleAttr} query\\n * @param {Element} element\\n * @param {Info} info\\n * @returns {boolean}\\n */\\n\\n\\nfunction exact(query, element, info) {\\n  return Boolean((0, _hastUtilHasProperty.hasProperty)(element, info.property) && element.properties && normalizeValue(element.properties[info.property], info) === query.value);\\n}\\n/**\\n * Check whether an attribute, interpreted as a space-separated list, contains\\n * a value.\\n *\\n * `[attr~=value]`\\n *\\n * @param {RuleAttr} query\\n * @param {Element} element\\n * @param {Info} info\\n * @returns {boolean}\\n */\\n\\n\\nfunction spaceSeparatedList(query, element, info) {\\n  const value = element.properties && element.properties[info.property];\\n  return (// If this is a space-separated list, and the query is contained in it, return\\n    // true.\\n    !info.commaSeparated && value && typeof value === 'object' && query.value && value.includes(query.value) || (0, _hastUtilHasProperty.hasProperty)(element, info.property) && normalizeValue(value, info) === query.value\\n  );\\n}\\n/**\\n * Check whether an attribute has a substring as either the exact value or a\\n * prefix.\\n *\\n * `[attr|=value]`\\n *\\n * @param {RuleAttr} query\\n * @param {Element} element\\n * @param {Info} info\\n * @returns {boolean}\\n */\\n\\n\\nfunction exactOrPrefix(query, element, info) {\\n  const value = normalizeValue(element.properties && element.properties[info.property], info);\\n  return Boolean((0, _hastUtilHasProperty.hasProperty)(element, info.property) && query.value && (value === query.value || value.slice(0, query.value.length) === query.value && value.charAt(query.value.length) === '-'));\\n}\\n/**\\n * Check whether an attribute has a substring as its start.\\n *\\n * `[attr^=value]`\\n *\\n * @param {RuleAttr} query\\n * @param {Element} element\\n * @param {Info} info\\n * @returns {boolean}\\n */\\n\\n\\nfunction begins(query, element, info) {\\n  return Boolean((0, _hastUtilHasProperty.hasProperty)(element, info.property) && element.properties && query.value && normalizeValue(element.properties[info.property], info).slice(0, query.value.length) === query.value);\\n}\\n/**\\n * Check whether an attribute has a substring as its end.\\n *\\n * `[attr$=value]`\\n *\\n * @param {RuleAttr} query\\n * @param {Element} element\\n * @param {Info} info\\n * @returns {boolean}\\n */\\n\\n\\nfunction ends(query, element, info) {\\n  return Boolean((0, _hastUtilHasProperty.hasProperty)(element, info.property) && element.properties && query.value && normalizeValue(element.properties[info.property], info).slice(-query.value.length) === query.value);\\n}\\n/**\\n * Check whether an attribute contains a substring.\\n *\\n * `[attr*=value]`\\n *\\n * @param {RuleAttr} query\\n * @param {Element} element\\n * @param {Info} info\\n * @returns {boolean}\\n */\\n\\n\\nfunction contains(query, element, info) {\\n  return Boolean((0, _hastUtilHasProperty.hasProperty)(element, info.property) && element.properties && query.value && normalizeValue(element.properties[info.property], info).includes(query.value));\\n} // Shouldn\\u2019t be called, Parser throws an error instead.\\n\\n/**\\n * @param {unknown} query\\n * @returns {never}\\n */\\n\\n/* c8 ignore next 4 */\\n\\n\\nfunction unknownOperator(query) {\\n  // @ts-expect-error: `operator` guaranteed.\\n  throw new Error('Unknown operator `' + query.operator + '`');\\n}\\n/**\\n * Stringify a hast value back to its HTML form.\\n *\\n * @param {PropertyValue} value\\n * @param {Info} info\\n * @returns {string}\\n */\\n\\n\\nfunction normalizeValue(value, info) {\\n  if (typeof value === 'boolean') {\\n    return info.attribute;\\n  }\\n\\n  if (Array.isArray(value)) {\\n    return (info.commaSeparated ? _commaSeparatedTokens.stringify : _spaceSeparatedTokens.stringify)(value);\\n  }\\n\\n  return String(value);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"normalizeValue\",\"value\",\"info\",\"attribute\",\"Array\",\"isArray\",\"commaSeparated\",\"_commaSeparatedTokens\",\"stringify\",\"_spaceSeparatedTokens\",\"String\",\"Object\",\"defineProperty\",\"query\",\"element\",\"schema\",\"attrs\",\"index\",\"length\",\"handle\",\"_propertyInformation\",\"find\",\"name\",\"_hastUtilHasProperty\",\"_zwitch\",\"zwitch\",\"unknown\",\"unknownOperator\",\"Error\",\"operator\",\"invalid\",\"exists\",\"_\",\"hasProperty\",\"property\",\"handlers\",\"exact\",\"properties\",\"spaceSeparatedList\",\"includes\",\"exactOrPrefix\",\"slice\",\"charAt\",\"begins\",\"ends\",\"contains\"]\n}\n"]