["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vfile/lib/index.js"],"~:js","shadow$provide.module$node_modules$vfile$lib$index=function(global,require,module,exports){function assertPart(part,name){if(part&&part.includes(_minpath.path.sep))throw Error(\"`\"+name+\"` cannot be a path: did not expect `\"+_minpath.path.sep+\"`\");}function assertNonEmpty(part,name){if(!part)throw Error(\"`\"+name+\"` cannot be empty\");}function assertPath(path,name){if(!path)throw Error(\"Setting `\"+name+\"` requires `path` to be set too\");}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.VFile=\nvoid 0;var _isBuffer=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(require(\"module$node_modules$is_buffer$index\")),_vfileMessage=require(\"module$node_modules$vfile_message$index\"),_minpath=require(\"module$node_modules$vfile$lib$minpath_browser\"),_minproc=require(\"module$node_modules$vfile$lib$minproc_browser\"),_minurl=require(\"module$node_modules$vfile$lib$minurl_browser\");const order=\"history path basename stem extname dirname\".split(\" \");class VFile{constructor(value){value=value?\n\"string\"===typeof value||(0,_isBuffer.default)(value)?{value}:(0,_minurl.isUrl)(value)?{path:value}:value:{};this.data={};this.messages=[];this.history=[];this.cwd=_minproc.proc.cwd();let index=-1;for(;++index<order.length;){const prop=order[index];prop in value&&void 0!==value[prop]&&null!==value[prop]&&(this[prop]=\"history\"===prop?[...value[prop]]:value[prop])}let prop$jscomp$0;for(prop$jscomp$0 in value)order.includes(prop$jscomp$0)||(this[prop$jscomp$0]=value[prop$jscomp$0])}get path(){return this.history[this.history.length-\n1]}set path(path){(0,_minurl.isUrl)(path)&&(path=(0,_minurl.urlToPath)(path));assertNonEmpty(path,\"path\");this.path!==path&&this.history.push(path)}get dirname(){return\"string\"===typeof this.path?_minpath.path.dirname(this.path):void 0}set dirname(dirname){assertPath(this.basename,\"dirname\");this.path=_minpath.path.join(dirname||\"\",this.basename)}get basename(){return\"string\"===typeof this.path?_minpath.path.basename(this.path):void 0}set basename(basename){assertNonEmpty(basename,\"basename\");assertPart(basename,\n\"basename\");this.path=_minpath.path.join(this.dirname||\"\",basename)}get extname(){return\"string\"===typeof this.path?_minpath.path.extname(this.path):void 0}set extname(extname){assertPart(extname,\"extname\");assertPath(this.dirname,\"extname\");if(extname){if(46!==extname.charCodeAt(0))throw Error(\"`extname` must start with `.`\");if(extname.includes(\".\",1))throw Error(\"`extname` cannot contain multiple dots\");}this.path=_minpath.path.join(this.dirname,this.stem+(extname||\"\"))}get stem(){return\"string\"===\ntypeof this.path?_minpath.path.basename(this.path,this.extname):void 0}set stem(stem){assertNonEmpty(stem,\"stem\");assertPart(stem,\"stem\");this.path=_minpath.path.join(this.dirname||\"\",stem+(this.extname||\"\"))}toString(encoding){return(this.value||\"\").toString(encoding||void 0)}message(reason,place,origin){reason=new _vfileMessage.VFileMessage(reason,place,origin);this.path&&(reason.name=this.path+\":\"+reason.name,reason.file=this.path);reason.fatal=!1;this.messages.push(reason);return reason}info(reason,\nplace,origin){reason=this.message(reason,place,origin);reason.fatal=null;return reason}fail(reason,place,origin){reason=this.message(reason,place,origin);reason.fatal=!0;throw reason;}}exports.VFile=VFile}","~:source","shadow$provide[\"module$node_modules$vfile$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VFile = void 0;\n\nvar _isBuffer = _interopRequireDefault(require(\"is-buffer\"));\n\nvar _vfileMessage = require(\"vfile-message\");\n\nvar _minpath = require(\"./minpath.js\");\n\nvar _minproc = require(\"./minproc.js\");\n\nvar _minurl = require(\"./minurl.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('./minurl.shared.js').URL} URL\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Value} Value\n */\n\n/**\n * @typedef {Record<string, unknown> & {type: string, position?: Position | undefined}} NodeLike\n *\n * @typedef {'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'base64url' | 'latin1' | 'binary' | 'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *\n *   This is a copy of the types from Node, copied to prevent Node globals from\n *   being needed.\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\n *\n * @typedef {Options | URL | Value | VFile} Compatible\n *   Things that can be passed to the constructor.\n *\n * @typedef VFileCoreOptions\n *   Set multiple values.\n * @property {Value | null | undefined} [value]\n *   Set `value`.\n * @property {string | null | undefined} [cwd]\n *   Set `cwd`.\n * @property {Array<string> | null | undefined} [history]\n *   Set `history`.\n * @property {URL | string | null | undefined} [path]\n *   Set `path`.\n * @property {string | null | undefined} [basename]\n *   Set `basename`.\n * @property {string | null | undefined} [stem]\n *   Set `stem`.\n * @property {string | null | undefined} [extname]\n *   Set `extname`.\n * @property {string | null | undefined} [dirname]\n *   Set `dirname`.\n * @property {Data | null | undefined} [data]\n *   Set `data`.\n *\n * @typedef Map\n *   Raw source map.\n *\n *   See:\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\n * @property {number} version\n *   Which version of the source map spec this map is following.\n * @property {Array<string>} sources\n *   An array of URLs to the original source files.\n * @property {Array<string>} names\n *   An array of identifiers which can be referenced by individual mappings.\n * @property {string | undefined} [sourceRoot]\n *   The URL root from which all sources are relative.\n * @property {Array<string> | undefined} [sourcesContent]\n *   An array of contents of the original source files.\n * @property {string} mappings\n *   A string of base64 VLQs which contain the actual mappings.\n * @property {string} file\n *   The generated file this source map is associated with.\n *\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options\n *   Configuration.\n *\n *   A bunch of keys that will be shallow copied over to the new file.\n *\n * @typedef {Record<string, unknown>} ReporterSettings\n *   Configuration for reporters.\n */\n\n/**\n * @template {ReporterSettings} Settings\n *   Options type.\n * @callback Reporter\n *   Type for a reporter.\n * @param {Array<VFile>} files\n *   Files to report.\n * @param {Settings} options\n *   Configuration.\n * @returns {string}\n *   Report.\n */\n\n/**\n * Order of setting (least specific to most), we need this because otherwise\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n * stem can be set.\n *\n * @type {Array<'basename' | 'dirname' | 'extname' | 'history' | 'path' | 'stem'>}\n */\nconst order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname'];\n\nclass VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Buffer` — `{value: options}`\n   * *   `URL` — `{path: options}`\n   * *   `VFile` — shallow copies its data over to the new file\n   * *   `object` — all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */\n  constructor(value) {\n    /** @type {Options | VFile} */\n    let options;\n\n    if (!value) {\n      options = {};\n    } else if (typeof value === 'string' || buffer(value)) {\n      options = {\n        value\n      };\n    } else if ((0, _minurl.isUrl)(value)) {\n      options = {\n        path: value\n      };\n    } else {\n      options = value;\n    }\n    /**\n     * Place to store custom information (default: `{}`).\n     *\n     * It’s OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     *\n     * @type {Data}\n     */\n\n\n    this.data = {};\n    /**\n     * List of messages associated with the file.\n     *\n     * @type {Array<VFileMessage>}\n     */\n\n    this.messages = [];\n    /**\n     * List of filepaths the file moved between.\n     *\n     * The first is the original path and the last is the current path.\n     *\n     * @type {Array<string>}\n     */\n\n    this.history = [];\n    /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     *\n     * @type {string}\n     */\n\n    this.cwd = _minproc.proc.cwd();\n    /* eslint-disable no-unused-expressions */\n\n    /**\n     * Raw value.\n     *\n     * @type {Value}\n     */\n\n    this.value; // The below are non-standard, they are “well-known”.\n    // As in, used in several tools.\n\n    /**\n     * Whether a file was saved to disk.\n     *\n     * This is used by vfile reporters.\n     *\n     * @type {boolean}\n     */\n\n    this.stored;\n    /**\n     * Custom, non-string, compiled, representation.\n     *\n     * This is used by unified to store non-string results.\n     * One example is when turning markdown into React nodes.\n     *\n     * @type {unknown}\n     */\n\n    this.result;\n    /**\n     * Source map.\n     *\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\n     * module.\n     *\n     * @type {Map | null | undefined}\n     */\n\n    this.map;\n    /* eslint-enable no-unused-expressions */\n    // Set path related properties in the correct order.\n\n    let index = -1;\n\n    while (++index < order.length) {\n      const prop = order[index]; // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n\n      if (prop in options && options[prop] !== undefined && options[prop] !== null) {\n        // @ts-expect-error: TS doesn’t understand basic reality.\n        this[prop] = prop === 'history' ? [...options[prop]] : options[prop];\n      }\n    }\n    /** @type {string} */\n\n\n    let prop; // Set non-path related properties.\n\n    for (prop in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(prop)) {\n        // @ts-expect-error: fine to set other things.\n        this[prop] = options[prop];\n      }\n    }\n  }\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   */\n\n\n  get path() {\n    return this.history[this.history.length - 1];\n  }\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {string | URL} path\n   */\n\n\n  set path(path) {\n    if ((0, _minurl.isUrl)(path)) {\n      path = (0, _minurl.urlToPath)(path);\n    }\n\n    assertNonEmpty(path, 'path');\n\n    if (this.path !== path) {\n      this.history.push(path);\n    }\n  }\n  /**\n   * Get the parent path (example: `'~'`).\n   */\n\n\n  get dirname() {\n    return typeof this.path === 'string' ? _minpath.path.dirname(this.path) : undefined;\n  }\n  /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if there’s no `path` yet.\n   */\n\n\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname');\n    this.path = _minpath.path.join(dirname || '', this.basename);\n  }\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   */\n\n\n  get basename() {\n    return typeof this.path === 'string' ? _minpath.path.basename(this.path) : undefined;\n  }\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n\n\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename');\n    assertPart(basename, 'basename');\n    this.path = _minpath.path.join(this.dirname || '', basename);\n  }\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   */\n\n\n  get extname() {\n    return typeof this.path === 'string' ? _minpath.path.extname(this.path) : undefined;\n  }\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if there’s no `path` yet.\n   */\n\n\n  set extname(extname) {\n    assertPart(extname, 'extname');\n    assertPath(this.dirname, 'extname');\n\n    if (extname) {\n      if (extname.charCodeAt(0) !== 46\n      /* `.` */\n      ) {\n        throw new Error('`extname` must start with `.`');\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots');\n      }\n    }\n\n    this.path = _minpath.path.join(this.dirname, this.stem + (extname || ''));\n  }\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   */\n\n\n  get stem() {\n    return typeof this.path === 'string' ? _minpath.path.basename(this.path, this.extname) : undefined;\n  }\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n\n\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem');\n    assertPart(stem, 'stem');\n    this.path = _minpath.path.join(this.dirname || '', stem + (this.extname || ''));\n  }\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when it’s a `Buffer`\n   *   (default: `'utf8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n\n\n  toString(encoding) {\n    return (this.value || '').toString(encoding || undefined);\n  }\n  /**\n   * Create a warning message associated with the file.\n   *\n   * Its `fatal` is set to `false` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n\n\n  message(reason, place, origin) {\n    const message = new _vfileMessage.VFileMessage(reason, place, origin);\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name;\n      message.file = this.path;\n    }\n\n    message.fatal = false;\n    this.messages.push(message);\n    return message;\n  }\n  /**\n   * Create an info message associated with the file.\n   *\n   * Its `fatal` is set to `null` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n\n\n  info(reason, place, origin) {\n    const message = this.message(reason, place, origin);\n    message.fatal = null;\n    return message;\n  }\n  /**\n   * Create a fatal error associated with the file.\n   *\n   * Its `fatal` is set to `true` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * > \uD83D\uDC49 **Note**: a fatal error means that a file is no longer processable.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Message.\n   * @throws {VFileMessage}\n   *   Message.\n   */\n\n\n  fail(reason, place, origin) {\n    const message = this.message(reason, place, origin);\n    message.fatal = true;\n    throw message;\n  }\n\n}\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string | null | undefined} part\n *   File path part.\n * @param {string} name\n *   Part name.\n * @returns {void}\n *   Nothing.\n */\n\n\nexports.VFile = VFile;\n\nfunction assertPart(part, name) {\n  if (part && part.includes(_minpath.path.sep)) {\n    throw new Error('`' + name + '` cannot be a path: did not expect `' + _minpath.path.sep + '`');\n  }\n}\n/**\n * Assert that `part` is not empty.\n *\n * @param {string | undefined} part\n *   Thing.\n * @param {string} name\n *   Part name.\n * @returns {asserts part is string}\n *   Nothing.\n */\n\n\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty');\n  }\n}\n/**\n * Assert `path` exists.\n *\n * @param {string | undefined} path\n *   Path.\n * @param {string} name\n *   Dependency name.\n * @returns {asserts path is string}\n *   Nothing.\n */\n\n\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too');\n  }\n}\n/**\n * Assert `value` is a buffer.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Buffer}\n *   Whether `value` is a Node.js buffer.\n */\n\n\nfunction buffer(value) {\n  return (0, _isBuffer.default)(value);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vfile$lib$minurl_browser","~$shadow.js","~$module$node_modules$vfile_message$index","~$module$node_modules$is_buffer$index","~$module$node_modules$vfile$lib$minproc_browser","~$module$node_modules$vfile$lib$minpath_browser"]],"~:properties",["^5",["fatal","VFile","__esModule","path","cwd","name","value","history","file","messages","data","default"]],"~:compiled-at",1676665867242,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vfile$lib$index.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vfile/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vfile$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.VFile = void 0;\\n\\nvar _isBuffer = _interopRequireDefault(require(\\\"is-buffer\\\"));\\n\\nvar _vfileMessage = require(\\\"vfile-message\\\");\\n\\nvar _minpath = require(\\\"./minpath.js\\\");\\n\\nvar _minproc = require(\\\"./minproc.js\\\");\\n\\nvar _minurl = require(\\\"./minurl.js\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n/**\\n * @typedef {import('unist').Node} Node\\n * @typedef {import('unist').Position} Position\\n * @typedef {import('unist').Point} Point\\n * @typedef {import('./minurl.shared.js').URL} URL\\n * @typedef {import('../index.js').Data} Data\\n * @typedef {import('../index.js').Value} Value\\n */\\n\\n/**\\n * @typedef {Record<string, unknown> & {type: string, position?: Position | undefined}} NodeLike\\n *\\n * @typedef {'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'base64url' | 'latin1' | 'binary' | 'hex'} BufferEncoding\\n *   Encodings supported by the buffer class.\\n *\\n *   This is a copy of the types from Node, copied to prevent Node globals from\\n *   being needed.\\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\\n *\\n * @typedef {Options | URL | Value | VFile} Compatible\\n *   Things that can be passed to the constructor.\\n *\\n * @typedef VFileCoreOptions\\n *   Set multiple values.\\n * @property {Value | null | undefined} [value]\\n *   Set `value`.\\n * @property {string | null | undefined} [cwd]\\n *   Set `cwd`.\\n * @property {Array<string> | null | undefined} [history]\\n *   Set `history`.\\n * @property {URL | string | null | undefined} [path]\\n *   Set `path`.\\n * @property {string | null | undefined} [basename]\\n *   Set `basename`.\\n * @property {string | null | undefined} [stem]\\n *   Set `stem`.\\n * @property {string | null | undefined} [extname]\\n *   Set `extname`.\\n * @property {string | null | undefined} [dirname]\\n *   Set `dirname`.\\n * @property {Data | null | undefined} [data]\\n *   Set `data`.\\n *\\n * @typedef Map\\n *   Raw source map.\\n *\\n *   See:\\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\\n * @property {number} version\\n *   Which version of the source map spec this map is following.\\n * @property {Array<string>} sources\\n *   An array of URLs to the original source files.\\n * @property {Array<string>} names\\n *   An array of identifiers which can be referenced by individual mappings.\\n * @property {string | undefined} [sourceRoot]\\n *   The URL root from which all sources are relative.\\n * @property {Array<string> | undefined} [sourcesContent]\\n *   An array of contents of the original source files.\\n * @property {string} mappings\\n *   A string of base64 VLQs which contain the actual mappings.\\n * @property {string} file\\n *   The generated file this source map is associated with.\\n *\\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options\\n *   Configuration.\\n *\\n *   A bunch of keys that will be shallow copied over to the new file.\\n *\\n * @typedef {Record<string, unknown>} ReporterSettings\\n *   Configuration for reporters.\\n */\\n\\n/**\\n * @template {ReporterSettings} Settings\\n *   Options type.\\n * @callback Reporter\\n *   Type for a reporter.\\n * @param {Array<VFile>} files\\n *   Files to report.\\n * @param {Settings} options\\n *   Configuration.\\n * @returns {string}\\n *   Report.\\n */\\n\\n/**\\n * Order of setting (least specific to most), we need this because otherwise\\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\\n * stem can be set.\\n *\\n * @type {Array<'basename' | 'dirname' | 'extname' | 'history' | 'path' | 'stem'>}\\n */\\nconst order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname'];\\n\\nclass VFile {\\n  /**\\n   * Create a new virtual file.\\n   *\\n   * `options` is treated as:\\n   *\\n   * *   `string` or `Buffer` \\u2014 `{value: options}`\\n   * *   `URL` \\u2014 `{path: options}`\\n   * *   `VFile` \\u2014 shallow copies its data over to the new file\\n   * *   `object` \\u2014 all fields are shallow copied over to the new file\\n   *\\n   * Path related fields are set in the following order (least specific to\\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\\n   * `dirname`.\\n   *\\n   * You cannot set `dirname` or `extname` without setting either `history`,\\n   * `path`, `basename`, or `stem` too.\\n   *\\n   * @param {Compatible | null | undefined} [value]\\n   *   File value.\\n   * @returns\\n   *   New instance.\\n   */\\n  constructor(value) {\\n    /** @type {Options | VFile} */\\n    let options;\\n\\n    if (!value) {\\n      options = {};\\n    } else if (typeof value === 'string' || buffer(value)) {\\n      options = {\\n        value\\n      };\\n    } else if ((0, _minurl.isUrl)(value)) {\\n      options = {\\n        path: value\\n      };\\n    } else {\\n      options = value;\\n    }\\n    /**\\n     * Place to store custom information (default: `{}`).\\n     *\\n     * It\\u2019s OK to store custom data directly on the file but moving it to\\n     * `data` is recommended.\\n     *\\n     * @type {Data}\\n     */\\n\\n\\n    this.data = {};\\n    /**\\n     * List of messages associated with the file.\\n     *\\n     * @type {Array<VFileMessage>}\\n     */\\n\\n    this.messages = [];\\n    /**\\n     * List of filepaths the file moved between.\\n     *\\n     * The first is the original path and the last is the current path.\\n     *\\n     * @type {Array<string>}\\n     */\\n\\n    this.history = [];\\n    /**\\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\\n     *\\n     * @type {string}\\n     */\\n\\n    this.cwd = _minproc.proc.cwd();\\n    /* eslint-disable no-unused-expressions */\\n\\n    /**\\n     * Raw value.\\n     *\\n     * @type {Value}\\n     */\\n\\n    this.value; // The below are non-standard, they are \\u201cwell-known\\u201d.\\n    // As in, used in several tools.\\n\\n    /**\\n     * Whether a file was saved to disk.\\n     *\\n     * This is used by vfile reporters.\\n     *\\n     * @type {boolean}\\n     */\\n\\n    this.stored;\\n    /**\\n     * Custom, non-string, compiled, representation.\\n     *\\n     * This is used by unified to store non-string results.\\n     * One example is when turning markdown into React nodes.\\n     *\\n     * @type {unknown}\\n     */\\n\\n    this.result;\\n    /**\\n     * Source map.\\n     *\\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\\n     * module.\\n     *\\n     * @type {Map | null | undefined}\\n     */\\n\\n    this.map;\\n    /* eslint-enable no-unused-expressions */\\n    // Set path related properties in the correct order.\\n\\n    let index = -1;\\n\\n    while (++index < order.length) {\\n      const prop = order[index]; // Note: we specifically use `in` instead of `hasOwnProperty` to accept\\n      // `vfile`s too.\\n\\n      if (prop in options && options[prop] !== undefined && options[prop] !== null) {\\n        // @ts-expect-error: TS doesn\\u2019t understand basic reality.\\n        this[prop] = prop === 'history' ? [...options[prop]] : options[prop];\\n      }\\n    }\\n    /** @type {string} */\\n\\n\\n    let prop; // Set non-path related properties.\\n\\n    for (prop in options) {\\n      // @ts-expect-error: fine to set other things.\\n      if (!order.includes(prop)) {\\n        // @ts-expect-error: fine to set other things.\\n        this[prop] = options[prop];\\n      }\\n    }\\n  }\\n  /**\\n   * Get the full path (example: `'~/index.min.js'`).\\n   *\\n   * @returns {string}\\n   */\\n\\n\\n  get path() {\\n    return this.history[this.history.length - 1];\\n  }\\n  /**\\n   * Set the full path (example: `'~/index.min.js'`).\\n   *\\n   * Cannot be nullified.\\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\\n   * be turned into a path with `url.fileURLToPath`.\\n   *\\n   * @param {string | URL} path\\n   */\\n\\n\\n  set path(path) {\\n    if ((0, _minurl.isUrl)(path)) {\\n      path = (0, _minurl.urlToPath)(path);\\n    }\\n\\n    assertNonEmpty(path, 'path');\\n\\n    if (this.path !== path) {\\n      this.history.push(path);\\n    }\\n  }\\n  /**\\n   * Get the parent path (example: `'~'`).\\n   */\\n\\n\\n  get dirname() {\\n    return typeof this.path === 'string' ? _minpath.path.dirname(this.path) : undefined;\\n  }\\n  /**\\n   * Set the parent path (example: `'~'`).\\n   *\\n   * Cannot be set if there\\u2019s no `path` yet.\\n   */\\n\\n\\n  set dirname(dirname) {\\n    assertPath(this.basename, 'dirname');\\n    this.path = _minpath.path.join(dirname || '', this.basename);\\n  }\\n  /**\\n   * Get the basename (including extname) (example: `'index.min.js'`).\\n   */\\n\\n\\n  get basename() {\\n    return typeof this.path === 'string' ? _minpath.path.basename(this.path) : undefined;\\n  }\\n  /**\\n   * Set basename (including extname) (`'index.min.js'`).\\n   *\\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\\\'`\\n   * on windows).\\n   * Cannot be nullified (use `file.path = file.dirname` instead).\\n   */\\n\\n\\n  set basename(basename) {\\n    assertNonEmpty(basename, 'basename');\\n    assertPart(basename, 'basename');\\n    this.path = _minpath.path.join(this.dirname || '', basename);\\n  }\\n  /**\\n   * Get the extname (including dot) (example: `'.js'`).\\n   */\\n\\n\\n  get extname() {\\n    return typeof this.path === 'string' ? _minpath.path.extname(this.path) : undefined;\\n  }\\n  /**\\n   * Set the extname (including dot) (example: `'.js'`).\\n   *\\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\\\'`\\n   * on windows).\\n   * Cannot be set if there\\u2019s no `path` yet.\\n   */\\n\\n\\n  set extname(extname) {\\n    assertPart(extname, 'extname');\\n    assertPath(this.dirname, 'extname');\\n\\n    if (extname) {\\n      if (extname.charCodeAt(0) !== 46\\n      /* `.` */\\n      ) {\\n        throw new Error('`extname` must start with `.`');\\n      }\\n\\n      if (extname.includes('.', 1)) {\\n        throw new Error('`extname` cannot contain multiple dots');\\n      }\\n    }\\n\\n    this.path = _minpath.path.join(this.dirname, this.stem + (extname || ''));\\n  }\\n  /**\\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\\n   */\\n\\n\\n  get stem() {\\n    return typeof this.path === 'string' ? _minpath.path.basename(this.path, this.extname) : undefined;\\n  }\\n  /**\\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\\n   *\\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\\\'`\\n   * on windows).\\n   * Cannot be nullified (use `file.path = file.dirname` instead).\\n   */\\n\\n\\n  set stem(stem) {\\n    assertNonEmpty(stem, 'stem');\\n    assertPart(stem, 'stem');\\n    this.path = _minpath.path.join(this.dirname || '', stem + (this.extname || ''));\\n  }\\n  /**\\n   * Serialize the file.\\n   *\\n   * @param {BufferEncoding | null | undefined} [encoding='utf8']\\n   *   Character encoding to understand `value` as when it\\u2019s a `Buffer`\\n   *   (default: `'utf8'`).\\n   * @returns {string}\\n   *   Serialized file.\\n   */\\n\\n\\n  toString(encoding) {\\n    return (this.value || '').toString(encoding || undefined);\\n  }\\n  /**\\n   * Create a warning message associated with the file.\\n   *\\n   * Its `fatal` is set to `false` and `file` is set to the current file path.\\n   * Its added to `file.messages`.\\n   *\\n   * @param {string | Error | VFileMessage} reason\\n   *   Reason for message, uses the stack and message of the error if given.\\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\\n   *   Place in file where the message occurred.\\n   * @param {string | null | undefined} [origin]\\n   *   Place in code where the message originates (example:\\n   *   `'my-package:my-rule'` or `'my-rule'`).\\n   * @returns {VFileMessage}\\n   *   Message.\\n   */\\n\\n\\n  message(reason, place, origin) {\\n    const message = new _vfileMessage.VFileMessage(reason, place, origin);\\n\\n    if (this.path) {\\n      message.name = this.path + ':' + message.name;\\n      message.file = this.path;\\n    }\\n\\n    message.fatal = false;\\n    this.messages.push(message);\\n    return message;\\n  }\\n  /**\\n   * Create an info message associated with the file.\\n   *\\n   * Its `fatal` is set to `null` and `file` is set to the current file path.\\n   * Its added to `file.messages`.\\n   *\\n   * @param {string | Error | VFileMessage} reason\\n   *   Reason for message, uses the stack and message of the error if given.\\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\\n   *   Place in file where the message occurred.\\n   * @param {string | null | undefined} [origin]\\n   *   Place in code where the message originates (example:\\n   *   `'my-package:my-rule'` or `'my-rule'`).\\n   * @returns {VFileMessage}\\n   *   Message.\\n   */\\n\\n\\n  info(reason, place, origin) {\\n    const message = this.message(reason, place, origin);\\n    message.fatal = null;\\n    return message;\\n  }\\n  /**\\n   * Create a fatal error associated with the file.\\n   *\\n   * Its `fatal` is set to `true` and `file` is set to the current file path.\\n   * Its added to `file.messages`.\\n   *\\n   * > \\ud83d\\udc49 **Note**: a fatal error means that a file is no longer processable.\\n   *\\n   * @param {string | Error | VFileMessage} reason\\n   *   Reason for message, uses the stack and message of the error if given.\\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\\n   *   Place in file where the message occurred.\\n   * @param {string | null | undefined} [origin]\\n   *   Place in code where the message originates (example:\\n   *   `'my-package:my-rule'` or `'my-rule'`).\\n   * @returns {never}\\n   *   Message.\\n   * @throws {VFileMessage}\\n   *   Message.\\n   */\\n\\n\\n  fail(reason, place, origin) {\\n    const message = this.message(reason, place, origin);\\n    message.fatal = true;\\n    throw message;\\n  }\\n\\n}\\n/**\\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\\n *\\n * @param {string | null | undefined} part\\n *   File path part.\\n * @param {string} name\\n *   Part name.\\n * @returns {void}\\n *   Nothing.\\n */\\n\\n\\nexports.VFile = VFile;\\n\\nfunction assertPart(part, name) {\\n  if (part && part.includes(_minpath.path.sep)) {\\n    throw new Error('`' + name + '` cannot be a path: did not expect `' + _minpath.path.sep + '`');\\n  }\\n}\\n/**\\n * Assert that `part` is not empty.\\n *\\n * @param {string | undefined} part\\n *   Thing.\\n * @param {string} name\\n *   Part name.\\n * @returns {asserts part is string}\\n *   Nothing.\\n */\\n\\n\\nfunction assertNonEmpty(part, name) {\\n  if (!part) {\\n    throw new Error('`' + name + '` cannot be empty');\\n  }\\n}\\n/**\\n * Assert `path` exists.\\n *\\n * @param {string | undefined} path\\n *   Path.\\n * @param {string} name\\n *   Dependency name.\\n * @returns {asserts path is string}\\n *   Nothing.\\n */\\n\\n\\nfunction assertPath(path, name) {\\n  if (!path) {\\n    throw new Error('Setting `' + name + '` requires `path` to be set too');\\n  }\\n}\\n/**\\n * Assert `value` is a buffer.\\n *\\n * @param {unknown} value\\n *   thing.\\n * @returns {value is Buffer}\\n *   Whether `value` is a Node.js buffer.\\n */\\n\\n\\nfunction buffer(value) {\\n  return (0, _isBuffer.default)(value);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"assertPart\",\"part\",\"name\",\"includes\",\"_minpath\",\"path\",\"sep\",\"Error\",\"assertNonEmpty\",\"assertPath\",\"Object\",\"defineProperty\",\"value\",\"VFile\",\"_isBuffer\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"default\",\"_vfileMessage\",\"_minproc\",\"_minurl\",\"order\",\"constructor\",\"options\",\"isUrl\",\"data\",\"messages\",\"history\",\"cwd\",\"proc\",\"index\",\"length\",\"prop\",\"undefined\",\"urlToPath\",\"push\",\"dirname\",\"basename\",\"join\",\"extname\",\"charCodeAt\",\"stem\",\"toString\",\"encoding\",\"message\",\"reason\",\"place\",\"origin\",\"VFileMessage\",\"file\",\"fatal\",\"info\",\"fail\"]\n}\n"]