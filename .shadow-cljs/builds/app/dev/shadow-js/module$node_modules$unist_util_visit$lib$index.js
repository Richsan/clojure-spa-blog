["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/unist-util-visit/lib/index.js"],"~:js","shadow$provide.module$node_modules$unist_util_visit$lib$index=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});Object.defineProperty(exports,\"CONTINUE\",{enumerable:!0,get:function(){return _unistUtilVisitParents.CONTINUE}});Object.defineProperty(exports,\"EXIT\",{enumerable:!0,get:function(){return _unistUtilVisitParents.EXIT}});Object.defineProperty(exports,\"SKIP\",{enumerable:!0,get:function(){return _unistUtilVisitParents.SKIP}});exports.visit=void 0;\nvar _unistUtilVisitParents=require(\"module$node_modules$unist_util_visit_parents$index\");exports.visit=function(tree,test,visitor,reverse){\"function\"===typeof test&&\"function\"!==typeof visitor&&(reverse=visitor,visitor=test,test=null);(0,_unistUtilVisitParents.visitParents)(tree,test,function(node,parents){parents=parents[parents.length-1];return visitor(node,parents?parents.children.indexOf(node):null,parents)},reverse)}}","~:source","shadow$provide[\"module$node_modules$unist_util_visit$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"CONTINUE\", {\n  enumerable: true,\n  get: function () {\n    return _unistUtilVisitParents.CONTINUE;\n  }\n});\nObject.defineProperty(exports, \"EXIT\", {\n  enumerable: true,\n  get: function () {\n    return _unistUtilVisitParents.EXIT;\n  }\n});\nObject.defineProperty(exports, \"SKIP\", {\n  enumerable: true,\n  get: function () {\n    return _unistUtilVisitParents.SKIP;\n  }\n});\nexports.visit = void 0;\n\nvar _unistUtilVisitParents = require(\"unist-util-visit-parents\");\n\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nconst visit =\n/**\n * @param {Node} tree\n * @param {Test} test\n * @param {Visitor} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {void}\n */\nfunction (tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor;\n    visitor = test;\n    test = null;\n  }\n\n  (0, _unistUtilVisitParents.visitParents)(tree, test, overload, reverse);\n  /**\n   * @param {Node} node\n   * @param {Array<Parent>} parents\n   */\n\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1];\n    return visitor(node, parent ? parent.children.indexOf(node) : null, parent);\n  }\n};\n\nexports.visit = visit;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$unist_util_visit_parents$index","~$shadow.js"]],"~:properties",["^5",["CONTINUE","visit","__esModule","SKIP","value","EXIT","enumerable","get"]],"~:compiled-at",1676665867320,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$unist_util_visit$lib$index.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,8CAAA,CAAmE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG3GC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAF,OAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,UAA/B,CAA2C,CACzCI,WAAY,CAAA,CAD6B,CAEzCC,IAAKA,QAAS,EAAG,CACf,MAAOC,uBAAuBC,CAAAA,QADf,CAFwB,CAA3C,CAMAN,OAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,MAA/B,CAAuC,CACrCI,WAAY,CAAA,CADyB,CAErCC,IAAKA,QAAS,EAAG,CACf,MAAOC,uBAAuBE,CAAAA,IADf,CAFoB,CAAvC,CAMAP,OAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,MAA/B,CAAuC,CACrCI,WAAY,CAAA,CADyB,CAErCC,IAAKA,QAAS,EAAG,CACf,MAAOC,uBAAuBG,CAAAA,IADf,CAFoB,CAAvC,CAMAT,QAAQU,CAAAA,KAAR,CAAgB,IAAK,EAErB;IAAIJ,uBAAyBR,OAAA,CAAQ,oDAAR,CAyK7BE,QAAQU,CAAAA,KAAR,CAnBAA,QAAS,CAACC,IAAD,CAAOC,IAAP,CAAaC,OAAb,CAAsBC,OAAtB,CAA+B,CAClB,UAApB,GAAI,MAAOF,KAAX,EAAqD,UAArD,GAAkC,MAAOC,QAAzC,GACEC,OAEA,CAFUD,OAEV,CADAA,OACA,CADUD,IACV,CAAAA,IAAA,CAAO,IAHT,CAMA,IAAIN,sBAAuBS,CAAAA,YAA3B,EAAyCJ,IAAzC,CAA+CC,IAA/C,CAMAI,QAAiB,CAACC,IAAD,CAAOC,OAAP,CAAgB,CACzBC,OAAAA,CAASD,OAAA,CAAQA,OAAQE,CAAAA,MAAhB,CAAyB,CAAzB,CACf,OAAOP,QAAA,CAAQI,IAAR,CAAcE,OAAA,CAASA,OAAOE,CAAAA,QAASC,CAAAA,OAAhB,CAAwBL,IAAxB,CAAT,CAAyC,IAAvD,CAA6DE,OAA7D,CAFwB,CANjC,CAA+DL,OAA/D,CAPsC,CAhLmE;\",\n\"sources\":[\"node_modules/unist-util-visit/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$unist_util_visit$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nObject.defineProperty(exports, \\\"CONTINUE\\\", {\\n  enumerable: true,\\n  get: function () {\\n    return _unistUtilVisitParents.CONTINUE;\\n  }\\n});\\nObject.defineProperty(exports, \\\"EXIT\\\", {\\n  enumerable: true,\\n  get: function () {\\n    return _unistUtilVisitParents.EXIT;\\n  }\\n});\\nObject.defineProperty(exports, \\\"SKIP\\\", {\\n  enumerable: true,\\n  get: function () {\\n    return _unistUtilVisitParents.SKIP;\\n  }\\n});\\nexports.visit = void 0;\\n\\nvar _unistUtilVisitParents = require(\\\"unist-util-visit-parents\\\");\\n\\n/**\\n * @typedef {import('unist').Node} Node\\n * @typedef {import('unist').Parent} Parent\\n * @typedef {import('unist-util-is').Test} Test\\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\\n */\\n\\n/**\\n * Check if `Child` can be a child of `Ancestor`.\\n *\\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\\n * `never`.\\n *\\n * @template {Node} Ancestor\\n *   Node type.\\n * @template {Node} Child\\n *   Node type.\\n * @typedef {(\\n *   Ancestor extends Parent\\n *     ? Child extends Ancestor['children'][number]\\n *       ? Ancestor\\n *       : never\\n *     : never\\n * )} ParentsOf\\n */\\n\\n/**\\n * @template {Node} [Visited=Node]\\n *   Visited node type.\\n * @template {Parent} [Ancestor=Parent]\\n *   Ancestor type.\\n * @callback Visitor\\n *   Handle a node (matching `test`, if given).\\n *\\n *   Visitors are free to transform `node`.\\n *   They can also transform `parent`.\\n *\\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\\n *   descendants to be walked (which is a bug).\\n *\\n *   When adding or removing previous siblings of `node` (or next siblings, in\\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\\n *   sibling to traverse after `node` is traversed.\\n *   Adding or removing next siblings of `node` (or previous siblings, in case\\n *   of reverse) is handled as expected without needing to return a new `Index`.\\n *\\n *   Removing the children property of `parent` still results in them being\\n *   traversed.\\n * @param {Visited} node\\n *   Found node.\\n * @param {Visited extends Node ? number | null : never} index\\n *   Index of `node` in `parent`.\\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\\n *   Parent of `node`.\\n * @returns {VisitorResult}\\n *   What to do next.\\n *\\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\\n *   An `Action` is treated as a tuple of `[Action]`.\\n *\\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\\n *   When the `Action` is `EXIT`, that action can be returned.\\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\\n */\\n\\n/**\\n * Build a typed `Visitor` function from a node and all possible parents.\\n *\\n * It will infer which values are passed as `node` and which as `parent`.\\n *\\n * @template {Node} Visited\\n *   Node type.\\n * @template {Parent} Ancestor\\n *   Parent type.\\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\\n */\\n\\n/**\\n * Build a typed `Visitor` function from a list of descendants and a test.\\n *\\n * It will infer which values are passed as `node` and which as `parent`.\\n *\\n * @template {Node} Descendant\\n *   Node type.\\n * @template {Test} Check\\n *   Test type.\\n * @typedef {(\\n *   BuildVisitorFromMatch<\\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\\n *     Extract<Descendant, Parent>\\n *   >\\n * )} BuildVisitorFromDescendants\\n */\\n\\n/**\\n * Build a typed `Visitor` function from a tree and a test.\\n *\\n * It will infer which values are passed as `node` and which as `parent`.\\n *\\n * @template {Node} [Tree=Node]\\n *   Node type.\\n * @template {Test} [Check=string]\\n *   Test type.\\n * @typedef {(\\n *   BuildVisitorFromDescendants<\\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\\n *     Check\\n *   >\\n * )} BuildVisitor\\n */\\n\\n/**\\n * Visit nodes.\\n *\\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\\n *\\n * You can choose for which nodes `visitor` is called by passing a `test`.\\n * For complex tests, you should test yourself in `visitor`, as it will be\\n * faster and will have improved type information.\\n *\\n * Walking the tree is an intensive task.\\n * Make use of the return values of the visitor when possible.\\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\\n * to check if a node matches, and then perform different operations.\\n *\\n * You can change the tree.\\n * See `Visitor` for more info.\\n *\\n * @param tree\\n *   Tree to traverse.\\n * @param test\\n *   `unist-util-is`-compatible test\\n * @param visitor\\n *   Handle each node.\\n * @param reverse\\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\\n * @returns\\n *   Nothing.\\n */\\nconst visit =\\n/**\\n * @param {Node} tree\\n * @param {Test} test\\n * @param {Visitor} visitor\\n * @param {boolean | null | undefined} [reverse]\\n * @returns {void}\\n */\\nfunction (tree, test, visitor, reverse) {\\n  if (typeof test === 'function' && typeof visitor !== 'function') {\\n    reverse = visitor;\\n    visitor = test;\\n    test = null;\\n  }\\n\\n  (0, _unistUtilVisitParents.visitParents)(tree, test, overload, reverse);\\n  /**\\n   * @param {Node} node\\n   * @param {Array<Parent>} parents\\n   */\\n\\n  function overload(node, parents) {\\n    const parent = parents[parents.length - 1];\\n    return visitor(node, parent ? parent.children.indexOf(node) : null, parent);\\n  }\\n};\\n\\nexports.visit = visit;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"enumerable\",\"get\",\"_unistUtilVisitParents\",\"CONTINUE\",\"EXIT\",\"SKIP\",\"visit\",\"tree\",\"test\",\"visitor\",\"reverse\",\"visitParents\",\"overload\",\"node\",\"parents\",\"parent\",\"length\",\"children\",\"indexOf\"]\n}\n"]