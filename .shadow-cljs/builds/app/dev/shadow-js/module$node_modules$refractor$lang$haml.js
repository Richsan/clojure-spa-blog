["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/haml.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$haml=function(global,require,module,exports){function haml(Prism$jscomp$0){Prism$jscomp$0.register(_ruby.default);(function(Prism){Prism.languages.haml={\"multiline-comment\":{pattern:/((?:^|\\r?\\n|\\r)([\\t ]*))(?:\\/|-#).*(?:(?:\\r?\\n|\\r)\\2[\\t ].+)*/,lookbehind:!0,alias:\"comment\"},\"multiline-code\":[{pattern:/((?:^|\\r?\\n|\\r)([\\t ]*)(?:[~-]|[&!]?=)).*,[\\t ]*(?:(?:\\r?\\n|\\r)\\2[\\t ].*,[\\t ]*)*(?:(?:\\r?\\n|\\r)\\2[\\t ].+)/,lookbehind:!0,inside:Prism.languages.ruby},\n{pattern:/((?:^|\\r?\\n|\\r)([\\t ]*)(?:[~-]|[&!]?=)).*\\|[\\t ]*(?:(?:\\r?\\n|\\r)\\2[\\t ].*\\|[\\t ]*)*/,lookbehind:!0,inside:Prism.languages.ruby}],filter:{pattern:/((?:^|\\r?\\n|\\r)([\\t ]*)):[\\w-]+(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+/,lookbehind:!0,inside:{\"filter-name\":{pattern:/^:[\\w-]+/,alias:\"symbol\"}}},markup:{pattern:/((?:^|\\r?\\n|\\r)[\\t ]*)<.+/,lookbehind:!0,inside:Prism.languages.markup},doctype:{pattern:/((?:^|\\r?\\n|\\r)[\\t ]*)!!!(?: .+)?/,lookbehind:!0},tag:{pattern:/((?:^|\\r?\\n|\\r)[\\t ]*)[%.#][\\w\\-#.]*[\\w\\-](?:\\([^)]+\\)|\\{(?:\\{[^}]+\\}|[^{}])+\\}|\\[[^\\]]+\\])*[\\/<>]*/,\nlookbehind:!0,inside:{attributes:[{pattern:/(^|[^#])\\{(?:\\{[^}]+\\}|[^{}])+\\}/,lookbehind:!0,inside:Prism.languages.ruby},{pattern:/\\([^)]+\\)/,inside:{\"attr-value\":{pattern:/(=\\s*)(?:\"(?:\\\\.|[^\\\\\"\\r\\n])*\"|[^)\\s]+)/,lookbehind:!0},\"attr-name\":/[\\w:-]+(?=\\s*!?=|\\s*[,)])/,punctuation:/[=(),]/}},{pattern:/\\[[^\\]]+\\]/,inside:Prism.languages.ruby}],punctuation:/[<>]/}},code:{pattern:/((?:^|\\r?\\n|\\r)[\\t ]*(?:[~-]|[&!]?=)).+/,lookbehind:!0,inside:Prism.languages.ruby},interpolation:{pattern:/#\\{[^}]+\\}/,inside:{delimiter:{pattern:/^#\\{|\\}$/,\nalias:\"punctuation\"},ruby:{pattern:/[\\s\\S]+/,inside:Prism.languages.ruby}}},punctuation:{pattern:/((?:^|\\r?\\n|\\r)[\\t ]*)[~=\\-&!]+/,lookbehind:!0}};for(var filters=[\"css\",{filter:\"coffee\",language:\"coffeescript\"},\"erb\",\"javascript\",\"less\",\"markdown\",\"ruby\",\"scss\",\"textile\"],all_filters={},i=0,l=filters.length;i<l;i++){var filter=filters[i];filter=\"string\"===typeof filter?{filter,language:filter}:filter;Prism.languages[filter.language]&&(all_filters[\"filter-\"+filter.filter]={pattern:RegExp(\"((?:^|\\\\r?\\\\n|\\\\r)([\\\\t ]*)):{{filter_name}}(?:(?:\\\\r?\\\\n|\\\\r)(?:\\\\2[\\\\t ].+|\\\\s*?(?\\x3d\\\\r?\\\\n|\\\\r)))+\".replace(\"{{filter_name}}\",\nfunction(){return filter.filter})),lookbehind:!0,inside:{\"filter-name\":{pattern:/^:[\\w-]+/,alias:\"symbol\"},text:{pattern:/[\\s\\S]+/,alias:[filter.language,\"language-\"+filter.language],inside:Prism.languages[filter.language]}}})}Prism.languages.insertBefore(\"haml\",\"filter\",all_filters)})(Prism$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=haml;var _ruby=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(require(\"module$node_modules$refractor$lang$ruby\"));\nhaml.displayName=\"haml\";haml.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$haml\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = haml;\n\nvar _ruby = _interopRequireDefault(require(\"./ruby.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// @ts-nocheck\nhaml.displayName = 'haml';\nhaml.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction haml(Prism) {\n  Prism.register(_ruby.default)\n  /* TODO\n  Handle multiline code after tag\n  %foo= some |\n  multiline |\n  code |\n  */\n  ;\n\n  (function (Prism) {\n    Prism.languages.haml = {\n      // Multiline stuff should appear before the rest\n      'multiline-comment': {\n        pattern: /((?:^|\\r?\\n|\\r)([\\t ]*))(?:\\/|-#).*(?:(?:\\r?\\n|\\r)\\2[\\t ].+)*/,\n        lookbehind: true,\n        alias: 'comment'\n      },\n      'multiline-code': [{\n        pattern: /((?:^|\\r?\\n|\\r)([\\t ]*)(?:[~-]|[&!]?=)).*,[\\t ]*(?:(?:\\r?\\n|\\r)\\2[\\t ].*,[\\t ]*)*(?:(?:\\r?\\n|\\r)\\2[\\t ].+)/,\n        lookbehind: true,\n        inside: Prism.languages.ruby\n      }, {\n        pattern: /((?:^|\\r?\\n|\\r)([\\t ]*)(?:[~-]|[&!]?=)).*\\|[\\t ]*(?:(?:\\r?\\n|\\r)\\2[\\t ].*\\|[\\t ]*)*/,\n        lookbehind: true,\n        inside: Prism.languages.ruby\n      }],\n      // See at the end of the file for known filters\n      filter: {\n        pattern: /((?:^|\\r?\\n|\\r)([\\t ]*)):[\\w-]+(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+/,\n        lookbehind: true,\n        inside: {\n          'filter-name': {\n            pattern: /^:[\\w-]+/,\n            alias: 'symbol'\n          }\n        }\n      },\n      markup: {\n        pattern: /((?:^|\\r?\\n|\\r)[\\t ]*)<.+/,\n        lookbehind: true,\n        inside: Prism.languages.markup\n      },\n      doctype: {\n        pattern: /((?:^|\\r?\\n|\\r)[\\t ]*)!!!(?: .+)?/,\n        lookbehind: true\n      },\n      tag: {\n        // Allows for one nested group of braces\n        pattern: /((?:^|\\r?\\n|\\r)[\\t ]*)[%.#][\\w\\-#.]*[\\w\\-](?:\\([^)]+\\)|\\{(?:\\{[^}]+\\}|[^{}])+\\}|\\[[^\\]]+\\])*[\\/<>]*/,\n        lookbehind: true,\n        inside: {\n          attributes: [{\n            // Lookbehind tries to prevent interpolations from breaking it all\n            // Allows for one nested group of braces\n            pattern: /(^|[^#])\\{(?:\\{[^}]+\\}|[^{}])+\\}/,\n            lookbehind: true,\n            inside: Prism.languages.ruby\n          }, {\n            pattern: /\\([^)]+\\)/,\n            inside: {\n              'attr-value': {\n                pattern: /(=\\s*)(?:\"(?:\\\\.|[^\\\\\"\\r\\n])*\"|[^)\\s]+)/,\n                lookbehind: true\n              },\n              'attr-name': /[\\w:-]+(?=\\s*!?=|\\s*[,)])/,\n              punctuation: /[=(),]/\n            }\n          }, {\n            pattern: /\\[[^\\]]+\\]/,\n            inside: Prism.languages.ruby\n          }],\n          punctuation: /[<>]/\n        }\n      },\n      code: {\n        pattern: /((?:^|\\r?\\n|\\r)[\\t ]*(?:[~-]|[&!]?=)).+/,\n        lookbehind: true,\n        inside: Prism.languages.ruby\n      },\n      // Interpolations in plain text\n      interpolation: {\n        pattern: /#\\{[^}]+\\}/,\n        inside: {\n          delimiter: {\n            pattern: /^#\\{|\\}$/,\n            alias: 'punctuation'\n          },\n          ruby: {\n            pattern: /[\\s\\S]+/,\n            inside: Prism.languages.ruby\n          }\n        }\n      },\n      punctuation: {\n        pattern: /((?:^|\\r?\\n|\\r)[\\t ]*)[~=\\-&!]+/,\n        lookbehind: true\n      }\n    };\n    var filter_pattern = '((?:^|\\\\r?\\\\n|\\\\r)([\\\\t ]*)):{{filter_name}}(?:(?:\\\\r?\\\\n|\\\\r)(?:\\\\2[\\\\t ].+|\\\\s*?(?=\\\\r?\\\\n|\\\\r)))+'; // Non exhaustive list of available filters and associated languages\n\n    var filters = ['css', {\n      filter: 'coffee',\n      language: 'coffeescript'\n    }, 'erb', 'javascript', 'less', 'markdown', 'ruby', 'scss', 'textile'];\n    var all_filters = {};\n\n    for (var i = 0, l = filters.length; i < l; i++) {\n      var filter = filters[i];\n      filter = typeof filter === 'string' ? {\n        filter: filter,\n        language: filter\n      } : filter;\n\n      if (Prism.languages[filter.language]) {\n        all_filters['filter-' + filter.filter] = {\n          pattern: RegExp(filter_pattern.replace('{{filter_name}}', function () {\n            return filter.filter;\n          })),\n          lookbehind: true,\n          inside: {\n            'filter-name': {\n              pattern: /^:[\\w-]+/,\n              alias: 'symbol'\n            },\n            text: {\n              pattern: /[\\s\\S]+/,\n              alias: [filter.language, 'language-' + filter.language],\n              inside: Prism.languages[filter.language]\n            }\n          }\n        };\n      }\n    }\n\n    Prism.languages.insertBefore('haml', 'filter', all_filters);\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$refractor$lang$ruby"]],"~:properties",["^5",["punctuation","aliases","displayName","markup","__esModule","lookbehind","tag","value","delimiter","text","filter","ruby","attributes","pattern","inside","alias","language","doctype","interpolation","default","code","haml"]],"~:compiled-at",1676841365418,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$haml.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lang/haml.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$haml\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = haml;\\n\\nvar _ruby = _interopRequireDefault(require(\\\"./ruby.js\\\"));\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n// @ts-nocheck\\nhaml.displayName = 'haml';\\nhaml.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction haml(Prism) {\\n  Prism.register(_ruby.default)\\n  /* TODO\\n  Handle multiline code after tag\\n  %foo= some |\\n  multiline |\\n  code |\\n  */\\n  ;\\n\\n  (function (Prism) {\\n    Prism.languages.haml = {\\n      // Multiline stuff should appear before the rest\\n      'multiline-comment': {\\n        pattern: /((?:^|\\\\r?\\\\n|\\\\r)([\\\\t ]*))(?:\\\\/|-#).*(?:(?:\\\\r?\\\\n|\\\\r)\\\\2[\\\\t ].+)*/,\\n        lookbehind: true,\\n        alias: 'comment'\\n      },\\n      'multiline-code': [{\\n        pattern: /((?:^|\\\\r?\\\\n|\\\\r)([\\\\t ]*)(?:[~-]|[&!]?=)).*,[\\\\t ]*(?:(?:\\\\r?\\\\n|\\\\r)\\\\2[\\\\t ].*,[\\\\t ]*)*(?:(?:\\\\r?\\\\n|\\\\r)\\\\2[\\\\t ].+)/,\\n        lookbehind: true,\\n        inside: Prism.languages.ruby\\n      }, {\\n        pattern: /((?:^|\\\\r?\\\\n|\\\\r)([\\\\t ]*)(?:[~-]|[&!]?=)).*\\\\|[\\\\t ]*(?:(?:\\\\r?\\\\n|\\\\r)\\\\2[\\\\t ].*\\\\|[\\\\t ]*)*/,\\n        lookbehind: true,\\n        inside: Prism.languages.ruby\\n      }],\\n      // See at the end of the file for known filters\\n      filter: {\\n        pattern: /((?:^|\\\\r?\\\\n|\\\\r)([\\\\t ]*)):[\\\\w-]+(?:(?:\\\\r?\\\\n|\\\\r)(?:\\\\2[\\\\t ].+|\\\\s*?(?=\\\\r?\\\\n|\\\\r)))+/,\\n        lookbehind: true,\\n        inside: {\\n          'filter-name': {\\n            pattern: /^:[\\\\w-]+/,\\n            alias: 'symbol'\\n          }\\n        }\\n      },\\n      markup: {\\n        pattern: /((?:^|\\\\r?\\\\n|\\\\r)[\\\\t ]*)<.+/,\\n        lookbehind: true,\\n        inside: Prism.languages.markup\\n      },\\n      doctype: {\\n        pattern: /((?:^|\\\\r?\\\\n|\\\\r)[\\\\t ]*)!!!(?: .+)?/,\\n        lookbehind: true\\n      },\\n      tag: {\\n        // Allows for one nested group of braces\\n        pattern: /((?:^|\\\\r?\\\\n|\\\\r)[\\\\t ]*)[%.#][\\\\w\\\\-#.]*[\\\\w\\\\-](?:\\\\([^)]+\\\\)|\\\\{(?:\\\\{[^}]+\\\\}|[^{}])+\\\\}|\\\\[[^\\\\]]+\\\\])*[\\\\/<>]*/,\\n        lookbehind: true,\\n        inside: {\\n          attributes: [{\\n            // Lookbehind tries to prevent interpolations from breaking it all\\n            // Allows for one nested group of braces\\n            pattern: /(^|[^#])\\\\{(?:\\\\{[^}]+\\\\}|[^{}])+\\\\}/,\\n            lookbehind: true,\\n            inside: Prism.languages.ruby\\n          }, {\\n            pattern: /\\\\([^)]+\\\\)/,\\n            inside: {\\n              'attr-value': {\\n                pattern: /(=\\\\s*)(?:\\\"(?:\\\\\\\\.|[^\\\\\\\\\\\"\\\\r\\\\n])*\\\"|[^)\\\\s]+)/,\\n                lookbehind: true\\n              },\\n              'attr-name': /[\\\\w:-]+(?=\\\\s*!?=|\\\\s*[,)])/,\\n              punctuation: /[=(),]/\\n            }\\n          }, {\\n            pattern: /\\\\[[^\\\\]]+\\\\]/,\\n            inside: Prism.languages.ruby\\n          }],\\n          punctuation: /[<>]/\\n        }\\n      },\\n      code: {\\n        pattern: /((?:^|\\\\r?\\\\n|\\\\r)[\\\\t ]*(?:[~-]|[&!]?=)).+/,\\n        lookbehind: true,\\n        inside: Prism.languages.ruby\\n      },\\n      // Interpolations in plain text\\n      interpolation: {\\n        pattern: /#\\\\{[^}]+\\\\}/,\\n        inside: {\\n          delimiter: {\\n            pattern: /^#\\\\{|\\\\}$/,\\n            alias: 'punctuation'\\n          },\\n          ruby: {\\n            pattern: /[\\\\s\\\\S]+/,\\n            inside: Prism.languages.ruby\\n          }\\n        }\\n      },\\n      punctuation: {\\n        pattern: /((?:^|\\\\r?\\\\n|\\\\r)[\\\\t ]*)[~=\\\\-&!]+/,\\n        lookbehind: true\\n      }\\n    };\\n    var filter_pattern = '((?:^|\\\\\\\\r?\\\\\\\\n|\\\\\\\\r)([\\\\\\\\t ]*)):{{filter_name}}(?:(?:\\\\\\\\r?\\\\\\\\n|\\\\\\\\r)(?:\\\\\\\\2[\\\\\\\\t ].+|\\\\\\\\s*?(?=\\\\\\\\r?\\\\\\\\n|\\\\\\\\r)))+'; // Non exhaustive list of available filters and associated languages\\n\\n    var filters = ['css', {\\n      filter: 'coffee',\\n      language: 'coffeescript'\\n    }, 'erb', 'javascript', 'less', 'markdown', 'ruby', 'scss', 'textile'];\\n    var all_filters = {};\\n\\n    for (var i = 0, l = filters.length; i < l; i++) {\\n      var filter = filters[i];\\n      filter = typeof filter === 'string' ? {\\n        filter: filter,\\n        language: filter\\n      } : filter;\\n\\n      if (Prism.languages[filter.language]) {\\n        all_filters['filter-' + filter.filter] = {\\n          pattern: RegExp(filter_pattern.replace('{{filter_name}}', function () {\\n            return filter.filter;\\n          })),\\n          lookbehind: true,\\n          inside: {\\n            'filter-name': {\\n              pattern: /^:[\\\\w-]+/,\\n              alias: 'symbol'\\n            },\\n            text: {\\n              pattern: /[\\\\s\\\\S]+/,\\n              alias: [filter.language, 'language-' + filter.language],\\n              inside: Prism.languages[filter.language]\\n            }\\n          }\\n        };\\n      }\\n    }\\n\\n    Prism.languages.insertBefore('haml', 'filter', all_filters);\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"haml\",\"Prism\",\"register\",\"_ruby\",\"default\",\"languages\",\"pattern\",\"lookbehind\",\"alias\",\"inside\",\"ruby\",\"filter\",\"markup\",\"doctype\",\"tag\",\"attributes\",\"punctuation\",\"code\",\"interpolation\",\"delimiter\",\"filters\",\"language\",\"all_filters\",\"i\",\"l\",\"length\",\"RegExp\",\"filter_pattern\",\"replace\",\"text\",\"insertBefore\",\"Object\",\"defineProperty\",\"value\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"displayName\",\"aliases\"]\n}\n"]