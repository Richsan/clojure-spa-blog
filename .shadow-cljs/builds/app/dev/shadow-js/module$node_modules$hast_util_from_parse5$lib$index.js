["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hast-util-from-parse5/lib/index.js"],"~:js","shadow$provide.module$node_modules$hast_util_from_parse5$lib$index=function(global,require,module,exports){function one(state,node){switch(node.nodeName){case \"#comment\":var result={type:\"comment\",value:node.data};patch(state,node,result);return result;case \"#document\":case \"#document-fragment\":result=\"mode\"in node?\"quirks\"===node.mode||\"limited-quirks\"===node.mode:!1;result={type:\"root\",children:all(state,node.childNodes),data:{quirksMode:result}};if(state.file&&state.location){node=String(state.file);\nvar loc=(0,_vfileLocation.location)(node);state=loc.toPoint(0);node=loc.toPoint(node.length);result.position={start:state,end:node}}return result;case \"#documentType\":return result={type:\"doctype\"},patch(state,node,result),result;case \"#text\":return result={type:\"text\",value:node.value},patch(state,node,result),result;default:result=state.schema;state.schema=node.namespaceURI===_webNamespaces.webNamespaces.svg?_propertyInformation.svg:_propertyInformation.html;loc=-1;for(var props={};++loc<node.attrs.length;){var attribute=\nnode.attrs[loc];const name=(attribute.prefix?attribute.prefix+\":\":\"\")+attribute.name;own.call(proto,name)||(props[name]=attribute.value)}loc=(\"svg\"===state.schema.space?_hastscript.s:_hastscript.h)(node.tagName,props,all(state,node.childNodes));patch(state,node,loc);\"template\"===loc.tagName&&(props=(attribute=node.sourceCodeLocation)&&attribute.startTag&&position(attribute.startTag),attribute=attribute&&attribute.endTag&&position(attribute.endTag),node=one(state,node.content),props&&attribute&&state.file&&\n(node.position={start:props.end,end:attribute.start}),loc.content=node);state.schema=result;return result=loc}}function all(state,nodes){let index=-1;const result=[];for(;++index<nodes.length;)result[index]=one(state,nodes[index]);return result}function patch(state,from,to){if(\"sourceCodeLocation\"in from&&from.sourceCodeLocation&&state.file){var JSCompiler_inline_result;from=from.sourceCodeLocation;const result=position(from);if(\"element\"===to.type){var tail=to.children[to.children.length-1];result&&\n!from.endTag&&tail&&tail.position&&tail.position.end&&(result.end=Object.assign({},tail.position.end));if(state.verbose){tail={};if(from.attrs)for(JSCompiler_inline_result in from.attrs)own.call(from.attrs,JSCompiler_inline_result)&&(tail[(0,_propertyInformation.find)(state.schema,JSCompiler_inline_result).property]=position(from.attrs[JSCompiler_inline_result]));to.data={position:{opening:position(from.startTag),closing:from.endTag?position(from.endTag):null,properties:tail}}}}if(JSCompiler_inline_result=\nresult)state.location=!0,to.position=JSCompiler_inline_result}}function position(loc){const start=point$jscomp$0({line:loc.startLine,column:loc.startCol,offset:loc.startOffset});loc=point$jscomp$0({line:loc.endLine,column:loc.endCol,offset:loc.endOffset});return start||loc?{start,end:loc}:void 0}function point$jscomp$0(point){return point.line&&point.column?point:void 0}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.fromParse5=function(tree,options){var options_=options||{};\"messages\"in\noptions_?(options=options_,options_={}):options=options_.file||void 0;return one({schema:\"svg\"===options_.space?_propertyInformation.svg:_propertyInformation.html,file:options,verbose:options_.verbose,location:!1},tree)};var _hastscript=require(\"module$node_modules$hastscript$index\"),_propertyInformation=require(\"module$node_modules$property_information$index\"),_vfileLocation=require(\"module$node_modules$vfile_location$index\"),_webNamespaces=require(\"module$node_modules$web_namespaces$index\");const own=\n{}.hasOwnProperty,proto=Object.prototype}","~:source","shadow$provide[\"module$node_modules$hast_util_from_parse5$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromParse5 = fromParse5;\n\nvar _hastscript = require(\"hastscript\");\n\nvar _propertyInformation = require(\"property-information\");\n\nvar _vfileLocation = require(\"vfile-location\");\n\nvar _webNamespaces = require(\"web-namespaces\");\n\n/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {import('parse5').Token.ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Token.Location} P5Location\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5DocumentFragment\n * @typedef {DefaultTreeAdapterMap['documentType']} P5DocumentType\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['template']} P5Template\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in.\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {VFile | null | undefined} [file]\n *   File used to add positional info to nodes.\n *\n *   If given, the file should represent the original HTML source.\n * @property {boolean} [verbose=false]\n *   Whether to add extra positional info about starting tags, closing tags,\n *   and attributes to elements.\n *\n *   > \uD83D\uDC49 **Note**: only used when `file` is given.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {Schema} schema\n *   Current schema.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n * @property {boolean} location\n *   Whether location info was found.\n */\nconst own = {}.hasOwnProperty;\n/** @type {unknown} */\n// type-coverage:ignore-next-line\n\nconst proto = Object.prototype;\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {P5Node} tree\n *   `parse5` tree to transform.\n * @param {Options | VFile | null | undefined} [options]\n *   Configuration.\n * @returns {Node}\n *   hast tree.\n */\n\nfunction fromParse5(tree, options) {\n  const options_ = options || {};\n  /** @type {Options} */\n\n  let settings;\n  /** @type {VFile | undefined} */\n\n  let file;\n\n  if (isFile(options_)) {\n    file = options_;\n    settings = {};\n  } else {\n    file = options_.file || undefined;\n    settings = options_;\n  }\n\n  return one({\n    schema: settings.space === 'svg' ? _propertyInformation.svg : _propertyInformation.html,\n    file,\n    verbose: settings.verbose,\n    location: false\n  }, tree);\n}\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} node\n *   p5 node.\n * @returns {Node}\n *   hast node.\n */\n\n\nfunction one(state, node) {\n  /** @type {Node} */\n  let result;\n\n  switch (node.nodeName) {\n    case '#comment':\n      {\n        const reference = node;\n        result = {\n          type: 'comment',\n          value: reference.data\n        };\n        patch(state, reference, result);\n        return result;\n      }\n\n    case '#document':\n    case '#document-fragment':\n      {\n        const reference = node;\n        const quirksMode = 'mode' in reference ? reference.mode === 'quirks' || reference.mode === 'limited-quirks' : false;\n        result = {\n          type: 'root',\n          children: all(state, node.childNodes),\n          data: {\n            quirksMode\n          }\n        };\n\n        if (state.file && state.location) {\n          const doc = String(state.file);\n          const loc = (0, _vfileLocation.location)(doc);\n          const start = loc.toPoint(0);\n          const end = loc.toPoint(doc.length); // @ts-expect-error: always defined as we give valid input.\n\n          result.position = {\n            start,\n            end\n          };\n        }\n\n        return result;\n      }\n\n    case '#documentType':\n      {\n        const reference = node; // @ts-expect-error Types are out of date.\n\n        result = {\n          type: 'doctype'\n        };\n        patch(state, reference, result);\n        return result;\n      }\n\n    case '#text':\n      {\n        const reference = node;\n        result = {\n          type: 'text',\n          value: reference.value\n        };\n        patch(state, reference, result);\n        return result;\n      }\n    // Element.\n\n    default:\n      {\n        const reference = node;\n        result = element(state, reference);\n        return result;\n      }\n  }\n}\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<P5Node>} nodes\n *   Nodes.\n * @returns {Array<Content>}\n *   hast nodes.\n */\n\n\nfunction all(state, nodes) {\n  let index = -1;\n  /** @type {Array<Content>} */\n\n  const result = [];\n\n  while (++index < nodes.length) {\n    // @ts-expect-error Assume no roots in `nodes`.\n    result[index] = one(state, nodes[index]);\n  }\n\n  return result;\n}\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Element} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\n\n\nfunction element(state, node) {\n  const schema = state.schema;\n  state.schema = node.namespaceURI === _webNamespaces.webNamespaces.svg ? _propertyInformation.svg : _propertyInformation.html; // Props.\n\n  let index = -1;\n  /** @type {Record<string, string>} */\n\n  const props = {};\n\n  while (++index < node.attrs.length) {\n    const attribute = node.attrs[index];\n    const name = (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name;\n\n    if (!own.call(proto, name)) {\n      props[name] = attribute.value;\n    }\n  } // Build.\n\n\n  const fn = state.schema.space === 'svg' ? _hastscript.s : _hastscript.h;\n  const result = fn(node.tagName, props, all(state, node.childNodes));\n  patch(state, node, result); // Switch content.\n\n  if (result.tagName === 'template') {\n    const reference = node;\n    const pos = reference.sourceCodeLocation;\n    const startTag = pos && pos.startTag && position(pos.startTag);\n    const endTag = pos && pos.endTag && position(pos.endTag);\n    /** @type {Root} */\n    // @ts-expect-error Types are wrong.\n\n    const content = one(state, reference.content);\n\n    if (startTag && endTag && state.file) {\n      content.position = {\n        start: startTag.end,\n        end: endTag.start\n      };\n    }\n\n    result.content = content;\n  }\n\n  state.schema = schema;\n  return result;\n}\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} from\n *   p5 node.\n * @param {Node} to\n *   hast node.\n * @returns {void}\n *   Nothing.\n */\n\n\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    const position = createLocation(state, to, from.sourceCodeLocation);\n\n    if (position) {\n      state.location = true;\n      to.position = position;\n    }\n  }\n}\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Node} node\n *   hast node.\n * @param {P5ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\n\n\nfunction createLocation(state, node, location) {\n  const result = position(location);\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]; // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n\n    if (result && !location.endTag && tail && tail.position && tail.position.end) {\n      result.end = Object.assign({}, tail.position.end);\n    }\n\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      const props = {};\n      /** @type {string} */\n\n      let key;\n\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            props[(0, _propertyInformation.find)(state.schema, key).property] = position(location.attrs[key]);\n          }\n        }\n      }\n\n      node.data = {\n        position: {\n          // @ts-expect-error: assume not `undefined`.\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      };\n    }\n  }\n\n  return result;\n}\n/**\n * Turn a p5 location into a position.\n *\n * @param {P5Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\n\n\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  });\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  }); // @ts-expect-error `undefined` is fine.\n\n  return start || end ? {\n    start,\n    end\n  } : undefined;\n}\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\n\n\nfunction point(point) {\n  return point.line && point.column ? point : undefined;\n}\n/**\n * Check if something is a file.\n *\n * @param {VFile | Options} value\n *   File or options.\n * @returns {value is VFile}\n *   Whether `value` is a file.\n */\n\n\nfunction isFile(value) {\n  return 'messages' in value;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$property_information$index","~$shadow.js","~$module$node_modules$vfile_location$index","~$module$node_modules$hastscript$index","~$module$node_modules$web_namespaces$index"]],"~:properties",["^5",["properties","fromParse5","quirksMode","offset","children","__esModule","schema","opening","position","value","location","start","content","line","column","type","file","data","closing","end","verbose"]],"~:compiled-at",1676667638430,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hast_util_from_parse5$lib$index.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/hast-util-from-parse5/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hast_util_from_parse5$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.fromParse5 = fromParse5;\\n\\nvar _hastscript = require(\\\"hastscript\\\");\\n\\nvar _propertyInformation = require(\\\"property-information\\\");\\n\\nvar _vfileLocation = require(\\\"vfile-location\\\");\\n\\nvar _webNamespaces = require(\\\"web-namespaces\\\");\\n\\n/**\\n * @typedef {import('vfile').VFile} VFile\\n * @typedef {import('property-information').Schema} Schema\\n * @typedef {import('unist').Position} Position\\n * @typedef {import('unist').Point} Point\\n * @typedef {import('hast').Element} Element\\n * @typedef {import('hast').Root} Root\\n * @typedef {import('hast').Content} Content\\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\\n * @typedef {import('parse5').Token.ElementLocation} P5ElementLocation\\n * @typedef {import('parse5').Token.Location} P5Location\\n */\\n\\n/**\\n * @typedef {Content | Root} Node\\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5DocumentFragment\\n * @typedef {DefaultTreeAdapterMap['documentType']} P5DocumentType\\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\\n * @typedef {DefaultTreeAdapterMap['template']} P5Template\\n *\\n * @typedef {'html' | 'svg'} Space\\n *   Namespace.\\n *\\n * @typedef Options\\n *   Configuration.\\n * @property {Space | null | undefined} [space='html']\\n *   Which space the document is in.\\n *\\n *   When an `<svg>` element is found in the HTML space, this package already\\n *   automatically switches to and from the SVG space when entering and exiting\\n *   it.\\n * @property {VFile | null | undefined} [file]\\n *   File used to add positional info to nodes.\\n *\\n *   If given, the file should represent the original HTML source.\\n * @property {boolean} [verbose=false]\\n *   Whether to add extra positional info about starting tags, closing tags,\\n *   and attributes to elements.\\n *\\n *   > \\ud83d\\udc49 **Note**: only used when `file` is given.\\n *\\n * @typedef State\\n *   Info passed around about the current state.\\n * @property {Schema} schema\\n *   Current schema.\\n * @property {VFile | undefined} file\\n *   Corresponding file.\\n * @property {boolean | undefined} verbose\\n *   Add extra positional info.\\n * @property {boolean} location\\n *   Whether location info was found.\\n */\\nconst own = {}.hasOwnProperty;\\n/** @type {unknown} */\\n// type-coverage:ignore-next-line\\n\\nconst proto = Object.prototype;\\n/**\\n * Transform a `parse5` AST to hast.\\n *\\n * @param {P5Node} tree\\n *   `parse5` tree to transform.\\n * @param {Options | VFile | null | undefined} [options]\\n *   Configuration.\\n * @returns {Node}\\n *   hast tree.\\n */\\n\\nfunction fromParse5(tree, options) {\\n  const options_ = options || {};\\n  /** @type {Options} */\\n\\n  let settings;\\n  /** @type {VFile | undefined} */\\n\\n  let file;\\n\\n  if (isFile(options_)) {\\n    file = options_;\\n    settings = {};\\n  } else {\\n    file = options_.file || undefined;\\n    settings = options_;\\n  }\\n\\n  return one({\\n    schema: settings.space === 'svg' ? _propertyInformation.svg : _propertyInformation.html,\\n    file,\\n    verbose: settings.verbose,\\n    location: false\\n  }, tree);\\n}\\n/**\\n * Transform a node.\\n *\\n * @param {State} state\\n *   Info passed around about the current state.\\n * @param {P5Node} node\\n *   p5 node.\\n * @returns {Node}\\n *   hast node.\\n */\\n\\n\\nfunction one(state, node) {\\n  /** @type {Node} */\\n  let result;\\n\\n  switch (node.nodeName) {\\n    case '#comment':\\n      {\\n        const reference = node;\\n        result = {\\n          type: 'comment',\\n          value: reference.data\\n        };\\n        patch(state, reference, result);\\n        return result;\\n      }\\n\\n    case '#document':\\n    case '#document-fragment':\\n      {\\n        const reference = node;\\n        const quirksMode = 'mode' in reference ? reference.mode === 'quirks' || reference.mode === 'limited-quirks' : false;\\n        result = {\\n          type: 'root',\\n          children: all(state, node.childNodes),\\n          data: {\\n            quirksMode\\n          }\\n        };\\n\\n        if (state.file && state.location) {\\n          const doc = String(state.file);\\n          const loc = (0, _vfileLocation.location)(doc);\\n          const start = loc.toPoint(0);\\n          const end = loc.toPoint(doc.length); // @ts-expect-error: always defined as we give valid input.\\n\\n          result.position = {\\n            start,\\n            end\\n          };\\n        }\\n\\n        return result;\\n      }\\n\\n    case '#documentType':\\n      {\\n        const reference = node; // @ts-expect-error Types are out of date.\\n\\n        result = {\\n          type: 'doctype'\\n        };\\n        patch(state, reference, result);\\n        return result;\\n      }\\n\\n    case '#text':\\n      {\\n        const reference = node;\\n        result = {\\n          type: 'text',\\n          value: reference.value\\n        };\\n        patch(state, reference, result);\\n        return result;\\n      }\\n    // Element.\\n\\n    default:\\n      {\\n        const reference = node;\\n        result = element(state, reference);\\n        return result;\\n      }\\n  }\\n}\\n/**\\n * Transform children.\\n *\\n * @param {State} state\\n *   Info passed around about the current state.\\n * @param {Array<P5Node>} nodes\\n *   Nodes.\\n * @returns {Array<Content>}\\n *   hast nodes.\\n */\\n\\n\\nfunction all(state, nodes) {\\n  let index = -1;\\n  /** @type {Array<Content>} */\\n\\n  const result = [];\\n\\n  while (++index < nodes.length) {\\n    // @ts-expect-error Assume no roots in `nodes`.\\n    result[index] = one(state, nodes[index]);\\n  }\\n\\n  return result;\\n}\\n/**\\n * Transform an element.\\n *\\n * @param {State} state\\n *   Info passed around about the current state.\\n * @param {P5Element} node\\n *   `parse5` node to transform.\\n * @returns {Element}\\n *   hast node.\\n */\\n\\n\\nfunction element(state, node) {\\n  const schema = state.schema;\\n  state.schema = node.namespaceURI === _webNamespaces.webNamespaces.svg ? _propertyInformation.svg : _propertyInformation.html; // Props.\\n\\n  let index = -1;\\n  /** @type {Record<string, string>} */\\n\\n  const props = {};\\n\\n  while (++index < node.attrs.length) {\\n    const attribute = node.attrs[index];\\n    const name = (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name;\\n\\n    if (!own.call(proto, name)) {\\n      props[name] = attribute.value;\\n    }\\n  } // Build.\\n\\n\\n  const fn = state.schema.space === 'svg' ? _hastscript.s : _hastscript.h;\\n  const result = fn(node.tagName, props, all(state, node.childNodes));\\n  patch(state, node, result); // Switch content.\\n\\n  if (result.tagName === 'template') {\\n    const reference = node;\\n    const pos = reference.sourceCodeLocation;\\n    const startTag = pos && pos.startTag && position(pos.startTag);\\n    const endTag = pos && pos.endTag && position(pos.endTag);\\n    /** @type {Root} */\\n    // @ts-expect-error Types are wrong.\\n\\n    const content = one(state, reference.content);\\n\\n    if (startTag && endTag && state.file) {\\n      content.position = {\\n        start: startTag.end,\\n        end: endTag.start\\n      };\\n    }\\n\\n    result.content = content;\\n  }\\n\\n  state.schema = schema;\\n  return result;\\n}\\n/**\\n * Patch positional info from `from` onto `to`.\\n *\\n * @param {State} state\\n *   Info passed around about the current state.\\n * @param {P5Node} from\\n *   p5 node.\\n * @param {Node} to\\n *   hast node.\\n * @returns {void}\\n *   Nothing.\\n */\\n\\n\\nfunction patch(state, from, to) {\\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\\n    const position = createLocation(state, to, from.sourceCodeLocation);\\n\\n    if (position) {\\n      state.location = true;\\n      to.position = position;\\n    }\\n  }\\n}\\n/**\\n * Create clean positional information.\\n *\\n * @param {State} state\\n *   Info passed around about the current state.\\n * @param {Node} node\\n *   hast node.\\n * @param {P5ElementLocation} location\\n *   p5 location info.\\n * @returns {Position | undefined}\\n *   Position, or nothing.\\n */\\n\\n\\nfunction createLocation(state, node, location) {\\n  const result = position(location);\\n\\n  if (node.type === 'element') {\\n    const tail = node.children[node.children.length - 1]; // Bug for unclosed with children.\\n    // See: <https://github.com/inikulin/parse5/issues/109>.\\n\\n    if (result && !location.endTag && tail && tail.position && tail.position.end) {\\n      result.end = Object.assign({}, tail.position.end);\\n    }\\n\\n    if (state.verbose) {\\n      /** @type {Record<string, Position | undefined>} */\\n      const props = {};\\n      /** @type {string} */\\n\\n      let key;\\n\\n      if (location.attrs) {\\n        for (key in location.attrs) {\\n          if (own.call(location.attrs, key)) {\\n            props[(0, _propertyInformation.find)(state.schema, key).property] = position(location.attrs[key]);\\n          }\\n        }\\n      }\\n\\n      node.data = {\\n        position: {\\n          // @ts-expect-error: assume not `undefined`.\\n          opening: position(location.startTag),\\n          closing: location.endTag ? position(location.endTag) : null,\\n          properties: props\\n        }\\n      };\\n    }\\n  }\\n\\n  return result;\\n}\\n/**\\n * Turn a p5 location into a position.\\n *\\n * @param {P5Location} loc\\n *   Location.\\n * @returns {Position | undefined}\\n *   Position or nothing.\\n */\\n\\n\\nfunction position(loc) {\\n  const start = point({\\n    line: loc.startLine,\\n    column: loc.startCol,\\n    offset: loc.startOffset\\n  });\\n  const end = point({\\n    line: loc.endLine,\\n    column: loc.endCol,\\n    offset: loc.endOffset\\n  }); // @ts-expect-error `undefined` is fine.\\n\\n  return start || end ? {\\n    start,\\n    end\\n  } : undefined;\\n}\\n/**\\n * Filter out invalid points.\\n *\\n * @param {Point} point\\n *   Point with potentially `undefined` values.\\n * @returns {Point | undefined}\\n *   Point or nothing.\\n */\\n\\n\\nfunction point(point) {\\n  return point.line && point.column ? point : undefined;\\n}\\n/**\\n * Check if something is a file.\\n *\\n * @param {VFile | Options} value\\n *   File or options.\\n * @returns {value is VFile}\\n *   Whether `value` is a file.\\n */\\n\\n\\nfunction isFile(value) {\\n  return 'messages' in value;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"one\",\"state\",\"node\",\"nodeName\",\"result\",\"type\",\"value\",\"data\",\"patch\",\"quirksMode\",\"mode\",\"children\",\"all\",\"childNodes\",\"file\",\"location\",\"doc\",\"String\",\"loc\",\"_vfileLocation\",\"start\",\"toPoint\",\"end\",\"length\",\"position\",\"schema\",\"namespaceURI\",\"_webNamespaces\",\"webNamespaces\",\"svg\",\"_propertyInformation\",\"html\",\"index\",\"props\",\"attrs\",\"attribute\",\"name\",\"prefix\",\"own\",\"call\",\"proto\",\"fn\",\"space\",\"_hastscript\",\"s\",\"h\",\"tagName\",\"startTag\",\"pos\",\"sourceCodeLocation\",\"endTag\",\"content\",\"nodes\",\"from\",\"to\",\"tail\",\"Object\",\"assign\",\"verbose\",\"key\",\"find\",\"property\",\"opening\",\"closing\",\"properties\",\"point\",\"line\",\"startLine\",\"column\",\"startCol\",\"offset\",\"startOffset\",\"endLine\",\"endCol\",\"endOffset\",\"undefined\",\"defineProperty\",\"fromParse5\",\"tree\",\"options\",\"options_\",\"settings\",\"hasOwnProperty\",\"prototype\"]\n}\n"]