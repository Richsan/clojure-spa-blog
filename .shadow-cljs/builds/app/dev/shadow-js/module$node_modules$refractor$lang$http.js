["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/http.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$http=function(global,require,module,exports){function http(Prism$jscomp$0){(function(Prism){function headerValueOf(name){return RegExp(\"(^(?:\"+name+\"):[ \\t]*(?![ \\t]))[^]+\",\"i\")}function getSuffixPattern(contentType){var suffix=contentType.replace(/^[a-z]+\\//,\"\");return\"(?:\"+contentType+\"|\\\\w+/(?:[\\\\w.-]+\\\\+)+\"+(suffix+\"(?![+\\\\w.-]))\")}Prism.languages.http={\"request-line\":{pattern:/^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\\s(?:https?:\\/\\/|\\/)\\S*\\sHTTP\\/[\\d.]+/m,\ninside:{method:{pattern:/^[A-Z]+\\b/,alias:\"property\"},\"request-target\":{pattern:/^(\\s)(?:https?:\\/\\/|\\/)\\S*(?=\\s)/,lookbehind:!0,alias:\"url\",inside:Prism.languages.uri},\"http-version\":{pattern:/^(\\s)HTTP\\/[\\d.]+/,lookbehind:!0,alias:\"property\"}}},\"response-status\":{pattern:/^HTTP\\/[\\d.]+ \\d+ .+/m,inside:{\"http-version\":{pattern:/^HTTP\\/[\\d.]+/,alias:\"property\"},\"status-code\":{pattern:/^(\\s)\\d+(?=\\s)/,lookbehind:!0,alias:\"number\"},\"reason-phrase\":{pattern:/^(\\s).+/,lookbehind:!0,alias:\"string\"}}},\nheader:{pattern:/^[\\w-]+:.+(?:(?:\\r\\n?|\\n)[ \\t].+)*/m,inside:{\"header-value\":[{pattern:headerValueOf(/Content-Security-Policy/.source),lookbehind:!0,alias:[\"csp\",\"languages-csp\"],inside:Prism.languages.csp},{pattern:headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),lookbehind:!0,alias:[\"hpkp\",\"languages-hpkp\"],inside:Prism.languages.hpkp},{pattern:headerValueOf(/Strict-Transport-Security/.source),lookbehind:!0,alias:[\"hsts\",\"languages-hsts\"],inside:Prism.languages.hsts},{pattern:headerValueOf(/[^:]+/.source),\nlookbehind:!0}],\"header-name\":{pattern:/^[^:]+/,alias:\"keyword\"},punctuation:/^:/}}};var langs=Prism.languages;langs={\"application/javascript\":langs.javascript,\"application/json\":langs.json||langs.javascript,\"application/xml\":langs.xml,\"text/xml\":langs.xml,\"text/html\":langs.html,\"text/css\":langs.css,\"text/plain\":langs.plain};var suffixTypes={\"application/json\":!0,\"application/xml\":!0},contentType$jscomp$0;for(contentType$jscomp$0 in langs)if(langs[contentType$jscomp$0]){var options=options||{};var pattern=\nsuffixTypes[contentType$jscomp$0]?getSuffixPattern(contentType$jscomp$0):contentType$jscomp$0;options[contentType$jscomp$0.replace(/\\//g,\"-\")]={pattern:RegExp(\"(\"+/content-type:\\s*/.source+pattern+/(?:(?:\\r\\n?|\\n)[\\w-].*)*(?:\\r(?:\\n|(?!\\n))|\\n)/.source+\")\"+/[^ \\t\\w-][\\s\\S]*/.source,\"i\"),lookbehind:!0,inside:langs[contentType$jscomp$0]}}options&&Prism.languages.insertBefore(\"http\",\"header\",options)})(Prism$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=http;http.displayName=\n\"http\";http.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$http\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = http;\n// @ts-nocheck\nhttp.displayName = 'http';\nhttp.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction http(Prism) {\n  ;\n\n  (function (Prism) {\n    /**\n     * @param {string} name\n     * @returns {RegExp}\n     */\n    function headerValueOf(name) {\n      return RegExp('(^(?:' + name + '):[ \\t]*(?![ \\t]))[^]+', 'i');\n    }\n\n    Prism.languages.http = {\n      'request-line': {\n        pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\\s(?:https?:\\/\\/|\\/)\\S*\\sHTTP\\/[\\d.]+/m,\n        inside: {\n          // HTTP Method\n          method: {\n            pattern: /^[A-Z]+\\b/,\n            alias: 'property'\n          },\n          // Request Target e.g. http://example.com, /path/to/file\n          'request-target': {\n            pattern: /^(\\s)(?:https?:\\/\\/|\\/)\\S*(?=\\s)/,\n            lookbehind: true,\n            alias: 'url',\n            inside: Prism.languages.uri\n          },\n          // HTTP Version\n          'http-version': {\n            pattern: /^(\\s)HTTP\\/[\\d.]+/,\n            lookbehind: true,\n            alias: 'property'\n          }\n        }\n      },\n      'response-status': {\n        pattern: /^HTTP\\/[\\d.]+ \\d+ .+/m,\n        inside: {\n          // HTTP Version\n          'http-version': {\n            pattern: /^HTTP\\/[\\d.]+/,\n            alias: 'property'\n          },\n          // Status Code\n          'status-code': {\n            pattern: /^(\\s)\\d+(?=\\s)/,\n            lookbehind: true,\n            alias: 'number'\n          },\n          // Reason Phrase\n          'reason-phrase': {\n            pattern: /^(\\s).+/,\n            lookbehind: true,\n            alias: 'string'\n          }\n        }\n      },\n      header: {\n        pattern: /^[\\w-]+:.+(?:(?:\\r\\n?|\\n)[ \\t].+)*/m,\n        inside: {\n          'header-value': [{\n            pattern: headerValueOf(/Content-Security-Policy/.source),\n            lookbehind: true,\n            alias: ['csp', 'languages-csp'],\n            inside: Prism.languages.csp\n          }, {\n            pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),\n            lookbehind: true,\n            alias: ['hpkp', 'languages-hpkp'],\n            inside: Prism.languages.hpkp\n          }, {\n            pattern: headerValueOf(/Strict-Transport-Security/.source),\n            lookbehind: true,\n            alias: ['hsts', 'languages-hsts'],\n            inside: Prism.languages.hsts\n          }, {\n            pattern: headerValueOf(/[^:]+/.source),\n            lookbehind: true\n          }],\n          'header-name': {\n            pattern: /^[^:]+/,\n            alias: 'keyword'\n          },\n          punctuation: /^:/\n        }\n      }\n    }; // Create a mapping of Content-Type headers to language definitions\n\n    var langs = Prism.languages;\n    var httpLanguages = {\n      'application/javascript': langs.javascript,\n      'application/json': langs.json || langs.javascript,\n      'application/xml': langs.xml,\n      'text/xml': langs.xml,\n      'text/html': langs.html,\n      'text/css': langs.css,\n      'text/plain': langs.plain\n    }; // Declare which types can also be suffixes\n\n    var suffixTypes = {\n      'application/json': true,\n      'application/xml': true\n    };\n    /**\n     * Returns a pattern for the given content type which matches it and any type which has it as a suffix.\n     *\n     * @param {string} contentType\n     * @returns {string}\n     */\n\n    function getSuffixPattern(contentType) {\n      var suffix = contentType.replace(/^[a-z]+\\//, '');\n      var suffixPattern = '\\\\w+/(?:[\\\\w.-]+\\\\+)+' + suffix + '(?![+\\\\w.-])';\n      return '(?:' + contentType + '|' + suffixPattern + ')';\n    } // Insert each content type parser that has its associated language\n    // currently loaded.\n\n\n    var options;\n\n    for (var contentType in httpLanguages) {\n      if (httpLanguages[contentType]) {\n        options = options || {};\n        var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;\n        options[contentType.replace(/\\//g, '-')] = {\n          pattern: RegExp('(' + /content-type:\\s*/.source + pattern + /(?:(?:\\r\\n?|\\n)[\\w-].*)*(?:\\r(?:\\n|(?!\\n))|\\n)/.source + ')' + // This is a little interesting:\n          // The HTTP format spec required 1 empty line before the body to make everything unambiguous.\n          // However, when writing code by hand (e.g. to display on a website) people can forget about this,\n          // so we want to be liberal here. We will allow the empty line to be omitted if the first line of\n          // the body does not start with a [\\w-] character (as headers do).\n          /[^ \\t\\w-][\\s\\S]*/.source, 'i'),\n          lookbehind: true,\n          inside: httpLanguages[contentType]\n        };\n      }\n    }\n\n    if (options) {\n      Prism.languages.insertBefore('http', 'header', options);\n    }\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["punctuation","aliases","displayName","method","__esModule","http","lookbehind","value","pattern","inside","alias","default","header"]],"~:compiled-at",1676841365421,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$http.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lang/http.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$http\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = http;\\n// @ts-nocheck\\nhttp.displayName = 'http';\\nhttp.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction http(Prism) {\\n  ;\\n\\n  (function (Prism) {\\n    /**\\n     * @param {string} name\\n     * @returns {RegExp}\\n     */\\n    function headerValueOf(name) {\\n      return RegExp('(^(?:' + name + '):[ \\\\t]*(?![ \\\\t]))[^]+', 'i');\\n    }\\n\\n    Prism.languages.http = {\\n      'request-line': {\\n        pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\\\\s(?:https?:\\\\/\\\\/|\\\\/)\\\\S*\\\\sHTTP\\\\/[\\\\d.]+/m,\\n        inside: {\\n          // HTTP Method\\n          method: {\\n            pattern: /^[A-Z]+\\\\b/,\\n            alias: 'property'\\n          },\\n          // Request Target e.g. http://example.com, /path/to/file\\n          'request-target': {\\n            pattern: /^(\\\\s)(?:https?:\\\\/\\\\/|\\\\/)\\\\S*(?=\\\\s)/,\\n            lookbehind: true,\\n            alias: 'url',\\n            inside: Prism.languages.uri\\n          },\\n          // HTTP Version\\n          'http-version': {\\n            pattern: /^(\\\\s)HTTP\\\\/[\\\\d.]+/,\\n            lookbehind: true,\\n            alias: 'property'\\n          }\\n        }\\n      },\\n      'response-status': {\\n        pattern: /^HTTP\\\\/[\\\\d.]+ \\\\d+ .+/m,\\n        inside: {\\n          // HTTP Version\\n          'http-version': {\\n            pattern: /^HTTP\\\\/[\\\\d.]+/,\\n            alias: 'property'\\n          },\\n          // Status Code\\n          'status-code': {\\n            pattern: /^(\\\\s)\\\\d+(?=\\\\s)/,\\n            lookbehind: true,\\n            alias: 'number'\\n          },\\n          // Reason Phrase\\n          'reason-phrase': {\\n            pattern: /^(\\\\s).+/,\\n            lookbehind: true,\\n            alias: 'string'\\n          }\\n        }\\n      },\\n      header: {\\n        pattern: /^[\\\\w-]+:.+(?:(?:\\\\r\\\\n?|\\\\n)[ \\\\t].+)*/m,\\n        inside: {\\n          'header-value': [{\\n            pattern: headerValueOf(/Content-Security-Policy/.source),\\n            lookbehind: true,\\n            alias: ['csp', 'languages-csp'],\\n            inside: Prism.languages.csp\\n          }, {\\n            pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),\\n            lookbehind: true,\\n            alias: ['hpkp', 'languages-hpkp'],\\n            inside: Prism.languages.hpkp\\n          }, {\\n            pattern: headerValueOf(/Strict-Transport-Security/.source),\\n            lookbehind: true,\\n            alias: ['hsts', 'languages-hsts'],\\n            inside: Prism.languages.hsts\\n          }, {\\n            pattern: headerValueOf(/[^:]+/.source),\\n            lookbehind: true\\n          }],\\n          'header-name': {\\n            pattern: /^[^:]+/,\\n            alias: 'keyword'\\n          },\\n          punctuation: /^:/\\n        }\\n      }\\n    }; // Create a mapping of Content-Type headers to language definitions\\n\\n    var langs = Prism.languages;\\n    var httpLanguages = {\\n      'application/javascript': langs.javascript,\\n      'application/json': langs.json || langs.javascript,\\n      'application/xml': langs.xml,\\n      'text/xml': langs.xml,\\n      'text/html': langs.html,\\n      'text/css': langs.css,\\n      'text/plain': langs.plain\\n    }; // Declare which types can also be suffixes\\n\\n    var suffixTypes = {\\n      'application/json': true,\\n      'application/xml': true\\n    };\\n    /**\\n     * Returns a pattern for the given content type which matches it and any type which has it as a suffix.\\n     *\\n     * @param {string} contentType\\n     * @returns {string}\\n     */\\n\\n    function getSuffixPattern(contentType) {\\n      var suffix = contentType.replace(/^[a-z]+\\\\//, '');\\n      var suffixPattern = '\\\\\\\\w+/(?:[\\\\\\\\w.-]+\\\\\\\\+)+' + suffix + '(?![+\\\\\\\\w.-])';\\n      return '(?:' + contentType + '|' + suffixPattern + ')';\\n    } // Insert each content type parser that has its associated language\\n    // currently loaded.\\n\\n\\n    var options;\\n\\n    for (var contentType in httpLanguages) {\\n      if (httpLanguages[contentType]) {\\n        options = options || {};\\n        var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;\\n        options[contentType.replace(/\\\\//g, '-')] = {\\n          pattern: RegExp('(' + /content-type:\\\\s*/.source + pattern + /(?:(?:\\\\r\\\\n?|\\\\n)[\\\\w-].*)*(?:\\\\r(?:\\\\n|(?!\\\\n))|\\\\n)/.source + ')' + // This is a little interesting:\\n          // The HTTP format spec required 1 empty line before the body to make everything unambiguous.\\n          // However, when writing code by hand (e.g. to display on a website) people can forget about this,\\n          // so we want to be liberal here. We will allow the empty line to be omitted if the first line of\\n          // the body does not start with a [\\\\w-] character (as headers do).\\n          /[^ \\\\t\\\\w-][\\\\s\\\\S]*/.source, 'i'),\\n          lookbehind: true,\\n          inside: httpLanguages[contentType]\\n        };\\n      }\\n    }\\n\\n    if (options) {\\n      Prism.languages.insertBefore('http', 'header', options);\\n    }\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"http\",\"Prism\",\"headerValueOf\",\"name\",\"RegExp\",\"getSuffixPattern\",\"contentType\",\"suffix\",\"replace\",\"languages\",\"pattern\",\"inside\",\"method\",\"alias\",\"lookbehind\",\"uri\",\"header\",\"source\",\"csp\",\"hpkp\",\"hsts\",\"punctuation\",\"langs\",\"httpLanguages\",\"javascript\",\"json\",\"xml\",\"html\",\"css\",\"plain\",\"suffixTypes\",\"options\",\"insertBefore\",\"Object\",\"defineProperty\",\"value\",\"default\",\"displayName\",\"aliases\"]\n}\n"]