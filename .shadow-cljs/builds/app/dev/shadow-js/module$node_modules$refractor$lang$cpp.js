["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/cpp.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$cpp=function(global,require,module,exports){function cpp(Prism$jscomp$0){Prism$jscomp$0.register(_c.default);(function(Prism){var keyword=/\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/,\nmodName=/\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g,function(){return keyword.source});Prism.languages.cpp=Prism.languages.extend(\"c\",{\"class-name\":[{pattern:RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g,function(){return keyword.source})),lookbehind:!0},/\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,/\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,/\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/],keyword,number:{pattern:/(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\ngreedy:!0},operator:/>>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,boolean:/\\b(?:false|true)\\b/});Prism.languages.insertBefore(\"cpp\",\"string\",{module:{pattern:RegExp(/(\\b(?:import|module)\\s+)/.source+\"(?:\"+/\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source+\"|\"+/<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g,function(){return modName})+\")\"),lookbehind:!0,greedy:!0,inside:{string:/^[<\"][\\s\\S]+/,\noperator:/:/,punctuation:/\\./}},\"raw-string\":{pattern:/R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,alias:\"string\",greedy:!0}});Prism.languages.insertBefore(\"cpp\",\"keyword\",{\"generic-function\":{pattern:/\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,inside:{function:/^\\w+/,generic:{pattern:/<[\\s\\S]+/,alias:\"class-name\",inside:Prism.languages.cpp}}}});Prism.languages.insertBefore(\"cpp\",\"operator\",{\"double-colon\":{pattern:/::/,alias:\"punctuation\"}});Prism.languages.insertBefore(\"cpp\",\"class-name\",\n{\"base-clause\":{pattern:/(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,lookbehind:!0,greedy:!0,inside:Prism.languages.extend(\"cpp\",{})}});Prism.languages.insertBefore(\"inside\",\"double-colon\",{\"class-name\":/\\b[a-z_]\\w*\\b(?!\\s*::)/i},Prism.languages.cpp[\"base-clause\"])})(Prism$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=cpp;var _c=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(require(\"module$node_modules$refractor$lang$c\"));\ncpp.displayName=\"cpp\";cpp.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$cpp\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cpp;\n\nvar _c = _interopRequireDefault(require(\"./c.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// @ts-nocheck\ncpp.displayName = 'cpp';\ncpp.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction cpp(Prism) {\n  Prism.register(_c.default);\n\n  (function (Prism) {\n    var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n    var modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () {\n      return keyword.source;\n    });\n    Prism.languages.cpp = Prism.languages.extend('c', {\n      'class-name': [{\n        pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function () {\n          return keyword.source;\n        })),\n        lookbehind: true\n      }, // This is intended to capture the class name of method implementations like:\n      //   void foo::bar() const {}\n      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n      // it starts with an uppercase letter. This approximation should give decent results.\n      /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/, // This will capture the class name before destructors like:\n      //   Foo::~Foo() {}\n      /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i, // This also intends to capture the class name of method implementations but here the class has template\n      // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n      /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/],\n      keyword: keyword,\n      number: {\n        pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n        greedy: true\n      },\n      operator: />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n      boolean: /\\b(?:false|true)\\b/\n    });\n    Prism.languages.insertBefore('cpp', 'string', {\n      module: {\n        // https://en.cppreference.com/w/cpp/language/modules\n        pattern: RegExp(/(\\b(?:import|module)\\s+)/.source + '(?:' + // header-name\n        /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source + '|' + // module name or partition or both\n        /<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () {\n          return modName;\n        }) + ')'),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          string: /^[<\"][\\s\\S]+/,\n          operator: /:/,\n          punctuation: /\\./\n        }\n      },\n      'raw-string': {\n        pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n        alias: 'string',\n        greedy: true\n      }\n    });\n    Prism.languages.insertBefore('cpp', 'keyword', {\n      'generic-function': {\n        pattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n        inside: {\n          function: /^\\w+/,\n          generic: {\n            pattern: /<[\\s\\S]+/,\n            alias: 'class-name',\n            inside: Prism.languages.cpp\n          }\n        }\n      }\n    });\n    Prism.languages.insertBefore('cpp', 'operator', {\n      'double-colon': {\n        pattern: /::/,\n        alias: 'punctuation'\n      }\n    });\n    Prism.languages.insertBefore('cpp', 'class-name', {\n      // the base clause is an optional list of parent classes\n      // https://en.cppreference.com/w/cpp/language/class\n      'base-clause': {\n        pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n        lookbehind: true,\n        greedy: true,\n        inside: Prism.languages.extend('cpp', {})\n      }\n    });\n    Prism.languages.insertBefore('inside', 'double-colon', {\n      // All untokenized words that are not namespaces should be class names\n      'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n    }, Prism.languages.cpp['base-clause']);\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$refractor$lang$c"]],"~:properties",["^5",["boolean","generic","punctuation","string","aliases","operator","displayName","__esModule","cpp","lookbehind","value","keyword","number","greedy","function","pattern","inside","alias","default"]],"~:compiled-at",1676841365356,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$cpp.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lang/cpp.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$cpp\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = cpp;\\n\\nvar _c = _interopRequireDefault(require(\\\"./c.js\\\"));\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n// @ts-nocheck\\ncpp.displayName = 'cpp';\\ncpp.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction cpp(Prism) {\\n  Prism.register(_c.default);\\n\\n  (function (Prism) {\\n    var keyword = /\\\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\\\b/;\\n    var modName = /\\\\b(?!<keyword>)\\\\w+(?:\\\\s*\\\\.\\\\s*\\\\w+)*\\\\b/.source.replace(/<keyword>/g, function () {\\n      return keyword.source;\\n    });\\n    Prism.languages.cpp = Prism.languages.extend('c', {\\n      'class-name': [{\\n        pattern: RegExp(/(\\\\b(?:class|concept|enum|struct|typename)\\\\s+)(?!<keyword>)\\\\w+/.source.replace(/<keyword>/g, function () {\\n          return keyword.source;\\n        })),\\n        lookbehind: true\\n      }, // This is intended to capture the class name of method implementations like:\\n      //   void foo::bar() const {}\\n      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\\n      // it starts with an uppercase letter. This approximation should give decent results.\\n      /\\\\b[A-Z]\\\\w*(?=\\\\s*::\\\\s*\\\\w+\\\\s*\\\\()/, // This will capture the class name before destructors like:\\n      //   Foo::~Foo() {}\\n      /\\\\b[A-Z_]\\\\w*(?=\\\\s*::\\\\s*~\\\\w+\\\\s*\\\\()/i, // This also intends to capture the class name of method implementations but here the class has template\\n      // parameters, so it can't be a namespace (until C++ adds generic namespaces).\\n      /\\\\b\\\\w+(?=\\\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\\\s*::\\\\s*\\\\w+\\\\s*\\\\()/],\\n      keyword: keyword,\\n      number: {\\n        pattern: /(?:\\\\b0b[01']+|\\\\b0x(?:[\\\\da-f']+(?:\\\\.[\\\\da-f']*)?|\\\\.[\\\\da-f']+)(?:p[+-]?[\\\\d']+)?|(?:\\\\b[\\\\d']+(?:\\\\.[\\\\d']*)?|\\\\B\\\\.[\\\\d']+)(?:e[+-]?[\\\\d']+)?)[ful]{0,4}/i,\\n        greedy: true\\n      },\\n      operator: />>=?|<<=?|->|--|\\\\+\\\\+|&&|\\\\|\\\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\\\b/,\\n      boolean: /\\\\b(?:false|true)\\\\b/\\n    });\\n    Prism.languages.insertBefore('cpp', 'string', {\\n      module: {\\n        // https://en.cppreference.com/w/cpp/language/modules\\n        pattern: RegExp(/(\\\\b(?:import|module)\\\\s+)/.source + '(?:' + // header-name\\n        /\\\"(?:\\\\\\\\(?:\\\\r\\\\n|[\\\\s\\\\S])|[^\\\"\\\\\\\\\\\\r\\\\n])*\\\"|<[^<>\\\\r\\\\n]*>/.source + '|' + // module name or partition or both\\n        /<mod-name>(?:\\\\s*:\\\\s*<mod-name>)?|:\\\\s*<mod-name>/.source.replace(/<mod-name>/g, function () {\\n          return modName;\\n        }) + ')'),\\n        lookbehind: true,\\n        greedy: true,\\n        inside: {\\n          string: /^[<\\\"][\\\\s\\\\S]+/,\\n          operator: /:/,\\n          punctuation: /\\\\./\\n        }\\n      },\\n      'raw-string': {\\n        pattern: /R\\\"([^()\\\\\\\\ ]{0,16})\\\\([\\\\s\\\\S]*?\\\\)\\\\1\\\"/,\\n        alias: 'string',\\n        greedy: true\\n      }\\n    });\\n    Prism.languages.insertBefore('cpp', 'keyword', {\\n      'generic-function': {\\n        pattern: /\\\\b(?!operator\\\\b)[a-z_]\\\\w*\\\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\\\s*\\\\()/i,\\n        inside: {\\n          function: /^\\\\w+/,\\n          generic: {\\n            pattern: /<[\\\\s\\\\S]+/,\\n            alias: 'class-name',\\n            inside: Prism.languages.cpp\\n          }\\n        }\\n      }\\n    });\\n    Prism.languages.insertBefore('cpp', 'operator', {\\n      'double-colon': {\\n        pattern: /::/,\\n        alias: 'punctuation'\\n      }\\n    });\\n    Prism.languages.insertBefore('cpp', 'class-name', {\\n      // the base clause is an optional list of parent classes\\n      // https://en.cppreference.com/w/cpp/language/class\\n      'base-clause': {\\n        pattern: /(\\\\b(?:class|struct)\\\\s+\\\\w+\\\\s*:\\\\s*)[^;{}\\\"'\\\\s]+(?:\\\\s+[^;{}\\\"'\\\\s]+)*(?=\\\\s*[;{])/,\\n        lookbehind: true,\\n        greedy: true,\\n        inside: Prism.languages.extend('cpp', {})\\n      }\\n    });\\n    Prism.languages.insertBefore('inside', 'double-colon', {\\n      // All untokenized words that are not namespaces should be class names\\n      'class-name': /\\\\b[a-z_]\\\\w*\\\\b(?!\\\\s*::)/i\\n    }, Prism.languages.cpp['base-clause']);\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"cpp\",\"Prism\",\"register\",\"_c\",\"default\",\"keyword\",\"modName\",\"source\",\"replace\",\"languages\",\"extend\",\"pattern\",\"RegExp\",\"lookbehind\",\"number\",\"greedy\",\"operator\",\"boolean\",\"insertBefore\",\"inside\",\"string\",\"punctuation\",\"alias\",\"function\",\"generic\",\"Object\",\"defineProperty\",\"value\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"displayName\",\"aliases\"]\n}\n"]