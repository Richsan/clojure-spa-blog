["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-extension-gfm-table/lib/html.js"],"~:js","shadow$provide.module$node_modules$micromark_extension_gfm_table$lib$html=function(global,require,module,exports){function replace($0,$1){return\"|\"===$1?$1:$0}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.gfmTableHtml=void 0;const alignment={none:\"\",left:' align\\x3d\"left\"',right:' align\\x3d\"right\"',center:' align\\x3d\"center\"'};exports.gfmTableHtml={enter:{table(token){token=token._align;this.lineEndingIfNeeded();this.tag(\"\\x3ctable\\x3e\");this.setData(\"tableAlign\",token)},tableBody(){this.setData(\"slurpOneLineEnding\");\nthis.tag(\"\\x3ctbody\\x3e\")},tableData(){var tableAlign=this.getData(\"tableAlign\");const tableColumn=this.getData(\"tableColumn\");tableAlign=alignment[tableAlign[tableColumn]];void 0===tableAlign?this.buffer():(this.lineEndingIfNeeded(),this.tag(\"\\x3ctd\"+tableAlign+\"\\x3e\"))},tableHead(){this.lineEndingIfNeeded();this.tag(\"\\x3cthead\\x3e\")},tableHeader(){var tableAlign=this.getData(\"tableAlign\");const tableColumn=this.getData(\"tableColumn\");tableAlign=alignment[tableAlign[tableColumn]];this.lineEndingIfNeeded();\nthis.tag(\"\\x3cth\"+tableAlign+\"\\x3e\")},tableRow(){this.setData(\"tableColumn\",0);this.lineEndingIfNeeded();this.tag(\"\\x3ctr\\x3e\")}},exit:{codeTextData(token){token=this.sliceSerialize(token);this.getData(\"tableAlign\")&&(token=token.replace(/\\\\([\\\\|])/g,replace));this.raw(this.encode(token))},table(){this.setData(\"tableAlign\");this.setData(\"slurpAllLineEndings\");this.lineEndingIfNeeded();this.tag(\"\\x3c/table\\x3e\")},tableBody(){this.lineEndingIfNeeded();this.tag(\"\\x3c/tbody\\x3e\")},tableData(){const tableAlign=\nthis.getData(\"tableAlign\"),tableColumn=this.getData(\"tableColumn\");tableColumn in tableAlign?(this.tag(\"\\x3c/td\\x3e\"),this.setData(\"tableColumn\",tableColumn+1)):this.resume()},tableHead(){this.lineEndingIfNeeded();this.tag(\"\\x3c/thead\\x3e\");this.setData(\"slurpOneLineEnding\",!0)},tableHeader(){const tableColumn=this.getData(\"tableColumn\");this.tag(\"\\x3c/th\\x3e\");this.setData(\"tableColumn\",tableColumn+1)},tableRow(){const tableAlign=this.getData(\"tableAlign\");let tableColumn=this.getData(\"tableColumn\");\nfor(;tableColumn<tableAlign.length;)this.lineEndingIfNeeded(),this.tag(\"\\x3ctd\"+alignment[tableAlign[tableColumn]]+\"\\x3e\\x3c/td\\x3e\"),tableColumn++;this.setData(\"tableColumn\",tableColumn);this.lineEndingIfNeeded();this.tag(\"\\x3c/tr\\x3e\")}}}}","~:source","shadow$provide[\"module$node_modules$micromark_extension_gfm_table$lib$html\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gfmTableHtml = void 0;\n\n/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('./syntax.js').Align} Align\n */\nconst alignment = {\n  none: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n};\n/** @type {HtmlExtension} */\n\nconst gfmTableHtml = {\n  enter: {\n    table(token) {\n      /** @type {Array<Align>} */\n      // @ts-expect-error Custom.\n      const tableAlign = token._align;\n      this.lineEndingIfNeeded();\n      this.tag('<table>');\n      this.setData('tableAlign', tableAlign);\n    },\n\n    tableBody() {\n      // Clear slurping line ending from the delimiter row.\n      this.setData('slurpOneLineEnding');\n      this.tag('<tbody>');\n    },\n\n    tableData() {\n      const tableAlign =\n      /** @type {Array<Align>} */\n      this.getData('tableAlign');\n      const tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n      const align = alignment[tableAlign[tableColumn]];\n\n      if (align === undefined) {\n        // Capture results to ignore them.\n        this.buffer();\n      } else {\n        this.lineEndingIfNeeded();\n        this.tag('<td' + align + '>');\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded();\n      this.tag('<thead>');\n    },\n\n    tableHeader() {\n      const tableAlign =\n      /** @type {Array<Align>} */\n      this.getData('tableAlign');\n      const tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n      const align = alignment[tableAlign[tableColumn]];\n      this.lineEndingIfNeeded();\n      this.tag('<th' + align + '>');\n    },\n\n    tableRow() {\n      this.setData('tableColumn', 0);\n      this.lineEndingIfNeeded();\n      this.tag('<tr>');\n    }\n\n  },\n  exit: {\n    // Overwrite the default code text data handler to unescape escaped pipes when\n    // they are in tables.\n    codeTextData(token) {\n      let value = this.sliceSerialize(token);\n\n      if (this.getData('tableAlign')) {\n        value = value.replace(/\\\\([\\\\|])/g, replace);\n      }\n\n      this.raw(this.encode(value));\n    },\n\n    table() {\n      this.setData('tableAlign'); // If there was no table body, make sure the slurping from the delimiter row\n      // is cleared.\n\n      this.setData('slurpAllLineEndings');\n      this.lineEndingIfNeeded();\n      this.tag('</table>');\n    },\n\n    tableBody() {\n      this.lineEndingIfNeeded();\n      this.tag('</tbody>');\n    },\n\n    tableData() {\n      const tableAlign =\n      /** @type {Array<Align>} */\n      this.getData('tableAlign');\n      const tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n\n      if (tableColumn in tableAlign) {\n        this.tag('</td>');\n        this.setData('tableColumn', tableColumn + 1);\n      } else {\n        // Stop capturing.\n        this.resume();\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded();\n      this.tag('</thead>');\n      this.setData('slurpOneLineEnding', true); // Slurp the line ending from the delimiter row.\n    },\n\n    tableHeader() {\n      const tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n      this.tag('</th>');\n      this.setData('tableColumn', tableColumn + 1);\n    },\n\n    tableRow() {\n      const tableAlign =\n      /** @type {Array<Align>} */\n      this.getData('tableAlign');\n      let tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n\n      while (tableColumn < tableAlign.length) {\n        this.lineEndingIfNeeded();\n        this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>');\n        tableColumn++;\n      }\n\n      this.setData('tableColumn', tableColumn);\n      this.lineEndingIfNeeded();\n      this.tag('</tr>');\n    }\n\n  }\n};\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\n\nexports.gfmTableHtml = gfmTableHtml;\n\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["none","right","__esModule","gfmTableHtml","value","center","exit","enter","left"]],"~:compiled-at",1676841365324,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_extension_gfm_table$lib$html.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-extension-gfm-table/lib/html.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_extension_gfm_table$lib$html\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.gfmTableHtml = void 0;\\n\\n/**\\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\\n * @typedef {import('./syntax.js').Align} Align\\n */\\nconst alignment = {\\n  none: '',\\n  left: ' align=\\\"left\\\"',\\n  right: ' align=\\\"right\\\"',\\n  center: ' align=\\\"center\\\"'\\n};\\n/** @type {HtmlExtension} */\\n\\nconst gfmTableHtml = {\\n  enter: {\\n    table(token) {\\n      /** @type {Array<Align>} */\\n      // @ts-expect-error Custom.\\n      const tableAlign = token._align;\\n      this.lineEndingIfNeeded();\\n      this.tag('<table>');\\n      this.setData('tableAlign', tableAlign);\\n    },\\n\\n    tableBody() {\\n      // Clear slurping line ending from the delimiter row.\\n      this.setData('slurpOneLineEnding');\\n      this.tag('<tbody>');\\n    },\\n\\n    tableData() {\\n      const tableAlign =\\n      /** @type {Array<Align>} */\\n      this.getData('tableAlign');\\n      const tableColumn =\\n      /** @type {number} */\\n      this.getData('tableColumn');\\n      const align = alignment[tableAlign[tableColumn]];\\n\\n      if (align === undefined) {\\n        // Capture results to ignore them.\\n        this.buffer();\\n      } else {\\n        this.lineEndingIfNeeded();\\n        this.tag('<td' + align + '>');\\n      }\\n    },\\n\\n    tableHead() {\\n      this.lineEndingIfNeeded();\\n      this.tag('<thead>');\\n    },\\n\\n    tableHeader() {\\n      const tableAlign =\\n      /** @type {Array<Align>} */\\n      this.getData('tableAlign');\\n      const tableColumn =\\n      /** @type {number} */\\n      this.getData('tableColumn');\\n      const align = alignment[tableAlign[tableColumn]];\\n      this.lineEndingIfNeeded();\\n      this.tag('<th' + align + '>');\\n    },\\n\\n    tableRow() {\\n      this.setData('tableColumn', 0);\\n      this.lineEndingIfNeeded();\\n      this.tag('<tr>');\\n    }\\n\\n  },\\n  exit: {\\n    // Overwrite the default code text data handler to unescape escaped pipes when\\n    // they are in tables.\\n    codeTextData(token) {\\n      let value = this.sliceSerialize(token);\\n\\n      if (this.getData('tableAlign')) {\\n        value = value.replace(/\\\\\\\\([\\\\\\\\|])/g, replace);\\n      }\\n\\n      this.raw(this.encode(value));\\n    },\\n\\n    table() {\\n      this.setData('tableAlign'); // If there was no table body, make sure the slurping from the delimiter row\\n      // is cleared.\\n\\n      this.setData('slurpAllLineEndings');\\n      this.lineEndingIfNeeded();\\n      this.tag('</table>');\\n    },\\n\\n    tableBody() {\\n      this.lineEndingIfNeeded();\\n      this.tag('</tbody>');\\n    },\\n\\n    tableData() {\\n      const tableAlign =\\n      /** @type {Array<Align>} */\\n      this.getData('tableAlign');\\n      const tableColumn =\\n      /** @type {number} */\\n      this.getData('tableColumn');\\n\\n      if (tableColumn in tableAlign) {\\n        this.tag('</td>');\\n        this.setData('tableColumn', tableColumn + 1);\\n      } else {\\n        // Stop capturing.\\n        this.resume();\\n      }\\n    },\\n\\n    tableHead() {\\n      this.lineEndingIfNeeded();\\n      this.tag('</thead>');\\n      this.setData('slurpOneLineEnding', true); // Slurp the line ending from the delimiter row.\\n    },\\n\\n    tableHeader() {\\n      const tableColumn =\\n      /** @type {number} */\\n      this.getData('tableColumn');\\n      this.tag('</th>');\\n      this.setData('tableColumn', tableColumn + 1);\\n    },\\n\\n    tableRow() {\\n      const tableAlign =\\n      /** @type {Array<Align>} */\\n      this.getData('tableAlign');\\n      let tableColumn =\\n      /** @type {number} */\\n      this.getData('tableColumn');\\n\\n      while (tableColumn < tableAlign.length) {\\n        this.lineEndingIfNeeded();\\n        this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>');\\n        tableColumn++;\\n      }\\n\\n      this.setData('tableColumn', tableColumn);\\n      this.lineEndingIfNeeded();\\n      this.tag('</tr>');\\n    }\\n\\n  }\\n};\\n/**\\n * @param {string} $0\\n * @param {string} $1\\n * @returns {string}\\n */\\n\\nexports.gfmTableHtml = gfmTableHtml;\\n\\nfunction replace($0, $1) {\\n  // Pipes work, backslashes don\\u2019t (but can\\u2019t escape pipes).\\n  return $1 === '|' ? $1 : $0;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"replace\",\"$0\",\"$1\",\"Object\",\"defineProperty\",\"value\",\"gfmTableHtml\",\"alignment\",\"none\",\"left\",\"right\",\"center\",\"enter\",\"table\",\"token\",\"tableAlign\",\"_align\",\"lineEndingIfNeeded\",\"tag\",\"setData\",\"tableBody\",\"tableData\",\"getData\",\"tableColumn\",\"align\",\"undefined\",\"buffer\",\"tableHead\",\"tableHeader\",\"tableRow\",\"exit\",\"codeTextData\",\"sliceSerialize\",\"raw\",\"encode\",\"resume\",\"length\"]\n}\n"]