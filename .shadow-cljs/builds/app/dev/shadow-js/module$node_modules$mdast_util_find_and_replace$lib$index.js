["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mdast-util-find-and-replace/lib/index.js"],"~:js","shadow$provide.module$node_modules$mdast_util_find_and_replace$lib$index=function(global,require,module,exports){function toPairs(schema){const result=[];if(\"object\"!==typeof schema)throw new TypeError(\"Expected array or object as schema\");if(Array.isArray(schema))for(var index=-1;++index<schema.length;)result.push([toExpression(schema[index][0]),toFunction(schema[index][1])]);else for(index in schema)own.call(schema,index)&&result.push([toExpression(index),toFunction(schema[index])]);return result}\nfunction toExpression(find){return\"string\"===typeof find?new RegExp((0,_escapeStringRegexp.default)(find),\"g\"):find}function toFunction(replace){return\"function\"===typeof replace?replace:()=>replace}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.findAndReplace=void 0;var _escapeStringRegexp=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(require(\"module$node_modules$mdast_util_find_and_replace$node_modules$escape_string_regexp$index\")),_unistUtilVisitParents=require(\"module$node_modules$unist_util_visit_parents$index\"),\n_unistUtilIs=require(\"module$node_modules$unist_util_is$index\");const own={}.hasOwnProperty;exports.findAndReplace=function(tree,find,replace,options){function visitor(node,parents){for(var index$jscomp$0=-1,grandparent;++index$jscomp$0<parents.length;){var parent=parents[index$jscomp$0];if(ignored(parent,grandparent?grandparent.children.indexOf(parent):void 0,grandparent))return;grandparent=parent}if(grandparent){index$jscomp$0=parents[parents.length-1];grandparent=pairs[pairIndex][0];parent=pairs[pairIndex][1];\nlet start=0;const index=index$jscomp$0.children.indexOf(node);let change=!1,nodes=[];grandparent.lastIndex=0;let match=grandparent.exec(node.value);for(;match;){const position=match.index;var matchObject={index:match.index,input:match.input,stack:[...parents,node]};matchObject=parent(...match,matchObject);\"string\"===typeof matchObject&&(matchObject=0<matchObject.length?{type:\"text\",value:matchObject}:void 0);!1!==matchObject&&(start!==position&&nodes.push({type:\"text\",value:node.value.slice(start,\nposition)}),Array.isArray(matchObject)?nodes.push(...matchObject):matchObject&&nodes.push(matchObject),start=position+match[0].length,change=!0);if(!grandparent.global)break;match=grandparent.exec(node.value)}change?(start<node.value.length&&nodes.push({type:\"text\",value:node.value.slice(start)}),index$jscomp$0.children.splice(index,1,...nodes)):nodes=[node];return index+nodes.length}}if(\"string\"===typeof find||find instanceof RegExp)find=[[find,replace]],replace=options;replace||(replace={});const ignored=\n(0,_unistUtilIs.convert)(replace.ignore||[]),pairs=toPairs(find);let pairIndex=-1;for(;++pairIndex<pairs.length;)(0,_unistUtilVisitParents.visitParents)(tree,\"text\",visitor);return tree}}","~:source","shadow$provide[\"module$node_modules$mdast_util_find_and_replace$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findAndReplace = void 0;\n\nvar _escapeStringRegexp = _interopRequireDefault(require(\"escape-string-regexp\"));\n\nvar _unistUtilVisitParents = require(\"unist-util-visit-parents\");\n\nvar _unistUtilIs = require(\"unist-util-is\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {Extract<Node, MdastParent>} Parent\n * @typedef {Exclude<Parent, Root>} ContentParent\n *\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[Root, ...Array<ContentParent>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | undefined | null}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {string | RegExp} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n * @typedef {Record<string, Replace>} FindAndReplaceSchema\n *   Several find and replaces, in object form.\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n * @typedef {string | ReplaceFunction} Replace\n *   Thing to replace with.\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore.\n */\nconst own = {}.hasOwnProperty;\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param tree\n *   Tree to change.\n * @param find\n *   Patterns to find.\n * @param replace\n *   Things to replace with (when `find` is `Find`) or configuration.\n * @param options\n *   Configuration (when `find` is not `Find`).\n * @returns\n *   Given, modified, tree.\n */\n// To do: next major: remove `find` & `replace` combo, remove schema.\n\nconst findAndReplace =\n/**\n * @template {Node} Tree\n * @param {Tree} tree\n * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find\n * @param {Replace | Options | null | undefined} [replace]\n * @param {Options | null | undefined} [options]\n * @returns {Tree}\n */\nfunction (tree, find, replace, options) {\n  /** @type {Options | null | undefined} */\n  let settings;\n  /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n\n  let schema;\n\n  if (typeof find === 'string' || find instanceof RegExp) {\n    // @ts-expect-error don’t expect options twice.\n    schema = [[find, replace]];\n    settings = options;\n  } else {\n    schema = find; // @ts-expect-error don’t expect replace twice.\n\n    settings = replace;\n  }\n\n  if (!settings) {\n    settings = {};\n  }\n\n  const ignored = (0, _unistUtilIs.convert)(settings.ignore || []);\n  const pairs = toPairs(schema);\n  let pairIndex = -1;\n\n  while (++pairIndex < pairs.length) {\n    (0, _unistUtilVisitParents.visitParents)(tree, 'text', visitor);\n  } // To do next major: don’t return the given tree.\n\n\n  return tree;\n  /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */\n\n  function visitor(node, parents) {\n    let index = -1;\n    /** @type {Parent | undefined} */\n\n    let grandparent;\n\n    while (++index < parents.length) {\n      const parent = parents[index];\n\n      if (ignored(parent, // @ts-expect-error: TS doesn’t understand but it’s perfect.\n      grandparent ? grandparent.children.indexOf(parent) : undefined, grandparent)) {\n        return;\n      }\n\n      grandparent = parent;\n    }\n\n    if (grandparent) {\n      return handler(node, parents);\n    }\n  }\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parent>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n\n\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1];\n    const find = pairs[pairIndex][0];\n    const replace = pairs[pairIndex][1];\n    let start = 0; // @ts-expect-error: TS is wrong, some of these children can be text.\n\n    const index = parent.children.indexOf(node);\n    let change = false;\n    /** @type {Array<PhrasingContent>} */\n\n    let nodes = [];\n    find.lastIndex = 0;\n    let match = find.exec(node.value);\n\n    while (match) {\n      const position = match.index;\n      /** @type {RegExpMatchObject} */\n\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        // @ts-expect-error: stack is fine.\n        stack: [...parents, node]\n      };\n      let value = replace(...match, matchObject);\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {\n          type: 'text',\n          value\n        } : undefined;\n      } // It wasn’t a match after all.\n\n\n      if (value !== false) {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          });\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value);\n        } else if (value) {\n          nodes.push(value);\n        }\n\n        start = position + match[0].length;\n        change = true;\n      }\n\n      if (!find.global) {\n        break;\n      }\n\n      match = find.exec(node.value);\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({\n          type: 'text',\n          value: node.value.slice(start)\n        });\n      }\n\n      parent.children.splice(index, 1, ...nodes);\n    } else {\n      nodes = [node];\n    }\n\n    return index + nodes.length;\n  }\n};\n/**\n * Turn a schema into pairs.\n *\n * @param {FindAndReplaceSchema | FindAndReplaceList} schema\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\n\n\nexports.findAndReplace = findAndReplace;\n\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = [];\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema');\n  }\n\n  if (Array.isArray(schema)) {\n    let index = -1;\n\n    while (++index < schema.length) {\n      result.push([toExpression(schema[index][0]), toFunction(schema[index][1])]);\n    }\n  } else {\n    /** @type {string} */\n    let key;\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\n\n\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp((0, _escapeStringRegexp.default)(find), 'g') : find;\n}\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\n\n\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$unist_util_visit_parents$index","~$shadow.js","~$module$node_modules$unist_util_is$index","~$module$node_modules$mdast_util_find_and_replace$node_modules$escape_string_regexp$index"]],"~:properties",["^5",["index","findAndReplace","__esModule","lastIndex","value","input","type","default","stack"]],"~:compiled-at",1676841365333,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mdast_util_find_and_replace$lib$index.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mdast-util-find-and-replace/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mdast_util_find_and_replace$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.findAndReplace = void 0;\\n\\nvar _escapeStringRegexp = _interopRequireDefault(require(\\\"escape-string-regexp\\\"));\\n\\nvar _unistUtilVisitParents = require(\\\"unist-util-visit-parents\\\");\\n\\nvar _unistUtilIs = require(\\\"unist-util-is\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n/**\\n * @typedef {import('mdast').Parent} MdastParent\\n * @typedef {import('mdast').Root} Root\\n * @typedef {import('mdast').Content} Content\\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\\n * @typedef {import('mdast').Text} Text\\n * @typedef {import('unist-util-visit-parents').Test} Test\\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\\n */\\n\\n/**\\n * @typedef {Content | Root} Node\\n * @typedef {Extract<Node, MdastParent>} Parent\\n * @typedef {Exclude<Parent, Root>} ContentParent\\n *\\n * @typedef RegExpMatchObject\\n *   Info on the match.\\n * @property {number} index\\n *   The index of the search at which the result was found.\\n * @property {string} input\\n *   A copy of the search string in the text node.\\n * @property {[Root, ...Array<ContentParent>, Text]} stack\\n *   All ancestors of the text node, where the last node is the text itself.\\n *\\n * @callback ReplaceFunction\\n *   Callback called when a search matches.\\n * @param {...any} parameters\\n *   The parameters are the result of corresponding search expression:\\n *\\n *   * `value` (`string`) \\u2014 whole match\\n *   * `...capture` (`Array<string>`) \\u2014 matches from regex capture groups\\n *   * `match` (`RegExpMatchObject`) \\u2014 info on the match\\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | undefined | null}\\n *   Thing to replace with.\\n *\\n *   * when `null`, `undefined`, `''`, remove the match\\n *   * \\u2026or when `false`, do not replace at all\\n *   * \\u2026or when `string`, replace with a text node of that value\\n *   * \\u2026or when `Node` or `Array<Node>`, replace with those nodes\\n *\\n * @typedef {string | RegExp} Find\\n *   Pattern to find.\\n *\\n *   Strings are escaped and then turned into global expressions.\\n *\\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\\n *   Several find and replaces, in array form.\\n * @typedef {Record<string, Replace>} FindAndReplaceSchema\\n *   Several find and replaces, in object form.\\n * @typedef {[Find, Replace]} FindAndReplaceTuple\\n *   Find and replace in tuple form.\\n * @typedef {string | ReplaceFunction} Replace\\n *   Thing to replace with.\\n * @typedef {[RegExp, ReplaceFunction]} Pair\\n *   Normalized find and replace.\\n * @typedef {Array<Pair>} Pairs\\n *   All find and replaced.\\n *\\n * @typedef Options\\n *   Configuration.\\n * @property {Test | null | undefined} [ignore]\\n *   Test for which nodes to ignore.\\n */\\nconst own = {}.hasOwnProperty;\\n/**\\n * Find patterns in a tree and replace them.\\n *\\n * The algorithm searches the tree in *preorder* for complete values in `Text`\\n * nodes.\\n * Partial matches are not supported.\\n *\\n * @param tree\\n *   Tree to change.\\n * @param find\\n *   Patterns to find.\\n * @param replace\\n *   Things to replace with (when `find` is `Find`) or configuration.\\n * @param options\\n *   Configuration (when `find` is not `Find`).\\n * @returns\\n *   Given, modified, tree.\\n */\\n// To do: next major: remove `find` & `replace` combo, remove schema.\\n\\nconst findAndReplace =\\n/**\\n * @template {Node} Tree\\n * @param {Tree} tree\\n * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find\\n * @param {Replace | Options | null | undefined} [replace]\\n * @param {Options | null | undefined} [options]\\n * @returns {Tree}\\n */\\nfunction (tree, find, replace, options) {\\n  /** @type {Options | null | undefined} */\\n  let settings;\\n  /** @type {FindAndReplaceSchema|FindAndReplaceList} */\\n\\n  let schema;\\n\\n  if (typeof find === 'string' || find instanceof RegExp) {\\n    // @ts-expect-error don\\u2019t expect options twice.\\n    schema = [[find, replace]];\\n    settings = options;\\n  } else {\\n    schema = find; // @ts-expect-error don\\u2019t expect replace twice.\\n\\n    settings = replace;\\n  }\\n\\n  if (!settings) {\\n    settings = {};\\n  }\\n\\n  const ignored = (0, _unistUtilIs.convert)(settings.ignore || []);\\n  const pairs = toPairs(schema);\\n  let pairIndex = -1;\\n\\n  while (++pairIndex < pairs.length) {\\n    (0, _unistUtilVisitParents.visitParents)(tree, 'text', visitor);\\n  } // To do next major: don\\u2019t return the given tree.\\n\\n\\n  return tree;\\n  /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */\\n\\n  function visitor(node, parents) {\\n    let index = -1;\\n    /** @type {Parent | undefined} */\\n\\n    let grandparent;\\n\\n    while (++index < parents.length) {\\n      const parent = parents[index];\\n\\n      if (ignored(parent, // @ts-expect-error: TS doesn\\u2019t understand but it\\u2019s perfect.\\n      grandparent ? grandparent.children.indexOf(parent) : undefined, grandparent)) {\\n        return;\\n      }\\n\\n      grandparent = parent;\\n    }\\n\\n    if (grandparent) {\\n      return handler(node, parents);\\n    }\\n  }\\n  /**\\n   * Handle a text node which is not in an ignored parent.\\n   *\\n   * @param {Text} node\\n   *   Text node.\\n   * @param {Array<Parent>} parents\\n   *   Parents.\\n   * @returns {VisitorResult}\\n   *   Result.\\n   */\\n\\n\\n  function handler(node, parents) {\\n    const parent = parents[parents.length - 1];\\n    const find = pairs[pairIndex][0];\\n    const replace = pairs[pairIndex][1];\\n    let start = 0; // @ts-expect-error: TS is wrong, some of these children can be text.\\n\\n    const index = parent.children.indexOf(node);\\n    let change = false;\\n    /** @type {Array<PhrasingContent>} */\\n\\n    let nodes = [];\\n    find.lastIndex = 0;\\n    let match = find.exec(node.value);\\n\\n    while (match) {\\n      const position = match.index;\\n      /** @type {RegExpMatchObject} */\\n\\n      const matchObject = {\\n        index: match.index,\\n        input: match.input,\\n        // @ts-expect-error: stack is fine.\\n        stack: [...parents, node]\\n      };\\n      let value = replace(...match, matchObject);\\n\\n      if (typeof value === 'string') {\\n        value = value.length > 0 ? {\\n          type: 'text',\\n          value\\n        } : undefined;\\n      } // It wasn\\u2019t a match after all.\\n\\n\\n      if (value !== false) {\\n        if (start !== position) {\\n          nodes.push({\\n            type: 'text',\\n            value: node.value.slice(start, position)\\n          });\\n        }\\n\\n        if (Array.isArray(value)) {\\n          nodes.push(...value);\\n        } else if (value) {\\n          nodes.push(value);\\n        }\\n\\n        start = position + match[0].length;\\n        change = true;\\n      }\\n\\n      if (!find.global) {\\n        break;\\n      }\\n\\n      match = find.exec(node.value);\\n    }\\n\\n    if (change) {\\n      if (start < node.value.length) {\\n        nodes.push({\\n          type: 'text',\\n          value: node.value.slice(start)\\n        });\\n      }\\n\\n      parent.children.splice(index, 1, ...nodes);\\n    } else {\\n      nodes = [node];\\n    }\\n\\n    return index + nodes.length;\\n  }\\n};\\n/**\\n * Turn a schema into pairs.\\n *\\n * @param {FindAndReplaceSchema | FindAndReplaceList} schema\\n *   Schema.\\n * @returns {Pairs}\\n *   Clean pairs.\\n */\\n\\n\\nexports.findAndReplace = findAndReplace;\\n\\nfunction toPairs(schema) {\\n  /** @type {Pairs} */\\n  const result = [];\\n\\n  if (typeof schema !== 'object') {\\n    throw new TypeError('Expected array or object as schema');\\n  }\\n\\n  if (Array.isArray(schema)) {\\n    let index = -1;\\n\\n    while (++index < schema.length) {\\n      result.push([toExpression(schema[index][0]), toFunction(schema[index][1])]);\\n    }\\n  } else {\\n    /** @type {string} */\\n    let key;\\n\\n    for (key in schema) {\\n      if (own.call(schema, key)) {\\n        result.push([toExpression(key), toFunction(schema[key])]);\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n/**\\n * Turn a find into an expression.\\n *\\n * @param {Find} find\\n *   Find.\\n * @returns {RegExp}\\n *   Expression.\\n */\\n\\n\\nfunction toExpression(find) {\\n  return typeof find === 'string' ? new RegExp((0, _escapeStringRegexp.default)(find), 'g') : find;\\n}\\n/**\\n * Turn a replace into a function.\\n *\\n * @param {Replace} replace\\n *   Replace.\\n * @returns {ReplaceFunction}\\n *   Function.\\n */\\n\\n\\nfunction toFunction(replace) {\\n  return typeof replace === 'function' ? replace : () => replace;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"toPairs\",\"schema\",\"result\",\"TypeError\",\"Array\",\"isArray\",\"index\",\"length\",\"push\",\"toExpression\",\"toFunction\",\"key\",\"own\",\"call\",\"find\",\"RegExp\",\"_escapeStringRegexp\",\"default\",\"replace\",\"Object\",\"defineProperty\",\"value\",\"findAndReplace\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"_unistUtilVisitParents\",\"_unistUtilIs\",\"hasOwnProperty\",\"tree\",\"options\",\"visitor\",\"node\",\"parents\",\"grandparent\",\"parent\",\"ignored\",\"children\",\"indexOf\",\"undefined\",\"pairs\",\"pairIndex\",\"start\",\"change\",\"nodes\",\"lastIndex\",\"match\",\"exec\",\"position\",\"matchObject\",\"input\",\"stack\",\"type\",\"slice\",\"splice\",\"settings\",\"convert\",\"ignore\",\"visitParents\"]\n}\n"]