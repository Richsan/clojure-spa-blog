["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/stringify-entities/lib/util/format-smart.js"],"~:js","shadow$provide.module$node_modules$stringify_entities$lib$util$format_smart=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.formatSmart=function(code,next,options){let numeric=(0,_toHexadecimal.toHexadecimal)(code,next,options.omitOptionalSemicolons),named;if(options.useNamedReferences||options.useShortestReferences)named=(0,_toNamed.toNamed)(code,next,options.omitOptionalSemicolons,options.attribute);!options.useShortestReferences&&named||!options.useShortestReferences||\n(code=(0,_toDecimal.toDecimal)(code,next,options.omitOptionalSemicolons),code.length<numeric.length&&(numeric=code));return named&&(!options.useShortestReferences||named.length<numeric.length)?named:numeric};var _toHexadecimal=require(\"module$node_modules$stringify_entities$lib$util$to_hexadecimal\"),_toDecimal=require(\"module$node_modules$stringify_entities$lib$util$to_decimal\"),_toNamed=require(\"module$node_modules$stringify_entities$lib$util$to_named\")}","~:source","shadow$provide[\"module$node_modules$stringify_entities$lib$util$format_smart\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatSmart = formatSmart;\n\nvar _toHexadecimal = require(\"./to-hexadecimal.js\");\n\nvar _toDecimal = require(\"./to-decimal.js\");\n\nvar _toNamed = require(\"./to-named.js\");\n\n/**\n * @typedef FormatSmartOptions\n * @property {boolean} [useNamedReferences=false]\n *   Prefer named character references (`&amp;`) where possible.\n * @property {boolean} [useShortestReferences=false]\n *   Prefer the shortest possible reference, if that results in less bytes.\n *   **Note**: `useNamedReferences` can be omitted when using `useShortestReferences`.\n * @property {boolean} [omitOptionalSemicolons=false]\n *   Whether to omit semicolons when possible.\n *   **Note**: This creates what HTML calls “parse errors” but is otherwise still valid HTML — don’t use this except when building a minifier.\n *   Omitting semicolons is possible for certain named and numeric references in some cases.\n * @property {boolean} [attribute=false]\n *   Create character references which don’t fail in attributes.\n *   **Note**: `attribute` only applies when operating dangerously with\n *   `omitOptionalSemicolons: true`.\n */\n\n/**\n * Configurable ways to encode a character yielding pretty or small results.\n *\n * @param {number} code\n * @param {number} next\n * @param {FormatSmartOptions} options\n * @returns {string}\n */\nfunction formatSmart(code, next, options) {\n  let numeric = (0, _toHexadecimal.toHexadecimal)(code, next, options.omitOptionalSemicolons);\n  /** @type {string|undefined} */\n\n  let named;\n\n  if (options.useNamedReferences || options.useShortestReferences) {\n    named = (0, _toNamed.toNamed)(code, next, options.omitOptionalSemicolons, options.attribute);\n  } // Use the shortest numeric reference when requested.\n  // A simple algorithm would use decimal for all code points under 100, as\n  // those are shorter than hexadecimal:\n  //\n  // * `&#99;` vs `&#x63;` (decimal shorter)\n  // * `&#100;` vs `&#x64;` (equal)\n  //\n  // However, because we take `next` into consideration when `omit` is used,\n  // And it would be possible that decimals are shorter on bigger values as\n  // well if `next` is hexadecimal but not decimal, we instead compare both.\n\n\n  if ((options.useShortestReferences || !named) && options.useShortestReferences) {\n    const decimal = (0, _toDecimal.toDecimal)(code, next, options.omitOptionalSemicolons);\n\n    if (decimal.length < numeric.length) {\n      numeric = decimal;\n    }\n  }\n\n  return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$stringify_entities$lib$util$to_named","~$shadow.js","~$module$node_modules$stringify_entities$lib$util$to_decimal","~$module$node_modules$stringify_entities$lib$util$to_hexadecimal"]],"~:properties",["^5",["formatSmart","__esModule","value"]],"~:compiled-at",1676686799595,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$stringify_entities$lib$util$format_smart.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,4DAAA,CAAiF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGzHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,WAAR,CAiCAA,QAAoB,CAACC,IAAD,CAAOC,IAAP,CAAaC,OAAb,CAAsB,CACxC,IAAIC,QAAU,GAAIC,cAAeC,CAAAA,aAAnB,EAAkCL,IAAlC,CAAwCC,IAAxC,CAA8CC,OAAQI,CAAAA,sBAAtD,CAAd,CAGIC,KAEJ,IAAIL,OAAQM,CAAAA,kBAAZ,EAAkCN,OAAQO,CAAAA,qBAA1C,CACEF,KAAA,CAAQ,GAAIG,QAASC,CAAAA,OAAb,EAAsBX,IAAtB,CAA4BC,IAA5B,CAAkCC,OAAQI,CAAAA,sBAA1C,CAAkEJ,OAAQU,CAAAA,SAA1E,CAaGH,EAARP,OAAQO,CAAAA,qBAAb,EAAuCF,KAAvC,EAAyDE,CAARP,OAAQO,CAAAA,qBAAzD;CACQI,IAEN,CAFgB,GAAIC,UAAWC,CAAAA,SAAf,EAA0Bf,IAA1B,CAAgCC,IAAhC,CAAsCC,OAAQI,CAAAA,sBAA9C,CAEhB,CAAIO,IAAQG,CAAAA,MAAZ,CAAqBb,OAAQa,CAAAA,MAA7B,GACEb,OADF,CACYU,IADZ,CAHF,CAQA,OAAON,MAAA,GAAU,CAACL,OAAQO,CAAAA,qBAAnB,EAA4CF,KAAMS,CAAAA,MAAlD,CAA2Db,OAAQa,CAAAA,MAAnE,EAA6ET,KAA7E,CAAqFJ,OA5BpD,CA/B1C,KAAIC,eAAiBX,OAAA,CAAQ,gEAAR,CAArB,CAEIqB,WAAarB,OAAA,CAAQ,4DAAR,CAFjB,CAIIiB,SAAWjB,OAAA,CAAQ,0DAAR,CAZ0G;\",\n\"sources\":[\"node_modules/stringify-entities/lib/util/format-smart.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$stringify_entities$lib$util$format_smart\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.formatSmart = formatSmart;\\n\\nvar _toHexadecimal = require(\\\"./to-hexadecimal.js\\\");\\n\\nvar _toDecimal = require(\\\"./to-decimal.js\\\");\\n\\nvar _toNamed = require(\\\"./to-named.js\\\");\\n\\n/**\\n * @typedef FormatSmartOptions\\n * @property {boolean} [useNamedReferences=false]\\n *   Prefer named character references (`&amp;`) where possible.\\n * @property {boolean} [useShortestReferences=false]\\n *   Prefer the shortest possible reference, if that results in less bytes.\\n *   **Note**: `useNamedReferences` can be omitted when using `useShortestReferences`.\\n * @property {boolean} [omitOptionalSemicolons=false]\\n *   Whether to omit semicolons when possible.\\n *   **Note**: This creates what HTML calls \\u201cparse errors\\u201d but is otherwise still valid HTML \\u2014 don\\u2019t use this except when building a minifier.\\n *   Omitting semicolons is possible for certain named and numeric references in some cases.\\n * @property {boolean} [attribute=false]\\n *   Create character references which don\\u2019t fail in attributes.\\n *   **Note**: `attribute` only applies when operating dangerously with\\n *   `omitOptionalSemicolons: true`.\\n */\\n\\n/**\\n * Configurable ways to encode a character yielding pretty or small results.\\n *\\n * @param {number} code\\n * @param {number} next\\n * @param {FormatSmartOptions} options\\n * @returns {string}\\n */\\nfunction formatSmart(code, next, options) {\\n  let numeric = (0, _toHexadecimal.toHexadecimal)(code, next, options.omitOptionalSemicolons);\\n  /** @type {string|undefined} */\\n\\n  let named;\\n\\n  if (options.useNamedReferences || options.useShortestReferences) {\\n    named = (0, _toNamed.toNamed)(code, next, options.omitOptionalSemicolons, options.attribute);\\n  } // Use the shortest numeric reference when requested.\\n  // A simple algorithm would use decimal for all code points under 100, as\\n  // those are shorter than hexadecimal:\\n  //\\n  // * `&#99;` vs `&#x63;` (decimal shorter)\\n  // * `&#100;` vs `&#x64;` (equal)\\n  //\\n  // However, because we take `next` into consideration when `omit` is used,\\n  // And it would be possible that decimals are shorter on bigger values as\\n  // well if `next` is hexadecimal but not decimal, we instead compare both.\\n\\n\\n  if ((options.useShortestReferences || !named) && options.useShortestReferences) {\\n    const decimal = (0, _toDecimal.toDecimal)(code, next, options.omitOptionalSemicolons);\\n\\n    if (decimal.length < numeric.length) {\\n      numeric = decimal;\\n    }\\n  }\\n\\n  return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"formatSmart\",\"code\",\"next\",\"options\",\"numeric\",\"_toHexadecimal\",\"toHexadecimal\",\"omitOptionalSemicolons\",\"named\",\"useNamedReferences\",\"useShortestReferences\",\"_toNamed\",\"toNamed\",\"attribute\",\"decimal\",\"_toDecimal\",\"toDecimal\",\"length\"]\n}\n"]