["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/lisp.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$lisp=function(global,require,module,exports){function lisp(Prism$jscomp$0){(function(Prism){function simple_form(name){return RegExp(/(\\()/.source+\"(?:\"+name+\")\"+/(?=[\\s\\)])/.source)}function primitive(pattern){return RegExp(/([\\s([])/.source+\"(?:\"+pattern+\")\"+/(?=[\\s)])/.source)}var symbol=/(?!\\d)[-+*/~!@$%^=<>{}\\w]+/.source,marker=\"\\x26\"+symbol,nestedPar=/(?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\([^()]*\\))*\\))*\\))*\\))*\\))*/.source,language=\n{heading:{pattern:/;;;.*/,alias:[\"comment\",\"title\"]},comment:/;.*/,string:{pattern:/\"(?:[^\"\\\\]|\\\\.)*\"/,greedy:!0,inside:{argument:/[-A-Z]+(?=[.,\\s])/,symbol:RegExp(\"`\"+symbol+\"'\")}},\"quoted-symbol\":{pattern:RegExp(\"#?'\"+symbol),alias:[\"variable\",\"symbol\"]},\"lisp-property\":{pattern:RegExp(\":\"+symbol),alias:\"property\"},splice:{pattern:RegExp(\",@?\"+symbol),alias:[\"symbol\",\"variable\"]},keyword:[{pattern:RegExp(\"(\\\\()(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)(?\\x3d\\\\s)\"),\nlookbehind:!0},{pattern:RegExp(\"(\\\\()(?:append|by|collect|concat|do|finally|for|in|return)(?\\x3d\\\\s)\"),lookbehind:!0}],declare:{pattern:simple_form(/declare/.source),lookbehind:!0,alias:\"keyword\"},interactive:{pattern:simple_form(/interactive/.source),lookbehind:!0,alias:\"keyword\"},boolean:{pattern:primitive(/nil|t/.source),lookbehind:!0},number:{pattern:primitive(/[-+]?\\d+(?:\\.\\d*)?/.source),lookbehind:!0},defvar:{pattern:RegExp(\"(\\\\()def(?:const|custom|group|var)\\\\s+\"+symbol),lookbehind:!0,inside:{keyword:/^def[a-z]+/,\nvariable:RegExp(symbol)}},defun:{pattern:RegExp(\"(\\\\()\"+/(?:cl-)?(?:defmacro|defun\\*?)\\s+/.source+symbol+/\\s+\\(/.source+nestedPar+/\\)/.source),lookbehind:!0,greedy:!0,inside:{keyword:/^(?:cl-)?def\\S+/,arguments:null,function:{pattern:RegExp(\"(^\\\\s)\"+symbol),lookbehind:!0},punctuation:/[()]/}},lambda:{pattern:RegExp(\"(\\\\()lambda\\\\s+\\\\(\\\\s*(?:\\x26?\"+symbol+\"(?:\\\\s+\\x26?\"+symbol+\")*\\\\s*)?\\\\)\"),lookbehind:!0,greedy:!0,inside:{keyword:/^lambda/,arguments:null,punctuation:/[()]/}},car:{pattern:RegExp(\"(\\\\()\"+\nsymbol),lookbehind:!0},punctuation:[/(?:['`,]?\\(|[)\\[\\]])/,{pattern:/(\\s)\\.(?=\\s)/,lookbehind:!0}]};marker={\"lisp-marker\":RegExp(marker),varform:{pattern:RegExp(/\\(/.source+symbol+/\\s+(?=\\S)/.source+nestedPar+/\\)/.source),inside:language},argument:{pattern:RegExp(/(^|[\\s(])/.source+symbol),lookbehind:!0,alias:\"variable\"},rest:language};symbol={pattern:RegExp(\"(\\\\()\"+nestedPar+\"(?\\x3d\\\\))\"),lookbehind:!0,inside:{\"rest-vars\":{pattern:RegExp(\"\\x26(?:body|rest)\\\\s+\\\\S+(?:\\\\s+\\\\S+)*\"),inside:marker},\"other-marker-vars\":{pattern:RegExp(\"\\x26(?:aux|optional)\\\\s+\\\\S+(?:\\\\s+\\\\S+)*\"),\ninside:marker},keys:{pattern:RegExp(\"\\x26key\\\\s+\\\\S+(?:\\\\s+\\\\S+)*(?:\\\\s+\\x26allow-other-keys)?\"),inside:marker},argument:{pattern:RegExp(symbol),alias:\"variable\"},punctuation:/[()]/}};language.lambda.inside.arguments=symbol;language.defun.inside.arguments=Prism.util.clone(symbol);language.defun.inside.arguments.inside.sublist=symbol;Prism.languages.lisp=language;Prism.languages.elisp=language;Prism.languages.emacs=language;Prism.languages[\"emacs-lisp\"]=language})(Prism$jscomp$0)}Object.defineProperty(exports,\n\"__esModule\",{value:!0});exports.default=lisp;lisp.displayName=\"lisp\";lisp.aliases=[\"elisp\",\"emacs\",\"emacs-lisp\"]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$lisp\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = lisp;\n// @ts-nocheck\nlisp.displayName = 'lisp';\nlisp.aliases = ['elisp', 'emacs', 'emacs-lisp'];\n/** @type {import('../core.js').Syntax} */\n\nfunction lisp(Prism) {\n  ;\n\n  (function (Prism) {\n    /**\n     * Functions to construct regular expressions\n     * e.g. (interactive ... or (interactive)\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n    function simple_form(name) {\n      return RegExp(/(\\()/.source + '(?:' + name + ')' + /(?=[\\s\\)])/.source);\n    }\n    /**\n     * booleans and numbers\n     *\n     * @param {string} pattern\n     * @returns {RegExp}\n     */\n\n\n    function primitive(pattern) {\n      return RegExp(/([\\s([])/.source + '(?:' + pattern + ')' + /(?=[\\s)])/.source);\n    } // Patterns in regular expressions\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n    // & and : are excluded as they are usually used for special purposes\n\n\n    var symbol = /(?!\\d)[-+*/~!@$%^=<>{}\\w]+/.source; // symbol starting with & used in function arguments\n\n    var marker = '&' + symbol; // Open parenthesis for look-behind\n\n    var par = '(\\\\()';\n    var endpar = '(?=\\\\))'; // End the pattern with look-ahead space\n\n    var space = '(?=\\\\s)';\n    var nestedPar = /(?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\([^()]*\\))*\\))*\\))*\\))*\\))*/.source;\n    var language = {\n      // Three or four semicolons are considered a heading.\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n      heading: {\n        pattern: /;;;.*/,\n        alias: ['comment', 'title']\n      },\n      comment: /;.*/,\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true,\n        inside: {\n          argument: /[-A-Z]+(?=[.,\\s])/,\n          symbol: RegExp('`' + symbol + \"'\")\n        }\n      },\n      'quoted-symbol': {\n        pattern: RegExp(\"#?'\" + symbol),\n        alias: ['variable', 'symbol']\n      },\n      'lisp-property': {\n        pattern: RegExp(':' + symbol),\n        alias: 'property'\n      },\n      splice: {\n        pattern: RegExp(',@?' + symbol),\n        alias: ['symbol', 'variable']\n      },\n      keyword: [{\n        pattern: RegExp(par + '(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)' + space),\n        lookbehind: true\n      }, {\n        pattern: RegExp(par + '(?:append|by|collect|concat|do|finally|for|in|return)' + space),\n        lookbehind: true\n      }],\n      declare: {\n        pattern: simple_form(/declare/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      interactive: {\n        pattern: simple_form(/interactive/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      boolean: {\n        pattern: primitive(/nil|t/.source),\n        lookbehind: true\n      },\n      number: {\n        pattern: primitive(/[-+]?\\d+(?:\\.\\d*)?/.source),\n        lookbehind: true\n      },\n      defvar: {\n        pattern: RegExp(par + 'def(?:const|custom|group|var)\\\\s+' + symbol),\n        lookbehind: true,\n        inside: {\n          keyword: /^def[a-z]+/,\n          variable: RegExp(symbol)\n        }\n      },\n      defun: {\n        pattern: RegExp(par + /(?:cl-)?(?:defmacro|defun\\*?)\\s+/.source + symbol + /\\s+\\(/.source + nestedPar + /\\)/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^(?:cl-)?def\\S+/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          function: {\n            pattern: RegExp('(^\\\\s)' + symbol),\n            lookbehind: true\n          },\n          punctuation: /[()]/\n        }\n      },\n      lambda: {\n        pattern: RegExp(par + 'lambda\\\\s+\\\\(\\\\s*(?:&?' + symbol + '(?:\\\\s+&?' + symbol + ')*\\\\s*)?\\\\)'),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^lambda/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          punctuation: /[()]/\n        }\n      },\n      car: {\n        pattern: RegExp(par + symbol),\n        lookbehind: true\n      },\n      punctuation: [// open paren, brackets, and close paren\n      /(?:['`,]?\\(|[)\\[\\]])/, // cons\n      {\n        pattern: /(\\s)\\.(?=\\s)/,\n        lookbehind: true\n      }]\n    };\n    var arg = {\n      'lisp-marker': RegExp(marker),\n      varform: {\n        pattern: RegExp(/\\(/.source + symbol + /\\s+(?=\\S)/.source + nestedPar + /\\)/.source),\n        inside: language\n      },\n      argument: {\n        pattern: RegExp(/(^|[\\s(])/.source + symbol),\n        lookbehind: true,\n        alias: 'variable'\n      },\n      rest: language\n    };\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*';\n    var arglist = {\n      pattern: RegExp(par + nestedPar + endpar),\n      lookbehind: true,\n      inside: {\n        'rest-vars': {\n          pattern: RegExp('&(?:body|rest)\\\\s+' + forms),\n          inside: arg\n        },\n        'other-marker-vars': {\n          pattern: RegExp('&(?:aux|optional)\\\\s+' + forms),\n          inside: arg\n        },\n        keys: {\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n          inside: arg\n        },\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        punctuation: /[()]/\n      }\n    };\n    language['lambda'].inside.arguments = arglist;\n    language['defun'].inside.arguments = Prism.util.clone(arglist);\n    language['defun'].inside.arguments.inside.sublist = arglist;\n    Prism.languages.lisp = language;\n    Prism.languages.elisp = language;\n    Prism.languages.emacs = language;\n    Prism.languages['emacs-lisp'] = language;\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["interactive","boolean","varform","heading","punctuation","string","keys","aliases","declare","displayName","__esModule","rest","lookbehind","splice","value","emacs","variable","keyword","number","sublist","greedy","symbol","function","pattern","argument","inside","car","arguments","defvar","lisp","alias","defun","comment","lambda","elisp","default"]],"~:compiled-at",1676841365434,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$lisp.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lang/lisp.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$lisp\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = lisp;\\n// @ts-nocheck\\nlisp.displayName = 'lisp';\\nlisp.aliases = ['elisp', 'emacs', 'emacs-lisp'];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction lisp(Prism) {\\n  ;\\n\\n  (function (Prism) {\\n    /**\\n     * Functions to construct regular expressions\\n     * e.g. (interactive ... or (interactive)\\n     *\\n     * @param {string} name\\n     * @returns {RegExp}\\n     */\\n    function simple_form(name) {\\n      return RegExp(/(\\\\()/.source + '(?:' + name + ')' + /(?=[\\\\s\\\\)])/.source);\\n    }\\n    /**\\n     * booleans and numbers\\n     *\\n     * @param {string} pattern\\n     * @returns {RegExp}\\n     */\\n\\n\\n    function primitive(pattern) {\\n      return RegExp(/([\\\\s([])/.source + '(?:' + pattern + ')' + /(?=[\\\\s)])/.source);\\n    } // Patterns in regular expressions\\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\\n    // & and : are excluded as they are usually used for special purposes\\n\\n\\n    var symbol = /(?!\\\\d)[-+*/~!@$%^=<>{}\\\\w]+/.source; // symbol starting with & used in function arguments\\n\\n    var marker = '&' + symbol; // Open parenthesis for look-behind\\n\\n    var par = '(\\\\\\\\()';\\n    var endpar = '(?=\\\\\\\\))'; // End the pattern with look-ahead space\\n\\n    var space = '(?=\\\\\\\\s)';\\n    var nestedPar = /(?:[^()]|\\\\((?:[^()]|\\\\((?:[^()]|\\\\((?:[^()]|\\\\((?:[^()]|\\\\([^()]*\\\\))*\\\\))*\\\\))*\\\\))*\\\\))*/.source;\\n    var language = {\\n      // Three or four semicolons are considered a heading.\\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\\n      heading: {\\n        pattern: /;;;.*/,\\n        alias: ['comment', 'title']\\n      },\\n      comment: /;.*/,\\n      string: {\\n        pattern: /\\\"(?:[^\\\"\\\\\\\\]|\\\\\\\\.)*\\\"/,\\n        greedy: true,\\n        inside: {\\n          argument: /[-A-Z]+(?=[.,\\\\s])/,\\n          symbol: RegExp('`' + symbol + \\\"'\\\")\\n        }\\n      },\\n      'quoted-symbol': {\\n        pattern: RegExp(\\\"#?'\\\" + symbol),\\n        alias: ['variable', 'symbol']\\n      },\\n      'lisp-property': {\\n        pattern: RegExp(':' + symbol),\\n        alias: 'property'\\n      },\\n      splice: {\\n        pattern: RegExp(',@?' + symbol),\\n        alias: ['symbol', 'variable']\\n      },\\n      keyword: [{\\n        pattern: RegExp(par + '(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\\\\\\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)' + space),\\n        lookbehind: true\\n      }, {\\n        pattern: RegExp(par + '(?:append|by|collect|concat|do|finally|for|in|return)' + space),\\n        lookbehind: true\\n      }],\\n      declare: {\\n        pattern: simple_form(/declare/.source),\\n        lookbehind: true,\\n        alias: 'keyword'\\n      },\\n      interactive: {\\n        pattern: simple_form(/interactive/.source),\\n        lookbehind: true,\\n        alias: 'keyword'\\n      },\\n      boolean: {\\n        pattern: primitive(/nil|t/.source),\\n        lookbehind: true\\n      },\\n      number: {\\n        pattern: primitive(/[-+]?\\\\d+(?:\\\\.\\\\d*)?/.source),\\n        lookbehind: true\\n      },\\n      defvar: {\\n        pattern: RegExp(par + 'def(?:const|custom|group|var)\\\\\\\\s+' + symbol),\\n        lookbehind: true,\\n        inside: {\\n          keyword: /^def[a-z]+/,\\n          variable: RegExp(symbol)\\n        }\\n      },\\n      defun: {\\n        pattern: RegExp(par + /(?:cl-)?(?:defmacro|defun\\\\*?)\\\\s+/.source + symbol + /\\\\s+\\\\(/.source + nestedPar + /\\\\)/.source),\\n        lookbehind: true,\\n        greedy: true,\\n        inside: {\\n          keyword: /^(?:cl-)?def\\\\S+/,\\n          // See below, this property needs to be defined later so that it can\\n          // reference the language object.\\n          arguments: null,\\n          function: {\\n            pattern: RegExp('(^\\\\\\\\s)' + symbol),\\n            lookbehind: true\\n          },\\n          punctuation: /[()]/\\n        }\\n      },\\n      lambda: {\\n        pattern: RegExp(par + 'lambda\\\\\\\\s+\\\\\\\\(\\\\\\\\s*(?:&?' + symbol + '(?:\\\\\\\\s+&?' + symbol + ')*\\\\\\\\s*)?\\\\\\\\)'),\\n        lookbehind: true,\\n        greedy: true,\\n        inside: {\\n          keyword: /^lambda/,\\n          // See below, this property needs to be defined later so that it can\\n          // reference the language object.\\n          arguments: null,\\n          punctuation: /[()]/\\n        }\\n      },\\n      car: {\\n        pattern: RegExp(par + symbol),\\n        lookbehind: true\\n      },\\n      punctuation: [// open paren, brackets, and close paren\\n      /(?:['`,]?\\\\(|[)\\\\[\\\\]])/, // cons\\n      {\\n        pattern: /(\\\\s)\\\\.(?=\\\\s)/,\\n        lookbehind: true\\n      }]\\n    };\\n    var arg = {\\n      'lisp-marker': RegExp(marker),\\n      varform: {\\n        pattern: RegExp(/\\\\(/.source + symbol + /\\\\s+(?=\\\\S)/.source + nestedPar + /\\\\)/.source),\\n        inside: language\\n      },\\n      argument: {\\n        pattern: RegExp(/(^|[\\\\s(])/.source + symbol),\\n        lookbehind: true,\\n        alias: 'variable'\\n      },\\n      rest: language\\n    };\\n    var forms = '\\\\\\\\S+(?:\\\\\\\\s+\\\\\\\\S+)*';\\n    var arglist = {\\n      pattern: RegExp(par + nestedPar + endpar),\\n      lookbehind: true,\\n      inside: {\\n        'rest-vars': {\\n          pattern: RegExp('&(?:body|rest)\\\\\\\\s+' + forms),\\n          inside: arg\\n        },\\n        'other-marker-vars': {\\n          pattern: RegExp('&(?:aux|optional)\\\\\\\\s+' + forms),\\n          inside: arg\\n        },\\n        keys: {\\n          pattern: RegExp('&key\\\\\\\\s+' + forms + '(?:\\\\\\\\s+&allow-other-keys)?'),\\n          inside: arg\\n        },\\n        argument: {\\n          pattern: RegExp(symbol),\\n          alias: 'variable'\\n        },\\n        punctuation: /[()]/\\n      }\\n    };\\n    language['lambda'].inside.arguments = arglist;\\n    language['defun'].inside.arguments = Prism.util.clone(arglist);\\n    language['defun'].inside.arguments.inside.sublist = arglist;\\n    Prism.languages.lisp = language;\\n    Prism.languages.elisp = language;\\n    Prism.languages.emacs = language;\\n    Prism.languages['emacs-lisp'] = language;\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"lisp\",\"Prism\",\"simple_form\",\"name\",\"RegExp\",\"source\",\"primitive\",\"pattern\",\"symbol\",\"marker\",\"nestedPar\",\"language\",\"heading\",\"alias\",\"comment\",\"string\",\"greedy\",\"inside\",\"argument\",\"splice\",\"keyword\",\"lookbehind\",\"declare\",\"interactive\",\"boolean\",\"number\",\"defvar\",\"variable\",\"defun\",\"par\",\"arguments\",\"function\",\"punctuation\",\"lambda\",\"car\",\"arg\",\"varform\",\"rest\",\"arglist\",\"endpar\",\"keys\",\"util\",\"clone\",\"sublist\",\"languages\",\"elisp\",\"emacs\",\"Object\",\"defineProperty\",\"value\",\"default\",\"displayName\",\"aliases\"]\n}\n"]