["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mdast-util-to-markdown/lib/util/safe.js"],"~:js","shadow$provide.module$node_modules$mdast_util_to_markdown$lib$util$safe=function(global,require,module,exports){function numerical(a,b){return a-b}function escapeBackslashes(value,after){const expression=/\\\\(?=[!-/:-@[-`{-~])/g,positions=[],results=[];after=value+after;let index=-1,start=0,match;for(;match=expression.exec(after);)positions.push(match.index);for(;++index<positions.length;)start!==positions[index]&&results.push(value.slice(start,positions[index])),results.push(\"\\\\\"),start=positions[index];\nresults.push(value.slice(start));return results.join(\"\")}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.safe=function(state,input,config){input=(config.before||\"\")+(input||\"\")+(config.after||\"\");const positions=[],result=[],infos={};let index=-1;for(;++index<state.unsafe.length;){var pattern=state.unsafe[index];if((0,_patternInScope.patternInScope)(state.stack,pattern))for(var expression=(0,_patternCompile.patternCompile)(pattern),match=void 0;match=expression.exec(input);){const before=\n\"before\"in pattern||!!pattern.atBreak,after=\"after\"in pattern;match=match.index+(before?match[1].length:0);positions.includes(match)?(infos[match].before&&!before&&(infos[match].before=!1),infos[match].after&&!after&&(infos[match].after=!1)):(positions.push(match),infos[match]={before,after})}}positions.sort(numerical);state=config.before?config.before.length:0;pattern=input.length-(config.after?config.after.length:0);for(index=-1;++index<positions.length;)expression=positions[index],expression<state||\nexpression>=pattern||expression+1<pattern&&positions[index+1]===expression+1&&infos[expression].after&&!infos[expression+1].before&&!infos[expression+1].after||positions[index-1]===expression-1&&infos[expression].before&&!infos[expression-1].before&&!infos[expression-1].after||(state!==expression&&result.push(escapeBackslashes(input.slice(state,expression),\"\\\\\")),state=expression,!/[!-/:-@[-`{-~]/.test(input.charAt(expression))||config.encode&&config.encode.includes(input.charAt(expression))?(result.push(\"\\x26#x\"+\ninput.charCodeAt(expression).toString(16).toUpperCase()+\";\"),state++):result.push(\"\\\\\"));result.push(escapeBackslashes(input.slice(state,pattern),config.after));return result.join(\"\")};var _patternCompile=require(\"module$node_modules$mdast_util_to_markdown$lib$util$pattern_compile\"),_patternInScope=require(\"module$node_modules$mdast_util_to_markdown$lib$util$pattern_in_scope\")}","~:source","shadow$provide[\"module$node_modules$mdast_util_to_markdown$lib$util$safe\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.safe = safe;\n\nvar _patternCompile = require(\"./pattern-compile.js\");\n\nvar _patternInScope = require(\"./pattern-in-scope.js\");\n\n/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '');\n  /** @type {Array<number>} */\n\n  const positions = [];\n  /** @type {Array<string>} */\n\n  const result = [];\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n\n  const infos = {};\n  let index = -1;\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index];\n\n    if (!(0, _patternInScope.patternInScope)(state.stack, pattern)) {\n      continue;\n    }\n\n    const expression = (0, _patternCompile.patternCompile)(pattern);\n    /** @type {RegExpExecArray | null} */\n\n    let match;\n\n    while (match = expression.exec(value)) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak);\n      const after = ('after' in pattern);\n      const position = match.index + (before ? match[1].length : 0);\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false;\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false;\n        }\n      } else {\n        positions.push(position);\n        infos[position] = {\n          before,\n          after\n        };\n      }\n    }\n  }\n\n  positions.sort(numerical);\n  let start = config.before ? config.before.length : 0;\n  const end = value.length - (config.after ? config.after.length : 0);\n  index = -1;\n\n  while (++index < positions.length) {\n    const position = positions[index]; // Character before or after matched:\n\n    if (position < start || position >= end) {\n      continue;\n    } // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n\n\n    if (position + 1 < end && positions[index + 1] === position + 1 && infos[position].after && !infos[position + 1].before && !infos[position + 1].after || positions[index - 1] === position - 1 && infos[position].before && !infos[position - 1].before && !infos[position - 1].after) {\n      continue;\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'));\n    }\n\n    start = position;\n\n    if (/[!-/:-@[-`{-~]/.test(value.charAt(position)) && (!config.encode || !config.encode.includes(value.charAt(position)))) {\n      // Character escape.\n      result.push('\\\\');\n    } else {\n      // Character reference.\n      result.push('&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';');\n      start++;\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after));\n  return result.join('');\n}\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\n\nfunction numerical(a, b) {\n  return a - b;\n}\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\n\n\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g;\n  /** @type {Array<number>} */\n\n  const positions = [];\n  /** @type {Array<string>} */\n\n  const results = [];\n  const whole = value + after;\n  let index = -1;\n  let start = 0;\n  /** @type {RegExpExecArray | null} */\n\n  let match;\n\n  while (match = expression.exec(whole)) {\n    positions.push(match.index);\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]));\n    }\n\n    results.push('\\\\');\n    start = positions[index];\n  }\n\n  results.push(value.slice(start));\n  return results.join('');\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$mdast_util_to_markdown$lib$util$pattern_in_scope","~$shadow.js","~$module$node_modules$mdast_util_to_markdown$lib$util$pattern_compile"]],"~:properties",["^5",["after","__esModule","value","before","safe"]],"~:compiled-at",1676667584527,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mdast_util_to_markdown$lib$util$safe.js\",\n\"lineCount\":5,\n\"mappings\":\"AAAAA,cAAA,CAAA,wDAAA,CAA6E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CA0IrHC,QAASA,UAAS,CAACC,CAAD,CAAIC,CAAJ,CAAO,CACvB,MAAOD,EAAP,CAAWC,CADY,CAUzBC,QAASA,kBAAiB,CAACC,KAAD,CAAQC,KAAR,CAAe,CACvC,MAAMC,WAAa,uBAAnB,CAGMC,UAAY,EAHlB,CAMMC,QAAU,EACVC,MAAAA,CAAQL,KAARK,CAAgBJ,KACtB,KAAIK,MAAQ,CAAC,CAAb,CACIC,MAAQ,CADZ,CAIIC,KAEJ,KAAA,CAAOA,KAAP,CAAeN,UAAWO,CAAAA,IAAX,CAAgBJ,KAAhB,CAAf,CAAA,CACEF,SAAUO,CAAAA,IAAV,CAAeF,KAAMF,CAAAA,KAArB,CAGF,KAAA,CAAO,EAAEA,KAAT,CAAiBH,SAAUQ,CAAAA,MAA3B,CAAA,CACMJ,KAKJ,GALcJ,SAAA,CAAUG,KAAV,CAKd,EAJEF,OAAQM,CAAAA,IAAR,CAAaV,KAAMY,CAAAA,KAAN,CAAYL,KAAZ,CAAmBJ,SAAA,CAAUG,KAAV,CAAnB,CAAb,CAIF,CADAF,OAAQM,CAAAA,IAAR,CAAa,IAAb,CACA,CAAAH,KAAA,CAAQJ,SAAA,CAAUG,KAAV,CAGVF;OAAQM,CAAAA,IAAR,CAAaV,KAAMY,CAAAA,KAAN,CAAYL,KAAZ,CAAb,CACA,OAAOH,QAAQS,CAAAA,IAAR,CAAa,EAAb,CA7BgC,CAjJzCC,MAAOC,CAAAA,cAAP,CAAsBpB,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CK,MAAO,CAAA,CADoC,CAA7C,CAGAL,QAAQqB,CAAAA,IAAR,CAoCAA,QAAa,CAACC,KAAD,CAAQC,KAAR,CAAeC,MAAf,CAAuB,CAC5BnB,KAAAA,EAASmB,MAAOC,CAAAA,MAAhBpB,EAA0B,EAA1BA,GAAiCkB,KAAjClB,EAA0C,EAA1CA,GAAiDmB,MAAOlB,CAAAA,KAAxDD,EAAiE,EAAjEA,CAGN,OAAMG,UAAY,EAAlB,CAGMkB,OAAS,EAHf,CAMMC,MAAQ,EACd,KAAIhB,MAAQ,CAAC,CAEb,KAAA,CAAO,EAAEA,KAAT,CAAiBW,KAAMM,CAAAA,MAAOZ,CAAAA,MAA9B,CAAA,CAAsC,CACpC,IAAMa,QAAUP,KAAMM,CAAAA,MAAN,CAAajB,KAAb,CAEhB,IAAK,GAAImB,eAAgBC,CAAAA,cAApB,EAAoCT,KAAMU,CAAAA,KAA1C,CAAiDH,OAAjD,CAAL,CASA,IALA,IAAMtB,WAAa,GAAI0B,eAAgBC,CAAAA,cAApB,EAAoCL,OAApC,CAAnB,CAGIhB,MAAAA,IAAAA,EAEJ,CAAOA,KAAP,CAAeN,UAAWO,CAAAA,IAAX,CAAgBT,KAAhB,CAAf,CAAA,CAAuC,CACrC,MAAMoB;AAAS,QAATA,EAAqBI,QAArBJ,EAAgC,CAAA,CAAQI,OAAQM,CAAAA,OAAtD,CACM7B,MAAS,OAATA,EAAoBuB,QACpBO,MAAAA,CAAWvB,KAAMF,CAAAA,KAAjByB,EAA0BX,MAAA,CAASZ,KAAA,CAAM,CAAN,CAASG,CAAAA,MAAlB,CAA2B,CAArDoB,CAEF5B,UAAU6B,CAAAA,QAAV,CAAmBD,KAAnB,CAAJ,EACMT,KAAA,CAAMS,KAAN,CAAgBX,CAAAA,MAIpB,EAJ8B,CAACA,MAI/B,GAHEE,KAAA,CAAMS,KAAN,CAAgBX,CAAAA,MAGlB,CAH2B,CAAA,CAG3B,EAAIE,KAAA,CAAMS,KAAN,CAAgB9B,CAAAA,KAApB,EAA6B,CAACA,KAA9B,GACEqB,KAAA,CAAMS,KAAN,CAAgB9B,CAAAA,KADlB,CAC0B,CAAA,CAD1B,CALF,GASEE,SAAUO,CAAAA,IAAV,CAAeqB,KAAf,CACA,CAAAT,KAAA,CAAMS,KAAN,CAAA,CAAkB,CAChBX,MADgB,CAEhBnB,KAFgB,CAVpB,CALqC,CAZH,CAmCtCE,SAAU8B,CAAAA,IAAV,CAAerC,SAAf,CACIW,MAAAA,CAAQY,MAAOC,CAAAA,MAAP,CAAgBD,MAAOC,CAAAA,MAAOT,CAAAA,MAA9B,CAAuC,CAC7CuB,QAAAA,CAAMlC,KAAMW,CAAAA,MAAZuB,EAAsBf,MAAOlB,CAAAA,KAAP,CAAekB,MAAOlB,CAAAA,KAAMU,CAAAA,MAA5B,CAAqC,CAA3DuB,CAGN,KAFA5B,KAEA,CAFQ,CAAC,CAET,CAAO,EAAEA,KAAT,CAAiBH,SAAUQ,CAAAA,MAA3B,CAAA,CACQoB,UAEN,CAFiB5B,SAAA,CAAUG,KAAV,CAEjB,CAAIyB,UAAJ,CAAexB,KAAf;AAAwBwB,UAAxB,EAAoCG,OAApC,EAOIH,UAPJ,CAOe,CAPf,CAOmBG,OAPnB,EAO0B/B,SAAA,CAAUG,KAAV,CAAkB,CAAlB,CAP1B,GAOmDyB,UAPnD,CAO8D,CAP9D,EAOmET,KAAA,CAAMS,UAAN,CAAgB9B,CAAAA,KAPnF,EAO4F,CAACqB,KAAA,CAAMS,UAAN,CAAiB,CAAjB,CAAoBX,CAAAA,MAPjH,EAO2H,CAACE,KAAA,CAAMS,UAAN,CAAiB,CAAjB,CAAoB9B,CAAAA,KAPhJ,EAOyJE,SAAA,CAAUG,KAAV,CAAkB,CAAlB,CAPzJ,GAOkLyB,UAPlL,CAO6L,CAP7L,EAOkMT,KAAA,CAAMS,UAAN,CAAgBX,CAAAA,MAPlN,EAO4N,CAACE,KAAA,CAAMS,UAAN,CAAiB,CAAjB,CAAoBX,CAAAA,MAPjP,EAO2P,CAACE,KAAA,CAAMS,UAAN,CAAiB,CAAjB,CAAoB9B,CAAAA,KAPhR,GAWIM,KASJ,GATcwB,UASd,EALEV,MAAOX,CAAAA,IAAP,CAAYX,iBAAA,CAAkBC,KAAMY,CAAAA,KAAN,CAAYL,KAAZ,CAAmBwB,UAAnB,CAAlB,CAAgD,IAAhD,CAAZ,CAKF,CAFAxB,KAEA,CAFQwB,UAER,CAAI,CAAA,gBAAiBI,CAAAA,IAAjB,CAAsBnC,KAAMoC,CAAAA,MAAN,CAAaL,UAAb,CAAtB,CAAJ,EAAuDZ,MAAOkB,CAAAA,MAA9D,EAAyElB,MAAOkB,CAAAA,MAAOL,CAAAA,QAAd,CAAuBhC,KAAMoC,CAAAA,MAAN,CAAaL,UAAb,CAAvB,CAAzE,EAKEV,MAAOX,CAAAA,IAAP,CAAY,QAAZ;AAAoBV,KAAMsC,CAAAA,UAAN,CAAiBP,UAAjB,CAA2BQ,CAAAA,QAA3B,CAAoC,EAApC,CAAwCC,CAAAA,WAAxC,EAApB,CAA4E,GAA5E,CACA,CAAAjC,KAAA,EANF,EAEEc,MAAOX,CAAAA,IAAP,CAAY,IAAZ,CAtBF,CA8BFW,OAAOX,CAAAA,IAAP,CAAYX,iBAAA,CAAkBC,KAAMY,CAAAA,KAAN,CAAYL,KAAZ,CAAmB2B,OAAnB,CAAlB,CAA2Cf,MAAOlB,CAAAA,KAAlD,CAAZ,CACA,OAAOoB,OAAOR,CAAAA,IAAP,CAAY,EAAZ,CAvF2B,CAlCpC,KAAIe,gBAAkBnC,OAAA,CAAQ,qEAAR,CAAtB,CAEIgC,gBAAkBhC,OAAA,CAAQ,sEAAR,CAV+F;\",\n\"sources\":[\"node_modules/mdast-util-to-markdown/lib/util/safe.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mdast_util_to_markdown$lib$util$safe\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.safe = safe;\\n\\nvar _patternCompile = require(\\\"./pattern-compile.js\\\");\\n\\nvar _patternInScope = require(\\\"./pattern-in-scope.js\\\");\\n\\n/**\\n * @typedef {import('../types.js').State} State\\n * @typedef {import('../types.js').SafeConfig} SafeConfig\\n */\\n\\n/**\\n * Make a string safe for embedding in markdown constructs.\\n *\\n * In markdown, almost all punctuation characters can, in certain cases,\\n * result in something.\\n * Whether they do is highly subjective to where they happen and in what\\n * they happen.\\n *\\n * To solve this, `mdast-util-to-markdown` tracks:\\n *\\n * * Characters before and after something;\\n * * What \\u201cconstructs\\u201d we are in.\\n *\\n * This information is then used by this function to escape or encode\\n * special characters.\\n *\\n * @param {State} state\\n *   Info passed around about the current state.\\n * @param {string | null | undefined} input\\n *   Raw value to make safe.\\n * @param {SafeConfig} config\\n *   Configuration.\\n * @returns {string}\\n *   Serialized markdown safe for embedding.\\n */\\nfunction safe(state, input, config) {\\n  const value = (config.before || '') + (input || '') + (config.after || '');\\n  /** @type {Array<number>} */\\n\\n  const positions = [];\\n  /** @type {Array<string>} */\\n\\n  const result = [];\\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\\n\\n  const infos = {};\\n  let index = -1;\\n\\n  while (++index < state.unsafe.length) {\\n    const pattern = state.unsafe[index];\\n\\n    if (!(0, _patternInScope.patternInScope)(state.stack, pattern)) {\\n      continue;\\n    }\\n\\n    const expression = (0, _patternCompile.patternCompile)(pattern);\\n    /** @type {RegExpExecArray | null} */\\n\\n    let match;\\n\\n    while (match = expression.exec(value)) {\\n      const before = 'before' in pattern || Boolean(pattern.atBreak);\\n      const after = ('after' in pattern);\\n      const position = match.index + (before ? match[1].length : 0);\\n\\n      if (positions.includes(position)) {\\n        if (infos[position].before && !before) {\\n          infos[position].before = false;\\n        }\\n\\n        if (infos[position].after && !after) {\\n          infos[position].after = false;\\n        }\\n      } else {\\n        positions.push(position);\\n        infos[position] = {\\n          before,\\n          after\\n        };\\n      }\\n    }\\n  }\\n\\n  positions.sort(numerical);\\n  let start = config.before ? config.before.length : 0;\\n  const end = value.length - (config.after ? config.after.length : 0);\\n  index = -1;\\n\\n  while (++index < positions.length) {\\n    const position = positions[index]; // Character before or after matched:\\n\\n    if (position < start || position >= end) {\\n      continue;\\n    } // If this character is supposed to be escaped because it has a condition on\\n    // the next character, and the next character is definitly being escaped,\\n    // then skip this escape.\\n\\n\\n    if (position + 1 < end && positions[index + 1] === position + 1 && infos[position].after && !infos[position + 1].before && !infos[position + 1].after || positions[index - 1] === position - 1 && infos[position].before && !infos[position - 1].before && !infos[position - 1].after) {\\n      continue;\\n    }\\n\\n    if (start !== position) {\\n      // If we have to use a character reference, an ampersand would be more\\n      // correct, but as backslashes only care about punctuation, either will\\n      // do the trick\\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\\\\\'));\\n    }\\n\\n    start = position;\\n\\n    if (/[!-/:-@[-`{-~]/.test(value.charAt(position)) && (!config.encode || !config.encode.includes(value.charAt(position)))) {\\n      // Character escape.\\n      result.push('\\\\\\\\');\\n    } else {\\n      // Character reference.\\n      result.push('&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';');\\n      start++;\\n    }\\n  }\\n\\n  result.push(escapeBackslashes(value.slice(start, end), config.after));\\n  return result.join('');\\n}\\n/**\\n * @param {number} a\\n * @param {number} b\\n * @returns {number}\\n */\\n\\n\\nfunction numerical(a, b) {\\n  return a - b;\\n}\\n/**\\n * @param {string} value\\n * @param {string} after\\n * @returns {string}\\n */\\n\\n\\nfunction escapeBackslashes(value, after) {\\n  const expression = /\\\\\\\\(?=[!-/:-@[-`{-~])/g;\\n  /** @type {Array<number>} */\\n\\n  const positions = [];\\n  /** @type {Array<string>} */\\n\\n  const results = [];\\n  const whole = value + after;\\n  let index = -1;\\n  let start = 0;\\n  /** @type {RegExpExecArray | null} */\\n\\n  let match;\\n\\n  while (match = expression.exec(whole)) {\\n    positions.push(match.index);\\n  }\\n\\n  while (++index < positions.length) {\\n    if (start !== positions[index]) {\\n      results.push(value.slice(start, positions[index]));\\n    }\\n\\n    results.push('\\\\\\\\');\\n    start = positions[index];\\n  }\\n\\n  results.push(value.slice(start));\\n  return results.join('');\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"numerical\",\"a\",\"b\",\"escapeBackslashes\",\"value\",\"after\",\"expression\",\"positions\",\"results\",\"whole\",\"index\",\"start\",\"match\",\"exec\",\"push\",\"length\",\"slice\",\"join\",\"Object\",\"defineProperty\",\"safe\",\"state\",\"input\",\"config\",\"before\",\"result\",\"infos\",\"unsafe\",\"pattern\",\"_patternInScope\",\"patternInScope\",\"stack\",\"_patternCompile\",\"patternCompile\",\"atBreak\",\"position\",\"includes\",\"sort\",\"end\",\"test\",\"charAt\",\"encode\",\"charCodeAt\",\"toString\",\"toUpperCase\"]\n}\n"]