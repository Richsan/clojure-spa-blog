["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-util-chunked/index.js"],"~:js","shadow$provide.module$node_modules$micromark_util_chunked$index=function(global,require,module,exports){function splice(list,start,remove,items){var end=list.length;let chunkStart=0;start=0>start?-start>end?0:end+start:start>end?end:start;remove=0<remove?remove:0;if(1E4>items.length)end=Array.from(items),end.unshift(start,remove),[].splice.apply(list,end);else for(remove&&[].splice.apply(list,[start,remove]);chunkStart<items.length;)end=items.slice(chunkStart,chunkStart+1E4),end.unshift(start,0),\n[].splice.apply(list,end),chunkStart+=1E4,start+=1E4}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.splice=splice;exports.push=function(list,items){return 0<list.length?(splice(list,list.length,0,items),list):items}}","~:source","shadow$provide[\"module$node_modules$micromark_util_chunked$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.splice = splice;\nexports.push = push;\n\n/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {number} start\n * @param {number} remove\n * @param {T[]} items\n * @returns {void}\n */\nfunction splice(list, start, remove, items) {\n  const end = list.length;\n  let chunkStart = 0;\n  /** @type {unknown[]} */\n\n  let parameters; // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start;\n  } else {\n    start = start > end ? end : start;\n  }\n\n  remove = remove > 0 ? remove : 0; // No need to chunk the items if there’s only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items);\n    parameters.unshift(start, remove) // @ts-expect-error Hush, it’s fine.\n    ;\n    [].splice.apply(list, parameters);\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) [].splice.apply(list, [start, remove]); // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000);\n      parameters.unshift(start, 0) // @ts-expect-error Hush, it’s fine.\n      ;\n      [].splice.apply(list, parameters);\n      chunkStart += 10000;\n      start += 10000;\n    }\n  }\n}\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {T[]} items\n * @returns {T[]}\n */\n\n\nfunction push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items);\n    return list;\n  }\n\n  return items;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["__esModule","push","splice","value"]],"~:compiled-at",1676665867257,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_util_chunked$index.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,gDAAA,CAAqE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAyB7GC,QAASA,OAAM,CAACC,IAAD,CAAOC,KAAP,CAAcC,MAAd,CAAsBC,KAAtB,CAA6B,CAC1C,IAAMC,IAAMJ,IAAKK,CAAAA,MACjB,KAAIC,WAAa,CAMfL,MAAA,CADU,CAAZ,CAAIA,KAAJ,CACU,CAACA,KAAD,CAASG,GAAT,CAAe,CAAf,CAAmBA,GAAnB,CAAyBH,KADnC,CAGUA,KAAA,CAAQG,GAAR,CAAcA,GAAd,CAAoBH,KAG9BC,OAAA,CAAkB,CAAT,CAAAA,MAAA,CAAaA,MAAb,CAAsB,CAE/B,IAAmB,GAAnB,CAAIC,KAAME,CAAAA,MAAV,CACEE,GAGA,CAHaC,KAAMC,CAAAA,IAAN,CAAWN,KAAX,CAGb,CAFAI,GAAWG,CAAAA,OAAX,CAAmBT,KAAnB,CAA0BC,MAA1B,CAEA,CAAA,EAAGH,CAAAA,MAAOY,CAAAA,KAAV,CAAgBX,IAAhB,CAAsBO,GAAtB,CAJF,KASE,KAFIL,MAEJ,EAFY,EAAGH,CAAAA,MAAOY,CAAAA,KAAV,CAAgBX,IAAhB,CAAsB,CAACC,KAAD,CAAQC,MAAR,CAAtB,CAEZ,CAAOI,UAAP,CAAoBH,KAAME,CAAAA,MAA1B,CAAA,CACEE,GAKA,CALaJ,KAAMS,CAAAA,KAAN,CAAYN,UAAZ,CAAwBA,UAAxB,CAAqC,GAArC,CAKb,CAJAC,GAAWG,CAAAA,OAAX,CAAmBT,KAAnB,CAA0B,CAA1B,CAIA;AAFA,EAAGF,CAAAA,MAAOY,CAAAA,KAAV,CAAgBX,IAAhB,CAAsBO,GAAtB,CAEA,CADAD,UACA,EADc,GACd,CAAAL,KAAA,EAAS,GA9B6B,CAtB5CY,MAAOC,CAAAA,cAAP,CAAsBhB,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CiB,MAAO,CAAA,CADoC,CAA7C,CAGAjB,QAAQC,CAAAA,MAAR,CAAiBA,MACjBD,QAAQkB,CAAAA,IAAR,CAkEAA,QAAa,CAAChB,IAAD,CAAOG,KAAP,CAAc,CACzB,MAAkB,EAAlB,CAAIH,IAAKK,CAAAA,MAAT,EACEN,MAAA,CAAOC,IAAP,CAAaA,IAAKK,CAAAA,MAAlB,CAA0B,CAA1B,CAA6BF,KAA7B,CACOH,CAAAA,IAFT,EAKOG,KANkB,CAzEkF;\",\n\"sources\":[\"node_modules/micromark-util-chunked/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_util_chunked$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.splice = splice;\\nexports.push = push;\\n\\n/**\\n * Like `Array#splice`, but smarter for giant arrays.\\n *\\n * `Array#splice` takes all items to be inserted as individual argument which\\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\\n *\\n * Otherwise, this does not return the removed items, and takes `items` as an\\n * array instead of rest parameters.\\n *\\n * @template {unknown} T\\n * @param {T[]} list\\n * @param {number} start\\n * @param {number} remove\\n * @param {T[]} items\\n * @returns {void}\\n */\\nfunction splice(list, start, remove, items) {\\n  const end = list.length;\\n  let chunkStart = 0;\\n  /** @type {unknown[]} */\\n\\n  let parameters; // Make start between zero and `end` (included).\\n\\n  if (start < 0) {\\n    start = -start > end ? 0 : end + start;\\n  } else {\\n    start = start > end ? end : start;\\n  }\\n\\n  remove = remove > 0 ? remove : 0; // No need to chunk the items if there\\u2019s only a couple (10k) items.\\n\\n  if (items.length < 10000) {\\n    parameters = Array.from(items);\\n    parameters.unshift(start, remove) // @ts-expect-error Hush, it\\u2019s fine.\\n    ;\\n    [].splice.apply(list, parameters);\\n  } else {\\n    // Delete `remove` items starting from `start`\\n    if (remove) [].splice.apply(list, [start, remove]); // Insert the items in chunks to not cause stack overflows.\\n\\n    while (chunkStart < items.length) {\\n      parameters = items.slice(chunkStart, chunkStart + 10000);\\n      parameters.unshift(start, 0) // @ts-expect-error Hush, it\\u2019s fine.\\n      ;\\n      [].splice.apply(list, parameters);\\n      chunkStart += 10000;\\n      start += 10000;\\n    }\\n  }\\n}\\n/**\\n * Append `items` (an array) at the end of `list` (another array).\\n * When `list` was empty, returns `items` instead.\\n *\\n * This prevents a potentially expensive operation when `list` is empty,\\n * and adds items in batches to prevent V8 from hanging.\\n *\\n * @template {unknown} T\\n * @param {T[]} list\\n * @param {T[]} items\\n * @returns {T[]}\\n */\\n\\n\\nfunction push(list, items) {\\n  if (list.length > 0) {\\n    splice(list, list.length, 0, items);\\n    return list;\\n  }\\n\\n  return items;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"splice\",\"list\",\"start\",\"remove\",\"items\",\"end\",\"length\",\"chunkStart\",\"parameters\",\"Array\",\"from\",\"unshift\",\"apply\",\"slice\",\"Object\",\"defineProperty\",\"value\",\"push\"]\n}\n"]