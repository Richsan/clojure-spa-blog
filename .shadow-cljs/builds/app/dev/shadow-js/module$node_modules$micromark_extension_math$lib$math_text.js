["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-extension-math/lib/math-text.js"],"~:js","shadow$provide.module$node_modules$micromark_extension_math$lib$math_text=function(global,require,module,exports){function resolveMathText(events){let tailExitIndex=events.length-4,headEnterIndex=3,index,enter;if(!(\"lineEnding\"!==events[headEnterIndex][1].type&&\"space\"!==events[headEnterIndex][1].type||\"lineEnding\"!==events[tailExitIndex][1].type&&\"space\"!==events[tailExitIndex][1].type))for(index=headEnterIndex;++index<tailExitIndex;)if(\"mathTextData\"===events[index][1].type){events[tailExitIndex][1].type=\n\"mathTextPadding\";events[headEnterIndex][1].type=\"mathTextPadding\";headEnterIndex+=2;tailExitIndex-=2;break}index=headEnterIndex-1;for(tailExitIndex++;++index<=tailExitIndex;)if(void 0===enter)index!==tailExitIndex&&\"lineEnding\"!==events[index][1].type&&(enter=index);else if(index===tailExitIndex||\"lineEnding\"===events[index][1].type)events[enter][1].type=\"mathTextData\",index!==enter+2&&(events[enter][1].end=events[index-1][1].end,events.splice(enter+2,index-enter-2),tailExitIndex-=index-enter-2,\nindex=enter+2),enter=void 0;return events}function previous(code){return 36!==code||\"characterEscape\"===this.events[this.events.length-1][1].type}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.mathText=function(options={}){let single=options.singleDollarTextMath;if(null===single||void 0===single)single=!0;return{tokenize:function(effects,ok,nok){function openingSequence(code){if(36===code)return effects.consume(code),sizeOpen++,openingSequence;if(2>sizeOpen&&!single)return nok(code);\neffects.exit(\"mathTextSequence\");return gap(code)}function gap(code){if(null===code)return nok(code);if(36===code)return token=effects.enter(\"mathTextSequence\"),size=0,closingSequence(code);if(32===code)return effects.enter(\"space\"),effects.consume(code),effects.exit(\"space\"),gap;if((0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.enter(\"lineEnding\"),effects.consume(code),effects.exit(\"lineEnding\"),gap;effects.enter(\"mathTextData\");return data(code)}function data(code){if(null===\ncode||32===code||36===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.exit(\"mathTextData\"),gap(code);effects.consume(code);return data}function closingSequence(code){if(36===code)return effects.consume(code),size++,closingSequence;if(size===sizeOpen)return effects.exit(\"mathTextSequence\"),effects.exit(\"mathText\"),ok(code);token.type=\"mathTextData\";return data(code)}let sizeOpen=0,size,token;return function(code){effects.enter(\"mathText\");effects.enter(\"mathTextSequence\");\nreturn openingSequence(code)}},resolve:resolveMathText,previous}};var _micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\")}","~:source","shadow$provide[\"module$node_modules$micromark_extension_math$lib$math_text\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mathText = mathText;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n *\n * @typedef Options\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\n\n/**\n * @param {Options} [options]\n * @returns {Construct}\n */\nfunction mathText(options = {}) {\n  let single = options.singleDollarTextMath;\n\n  if (single === null || single === undefined) {\n    single = true;\n  }\n\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous\n  };\n  /** @type {Tokenizer} */\n\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this;\n    let sizeOpen = 0;\n    /** @type {number} */\n\n    let size;\n    /** @type {Token} */\n\n    let token;\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('mathText');\n      effects.enter('mathTextSequence');\n      return openingSequence(code);\n    }\n    /** @type {State} */\n\n\n    function openingSequence(code) {\n      if (code === 36) {\n        effects.consume(code);\n        sizeOpen++;\n        return openingSequence;\n      }\n\n      if (sizeOpen < 2 && !single) return nok(code);\n      effects.exit('mathTextSequence');\n      return gap(code);\n    }\n    /** @type {State} */\n\n\n    function gap(code) {\n      if (code === null) {\n        return nok(code);\n      } // Closing fence?\n      // Could also be data.\n\n\n      if (code === 36) {\n        token = effects.enter('mathTextSequence');\n        size = 0;\n        return closingSequence(code);\n      } // Tabs don’t work, and virtual spaces don’t make sense.\n\n\n      if (code === 32) {\n        effects.enter('space');\n        effects.consume(code);\n        effects.exit('space');\n        return gap;\n      }\n\n      if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n        effects.enter('lineEnding');\n        effects.consume(code);\n        effects.exit('lineEnding');\n        return gap;\n      } // Data.\n\n\n      effects.enter('mathTextData');\n      return data(code);\n    } // In math.\n\n    /** @type {State} */\n\n\n    function data(code) {\n      if (code === null || code === 32 || code === 36 || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n        effects.exit('mathTextData');\n        return gap(code);\n      }\n\n      effects.consume(code);\n      return data;\n    } // Closing fence.\n\n    /** @type {State} */\n\n\n    function closingSequence(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      } // Done!\n\n\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence');\n        effects.exit('mathText');\n        return ok(code);\n      } // More or less accents: mark as data.\n\n\n      token.type = 'mathTextData';\n      return data(code);\n    }\n  }\n}\n/** @type {Resolver} */\n\n\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n\n  let index;\n  /** @type {number|undefined} */\n\n  let enter; // If we start and end with an EOL or a space.\n\n  if ((events[headEnterIndex][1].type === 'lineEnding' || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === 'lineEnding' || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex; // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding';\n        events[headEnterIndex][1].type = 'mathTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === 'lineEnding') {\n      events[enter][1].type = 'mathTextData';\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n\n      enter = undefined;\n    }\n  }\n\n  return events;\n}\n/** @type {Previous} */\n\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 36 || this.events[this.events.length - 1][1].type === 'characterEscape';\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js"]],"~:properties",["^5",["resolve","tokenize","__esModule","value","previous","mathText","type","end"]],"~:compiled-at",1676667584430,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_extension_math$lib$math_text.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-extension-math/lib/math-text.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_extension_math$lib$math_text\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.mathText = mathText;\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').Resolver} Resolver\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').Previous} Previous\\n * @typedef {import('micromark-util-types').State} State\\n * @typedef {import('micromark-util-types').Token} Token\\n *\\n * @typedef Options\\n * @property {boolean} [singleDollarTextMath=true]\\n *   Whether to support math (text) with a single dollar (`boolean`, default:\\n *   `true`).\\n *   Single dollars work in Pandoc and many other places, but often interfere\\n *   with \\u201cnormal\\u201d dollars in text.\\n */\\n\\n/**\\n * @param {Options} [options]\\n * @returns {Construct}\\n */\\nfunction mathText(options = {}) {\\n  let single = options.singleDollarTextMath;\\n\\n  if (single === null || single === undefined) {\\n    single = true;\\n  }\\n\\n  return {\\n    tokenize: tokenizeMathText,\\n    resolve: resolveMathText,\\n    previous\\n  };\\n  /** @type {Tokenizer} */\\n\\n  function tokenizeMathText(effects, ok, nok) {\\n    const self = this;\\n    let sizeOpen = 0;\\n    /** @type {number} */\\n\\n    let size;\\n    /** @type {Token} */\\n\\n    let token;\\n    return start;\\n    /** @type {State} */\\n\\n    function start(code) {\\n      effects.enter('mathText');\\n      effects.enter('mathTextSequence');\\n      return openingSequence(code);\\n    }\\n    /** @type {State} */\\n\\n\\n    function openingSequence(code) {\\n      if (code === 36) {\\n        effects.consume(code);\\n        sizeOpen++;\\n        return openingSequence;\\n      }\\n\\n      if (sizeOpen < 2 && !single) return nok(code);\\n      effects.exit('mathTextSequence');\\n      return gap(code);\\n    }\\n    /** @type {State} */\\n\\n\\n    function gap(code) {\\n      if (code === null) {\\n        return nok(code);\\n      } // Closing fence?\\n      // Could also be data.\\n\\n\\n      if (code === 36) {\\n        token = effects.enter('mathTextSequence');\\n        size = 0;\\n        return closingSequence(code);\\n      } // Tabs don\\u2019t work, and virtual spaces don\\u2019t make sense.\\n\\n\\n      if (code === 32) {\\n        effects.enter('space');\\n        effects.consume(code);\\n        effects.exit('space');\\n        return gap;\\n      }\\n\\n      if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n        effects.enter('lineEnding');\\n        effects.consume(code);\\n        effects.exit('lineEnding');\\n        return gap;\\n      } // Data.\\n\\n\\n      effects.enter('mathTextData');\\n      return data(code);\\n    } // In math.\\n\\n    /** @type {State} */\\n\\n\\n    function data(code) {\\n      if (code === null || code === 32 || code === 36 || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n        effects.exit('mathTextData');\\n        return gap(code);\\n      }\\n\\n      effects.consume(code);\\n      return data;\\n    } // Closing fence.\\n\\n    /** @type {State} */\\n\\n\\n    function closingSequence(code) {\\n      // More.\\n      if (code === 36) {\\n        effects.consume(code);\\n        size++;\\n        return closingSequence;\\n      } // Done!\\n\\n\\n      if (size === sizeOpen) {\\n        effects.exit('mathTextSequence');\\n        effects.exit('mathText');\\n        return ok(code);\\n      } // More or less accents: mark as data.\\n\\n\\n      token.type = 'mathTextData';\\n      return data(code);\\n    }\\n  }\\n}\\n/** @type {Resolver} */\\n\\n\\nfunction resolveMathText(events) {\\n  let tailExitIndex = events.length - 4;\\n  let headEnterIndex = 3;\\n  /** @type {number} */\\n\\n  let index;\\n  /** @type {number|undefined} */\\n\\n  let enter; // If we start and end with an EOL or a space.\\n\\n  if ((events[headEnterIndex][1].type === 'lineEnding' || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === 'lineEnding' || events[tailExitIndex][1].type === 'space')) {\\n    index = headEnterIndex; // And we have data.\\n\\n    while (++index < tailExitIndex) {\\n      if (events[index][1].type === 'mathTextData') {\\n        // Then we have padding.\\n        events[tailExitIndex][1].type = 'mathTextPadding';\\n        events[headEnterIndex][1].type = 'mathTextPadding';\\n        headEnterIndex += 2;\\n        tailExitIndex -= 2;\\n        break;\\n      }\\n    }\\n  } // Merge adjacent spaces and data.\\n\\n\\n  index = headEnterIndex - 1;\\n  tailExitIndex++;\\n\\n  while (++index <= tailExitIndex) {\\n    if (enter === undefined) {\\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\\n        enter = index;\\n      }\\n    } else if (index === tailExitIndex || events[index][1].type === 'lineEnding') {\\n      events[enter][1].type = 'mathTextData';\\n\\n      if (index !== enter + 2) {\\n        events[enter][1].end = events[index - 1][1].end;\\n        events.splice(enter + 2, index - enter - 2);\\n        tailExitIndex -= index - enter - 2;\\n        index = enter + 2;\\n      }\\n\\n      enter = undefined;\\n    }\\n  }\\n\\n  return events;\\n}\\n/** @type {Previous} */\\n\\n\\nfunction previous(code) {\\n  // If there is a previous code, there will always be a tail.\\n  return code !== 36 || this.events[this.events.length - 1][1].type === 'characterEscape';\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"resolveMathText\",\"events\",\"tailExitIndex\",\"length\",\"headEnterIndex\",\"index\",\"enter\",\"type\",\"undefined\",\"end\",\"splice\",\"previous\",\"code\",\"Object\",\"defineProperty\",\"value\",\"mathText\",\"options\",\"single\",\"singleDollarTextMath\",\"tokenize\",\"tokenizeMathText\",\"effects\",\"ok\",\"nok\",\"openingSequence\",\"consume\",\"sizeOpen\",\"exit\",\"gap\",\"token\",\"size\",\"closingSequence\",\"_micromarkUtilCharacter\",\"markdownLineEnding\",\"data\",\"start\",\"resolve\"]\n}\n"]