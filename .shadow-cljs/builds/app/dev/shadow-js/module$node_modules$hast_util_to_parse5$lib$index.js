["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hast-util-to-parse5/lib/index.js"],"~:js","shadow$provide.module$node_modules$hast_util_to_parse5$lib$index=function(global,require,module,exports){function all(children,parentNode,schema){let index=-1;const results=[];if(children)for(;++index<children.length;){const child=one(children[index],schema);child.parentNode=parentNode;results.push(child)}return results}function patch(from,to){(from=from.position)&&from.start&&from.end&&(to.sourceCodeLocation={startLine:from.start.line,startCol:from.start.column,startOffset:from.start.offset,endLine:from.end.line,\nendCol:from.end.column,endOffset:from.end.offset})}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.toParse5=function(tree,options){return one(tree,\"svg\"===(options&&\"object\"===typeof options?options.space:options)?_propertyInformation.svg:_propertyInformation.html)};var _commaSeparatedTokens=require(\"module$node_modules$comma_separated_tokens$index\"),_propertyInformation=require(\"module$node_modules$property_information$index\"),_spaceSeparatedTokens=require(\"module$node_modules$space_separated_tokens$index\"),\n_webNamespaces=require(\"module$node_modules$web_namespaces$index\");global=require(\"module$node_modules$zwitch$index\");const own={}.hasOwnProperty,one=(0,global.zwitch)(\"type\",{handlers:{root:function(node,schema){const result={nodeName:\"#document\",mode:(node.data||{}).quirksMode?\"quirks\":\"no-quirks\",childNodes:[]};result.childNodes=all(node.children,result,schema);patch(node,result);return result},element:function(node,schema){let currentSchema=schema;\"element\"===node.type&&\"svg\"===node.tagName.toLowerCase()&&\n\"html\"===schema.space&&(currentSchema=_propertyInformation.svg);schema=[];if(node.properties)for(prop in node.properties)if(\"children\"!==prop&&own.call(node.properties,prop)){var value=node.properties[prop];var JSCompiler_inline_result=(0,_propertyInformation.find)(currentSchema,prop);if(void 0===value||null===value||!1===value||\"number\"===typeof value&&Number.isNaN(value)||!value&&JSCompiler_inline_result.boolean)JSCompiler_inline_result=void 0;else{Array.isArray(value)&&(value=JSCompiler_inline_result.commaSeparated?\n(0,_commaSeparatedTokens.stringify)(value):(0,_spaceSeparatedTokens.stringify)(value));value={name:JSCompiler_inline_result.attribute,value:!0===value?\"\":String(value)};if(JSCompiler_inline_result.space&&\"html\"!==JSCompiler_inline_result.space&&\"svg\"!==JSCompiler_inline_result.space){const index=value.name.indexOf(\":\");0>index?value.prefix=\"\":(value.name=value.name.slice(index+1),value.prefix=JSCompiler_inline_result.attribute.slice(0,index));value.namespace=_webNamespaces.webNamespaces[JSCompiler_inline_result.space]}JSCompiler_inline_result=\nvalue}JSCompiler_inline_result&&schema.push(JSCompiler_inline_result)}var prop={nodeName:node.tagName,tagName:node.tagName,attrs:schema,namespaceURI:_webNamespaces.webNamespaces[currentSchema.space],childNodes:[],parentNode:void 0};prop.childNodes=all(node.children,prop,currentSchema);patch(node,prop);\"template\"===node.tagName&&node.content&&(node=node.content,schema={nodeName:\"#document-fragment\",childNodes:[]},schema.childNodes=all(node.children,schema,currentSchema),patch(node,schema),prop.content=\nschema);return prop},text:function(node){const result={nodeName:\"#text\",value:node.value,parentNode:void 0};patch(node,result);return result},comment:function(node){const result={nodeName:\"#comment\",data:node.value,parentNode:void 0};patch(node,result);return result},doctype:function(node){const result={nodeName:\"#documentType\",name:\"html\",publicId:\"\",systemId:\"\",parentNode:void 0};patch(node,result);return result}}})}","~:source","shadow$provide[\"module$node_modules$hast_util_to_parse5$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toParse5 = toParse5;\n\nvar _commaSeparatedTokens = require(\"comma-separated-tokens\");\n\nvar _propertyInformation = require(\"property-information\");\n\nvar _spaceSeparatedTokens = require(\"space-separated-tokens\");\n\nvar _webNamespaces = require(\"web-namespaces\");\n\nvar _zwitch = require(\"zwitch\");\n\n/**\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5Fragment\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['documentType']} P5Doctype\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['parentNode']} P5Parent\n * @typedef {import('parse5').Token.Attribute} P5Attribute\n * @typedef {Exclude<P5Node, P5Document | P5Fragment>} P5Child\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Content} Content\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {'html' | 'svg'} Space\n *\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in.\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n */\nconst own = {}.hasOwnProperty;\n/** @type {(from: Node, schema: Schema) => P5Node} */\n\nconst one = (0, _zwitch.zwitch)('type', {\n  handlers: {\n    root,\n    element,\n    text,\n    comment,\n    doctype\n  }\n});\n/**\n * Transform a hast tree to Parse5â€™s AST.\n *\n * @param {Node} tree\n *   Tree to transform.\n * @param {Options | Space | null | undefined} [options]\n *   Configuration.\n * @returns {P5Node}\n *   `parse5` node.\n */\n\nfunction toParse5(tree, options) {\n  const space = options && typeof options === 'object' ? options.space : options;\n  return one(tree, space === 'svg' ? _propertyInformation.svg : _propertyInformation.html);\n}\n/**\n * @param {Root} node\n * @param {Schema} schema\n *   Current schema.\n * @returns {P5Document}\n */\n\n\nfunction root(node, schema) {\n  /** @type {P5Document} */\n  const result = {\n    nodeName: '#document',\n    // @ts-expect-error: `parse5` uses enums, which are actually strings.\n    mode: (node.data || {}).quirksMode ? 'quirks' : 'no-quirks',\n    childNodes: []\n  };\n  result.childNodes = all(node.children, result, schema);\n  patch(node, result);\n  return result;\n}\n/**\n * @param {Root} node\n * @param {Schema} schema\n *   Current schema.\n * @returns {P5Fragment}\n */\n\n\nfunction fragment(node, schema) {\n  /** @type {P5Fragment} */\n  const result = {\n    nodeName: '#document-fragment',\n    childNodes: []\n  };\n  result.childNodes = all(node.children, result, schema);\n  patch(node, result);\n  return result;\n}\n/**\n * @param {Doctype} node\n * @returns {P5Doctype}\n */\n\n\nfunction doctype(node) {\n  /** @type {P5Doctype} */\n  const result = {\n    nodeName: '#documentType',\n    name: 'html',\n    publicId: '',\n    systemId: '',\n    // @ts-expect-error: change to `null` in a major?\n    parentNode: undefined\n  };\n  patch(node, result);\n  return result;\n}\n/**\n * @param {Text} node\n * @returns {P5Text}\n */\n\n\nfunction text(node) {\n  /** @type {P5Text} */\n  const result = {\n    nodeName: '#text',\n    value: node.value,\n    // @ts-expect-error: no `parentNode`\n    parentNode: undefined\n  };\n  patch(node, result);\n  return result;\n}\n/**\n * @param {Comment} node\n * @returns {P5Comment}\n */\n\n\nfunction comment(node) {\n  /** @type {P5Comment} */\n  const result = {\n    nodeName: '#comment',\n    data: node.value,\n    // @ts-expect-error: no `parentNode`\n    parentNode: undefined\n  };\n  patch(node, result);\n  return result;\n}\n/**\n * @param {Element} node\n * @param {Schema} schema\n *   Current schema.\n * @returns {P5Element}\n *   `parse5` node.\n */\n\n\nfunction element(node, schema) {\n  const parentSchema = schema;\n  let currentSchema = parentSchema;\n\n  if (node.type === 'element' && node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n    currentSchema = _propertyInformation.svg;\n  }\n  /** @type {Array<P5Attribute>} */\n\n\n  const attrs = [];\n  /** @type {string} */\n\n  let prop;\n\n  if (node.properties) {\n    for (prop in node.properties) {\n      if (prop !== 'children' && own.call(node.properties, prop)) {\n        const result = createProperty(currentSchema, prop, node.properties[prop]);\n\n        if (result) {\n          attrs.push(result);\n        }\n      }\n    }\n  }\n  /** @type {P5Element} */\n\n\n  const result = {\n    nodeName: node.tagName,\n    tagName: node.tagName,\n    attrs,\n    // @ts-expect-error: html and svg both have a space.\n    namespaceURI: _webNamespaces.webNamespaces[currentSchema.space],\n    childNodes: [],\n    // @ts-expect-error: no `parentNode`\n    parentNode: undefined\n  };\n  result.childNodes = all(node.children, result, currentSchema);\n  patch(node, result);\n\n  if (node.tagName === 'template' && node.content) {\n    // @ts-expect-error: `parse5` types are wrong.\n    result.content = fragment(node.content, currentSchema);\n  }\n\n  return result;\n}\n/**\n * Handle a property.\n *\n * @param {Schema} schema\n *   Current schema.\n * @param {string} prop\n *   Key.\n * @param {Array<string | number> | string | number | boolean | null | undefined} value\n *   hast property value.\n * @returns {P5Attribute | void}\n *   Field for runtime, optional.\n */\n\n\nfunction createProperty(schema, prop, value) {\n  const info = (0, _propertyInformation.find)(schema, prop); // Ignore nullish and `NaN` values.\n\n  if (value === undefined || value === null || value === false || typeof value === 'number' && Number.isNaN(value) || !value && info.boolean) {\n    return;\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? (0, _commaSeparatedTokens.stringify)(value) : (0, _spaceSeparatedTokens.stringify)(value);\n  }\n  /** @type {P5Attribute} */\n\n\n  const attribute = {\n    name: info.attribute,\n    value: value === true ? '' : String(value)\n  };\n\n  if (info.space && info.space !== 'html' && info.space !== 'svg') {\n    const index = attribute.name.indexOf(':');\n\n    if (index < 0) {\n      attribute.prefix = '';\n    } else {\n      attribute.name = attribute.name.slice(index + 1);\n      attribute.prefix = info.attribute.slice(0, index);\n    }\n\n    attribute.namespace = _webNamespaces.webNamespaces[info.space];\n  }\n\n  return attribute;\n}\n/**\n * Transform all hast nodes.\n *\n * @param {Array<Content>} children\n *   List of children.\n * @param {P5Parent} parentNode\n *   `parse5` parent node.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Array<P5Child>}\n *   Transformed children.\n */\n\n\nfunction all(children, parentNode, schema) {\n  let index = -1;\n  /** @type {Array<P5Child>} */\n\n  const results = [];\n\n  if (children) {\n    while (++index < children.length) {\n      /** @type {P5Child} */\n      // @ts-expect-error assume no document.\n      const child = one(children[index], schema);\n      child.parentNode = parentNode;\n      results.push(child);\n    }\n  }\n\n  return results;\n}\n/**\n * Add position info from `from` to `to`.\n *\n * @param {Node} from\n *   hast node.\n * @param {P5Node} to\n *   `parse5` node.\n * @returns {void}\n *   Nothing.\n */\n\n\nfunction patch(from, to) {\n  const position = from.position;\n\n  if (position && position.start && position.end) {\n    to.sourceCodeLocation = {\n      startLine: position.start.line,\n      startCol: position.start.column,\n      // @ts-expect-error assume this is set.\n      startOffset: position.start.offset,\n      endLine: position.end.line,\n      endCol: position.end.column,\n      // @ts-expect-error assume this is set.\n      endOffset: position.end.offset\n    };\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$property_information$index","~$shadow.js","~$module$node_modules$space_separated_tokens$index","~$module$node_modules$comma_separated_tokens$index","~$module$node_modules$zwitch$index","~$module$node_modules$web_namespaces$index"]],"~:properties",["^5",["systemId","attrs","toParse5","endLine","prefix","handlers","childNodes","__esModule","publicId","root","endOffset","sourceCodeLocation","mode","parentNode","nodeName","element","name","value","startOffset","startLine","text","content","namespaceURI","tagName","namespace","comment","doctype","data","startCol","endCol"]],"~:compiled-at",1676841365346,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hast_util_to_parse5$lib$index.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/hast-util-to-parse5/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hast_util_to_parse5$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.toParse5 = toParse5;\\n\\nvar _commaSeparatedTokens = require(\\\"comma-separated-tokens\\\");\\n\\nvar _propertyInformation = require(\\\"property-information\\\");\\n\\nvar _spaceSeparatedTokens = require(\\\"space-separated-tokens\\\");\\n\\nvar _webNamespaces = require(\\\"web-namespaces\\\");\\n\\nvar _zwitch = require(\\\"zwitch\\\");\\n\\n/**\\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5Fragment\\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\\n * @typedef {DefaultTreeAdapterMap['documentType']} P5Doctype\\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\\n * @typedef {DefaultTreeAdapterMap['parentNode']} P5Parent\\n * @typedef {import('parse5').Token.Attribute} P5Attribute\\n * @typedef {Exclude<P5Node, P5Document | P5Fragment>} P5Child\\n * @typedef {import('property-information').Schema} Schema\\n * @typedef {import('hast').Root} Root\\n * @typedef {import('hast').DocType} Doctype\\n * @typedef {import('hast').Element} Element\\n * @typedef {import('hast').Text} Text\\n * @typedef {import('hast').Comment} Comment\\n * @typedef {import('hast').Content} Content\\n */\\n\\n/**\\n * @typedef {Content | Root} Node\\n * @typedef {'html' | 'svg'} Space\\n *\\n * @typedef Options\\n *   Configuration.\\n * @property {Space | null | undefined} [space='html']\\n *   Which space the document is in.\\n *\\n *   When an `<svg>` element is found in the HTML space, this package already\\n *   automatically switches to and from the SVG space when entering and exiting\\n *   it.\\n */\\nconst own = {}.hasOwnProperty;\\n/** @type {(from: Node, schema: Schema) => P5Node} */\\n\\nconst one = (0, _zwitch.zwitch)('type', {\\n  handlers: {\\n    root,\\n    element,\\n    text,\\n    comment,\\n    doctype\\n  }\\n});\\n/**\\n * Transform a hast tree to Parse5\\u2019s AST.\\n *\\n * @param {Node} tree\\n *   Tree to transform.\\n * @param {Options | Space | null | undefined} [options]\\n *   Configuration.\\n * @returns {P5Node}\\n *   `parse5` node.\\n */\\n\\nfunction toParse5(tree, options) {\\n  const space = options && typeof options === 'object' ? options.space : options;\\n  return one(tree, space === 'svg' ? _propertyInformation.svg : _propertyInformation.html);\\n}\\n/**\\n * @param {Root} node\\n * @param {Schema} schema\\n *   Current schema.\\n * @returns {P5Document}\\n */\\n\\n\\nfunction root(node, schema) {\\n  /** @type {P5Document} */\\n  const result = {\\n    nodeName: '#document',\\n    // @ts-expect-error: `parse5` uses enums, which are actually strings.\\n    mode: (node.data || {}).quirksMode ? 'quirks' : 'no-quirks',\\n    childNodes: []\\n  };\\n  result.childNodes = all(node.children, result, schema);\\n  patch(node, result);\\n  return result;\\n}\\n/**\\n * @param {Root} node\\n * @param {Schema} schema\\n *   Current schema.\\n * @returns {P5Fragment}\\n */\\n\\n\\nfunction fragment(node, schema) {\\n  /** @type {P5Fragment} */\\n  const result = {\\n    nodeName: '#document-fragment',\\n    childNodes: []\\n  };\\n  result.childNodes = all(node.children, result, schema);\\n  patch(node, result);\\n  return result;\\n}\\n/**\\n * @param {Doctype} node\\n * @returns {P5Doctype}\\n */\\n\\n\\nfunction doctype(node) {\\n  /** @type {P5Doctype} */\\n  const result = {\\n    nodeName: '#documentType',\\n    name: 'html',\\n    publicId: '',\\n    systemId: '',\\n    // @ts-expect-error: change to `null` in a major?\\n    parentNode: undefined\\n  };\\n  patch(node, result);\\n  return result;\\n}\\n/**\\n * @param {Text} node\\n * @returns {P5Text}\\n */\\n\\n\\nfunction text(node) {\\n  /** @type {P5Text} */\\n  const result = {\\n    nodeName: '#text',\\n    value: node.value,\\n    // @ts-expect-error: no `parentNode`\\n    parentNode: undefined\\n  };\\n  patch(node, result);\\n  return result;\\n}\\n/**\\n * @param {Comment} node\\n * @returns {P5Comment}\\n */\\n\\n\\nfunction comment(node) {\\n  /** @type {P5Comment} */\\n  const result = {\\n    nodeName: '#comment',\\n    data: node.value,\\n    // @ts-expect-error: no `parentNode`\\n    parentNode: undefined\\n  };\\n  patch(node, result);\\n  return result;\\n}\\n/**\\n * @param {Element} node\\n * @param {Schema} schema\\n *   Current schema.\\n * @returns {P5Element}\\n *   `parse5` node.\\n */\\n\\n\\nfunction element(node, schema) {\\n  const parentSchema = schema;\\n  let currentSchema = parentSchema;\\n\\n  if (node.type === 'element' && node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\\n    currentSchema = _propertyInformation.svg;\\n  }\\n  /** @type {Array<P5Attribute>} */\\n\\n\\n  const attrs = [];\\n  /** @type {string} */\\n\\n  let prop;\\n\\n  if (node.properties) {\\n    for (prop in node.properties) {\\n      if (prop !== 'children' && own.call(node.properties, prop)) {\\n        const result = createProperty(currentSchema, prop, node.properties[prop]);\\n\\n        if (result) {\\n          attrs.push(result);\\n        }\\n      }\\n    }\\n  }\\n  /** @type {P5Element} */\\n\\n\\n  const result = {\\n    nodeName: node.tagName,\\n    tagName: node.tagName,\\n    attrs,\\n    // @ts-expect-error: html and svg both have a space.\\n    namespaceURI: _webNamespaces.webNamespaces[currentSchema.space],\\n    childNodes: [],\\n    // @ts-expect-error: no `parentNode`\\n    parentNode: undefined\\n  };\\n  result.childNodes = all(node.children, result, currentSchema);\\n  patch(node, result);\\n\\n  if (node.tagName === 'template' && node.content) {\\n    // @ts-expect-error: `parse5` types are wrong.\\n    result.content = fragment(node.content, currentSchema);\\n  }\\n\\n  return result;\\n}\\n/**\\n * Handle a property.\\n *\\n * @param {Schema} schema\\n *   Current schema.\\n * @param {string} prop\\n *   Key.\\n * @param {Array<string | number> | string | number | boolean | null | undefined} value\\n *   hast property value.\\n * @returns {P5Attribute | void}\\n *   Field for runtime, optional.\\n */\\n\\n\\nfunction createProperty(schema, prop, value) {\\n  const info = (0, _propertyInformation.find)(schema, prop); // Ignore nullish and `NaN` values.\\n\\n  if (value === undefined || value === null || value === false || typeof value === 'number' && Number.isNaN(value) || !value && info.boolean) {\\n    return;\\n  }\\n\\n  if (Array.isArray(value)) {\\n    // Accept `array`.\\n    // Most props are space-separated.\\n    value = info.commaSeparated ? (0, _commaSeparatedTokens.stringify)(value) : (0, _spaceSeparatedTokens.stringify)(value);\\n  }\\n  /** @type {P5Attribute} */\\n\\n\\n  const attribute = {\\n    name: info.attribute,\\n    value: value === true ? '' : String(value)\\n  };\\n\\n  if (info.space && info.space !== 'html' && info.space !== 'svg') {\\n    const index = attribute.name.indexOf(':');\\n\\n    if (index < 0) {\\n      attribute.prefix = '';\\n    } else {\\n      attribute.name = attribute.name.slice(index + 1);\\n      attribute.prefix = info.attribute.slice(0, index);\\n    }\\n\\n    attribute.namespace = _webNamespaces.webNamespaces[info.space];\\n  }\\n\\n  return attribute;\\n}\\n/**\\n * Transform all hast nodes.\\n *\\n * @param {Array<Content>} children\\n *   List of children.\\n * @param {P5Parent} parentNode\\n *   `parse5` parent node.\\n * @param {Schema} schema\\n *   Current schema.\\n * @returns {Array<P5Child>}\\n *   Transformed children.\\n */\\n\\n\\nfunction all(children, parentNode, schema) {\\n  let index = -1;\\n  /** @type {Array<P5Child>} */\\n\\n  const results = [];\\n\\n  if (children) {\\n    while (++index < children.length) {\\n      /** @type {P5Child} */\\n      // @ts-expect-error assume no document.\\n      const child = one(children[index], schema);\\n      child.parentNode = parentNode;\\n      results.push(child);\\n    }\\n  }\\n\\n  return results;\\n}\\n/**\\n * Add position info from `from` to `to`.\\n *\\n * @param {Node} from\\n *   hast node.\\n * @param {P5Node} to\\n *   `parse5` node.\\n * @returns {void}\\n *   Nothing.\\n */\\n\\n\\nfunction patch(from, to) {\\n  const position = from.position;\\n\\n  if (position && position.start && position.end) {\\n    to.sourceCodeLocation = {\\n      startLine: position.start.line,\\n      startCol: position.start.column,\\n      // @ts-expect-error assume this is set.\\n      startOffset: position.start.offset,\\n      endLine: position.end.line,\\n      endCol: position.end.column,\\n      // @ts-expect-error assume this is set.\\n      endOffset: position.end.offset\\n    };\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"all\",\"children\",\"parentNode\",\"schema\",\"index\",\"results\",\"length\",\"child\",\"one\",\"push\",\"patch\",\"from\",\"to\",\"position\",\"start\",\"end\",\"sourceCodeLocation\",\"startLine\",\"line\",\"startCol\",\"column\",\"startOffset\",\"offset\",\"endLine\",\"endCol\",\"endOffset\",\"Object\",\"defineProperty\",\"value\",\"toParse5\",\"tree\",\"options\",\"space\",\"_propertyInformation\",\"svg\",\"html\",\"_commaSeparatedTokens\",\"_spaceSeparatedTokens\",\"_webNamespaces\",\"_zwitch\",\"own\",\"hasOwnProperty\",\"zwitch\",\"handlers\",\"root\",\"node\",\"result\",\"nodeName\",\"mode\",\"quirksMode\",\"data\",\"childNodes\",\"element\",\"currentSchema\",\"type\",\"tagName\",\"toLowerCase\",\"attrs\",\"properties\",\"prop\",\"call\",\"info\",\"find\",\"undefined\",\"Number\",\"isNaN\",\"boolean\",\"Array\",\"isArray\",\"commaSeparated\",\"stringify\",\"attribute\",\"name\",\"String\",\"indexOf\",\"prefix\",\"slice\",\"namespace\",\"webNamespaces\",\"namespaceURI\",\"content\",\"text\",\"comment\",\"doctype\",\"publicId\",\"systemId\"]\n}\n"]