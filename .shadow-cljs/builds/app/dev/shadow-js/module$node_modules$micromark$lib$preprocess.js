["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark/lib/preprocess.js"],"~:js","shadow$provide.module$node_modules$micromark$lib$preprocess=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.preprocess=function(){let column=1,buffer=\"\",start=!0,atCarriageReturn;return function(value,encoding,end){const chunks=[];var match;let startPosition,code;value=buffer+value.toString(encoding);startPosition=0;buffer=\"\";start&&(65279===value.charCodeAt(0)&&startPosition++,start=void 0);for(;startPosition<value.length;){search.lastIndex=\nstartPosition;encoding=(match=search.exec(value))&&void 0!==match.index?match.index:value.length;code=value.charCodeAt(encoding);if(!match){buffer=value.slice(startPosition);break}if(10===code&&startPosition===encoding&&atCarriageReturn)chunks.push(-3),atCarriageReturn=void 0;else switch(atCarriageReturn&&(chunks.push(-5),atCarriageReturn=void 0),startPosition<encoding&&(chunks.push(value.slice(startPosition,encoding)),column+=encoding-startPosition),code){case 0:chunks.push(65533);column++;break;\ncase 9:match=4*Math.ceil(column/4);for(chunks.push(-2);column++<match;)chunks.push(-1);break;case 10:chunks.push(-4);column=1;break;default:atCarriageReturn=!0,column=1}startPosition=encoding+1}end&&(atCarriageReturn&&chunks.push(-5),buffer&&chunks.push(buffer),chunks.push(null));return chunks}};const search=/[\\0\\t\\n\\r]/g}","~:source","shadow$provide[\"module$node_modules$micromark$lib$preprocess\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.preprocess = preprocess;\n\n/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Value} Value\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * @callback Preprocessor\n * @param {Value} value\n * @param {Encoding} [encoding]\n * @param {boolean} [end=false]\n * @returns {Array<Chunk>}\n */\nconst search = /[\\0\\t\\n\\r]/g;\n/**\n * @returns {Preprocessor}\n */\n\nfunction preprocess() {\n  let column = 1;\n  let buffer = '';\n  /** @type {boolean|undefined} */\n\n  let start = true;\n  /** @type {boolean|undefined} */\n\n  let atCarriageReturn;\n  return preprocessor;\n  /** @type {Preprocessor} */\n\n  function preprocessor(value, encoding, end) {\n    /** @type {Array<Chunk>} */\n    const chunks = [];\n    /** @type {RegExpMatchArray|null} */\n\n    let match;\n    /** @type {number} */\n\n    let next;\n    /** @type {number} */\n\n    let startPosition;\n    /** @type {number} */\n\n    let endPosition;\n    /** @type {Code} */\n\n    let code; // @ts-expect-error `Buffer` does allow an encoding.\n\n    value = buffer + value.toString(encoding);\n    startPosition = 0;\n    buffer = '';\n\n    if (start) {\n      if (value.charCodeAt(0) === 65279) {\n        startPosition++;\n      }\n\n      start = undefined;\n    }\n\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition;\n      match = search.exec(value);\n      endPosition = match && match.index !== undefined ? match.index : value.length;\n      code = value.charCodeAt(endPosition);\n\n      if (!match) {\n        buffer = value.slice(startPosition);\n        break;\n      }\n\n      if (code === 10 && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(-3);\n        atCarriageReturn = undefined;\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(-5);\n          atCarriageReturn = undefined;\n        }\n\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition));\n          column += endPosition - startPosition;\n        }\n\n        switch (code) {\n          case 0:\n            {\n              chunks.push(65533);\n              column++;\n              break;\n            }\n\n          case 9:\n            {\n              next = Math.ceil(column / 4) * 4;\n              chunks.push(-2);\n\n              while (column++ < next) chunks.push(-1);\n\n              break;\n            }\n\n          case 10:\n            {\n              chunks.push(-4);\n              column = 1;\n              break;\n            }\n\n          default:\n            {\n              atCarriageReturn = true;\n              column = 1;\n            }\n        }\n      }\n\n      startPosition = endPosition + 1;\n    }\n\n    if (end) {\n      if (atCarriageReturn) chunks.push(-5);\n      if (buffer) chunks.push(buffer);\n      chunks.push(null);\n    }\n\n    return chunks;\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["__esModule","lastIndex","value","preprocess"]],"~:compiled-at",1676665867303,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark$lib$preprocess.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark/lib/preprocess.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark$lib$preprocess\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.preprocess = preprocess;\\n\\n/**\\n * @typedef {import('micromark-util-types').Encoding} Encoding\\n * @typedef {import('micromark-util-types').Value} Value\\n * @typedef {import('micromark-util-types').Chunk} Chunk\\n * @typedef {import('micromark-util-types').Code} Code\\n */\\n\\n/**\\n * @callback Preprocessor\\n * @param {Value} value\\n * @param {Encoding} [encoding]\\n * @param {boolean} [end=false]\\n * @returns {Array<Chunk>}\\n */\\nconst search = /[\\\\0\\\\t\\\\n\\\\r]/g;\\n/**\\n * @returns {Preprocessor}\\n */\\n\\nfunction preprocess() {\\n  let column = 1;\\n  let buffer = '';\\n  /** @type {boolean|undefined} */\\n\\n  let start = true;\\n  /** @type {boolean|undefined} */\\n\\n  let atCarriageReturn;\\n  return preprocessor;\\n  /** @type {Preprocessor} */\\n\\n  function preprocessor(value, encoding, end) {\\n    /** @type {Array<Chunk>} */\\n    const chunks = [];\\n    /** @type {RegExpMatchArray|null} */\\n\\n    let match;\\n    /** @type {number} */\\n\\n    let next;\\n    /** @type {number} */\\n\\n    let startPosition;\\n    /** @type {number} */\\n\\n    let endPosition;\\n    /** @type {Code} */\\n\\n    let code; // @ts-expect-error `Buffer` does allow an encoding.\\n\\n    value = buffer + value.toString(encoding);\\n    startPosition = 0;\\n    buffer = '';\\n\\n    if (start) {\\n      if (value.charCodeAt(0) === 65279) {\\n        startPosition++;\\n      }\\n\\n      start = undefined;\\n    }\\n\\n    while (startPosition < value.length) {\\n      search.lastIndex = startPosition;\\n      match = search.exec(value);\\n      endPosition = match && match.index !== undefined ? match.index : value.length;\\n      code = value.charCodeAt(endPosition);\\n\\n      if (!match) {\\n        buffer = value.slice(startPosition);\\n        break;\\n      }\\n\\n      if (code === 10 && startPosition === endPosition && atCarriageReturn) {\\n        chunks.push(-3);\\n        atCarriageReturn = undefined;\\n      } else {\\n        if (atCarriageReturn) {\\n          chunks.push(-5);\\n          atCarriageReturn = undefined;\\n        }\\n\\n        if (startPosition < endPosition) {\\n          chunks.push(value.slice(startPosition, endPosition));\\n          column += endPosition - startPosition;\\n        }\\n\\n        switch (code) {\\n          case 0:\\n            {\\n              chunks.push(65533);\\n              column++;\\n              break;\\n            }\\n\\n          case 9:\\n            {\\n              next = Math.ceil(column / 4) * 4;\\n              chunks.push(-2);\\n\\n              while (column++ < next) chunks.push(-1);\\n\\n              break;\\n            }\\n\\n          case 10:\\n            {\\n              chunks.push(-4);\\n              column = 1;\\n              break;\\n            }\\n\\n          default:\\n            {\\n              atCarriageReturn = true;\\n              column = 1;\\n            }\\n        }\\n      }\\n\\n      startPosition = endPosition + 1;\\n    }\\n\\n    if (end) {\\n      if (atCarriageReturn) chunks.push(-5);\\n      if (buffer) chunks.push(buffer);\\n      chunks.push(null);\\n    }\\n\\n    return chunks;\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"preprocess\",\"column\",\"buffer\",\"start\",\"atCarriageReturn\",\"preprocessor\",\"encoding\",\"end\",\"chunks\",\"match\",\"startPosition\",\"code\",\"toString\",\"charCodeAt\",\"undefined\",\"length\",\"search\",\"lastIndex\",\"endPosition\",\"exec\",\"index\",\"slice\",\"push\",\"next\",\"Math\",\"ceil\"]\n}\n"]