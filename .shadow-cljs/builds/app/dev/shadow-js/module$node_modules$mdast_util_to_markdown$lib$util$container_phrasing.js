["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js"],"~:js","shadow$provide.module$node_modules$mdast_util_to_markdown$lib$util$container_phrasing=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.containerPhrasing=function(parent,state,info){const indexStack=state.indexStack,children=parent.children||[],results=[];let index=-1,before=info.before;indexStack.push(-1);let tracker=state.createTracker(info);for(;++index<children.length;){const child=children[index];var after=void 0;indexStack[indexStack.length-\n1]=index;index+1<children.length?((after=state.handle.handlers[children[index+1].type])&&after.peek&&(after=after.peek),after=after?after(children[index+1],parent,state,{before:\"\",after:\"\",...tracker.current()}).charAt(0):\"\"):after=info.after;0<results.length&&(\"\\r\"===before||\"\\n\"===before)&&\"html\"===child.type&&(results[results.length-1]=results[results.length-1].replace(/(\\r?\\n|\\r)$/,\" \"),before=\" \",tracker=state.createTracker(info),tracker.move(results.join(\"\")));results.push(tracker.move(state.handle(child,\nparent,state,{...tracker.current(),before,after})));before=results[results.length-1].slice(-1)}indexStack.pop();return results.join(\"\")}}","~:source","shadow$provide[\"module$node_modules$mdast_util_to_markdown$lib$util$container_phrasing\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.containerPhrasing = containerPhrasing;\n\n/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack;\n  const children = parent.children || [];\n  /** @type {Array<string>} */\n\n  const results = [];\n  let index = -1;\n  let before = info.before;\n  indexStack.push(-1);\n  let tracker = state.createTracker(info);\n\n  while (++index < children.length) {\n    const child = children[index];\n    /** @type {string} */\n\n    let after;\n    indexStack[indexStack.length - 1] = index;\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type];\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n\n      if (handle && handle.peek) handle = handle.peek;\n      after = handle ? handle(children[index + 1], parent, state, {\n        before: '',\n        after: '',\n        ...tracker.current()\n      }).charAt(0) : '';\n    } else {\n      after = info.after;\n    } // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n\n\n    if (results.length > 0 && (before === '\\r' || before === '\\n') && child.type === 'html') {\n      results[results.length - 1] = results[results.length - 1].replace(/(\\r?\\n|\\r)$/, ' ');\n      before = ' '; // To do: does this work to reset tracker?\n\n      tracker = state.createTracker(info);\n      tracker.move(results.join(''));\n    }\n\n    results.push(tracker.move(state.handle(child, parent, state, { ...tracker.current(),\n      before,\n      after\n    })));\n    before = results[results.length - 1].slice(-1);\n  }\n\n  indexStack.pop();\n  return results.join('');\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["containerPhrasing","after","__esModule","value","before"]],"~:compiled-at",1676841365339,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mdast_util_to_markdown$lib$util$container_phrasing.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,sEAAA,CAA2F,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGnIC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,iBAAR,CAwBAA,QAA0B,CAACC,MAAD,CAASC,KAAT,CAAgBC,IAAhB,CAAsB,CAC9C,MAAMC,WAAaF,KAAME,CAAAA,UAAzB,CACMC,SAAWJ,MAAOI,CAAAA,QAAlBA,EAA8B,EADpC,CAIMC,QAAU,EAChB,KAAIC,MAAQ,CAAC,CAAb,CACIC,OAASL,IAAKK,CAAAA,MAClBJ,WAAWK,CAAAA,IAAX,CAAgB,CAAC,CAAjB,CACA,KAAIC,QAAUR,KAAMS,CAAAA,aAAN,CAAoBR,IAApB,CAEd,KAAA,CAAO,EAAEI,KAAT,CAAiBF,QAASO,CAAAA,MAA1B,CAAA,CAAkC,CAChC,MAAMC,MAAQR,QAAA,CAASE,KAAT,CAGd,KAAIO,MAAAA,IAAAA,EACJV,WAAA,CAAWA,UAAWQ,CAAAA,MAAtB;AAA+B,CAA/B,CAAA,CAAoCL,KAEhCA,MAAJ,CAAY,CAAZ,CAAgBF,QAASO,CAAAA,MAAzB,EAQE,CALIG,KAKJ,CALab,KAAMa,CAAAA,MAAOC,CAAAA,QAAb,CAAsBX,QAAA,CAASE,KAAT,CAAiB,CAAjB,CAAoBU,CAAAA,IAA1C,CAKb,GADcF,KAAOG,CAAAA,IACrB,GAD2BH,KAC3B,CADoCA,KAAOG,CAAAA,IAC3C,EAAAJ,KAAA,CAAQC,KAAA,CAASA,KAAA,CAAOV,QAAA,CAASE,KAAT,CAAiB,CAAjB,CAAP,CAA4BN,MAA5B,CAAoCC,KAApC,CAA2C,CAC1DM,OAAQ,EADkD,CAE1DM,MAAO,EAFmD,CAG1D,GAAGJ,OAAQS,CAAAA,OAAR,EAHuD,CAA3C,CAIdC,CAAAA,MAJc,CAIP,CAJO,CAAT,CAIO,EAZjB,EAcEN,KAdF,CAcUX,IAAKW,CAAAA,KASM,EAArB,CAAIR,OAAQM,CAAAA,MAAZ,GAAsC,IAAtC,GAA2BJ,MAA3B,EAAyD,IAAzD,GAA8CA,MAA9C,GAAiF,MAAjF,GAAkEK,KAAMI,CAAAA,IAAxE,GACEX,OAAA,CAAQA,OAAQM,CAAAA,MAAhB,CAAyB,CAAzB,CAIA,CAJ8BN,OAAA,CAAQA,OAAQM,CAAAA,MAAhB,CAAyB,CAAzB,CAA4BS,CAAAA,OAA5B,CAAoC,aAApC,CAAmD,GAAnD,CAI9B,CAHAb,MAGA,CAHS,GAGT,CADAE,OACA,CADUR,KAAMS,CAAAA,aAAN,CAAoBR,IAApB,CACV,CAAAO,OAAQY,CAAAA,IAAR,CAAahB,OAAQiB,CAAAA,IAAR,CAAa,EAAb,CAAb,CALF,CAQAjB,QAAQG,CAAAA,IAAR,CAAaC,OAAQY,CAAAA,IAAR,CAAapB,KAAMa,CAAAA,MAAN,CAAaF,KAAb;AAAoBZ,MAApB,CAA4BC,KAA5B,CAAmC,CAAE,GAAGQ,OAAQS,CAAAA,OAAR,EAAL,CAC3DX,MAD2D,CAE3DM,KAF2D,CAAnC,CAAb,CAAb,CAIAN,OAAA,CAASF,OAAA,CAAQA,OAAQM,CAAAA,MAAhB,CAAyB,CAAzB,CAA4BY,CAAAA,KAA5B,CAAkC,CAAC,CAAnC,CA1CuB,CA6ClCpB,UAAWqB,CAAAA,GAAX,EACA,OAAOnB,QAAQiB,CAAAA,IAAR,CAAa,EAAb,CAzDuC,CA9BmF;\",\n\"sources\":[\"node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mdast_util_to_markdown$lib$util$container_phrasing\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.containerPhrasing = containerPhrasing;\\n\\n/**\\n * @typedef {import('../types.js').Handle} Handle\\n * @typedef {import('../types.js').Info} Info\\n * @typedef {import('../types.js').Parent} Parent\\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\\n * @typedef {import('../types.js').State} State\\n */\\n\\n/**\\n * Serialize the children of a parent that contains phrasing children.\\n *\\n * These children will be joined flush together.\\n *\\n * @param {Parent & {children: Array<PhrasingContent>}} parent\\n *   Parent of flow nodes.\\n * @param {State} state\\n *   Info passed around about the current state.\\n * @param {Info} info\\n *   Info on where we are in the document we are generating.\\n * @returns {string}\\n *   Serialized children, joined together.\\n */\\nfunction containerPhrasing(parent, state, info) {\\n  const indexStack = state.indexStack;\\n  const children = parent.children || [];\\n  /** @type {Array<string>} */\\n\\n  const results = [];\\n  let index = -1;\\n  let before = info.before;\\n  indexStack.push(-1);\\n  let tracker = state.createTracker(info);\\n\\n  while (++index < children.length) {\\n    const child = children[index];\\n    /** @type {string} */\\n\\n    let after;\\n    indexStack[indexStack.length - 1] = index;\\n\\n    if (index + 1 < children.length) {\\n      /** @type {Handle} */\\n      // @ts-expect-error: hush, it\\u2019s actually a `zwitch`.\\n      let handle = state.handle.handlers[children[index + 1].type];\\n      /** @type {Handle} */\\n      // @ts-expect-error: hush, it\\u2019s actually a `zwitch`.\\n\\n      if (handle && handle.peek) handle = handle.peek;\\n      after = handle ? handle(children[index + 1], parent, state, {\\n        before: '',\\n        after: '',\\n        ...tracker.current()\\n      }).charAt(0) : '';\\n    } else {\\n      after = info.after;\\n    } // In some cases, html (text) can be found in phrasing right after an eol.\\n    // When we\\u2019d serialize that, in most cases that would be seen as html\\n    // (flow).\\n    // As we can\\u2019t escape or so to prevent it from happening, we take a somewhat\\n    // reasonable approach: replace that eol with a space.\\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\\n\\n\\n    if (results.length > 0 && (before === '\\\\r' || before === '\\\\n') && child.type === 'html') {\\n      results[results.length - 1] = results[results.length - 1].replace(/(\\\\r?\\\\n|\\\\r)$/, ' ');\\n      before = ' '; // To do: does this work to reset tracker?\\n\\n      tracker = state.createTracker(info);\\n      tracker.move(results.join(''));\\n    }\\n\\n    results.push(tracker.move(state.handle(child, parent, state, { ...tracker.current(),\\n      before,\\n      after\\n    })));\\n    before = results[results.length - 1].slice(-1);\\n  }\\n\\n  indexStack.pop();\\n  return results.join('');\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"containerPhrasing\",\"parent\",\"state\",\"info\",\"indexStack\",\"children\",\"results\",\"index\",\"before\",\"push\",\"tracker\",\"createTracker\",\"length\",\"child\",\"after\",\"handle\",\"handlers\",\"type\",\"peek\",\"current\",\"charAt\",\"replace\",\"move\",\"join\",\"slice\",\"pop\"]\n}\n"]