["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/trough/index.js"],"~:js","shadow$provide.module$node_modules$trough$index=function(global,require,module,exports){function wrap(middleware,callback){function done(error,...output){called||(called=!0,callback(error,...output))}function then(value){done(null,value)}let called;return function(...parameters){const fnExpectsCallback=middleware.length>parameters.length;let result;fnExpectsCallback&&parameters.push(done);try{result=middleware.apply(this,parameters)}catch(error){if(fnExpectsCallback&&called)throw error;return done(error)}fnExpectsCallback||\n(result instanceof Promise?result.then(then,done):result instanceof Error?done(result):then(result))}}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.trough=function(){const fns=[],pipeline={run:function(...values){function next(error,...output){const fn=fns[++middlewareIndex];let index=-1;if(error)callback(error);else{for(;++index<values.length;)if(null===output[index]||void 0===output[index])output[index]=values[index];values=output;fn?wrap(fn,next)(...output):callback(null,...output)}}\nlet middlewareIndex=-1;const callback=values.pop();if(\"function\"!==typeof callback)throw new TypeError(\"Expected function as last argument, not \"+callback);next(null,...values)},use:function(middelware){if(\"function\"!==typeof middelware)throw new TypeError(\"Expected `middelware` to be a function, not \"+middelware);fns.push(middelware);return pipeline}};return pipeline};exports.wrap=wrap}","~:source","shadow$provide[\"module$node_modules$trough$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.trough = trough;\nexports.wrap = wrap;\n\n/**\n * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback\n * @typedef {(...input: Array<any>) => any} Middleware\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n *   Middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */\nfunction trough() {\n  /** @type {Array<Middleware>} */\n  const fns = [];\n  /** @type {Pipeline} */\n\n  const pipeline = {\n    run,\n    use\n  };\n  return pipeline;\n  /** @type {Run} */\n\n  function run(...values) {\n    let middlewareIndex = -1;\n    /** @type {Callback} */\n\n    const callback = values.pop();\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback);\n    }\n\n    next(null, ...values);\n    /**\n     * Run the next `fn`, or weâ€™re done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {Array<any>} output\n     */\n\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex];\n      let index = -1;\n\n      if (error) {\n        callback(error);\n        return;\n      } // Copy non-nullish input into values.\n\n\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index];\n        }\n      } // Save the newly created `output` for the next call.\n\n\n      values = output; // Next or done.\n\n      if (fn) {\n        wrap(fn, next)(...output);\n      } else {\n        callback(null, ...output);\n      }\n    }\n  }\n  /** @type {Use} */\n\n\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError('Expected `middelware` to be a function, not ' + middelware);\n    }\n\n    fns.push(middelware);\n    return pipeline;\n  }\n}\n/**\n * Wrap `middleware`.\n * Can be sync or async; return a promise, receive a callback, or return new\n * values and errors.\n *\n * @param {Middleware} middleware\n * @param {Callback} callback\n */\n\n\nfunction wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called;\n  return wrapped;\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length;\n    /** @type {any} */\n\n    let result;\n\n    if (fnExpectsCallback) {\n      parameters.push(done);\n    }\n\n    try {\n      result = middleware.apply(this, parameters);\n    } catch (error) {\n      const exception = error; // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n\n      if (fnExpectsCallback && called) {\n        throw exception;\n      }\n\n      return done(exception);\n    }\n\n    if (!fnExpectsCallback) {\n      if (result instanceof Promise) {\n        result.then(then, done);\n      } else if (result instanceof Error) {\n        done(result);\n      } else {\n        then(result);\n      }\n    }\n  }\n  /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */\n\n\n  function done(error, ...output) {\n    if (!called) {\n      called = true;\n      callback(error, ...output);\n    }\n  }\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n\n\n  function then(value) {\n    done(null, value);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["__esModule","run","trough","wrap","value","use"]],"~:compiled-at",1676665867246,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$trough$index.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/trough/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$trough$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.trough = trough;\\nexports.wrap = wrap;\\n\\n/**\\n * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback\\n * @typedef {(...input: Array<any>) => any} Middleware\\n *\\n * @typedef {(...input: Array<any>) => void} Run\\n *   Call all middleware.\\n * @typedef {(fn: Middleware) => Pipeline} Use\\n *   Add `fn` (middleware) to the list.\\n * @typedef {{run: Run, use: Use}} Pipeline\\n *   Middleware.\\n */\\n\\n/**\\n * Create new middleware.\\n *\\n * @returns {Pipeline}\\n */\\nfunction trough() {\\n  /** @type {Array<Middleware>} */\\n  const fns = [];\\n  /** @type {Pipeline} */\\n\\n  const pipeline = {\\n    run,\\n    use\\n  };\\n  return pipeline;\\n  /** @type {Run} */\\n\\n  function run(...values) {\\n    let middlewareIndex = -1;\\n    /** @type {Callback} */\\n\\n    const callback = values.pop();\\n\\n    if (typeof callback !== 'function') {\\n      throw new TypeError('Expected function as last argument, not ' + callback);\\n    }\\n\\n    next(null, ...values);\\n    /**\\n     * Run the next `fn`, or we\\u2019re done.\\n     *\\n     * @param {Error|null|undefined} error\\n     * @param {Array<any>} output\\n     */\\n\\n    function next(error, ...output) {\\n      const fn = fns[++middlewareIndex];\\n      let index = -1;\\n\\n      if (error) {\\n        callback(error);\\n        return;\\n      } // Copy non-nullish input into values.\\n\\n\\n      while (++index < values.length) {\\n        if (output[index] === null || output[index] === undefined) {\\n          output[index] = values[index];\\n        }\\n      } // Save the newly created `output` for the next call.\\n\\n\\n      values = output; // Next or done.\\n\\n      if (fn) {\\n        wrap(fn, next)(...output);\\n      } else {\\n        callback(null, ...output);\\n      }\\n    }\\n  }\\n  /** @type {Use} */\\n\\n\\n  function use(middelware) {\\n    if (typeof middelware !== 'function') {\\n      throw new TypeError('Expected `middelware` to be a function, not ' + middelware);\\n    }\\n\\n    fns.push(middelware);\\n    return pipeline;\\n  }\\n}\\n/**\\n * Wrap `middleware`.\\n * Can be sync or async; return a promise, receive a callback, or return new\\n * values and errors.\\n *\\n * @param {Middleware} middleware\\n * @param {Callback} callback\\n */\\n\\n\\nfunction wrap(middleware, callback) {\\n  /** @type {boolean} */\\n  let called;\\n  return wrapped;\\n  /**\\n   * Call `middleware`.\\n   * @this {any}\\n   * @param {Array<any>} parameters\\n   * @returns {void}\\n   */\\n\\n  function wrapped(...parameters) {\\n    const fnExpectsCallback = middleware.length > parameters.length;\\n    /** @type {any} */\\n\\n    let result;\\n\\n    if (fnExpectsCallback) {\\n      parameters.push(done);\\n    }\\n\\n    try {\\n      result = middleware.apply(this, parameters);\\n    } catch (error) {\\n      const exception = error; // Well, this is quite the pickle.\\n      // `middleware` received a callback and called it synchronously, but that\\n      // threw an error.\\n      // The only thing left to do is to throw the thing instead.\\n\\n      if (fnExpectsCallback && called) {\\n        throw exception;\\n      }\\n\\n      return done(exception);\\n    }\\n\\n    if (!fnExpectsCallback) {\\n      if (result instanceof Promise) {\\n        result.then(then, done);\\n      } else if (result instanceof Error) {\\n        done(result);\\n      } else {\\n        then(result);\\n      }\\n    }\\n  }\\n  /**\\n   * Call `callback`, only once.\\n   * @type {Callback}\\n   */\\n\\n\\n  function done(error, ...output) {\\n    if (!called) {\\n      called = true;\\n      callback(error, ...output);\\n    }\\n  }\\n  /**\\n   * Call `done` with one value.\\n   *\\n   * @param {any} [value]\\n   */\\n\\n\\n  function then(value) {\\n    done(null, value);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"wrap\",\"middleware\",\"callback\",\"done\",\"error\",\"output\",\"called\",\"then\",\"value\",\"wrapped\",\"parameters\",\"fnExpectsCallback\",\"length\",\"result\",\"push\",\"apply\",\"Promise\",\"Error\",\"Object\",\"defineProperty\",\"trough\",\"fns\",\"pipeline\",\"run\",\"values\",\"next\",\"fn\",\"middlewareIndex\",\"index\",\"undefined\",\"pop\",\"TypeError\",\"use\",\"middelware\"]\n}\n"]