["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-core-commonmark/lib/code-indented.js"],"~:js","shadow$provide.module$node_modules$micromark_core_commonmark$lib$code_indented=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.codeIndented=void 0;var _micromarkFactorySpace=require(\"module$node_modules$micromark_factory_space$index\"),_micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\");exports.codeIndented={name:\"codeIndented\",tokenize:function(effects,ok,nok){function afterStartPrefix(code){const tail=self.events[self.events.length-\n1];return tail&&\"linePrefix\"===tail[1].type&&4<=tail[2].sliceSerialize(tail[1],!0).length?afterPrefix(code):nok(code)}function afterPrefix(code){if(null===code)return after(code);if((0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.attempt(indentedContent,afterPrefix,after)(code);effects.enter(\"codeFlowValue\");return content(code)}function content(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.exit(\"codeFlowValue\"),afterPrefix(code);effects.consume(code);\nreturn content}function after(code){effects.exit(\"codeIndented\");return ok(code)}const self=this;return function(code){effects.enter(\"codeIndented\");return(0,_micromarkFactorySpace.factorySpace)(effects,afterStartPrefix,\"linePrefix\",5)(code)}}};const indentedContent={tokenize:function(effects,ok,nok){function start(code){return self.parser.lazy[self.now().line]?nok(code):(0,_micromarkUtilCharacter.markdownLineEnding)(code)?(effects.enter(\"lineEnding\"),effects.consume(code),effects.exit(\"lineEnding\"),\nstart):(0,_micromarkFactorySpace.factorySpace)(effects,afterPrefix,\"linePrefix\",5)(code)}function afterPrefix(code){const tail=self.events[self.events.length-1];return tail&&\"linePrefix\"===tail[1].type&&4<=tail[2].sliceSerialize(tail[1],!0).length?ok(code):(0,_micromarkUtilCharacter.markdownLineEnding)(code)?start(code):nok(code)}const self=this;return start},partial:!0}}","~:source","shadow$provide[\"module$node_modules$micromark_core_commonmark$lib$code_indented\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.codeIndented = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\n\n/** @type {Construct} */\nconst codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented\n};\n/** @type {Construct} */\n\nexports.codeIndented = codeIndented;\nconst indentedContent = {\n  tokenize: tokenizeIndentedContent,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeIndented');\n    return (0, _micromarkFactorySpace.factorySpace)(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code);\n  }\n  /** @type {State} */\n\n\n  function afterStartPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code) : nok(code);\n  }\n  /** @type {State} */\n\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return after(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return effects.attempt(indentedContent, afterPrefix, after)(code);\n    }\n\n    effects.enter('codeFlowValue');\n    return content(code);\n  }\n  /** @type {State} */\n\n\n  function content(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('codeFlowValue');\n      return afterPrefix(code);\n    }\n\n    effects.consume(code);\n    return content;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    effects.exit('codeIndented');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeIndentedContent(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // If this is a lazy line, it canâ€™t be code.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return start;\n    }\n\n    return (0, _micromarkFactorySpace.factorySpace)(effects, afterPrefix, 'linePrefix', 4 + 1)(code);\n  }\n  /** @type {State} */\n\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok(code) : (0, _micromarkUtilCharacter.markdownLineEnding)(code) ? start(code) : nok(code);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js","~$module$node_modules$micromark_factory_space$index"]],"~:properties",["^5",["partial","tokenize","__esModule","name","value","codeIndented"]],"~:compiled-at",1676665867281,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_core_commonmark$lib$code_indented.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAA,+DAAA,CAAoF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG5HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,YAAR,CAAuB,IAAK,EAE5B,KAAIC,uBAAyBP,OAAA,CAAQ,mDAAR,CAA7B,CAEIQ,wBAA0BR,OAAA,CAAQ,oDAAR,CAiB9BE,QAAQI,CAAAA,YAAR,CANqBA,CACnBG,KAAM,cADaH,CAEnBI,SAWFC,QAA6B,CAACC,OAAD,CAAUC,EAAV,CAAcC,GAAd,CAAmB,CAY9CC,QAASA,iBAAgB,CAACC,IAAD,CAAO,CAC9B,MAAMC,KAAOC,IAAKC,CAAAA,MAAL,CAAYD,IAAKC,CAAAA,MAAOC,CAAAA,MAAxB;AAAiC,CAAjC,CACb,OAAOH,KAAA,EAAyB,YAAzB,GAAQA,IAAA,CAAK,CAAL,CAAQI,CAAAA,IAAhB,EAAyF,CAAzF,EAAyCJ,IAAA,CAAK,CAAL,CAAQK,CAAAA,cAAR,CAAuBL,IAAA,CAAK,CAAL,CAAvB,CAAgC,CAAA,CAAhC,CAAsCG,CAAAA,MAA/E,CAA6FG,WAAA,CAAYP,IAAZ,CAA7F,CAAiHF,GAAA,CAAIE,IAAJ,CAF1F,CAOhCO,QAASA,YAAW,CAACP,IAAD,CAAO,CACzB,GAAa,IAAb,GAAIA,IAAJ,CACE,MAAOQ,MAAA,CAAMR,IAAN,CAGT,IAAI,GAAIR,uBAAwBiB,CAAAA,kBAA5B,EAAgDT,IAAhD,CAAJ,CACE,MAAOJ,QAAQc,CAAAA,OAAR,CAAgBC,eAAhB,CAAiCJ,WAAjC,CAA8CC,KAA9C,CAAA,CAAqDR,IAArD,CAGTJ,QAAQgB,CAAAA,KAAR,CAAc,eAAd,CACA,OAAOC,QAAA,CAAQb,IAAR,CAVkB,CAe3Ba,QAASA,QAAO,CAACb,IAAD,CAAO,CACrB,GAAa,IAAb,GAAIA,IAAJ,EAAqB,GAAIR,uBAAwBiB,CAAAA,kBAA5B,EAAgDT,IAAhD,CAArB,CAEE,MADAJ,QAAQkB,CAAAA,IAAR,CAAa,eAAb,CACO,CAAAP,WAAA,CAAYP,IAAZ,CAGTJ,QAAQmB,CAAAA,OAAR,CAAgBf,IAAhB,CACA;MAAOa,QAPc,CAYvBL,QAASA,MAAK,CAACR,IAAD,CAAO,CACnBJ,OAAQkB,CAAAA,IAAR,CAAa,cAAb,CACA,OAAOjB,GAAA,CAAGG,IAAH,CAFY,CA7CrB,MAAME,KAAO,IACb,OAGAc,SAAc,CAAChB,IAAD,CAAO,CACnBJ,OAAQgB,CAAAA,KAAR,CAAc,cAAd,CACA,OAAO,GAAIrB,sBAAuB0B,CAAAA,YAA3B,EAAyCrB,OAAzC,CAAkDG,gBAAlD,CAAoE,YAApE,CAAkF,CAAlF,CAAA,CAAyFC,IAAzF,CAFY,CALyB,CAb3BV,CAOrB,OAAMqB,gBAAkB,CACtBjB,SA2DFwB,QAAgC,CAACtB,OAAD,CAAUC,EAAV,CAAcC,GAAd,CAAmB,CAKjDkB,QAASA,MAAK,CAAChB,IAAD,CAAO,CAEnB,MAAIE,KAAKiB,CAAAA,MAAOC,CAAAA,IAAZ,CAAiBlB,IAAKmB,CAAAA,GAAL,EAAWC,CAAAA,IAA5B,CAAJ,CACSxB,GAAA,CAAIE,IAAJ,CADT,CAII,GAAIR,uBAAwBiB,CAAAA,kBAA5B,EAAgDT,IAAhD,CAAJ,EACEJ,OAAQgB,CAAAA,KAAR,CAAc,YAAd,CAGOI,CAFPpB,OAAQmB,CAAAA,OAAR,CAAgBf,IAAhB,CAEOgB,CADPpB,OAAQkB,CAAAA,IAAR,CAAa,YAAb,CACOE;AAAAA,KAJT,EAOO,GAAIzB,sBAAuB0B,CAAAA,YAA3B,EAAyCrB,OAAzC,CAAkDW,WAAlD,CAA+D,YAA/D,CAA6E,CAA7E,CAAA,CAAoFP,IAApF,CAbY,CAkBrBO,QAASA,YAAW,CAACP,IAAD,CAAO,CACzB,MAAMC,KAAOC,IAAKC,CAAAA,MAAL,CAAYD,IAAKC,CAAAA,MAAOC,CAAAA,MAAxB,CAAiC,CAAjC,CACb,OAAOH,KAAA,EAAyB,YAAzB,GAAQA,IAAA,CAAK,CAAL,CAAQI,CAAAA,IAAhB,EAAyF,CAAzF,EAAyCJ,IAAA,CAAK,CAAL,CAAQK,CAAAA,cAAR,CAAuBL,IAAA,CAAK,CAAL,CAAvB,CAAgC,CAAA,CAAhC,CAAsCG,CAAAA,MAA/E,CAA6FP,EAAA,CAAGG,IAAH,CAA7F,CAAwG,GAAIR,uBAAwBiB,CAAAA,kBAA5B,EAAgDT,IAAhD,CAAA,CAAwDgB,KAAA,CAAMhB,IAAN,CAAxD,CAAsEF,GAAA,CAAIE,IAAJ,CAF5J,CAtB3B,MAAME,KAAO,IACb,OAAOc,MAF0C,CA5D3B,CAEtBO,QAAS,CAAA,CAFa,CA5BoG;\",\n\"sources\":[\"node_modules/micromark-core-commonmark/lib/code-indented.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_core_commonmark$lib$code_indented\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.codeIndented = void 0;\\n\\nvar _micromarkFactorySpace = require(\\\"micromark-factory-space\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').Resolver} Resolver\\n * @typedef {import('micromark-util-types').Token} Token\\n * @typedef {import('micromark-util-types').State} State\\n */\\n\\n/** @type {Construct} */\\nconst codeIndented = {\\n  name: 'codeIndented',\\n  tokenize: tokenizeCodeIndented\\n};\\n/** @type {Construct} */\\n\\nexports.codeIndented = codeIndented;\\nconst indentedContent = {\\n  tokenize: tokenizeIndentedContent,\\n  partial: true\\n};\\n/** @type {Tokenizer} */\\n\\nfunction tokenizeCodeIndented(effects, ok, nok) {\\n  const self = this;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('codeIndented');\\n    return (0, _micromarkFactorySpace.factorySpace)(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function afterStartPrefix(code) {\\n    const tail = self.events[self.events.length - 1];\\n    return tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code) : nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function afterPrefix(code) {\\n    if (code === null) {\\n      return after(code);\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      return effects.attempt(indentedContent, afterPrefix, after)(code);\\n    }\\n\\n    effects.enter('codeFlowValue');\\n    return content(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function content(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.exit('codeFlowValue');\\n      return afterPrefix(code);\\n    }\\n\\n    effects.consume(code);\\n    return content;\\n  }\\n  /** @type {State} */\\n\\n\\n  function after(code) {\\n    effects.exit('codeIndented');\\n    return ok(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeIndentedContent(effects, ok, nok) {\\n  const self = this;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    // If this is a lazy line, it can\\u2019t be code.\\n    if (self.parser.lazy[self.now().line]) {\\n      return nok(code);\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.enter('lineEnding');\\n      effects.consume(code);\\n      effects.exit('lineEnding');\\n      return start;\\n    }\\n\\n    return (0, _micromarkFactorySpace.factorySpace)(effects, afterPrefix, 'linePrefix', 4 + 1)(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function afterPrefix(code) {\\n    const tail = self.events[self.events.length - 1];\\n    return tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok(code) : (0, _micromarkUtilCharacter.markdownLineEnding)(code) ? start(code) : nok(code);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"codeIndented\",\"_micromarkFactorySpace\",\"_micromarkUtilCharacter\",\"name\",\"tokenize\",\"tokenizeCodeIndented\",\"effects\",\"ok\",\"nok\",\"afterStartPrefix\",\"code\",\"tail\",\"self\",\"events\",\"length\",\"type\",\"sliceSerialize\",\"afterPrefix\",\"after\",\"markdownLineEnding\",\"attempt\",\"indentedContent\",\"enter\",\"content\",\"exit\",\"consume\",\"start\",\"factorySpace\",\"tokenizeIndentedContent\",\"parser\",\"lazy\",\"now\",\"line\",\"partial\"]\n}\n"]