["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/unified/lib/index.js"],"~:js","shadow$provide.module$node_modules$unified$lib$index=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function base(){function processor(){const destination=base();let index=-1;for(;++index<attachers.length;)destination.use(...attachers[index]);destination.data((0,_extend.default)(!0,{},namespace));return destination}const transformers=(0,_trough.trough)(),attachers=[];let namespace={},frozen,freezeIndex=-1;processor.data=function(key,\nvalue){return\"string\"===typeof key?2===arguments.length?(assertUnfrozen(\"data\",frozen),namespace[key]=value,processor):own.call(namespace,key)&&namespace[key]||null:key?(assertUnfrozen(\"data\",frozen),namespace=key,processor):namespace};processor.Parser=void 0;processor.Compiler=void 0;processor.freeze=function(){if(frozen)return processor;for(;++freezeIndex<attachers.length;){const [attacher,...options]=attachers[freezeIndex];if(!1===options[0])continue;!0===options[0]&&(options[0]=void 0);const transformer=\nattacher.call(processor,...options);\"function\"===typeof transformer&&transformers.use(transformer)}frozen=!0;freezeIndex=Number.POSITIVE_INFINITY;return processor};processor.attachers=attachers;processor.use=function(value$jscomp$0,...options$jscomp$0){function addPreset(result){addList(result.plugins);result.settings&&(settings=Object.assign(settings||{},result.settings))}function addList(plugins){let index=-1;if(null!==plugins&&void 0!==plugins)if(Array.isArray(plugins))for(;++index<plugins.length;){var value=\nplugins[index];if(\"function\"===typeof value)addPlugin(value);else if(\"object\"===typeof value)if(Array.isArray(value)){const [plugin,...options]=value;addPlugin(plugin,...options)}else addPreset(value);else throw new TypeError(\"Expected usable value, not `\"+value+\"`\");}else throw new TypeError(\"Expected a list of plugins, not `\"+plugins+\"`\");}function addPlugin(plugin,value){let index=-1,entry;for(;++index<attachers.length;)if(attachers[index][0]===plugin){entry=attachers[index];break}entry?((0,_isPlainObj.default)(entry[1])&&\n(0,_isPlainObj.default)(value)&&(value=(0,_extend.default)(!0,entry[1],value)),entry[1]=value):attachers.push([...arguments])}let settings;assertUnfrozen(\"use\",frozen);if(null!==value$jscomp$0&&void 0!==value$jscomp$0)if(\"function\"===typeof value$jscomp$0)addPlugin(value$jscomp$0,...options$jscomp$0);else if(\"object\"===typeof value$jscomp$0)Array.isArray(value$jscomp$0)?addList(value$jscomp$0):addPreset(value$jscomp$0);else throw new TypeError(\"Expected usable value, not `\"+value$jscomp$0+\"`\");settings&&\n(namespace.settings=Object.assign(namespace.settings||{},settings));return processor};processor.parse=function(doc){processor.freeze();doc=vfile(doc);const Parser=processor.Parser;assertParser(\"parse\",Parser);return newable(Parser,\"parse\")?(new Parser(String(doc),doc)).parse():Parser(String(doc),doc)};processor.stringify=function(node,doc){processor.freeze();doc=vfile(doc);const Compiler=processor.Compiler;assertCompiler(\"stringify\",Compiler);assertNode(node);return newable(Compiler,\"compile\")?(new Compiler(node,\ndoc)).compile():Compiler(node,doc)};processor.run=function(node,doc,callback){function executor(resolve,reject){transformers.run(node,vfile(doc),function(error,tree,file){tree=tree||node;error?reject(error):resolve?resolve(tree):callback(null,tree,file)})}assertNode(node);processor.freeze();callback||\"function\"!==typeof doc||(callback=doc,doc=void 0);if(!callback)return new Promise(executor);executor(null,callback)};processor.runSync=function(node,file){let result,complete;processor.run(node,file,\nfunction(error,tree){(0,_bail.bail)(error);result=tree;complete=!0});assertDone(\"runSync\",\"run\",complete);return result};processor.process=function(doc,callback){function executor(resolve,reject){const file$jscomp$0=vfile(doc);processor.run(processor.parse(file$jscomp$0),file$jscomp$0,(error,tree,file)=>{!error&&tree&&file?(tree=processor.stringify(tree,file),void 0!==tree&&null!==tree&&(\"string\"===typeof tree||(0,_isBuffer.default)(tree)?file.value=tree:file.result=tree),error||!file?reject(error):\nresolve?resolve(file):callback(null,file)):reject(error)})}processor.freeze();assertParser(\"process\",processor.Parser);assertCompiler(\"process\",processor.Compiler);if(!callback)return new Promise(executor);executor(null,callback)};processor.processSync=function(doc){let complete;processor.freeze();assertParser(\"processSync\",processor.Parser);assertCompiler(\"processSync\",processor.Compiler);doc=vfile(doc);processor.process(doc,function(error){complete=!0;(0,_bail.bail)(error)});assertDone(\"processSync\",\n\"process\",complete);return doc};return processor}function newable(value,name){var JSCompiler_temp;if(JSCompiler_temp=\"function\"===typeof value&&value.prototype){a:{JSCompiler_temp=value.prototype;for(JSCompiler_inline_result in JSCompiler_temp)if(own.call(JSCompiler_temp,JSCompiler_inline_result)){var JSCompiler_inline_result=!0;break a}JSCompiler_inline_result=!1}JSCompiler_temp=JSCompiler_inline_result||name in value.prototype}return JSCompiler_temp}function assertParser(name,value){if(\"function\"!==\ntypeof value)throw new TypeError(\"Cannot `\"+name+\"` without `Parser`\");}function assertCompiler(name,value){if(\"function\"!==typeof value)throw new TypeError(\"Cannot `\"+name+\"` without `Compiler`\");}function assertUnfrozen(name,frozen){if(frozen)throw Error(\"Cannot call `\"+name+\"` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.\");}function assertNode(node){if(!(0,_isPlainObj.default)(node)||\"string\"!==typeof node.type)throw new TypeError(\"Expected node, got `\"+\nnode+\"`\");}function assertDone(name,asyncName,complete){if(!complete)throw Error(\"`\"+name+\"` finished async. Use `\"+asyncName+\"` instead\");}function vfile(value){return value&&\"object\"===typeof value&&\"message\"in value&&\"messages\"in value?value:new _vfile.VFile(value)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.unified=void 0;var _bail=require(\"module$node_modules$bail$index\"),_isBuffer=_interopRequireDefault(require(\"module$node_modules$is_buffer$index\")),_extend=_interopRequireDefault(require(\"module$node_modules$extend$index\")),\n_isPlainObj=_interopRequireDefault(require(\"module$node_modules$is_plain_obj$index\")),_trough=require(\"module$node_modules$trough$index\"),_vfile=require(\"module$node_modules$vfile$index\");global=base().freeze();exports.unified=global;const own={}.hasOwnProperty}","~:source","shadow$provide[\"module$node_modules$unified$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unified = void 0;\n\nvar _bail = require(\"bail\");\n\nvar _isBuffer = _interopRequireDefault(require(\"is-buffer\"));\n\nvar _extend = _interopRequireDefault(require(\"extend\"));\n\nvar _isPlainObj = _interopRequireDefault(require(\"is-plain-obj\"));\n\nvar _trough = require(\"trough\");\n\nvar _vfile = require(\"vfile\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\n// Expose a frozen processor.\nconst unified = base().freeze();\nexports.unified = unified;\nconst own = {}.hasOwnProperty; // Function to create the first processor.\n\n/**\n * @returns {Processor}\n */\n\nfunction base() {\n  const transformers = (0, _trough.trough)();\n  /** @type {Processor['attachers']} */\n\n  const attachers = [];\n  /** @type {Record<string, unknown>} */\n\n  let namespace = {};\n  /** @type {boolean|undefined} */\n\n  let frozen;\n  let freezeIndex = -1; // Data management.\n  // @ts-expect-error: overloads are handled.\n\n  processor.data = data;\n  processor.Parser = undefined;\n  processor.Compiler = undefined; // Lock.\n\n  processor.freeze = freeze; // Plugins.\n\n  processor.attachers = attachers; // @ts-expect-error: overloads are handled.\n\n  processor.use = use; // API.\n\n  processor.parse = parse;\n  processor.stringify = stringify; // @ts-expect-error: overloads are handled.\n\n  processor.run = run;\n  processor.runSync = runSync; // @ts-expect-error: overloads are handled.\n\n  processor.process = process;\n  processor.processSync = processSync; // Expose.\n\n  return processor; // Create a new processor based on the processor in the current scope.\n\n  /** @type {Processor} */\n\n  function processor() {\n    const destination = base();\n    let index = -1;\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index]);\n    }\n\n    destination.data((0, _extend.default)(true, {}, namespace));\n    return destination;\n  }\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n\n\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen);\n        namespace[key] = value;\n        return processor;\n      } // Get `key`.\n\n\n      return own.call(namespace, key) && namespace[key] || null;\n    } // Set space.\n\n\n    if (key) {\n      assertUnfrozen('data', frozen);\n      namespace = key;\n      return processor;\n    } // Get space.\n\n\n    return namespace;\n  }\n  /** @type {Processor['freeze']} */\n\n\n  function freeze() {\n    if (frozen) {\n      return processor;\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex];\n\n      if (options[0] === false) {\n        continue;\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined;\n      }\n      /** @type {Transformer|void} */\n\n\n      const transformer = attacher.call(processor, ...options);\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer);\n      }\n    }\n\n    frozen = true;\n    freezeIndex = Number.POSITIVE_INFINITY;\n    return processor;\n  }\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n\n\n  function use(value, ...options) {\n    /** @type {Record<string, unknown>|undefined} */\n    let settings;\n    assertUnfrozen('use', frozen);\n\n    if (value === null || value === undefined) {// Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options);\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value);\n      } else {\n        addPreset(value);\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`');\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings);\n    }\n\n    return processor;\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value);\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value;\n          addPlugin(plugin, ...options);\n        } else {\n          addPreset(value);\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`');\n      }\n    }\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n\n\n    function addPreset(result) {\n      addList(result.plugins);\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings);\n      }\n    }\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n\n\n    function addList(plugins) {\n      let index = -1;\n\n      if (plugins === null || plugins === undefined) {// Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index];\n          add(thing);\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`');\n      }\n    }\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n\n\n    function addPlugin(plugin, value) {\n      let index = -1;\n      /** @type {Processor['attachers'][number]|undefined} */\n\n      let entry;\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index];\n          break;\n        }\n      }\n\n      if (entry) {\n        if ((0, _isPlainObj.default)(entry[1]) && (0, _isPlainObj.default)(value)) {\n          value = (0, _extend.default)(true, entry[1], value);\n        }\n\n        entry[1] = value;\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments]);\n      }\n    }\n  }\n  /** @type {Processor['parse']} */\n\n\n  function parse(doc) {\n    processor.freeze();\n    const file = vfile(doc);\n    const Parser = processor.Parser;\n    assertParser('parse', Parser);\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse();\n    } // @ts-expect-error: `newable` checks this.\n\n\n    return Parser(String(file), file); // eslint-disable-line new-cap\n  }\n  /** @type {Processor['stringify']} */\n\n\n  function stringify(node, doc) {\n    processor.freeze();\n    const file = vfile(doc);\n    const Compiler = processor.Compiler;\n    assertCompiler('stringify', Compiler);\n    assertNode(node);\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile();\n    } // @ts-expect-error: `newable` checks this.\n\n\n    return Compiler(node, file); // eslint-disable-line new-cap\n  }\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n\n\n  function run(node, doc, callback) {\n    assertNode(node);\n    processor.freeze();\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc;\n      doc = undefined;\n    }\n\n    if (!callback) {\n      return new Promise(executor);\n    }\n\n    executor(null, callback);\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` canâ€™t be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done);\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n\n      function done(error, tree, file) {\n        tree = tree || node;\n\n        if (error) {\n          reject(error);\n        } else if (resolve) {\n          resolve(tree);\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file);\n        }\n      }\n    }\n  }\n  /** @type {Processor['runSync']} */\n\n\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result;\n    /** @type {boolean|undefined} */\n\n    let complete;\n    processor.run(node, file, done);\n    assertDone('runSync', 'run', complete); // @ts-expect-error: we either bailed on an error or have a tree.\n\n    return result;\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n\n    function done(error, tree) {\n      (0, _bail.bail)(error);\n      result = tree;\n      complete = true;\n    }\n  }\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n\n\n  function process(doc, callback) {\n    processor.freeze();\n    assertParser('process', processor.Parser);\n    assertCompiler('process', processor.Compiler);\n\n    if (!callback) {\n      return new Promise(executor);\n    }\n\n    executor(null, callback);\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n\n    function executor(resolve, reject) {\n      const file = vfile(doc);\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error);\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file);\n\n          if (result === undefined || result === null) {// Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result;\n          } else {\n            file.result = result;\n          }\n\n          done(error, file);\n        }\n      });\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n\n      function done(error, file) {\n        if (error || !file) {\n          reject(error);\n        } else if (resolve) {\n          resolve(file);\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file);\n        }\n      }\n    }\n  }\n  /** @type {Processor['processSync']} */\n\n\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete;\n    processor.freeze();\n    assertParser('processSync', processor.Parser);\n    assertCompiler('processSync', processor.Compiler);\n    const file = vfile(doc);\n    processor.process(file, done);\n    assertDone('processSync', 'process', complete);\n    return file;\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n\n    function done(error) {\n      complete = true;\n      (0, _bail.bail)(error);\n    }\n  }\n}\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\n\n\nfunction newable(value, name) {\n  return typeof value === 'function' && // Prototypes do exist.\n  // type-coverage:ignore-next-line\n  value.prototype && (keys(value.prototype) || name in value.prototype);\n}\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\n\n\nfunction keys(value) {\n  /** @type {string} */\n  let key;\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\n\n\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`');\n  }\n}\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\n\n\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`');\n  }\n}\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\n\n\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error('Cannot call `' + name + '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.');\n  }\n}\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\n\n\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!(0, _isPlainObj.default)(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`'); // Fine.\n  }\n}\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\n\n\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');\n  }\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\n\n\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new _vfile.VFile(value);\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\n\n\nfunction looksLikeAVFile(value) {\n  return Boolean(value && typeof value === 'object' && 'message' in value && 'messages' in value);\n}\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\n\n\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || (0, _isBuffer.default)(value);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$bail$index","~$module$node_modules$extend$index","~$shadow.js","~$module$node_modules$is_buffer$index","~$module$node_modules$vfile$index","~$module$node_modules$is_plain_obj$index","~$module$node_modules$trough$index"]],"~:properties",["^5",["freeze","settings","process","__esModule","run","Parser","value","runSync","unified","stringify","parse","use","data","default","processSync","result","attachers","Compiler"]],"~:compiled-at",1676665867249,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$unified$lib$index.js\",\n\"lineCount\":13,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/unified/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$unified$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.unified = void 0;\\n\\nvar _bail = require(\\\"bail\\\");\\n\\nvar _isBuffer = _interopRequireDefault(require(\\\"is-buffer\\\"));\\n\\nvar _extend = _interopRequireDefault(require(\\\"extend\\\"));\\n\\nvar _isPlainObj = _interopRequireDefault(require(\\\"is-plain-obj\\\"));\\n\\nvar _trough = require(\\\"trough\\\");\\n\\nvar _vfile = require(\\\"vfile\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n/**\\n * @typedef {import('unist').Node} Node\\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\\n * @typedef {import('vfile').VFileValue} VFileValue\\n * @typedef {import('..').Processor} Processor\\n * @typedef {import('..').Plugin} Plugin\\n * @typedef {import('..').Preset} Preset\\n * @typedef {import('..').Pluggable} Pluggable\\n * @typedef {import('..').PluggableList} PluggableList\\n * @typedef {import('..').Transformer} Transformer\\n * @typedef {import('..').Parser} Parser\\n * @typedef {import('..').Compiler} Compiler\\n * @typedef {import('..').RunCallback} RunCallback\\n * @typedef {import('..').ProcessCallback} ProcessCallback\\n *\\n * @typedef Context\\n * @property {Node} tree\\n * @property {VFile} file\\n */\\n// Expose a frozen processor.\\nconst unified = base().freeze();\\nexports.unified = unified;\\nconst own = {}.hasOwnProperty; // Function to create the first processor.\\n\\n/**\\n * @returns {Processor}\\n */\\n\\nfunction base() {\\n  const transformers = (0, _trough.trough)();\\n  /** @type {Processor['attachers']} */\\n\\n  const attachers = [];\\n  /** @type {Record<string, unknown>} */\\n\\n  let namespace = {};\\n  /** @type {boolean|undefined} */\\n\\n  let frozen;\\n  let freezeIndex = -1; // Data management.\\n  // @ts-expect-error: overloads are handled.\\n\\n  processor.data = data;\\n  processor.Parser = undefined;\\n  processor.Compiler = undefined; // Lock.\\n\\n  processor.freeze = freeze; // Plugins.\\n\\n  processor.attachers = attachers; // @ts-expect-error: overloads are handled.\\n\\n  processor.use = use; // API.\\n\\n  processor.parse = parse;\\n  processor.stringify = stringify; // @ts-expect-error: overloads are handled.\\n\\n  processor.run = run;\\n  processor.runSync = runSync; // @ts-expect-error: overloads are handled.\\n\\n  processor.process = process;\\n  processor.processSync = processSync; // Expose.\\n\\n  return processor; // Create a new processor based on the processor in the current scope.\\n\\n  /** @type {Processor} */\\n\\n  function processor() {\\n    const destination = base();\\n    let index = -1;\\n\\n    while (++index < attachers.length) {\\n      destination.use(...attachers[index]);\\n    }\\n\\n    destination.data((0, _extend.default)(true, {}, namespace));\\n    return destination;\\n  }\\n  /**\\n   * @param {string|Record<string, unknown>} [key]\\n   * @param {unknown} [value]\\n   * @returns {unknown}\\n   */\\n\\n\\n  function data(key, value) {\\n    if (typeof key === 'string') {\\n      // Set `key`.\\n      if (arguments.length === 2) {\\n        assertUnfrozen('data', frozen);\\n        namespace[key] = value;\\n        return processor;\\n      } // Get `key`.\\n\\n\\n      return own.call(namespace, key) && namespace[key] || null;\\n    } // Set space.\\n\\n\\n    if (key) {\\n      assertUnfrozen('data', frozen);\\n      namespace = key;\\n      return processor;\\n    } // Get space.\\n\\n\\n    return namespace;\\n  }\\n  /** @type {Processor['freeze']} */\\n\\n\\n  function freeze() {\\n    if (frozen) {\\n      return processor;\\n    }\\n\\n    while (++freezeIndex < attachers.length) {\\n      const [attacher, ...options] = attachers[freezeIndex];\\n\\n      if (options[0] === false) {\\n        continue;\\n      }\\n\\n      if (options[0] === true) {\\n        options[0] = undefined;\\n      }\\n      /** @type {Transformer|void} */\\n\\n\\n      const transformer = attacher.call(processor, ...options);\\n\\n      if (typeof transformer === 'function') {\\n        transformers.use(transformer);\\n      }\\n    }\\n\\n    frozen = true;\\n    freezeIndex = Number.POSITIVE_INFINITY;\\n    return processor;\\n  }\\n  /**\\n   * @param {Pluggable|null|undefined} [value]\\n   * @param {...unknown} options\\n   * @returns {Processor}\\n   */\\n\\n\\n  function use(value, ...options) {\\n    /** @type {Record<string, unknown>|undefined} */\\n    let settings;\\n    assertUnfrozen('use', frozen);\\n\\n    if (value === null || value === undefined) {// Empty.\\n    } else if (typeof value === 'function') {\\n      addPlugin(value, ...options);\\n    } else if (typeof value === 'object') {\\n      if (Array.isArray(value)) {\\n        addList(value);\\n      } else {\\n        addPreset(value);\\n      }\\n    } else {\\n      throw new TypeError('Expected usable value, not `' + value + '`');\\n    }\\n\\n    if (settings) {\\n      namespace.settings = Object.assign(namespace.settings || {}, settings);\\n    }\\n\\n    return processor;\\n    /**\\n     * @param {import('..').Pluggable<unknown[]>} value\\n     * @returns {void}\\n     */\\n\\n    function add(value) {\\n      if (typeof value === 'function') {\\n        addPlugin(value);\\n      } else if (typeof value === 'object') {\\n        if (Array.isArray(value)) {\\n          const [plugin, ...options] = value;\\n          addPlugin(plugin, ...options);\\n        } else {\\n          addPreset(value);\\n        }\\n      } else {\\n        throw new TypeError('Expected usable value, not `' + value + '`');\\n      }\\n    }\\n    /**\\n     * @param {Preset} result\\n     * @returns {void}\\n     */\\n\\n\\n    function addPreset(result) {\\n      addList(result.plugins);\\n\\n      if (result.settings) {\\n        settings = Object.assign(settings || {}, result.settings);\\n      }\\n    }\\n    /**\\n     * @param {PluggableList|null|undefined} [plugins]\\n     * @returns {void}\\n     */\\n\\n\\n    function addList(plugins) {\\n      let index = -1;\\n\\n      if (plugins === null || plugins === undefined) {// Empty.\\n      } else if (Array.isArray(plugins)) {\\n        while (++index < plugins.length) {\\n          const thing = plugins[index];\\n          add(thing);\\n        }\\n      } else {\\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`');\\n      }\\n    }\\n    /**\\n     * @param {Plugin} plugin\\n     * @param {...unknown} [value]\\n     * @returns {void}\\n     */\\n\\n\\n    function addPlugin(plugin, value) {\\n      let index = -1;\\n      /** @type {Processor['attachers'][number]|undefined} */\\n\\n      let entry;\\n\\n      while (++index < attachers.length) {\\n        if (attachers[index][0] === plugin) {\\n          entry = attachers[index];\\n          break;\\n        }\\n      }\\n\\n      if (entry) {\\n        if ((0, _isPlainObj.default)(entry[1]) && (0, _isPlainObj.default)(value)) {\\n          value = (0, _extend.default)(true, entry[1], value);\\n        }\\n\\n        entry[1] = value;\\n      } else {\\n        // @ts-expect-error: fine.\\n        attachers.push([...arguments]);\\n      }\\n    }\\n  }\\n  /** @type {Processor['parse']} */\\n\\n\\n  function parse(doc) {\\n    processor.freeze();\\n    const file = vfile(doc);\\n    const Parser = processor.Parser;\\n    assertParser('parse', Parser);\\n\\n    if (newable(Parser, 'parse')) {\\n      // @ts-expect-error: `newable` checks this.\\n      return new Parser(String(file), file).parse();\\n    } // @ts-expect-error: `newable` checks this.\\n\\n\\n    return Parser(String(file), file); // eslint-disable-line new-cap\\n  }\\n  /** @type {Processor['stringify']} */\\n\\n\\n  function stringify(node, doc) {\\n    processor.freeze();\\n    const file = vfile(doc);\\n    const Compiler = processor.Compiler;\\n    assertCompiler('stringify', Compiler);\\n    assertNode(node);\\n\\n    if (newable(Compiler, 'compile')) {\\n      // @ts-expect-error: `newable` checks this.\\n      return new Compiler(node, file).compile();\\n    } // @ts-expect-error: `newable` checks this.\\n\\n\\n    return Compiler(node, file); // eslint-disable-line new-cap\\n  }\\n  /**\\n   * @param {Node} node\\n   * @param {VFileCompatible|RunCallback} [doc]\\n   * @param {RunCallback} [callback]\\n   * @returns {Promise<Node>|void}\\n   */\\n\\n\\n  function run(node, doc, callback) {\\n    assertNode(node);\\n    processor.freeze();\\n\\n    if (!callback && typeof doc === 'function') {\\n      callback = doc;\\n      doc = undefined;\\n    }\\n\\n    if (!callback) {\\n      return new Promise(executor);\\n    }\\n\\n    executor(null, callback);\\n    /**\\n     * @param {null|((node: Node) => void)} resolve\\n     * @param {(error: Error) => void} reject\\n     * @returns {void}\\n     */\\n\\n    function executor(resolve, reject) {\\n      // @ts-expect-error: `doc` can\\u2019t be a callback anymore, we checked.\\n      transformers.run(node, vfile(doc), done);\\n      /**\\n       * @param {Error|null} error\\n       * @param {Node} tree\\n       * @param {VFile} file\\n       * @returns {void}\\n       */\\n\\n      function done(error, tree, file) {\\n        tree = tree || node;\\n\\n        if (error) {\\n          reject(error);\\n        } else if (resolve) {\\n          resolve(tree);\\n        } else {\\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\\n          callback(null, tree, file);\\n        }\\n      }\\n    }\\n  }\\n  /** @type {Processor['runSync']} */\\n\\n\\n  function runSync(node, file) {\\n    /** @type {Node|undefined} */\\n    let result;\\n    /** @type {boolean|undefined} */\\n\\n    let complete;\\n    processor.run(node, file, done);\\n    assertDone('runSync', 'run', complete); // @ts-expect-error: we either bailed on an error or have a tree.\\n\\n    return result;\\n    /**\\n     * @param {Error|null} [error]\\n     * @param {Node} [tree]\\n     * @returns {void}\\n     */\\n\\n    function done(error, tree) {\\n      (0, _bail.bail)(error);\\n      result = tree;\\n      complete = true;\\n    }\\n  }\\n  /**\\n   * @param {VFileCompatible} doc\\n   * @param {ProcessCallback} [callback]\\n   * @returns {Promise<VFile>|undefined}\\n   */\\n\\n\\n  function process(doc, callback) {\\n    processor.freeze();\\n    assertParser('process', processor.Parser);\\n    assertCompiler('process', processor.Compiler);\\n\\n    if (!callback) {\\n      return new Promise(executor);\\n    }\\n\\n    executor(null, callback);\\n    /**\\n     * @param {null|((file: VFile) => void)} resolve\\n     * @param {(error?: Error|null|undefined) => void} reject\\n     * @returns {void}\\n     */\\n\\n    function executor(resolve, reject) {\\n      const file = vfile(doc);\\n      processor.run(processor.parse(file), file, (error, tree, file) => {\\n        if (error || !tree || !file) {\\n          done(error);\\n        } else {\\n          /** @type {unknown} */\\n          const result = processor.stringify(tree, file);\\n\\n          if (result === undefined || result === null) {// Empty.\\n          } else if (looksLikeAVFileValue(result)) {\\n            file.value = result;\\n          } else {\\n            file.result = result;\\n          }\\n\\n          done(error, file);\\n        }\\n      });\\n      /**\\n       * @param {Error|null|undefined} [error]\\n       * @param {VFile|undefined} [file]\\n       * @returns {void}\\n       */\\n\\n      function done(error, file) {\\n        if (error || !file) {\\n          reject(error);\\n        } else if (resolve) {\\n          resolve(file);\\n        } else {\\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\\n          callback(null, file);\\n        }\\n      }\\n    }\\n  }\\n  /** @type {Processor['processSync']} */\\n\\n\\n  function processSync(doc) {\\n    /** @type {boolean|undefined} */\\n    let complete;\\n    processor.freeze();\\n    assertParser('processSync', processor.Parser);\\n    assertCompiler('processSync', processor.Compiler);\\n    const file = vfile(doc);\\n    processor.process(file, done);\\n    assertDone('processSync', 'process', complete);\\n    return file;\\n    /**\\n     * @param {Error|null|undefined} [error]\\n     * @returns {void}\\n     */\\n\\n    function done(error) {\\n      complete = true;\\n      (0, _bail.bail)(error);\\n    }\\n  }\\n}\\n/**\\n * Check if `value` is a constructor.\\n *\\n * @param {unknown} value\\n * @param {string} name\\n * @returns {boolean}\\n */\\n\\n\\nfunction newable(value, name) {\\n  return typeof value === 'function' && // Prototypes do exist.\\n  // type-coverage:ignore-next-line\\n  value.prototype && (keys(value.prototype) || name in value.prototype);\\n}\\n/**\\n * Check if `value` is an object with keys.\\n *\\n * @param {Record<string, unknown>} value\\n * @returns {boolean}\\n */\\n\\n\\nfunction keys(value) {\\n  /** @type {string} */\\n  let key;\\n\\n  for (key in value) {\\n    if (own.call(value, key)) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n/**\\n * Assert a parser is available.\\n *\\n * @param {string} name\\n * @param {unknown} value\\n * @returns {asserts value is Parser}\\n */\\n\\n\\nfunction assertParser(name, value) {\\n  if (typeof value !== 'function') {\\n    throw new TypeError('Cannot `' + name + '` without `Parser`');\\n  }\\n}\\n/**\\n * Assert a compiler is available.\\n *\\n * @param {string} name\\n * @param {unknown} value\\n * @returns {asserts value is Compiler}\\n */\\n\\n\\nfunction assertCompiler(name, value) {\\n  if (typeof value !== 'function') {\\n    throw new TypeError('Cannot `' + name + '` without `Compiler`');\\n  }\\n}\\n/**\\n * Assert the processor is not frozen.\\n *\\n * @param {string} name\\n * @param {unknown} frozen\\n * @returns {asserts frozen is false}\\n */\\n\\n\\nfunction assertUnfrozen(name, frozen) {\\n  if (frozen) {\\n    throw new Error('Cannot call `' + name + '` on a frozen processor.\\\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.');\\n  }\\n}\\n/**\\n * Assert `node` is a unist node.\\n *\\n * @param {unknown} node\\n * @returns {asserts node is Node}\\n */\\n\\n\\nfunction assertNode(node) {\\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\\n  // type-coverage:ignore-next-line\\n  if (!(0, _isPlainObj.default)(node) || typeof node.type !== 'string') {\\n    throw new TypeError('Expected node, got `' + node + '`'); // Fine.\\n  }\\n}\\n/**\\n * Assert that `complete` is `true`.\\n *\\n * @param {string} name\\n * @param {string} asyncName\\n * @param {unknown} complete\\n * @returns {asserts complete is true}\\n */\\n\\n\\nfunction assertDone(name, asyncName, complete) {\\n  if (!complete) {\\n    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');\\n  }\\n}\\n/**\\n * @param {VFileCompatible} [value]\\n * @returns {VFile}\\n */\\n\\n\\nfunction vfile(value) {\\n  return looksLikeAVFile(value) ? value : new _vfile.VFile(value);\\n}\\n/**\\n * @param {VFileCompatible} [value]\\n * @returns {value is VFile}\\n */\\n\\n\\nfunction looksLikeAVFile(value) {\\n  return Boolean(value && typeof value === 'object' && 'message' in value && 'messages' in value);\\n}\\n/**\\n * @param {unknown} [value]\\n * @returns {value is VFileValue}\\n */\\n\\n\\nfunction looksLikeAVFileValue(value) {\\n  return typeof value === 'string' || (0, _isBuffer.default)(value);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"default\",\"base\",\"processor\",\"destination\",\"index\",\"attachers\",\"length\",\"use\",\"data\",\"_extend\",\"namespace\",\"transformers\",\"_trough\",\"trough\",\"frozen\",\"freezeIndex\",\"key\",\"value\",\"arguments\",\"assertUnfrozen\",\"own\",\"call\",\"Parser\",\"undefined\",\"Compiler\",\"freeze\",\"attacher\",\"options\",\"transformer\",\"Number\",\"POSITIVE_INFINITY\",\"addPreset\",\"result\",\"addList\",\"plugins\",\"settings\",\"Object\",\"assign\",\"Array\",\"isArray\",\"thing\",\"addPlugin\",\"plugin\",\"TypeError\",\"entry\",\"_isPlainObj\",\"push\",\"parse\",\"doc\",\"file\",\"vfile\",\"assertParser\",\"newable\",\"String\",\"stringify\",\"node\",\"assertCompiler\",\"assertNode\",\"compile\",\"run\",\"callback\",\"executor\",\"resolve\",\"reject\",\"done\",\"error\",\"tree\",\"Promise\",\"runSync\",\"complete\",\"_bail\",\"bail\",\"assertDone\",\"process\",\"_isBuffer\",\"processSync\",\"name\",\"Error\",\"type\",\"asyncName\",\"_vfile\",\"VFile\",\"defineProperty\",\"unified\",\"hasOwnProperty\"]\n}\n"]