["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-util-sanitize-uri/index.js"],"~:js","shadow$provide.module$node_modules$micromark_util_sanitize_uri$index=function(global,require,module,exports){function normalizeUri(value){const result=[];let index=-1,start=0,skip=0;for(;++index<value.length;){const code=value.charCodeAt(index);var replace=\"\";37===code&&(0,_micromarkUtilCharacter.asciiAlphanumeric)(value.charCodeAt(index+1))&&(0,_micromarkUtilCharacter.asciiAlphanumeric)(value.charCodeAt(index+2))?skip=2:128>code?/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))||(replace=String.fromCharCode(code)):\n55295<code&&57344>code?(replace=value.charCodeAt(index+1),56320>code&&56319<replace&&57344>replace?(replace=String.fromCharCode(code,replace),skip=1):replace=\"�\"):replace=String.fromCharCode(code);replace&&(result.push(value.slice(start,index),encodeURIComponent(replace)),start=index+skip+1);skip&&(index+=skip,skip=0)}return result.join(\"\")+value.slice(start)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.sanitizeUri=function(url,protocol){url=(0,_micromarkUtilEncode.encode)(normalizeUri(url||\n\"\"));if(!protocol)return url;const colon=url.indexOf(\":\"),questionMark=url.indexOf(\"?\"),numberSign=url.indexOf(\"#\"),slash=url.indexOf(\"/\");return 0>colon||-1<slash&&colon>slash||-1<questionMark&&colon>questionMark||-1<numberSign&&colon>numberSign||protocol.test(url.slice(0,colon))?url:\"\"};exports.normalizeUri=normalizeUri;var _micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\"),_micromarkUtilEncode=require(\"module$node_modules$micromark_util_encode$index\")}","~:source","shadow$provide[\"module$node_modules$micromark_util_sanitize_uri$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sanitizeUri = sanitizeUri;\nexports.normalizeUri = normalizeUri;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilEncode = require(\"micromark-util-encode\");\n\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri` below).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * Then, a regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`,\n * or `/^https?$/i` for `img[src]`.\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string|undefined} url\n * @param {RegExp} [protocol]\n * @returns {string}\n */\nfunction sanitizeUri(url, protocol) {\n  const value = (0, _micromarkUtilEncode.encode)(normalizeUri(url || ''));\n\n  if (!protocol) {\n    return value;\n  }\n\n  const colon = value.indexOf(':');\n  const questionMark = value.indexOf('?');\n  const numberSign = value.indexOf('#');\n  const slash = value.indexOf('/');\n\n  if ( // If there is no protocol, it’s relative.\n  colon < 0 || slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || // It is a protocol, it should be allowed.\n  protocol.test(value.slice(0, colon))) {\n    return value;\n  }\n\n  return '';\n}\n/**\n * Normalize a URL (such as used in definitions).\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n * @returns {string}\n */\n\n\nfunction normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = [];\n  let index = -1;\n  let start = 0;\n  let skip = 0;\n\n  while (++index < value.length) {\n    const code = value.charCodeAt(index);\n    /** @type {string} */\n\n    let replace = ''; // A correct percent encoded value.\n\n    if (code === 37 && (0, _micromarkUtilCharacter.asciiAlphanumeric)(value.charCodeAt(index + 1)) && (0, _micromarkUtilCharacter.asciiAlphanumeric)(value.charCodeAt(index + 2))) {\n      skip = 2;\n    } // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code);\n      }\n    } // Astral.\n    else if (code > 55295 && code < 57344) {\n      const next = value.charCodeAt(index + 1); // A correct surrogate pair.\n\n      if (code < 56320 && next > 56319 && next < 57344) {\n        replace = String.fromCharCode(code, next);\n        skip = 1;\n      } // Lone surrogate.\n      else {\n        replace = '\\uFFFD';\n      }\n    } // Unicode.\n    else {\n      replace = String.fromCharCode(code);\n    }\n\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace));\n      start = index + skip + 1;\n      replace = '';\n    }\n\n    if (skip) {\n      index += skip;\n      skip = 0;\n    }\n  }\n\n  return result.join('') + value.slice(start);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js","~$module$node_modules$micromark_util_encode$index"]],"~:properties",["^5",["__esModule","value","normalizeUri","sanitizeUri"]],"~:compiled-at",1676665867310,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_util_sanitize_uri$index.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-util-sanitize-uri/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_util_sanitize_uri$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.sanitizeUri = sanitizeUri;\\nexports.normalizeUri = normalizeUri;\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\nvar _micromarkUtilEncode = require(\\\"micromark-util-encode\\\");\\n\\n/**\\n * Make a value safe for injection as a URL.\\n *\\n * This encodes unsafe characters with percent-encoding and skips already\\n * encoded sequences (see `normalizeUri` below).\\n * Further unsafe characters are encoded as character references (see\\n * `micromark-util-encode`).\\n *\\n * Then, a regex of allowed protocols can be given, in which case the URL is\\n * sanitized.\\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`,\\n * or `/^https?$/i` for `img[src]`.\\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\\n * as a dangerous example, `javascript:`), the value is ignored.\\n *\\n * @param {string|undefined} url\\n * @param {RegExp} [protocol]\\n * @returns {string}\\n */\\nfunction sanitizeUri(url, protocol) {\\n  const value = (0, _micromarkUtilEncode.encode)(normalizeUri(url || ''));\\n\\n  if (!protocol) {\\n    return value;\\n  }\\n\\n  const colon = value.indexOf(':');\\n  const questionMark = value.indexOf('?');\\n  const numberSign = value.indexOf('#');\\n  const slash = value.indexOf('/');\\n\\n  if ( // If there is no protocol, it\\u2019s relative.\\n  colon < 0 || slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || // It is a protocol, it should be allowed.\\n  protocol.test(value.slice(0, colon))) {\\n    return value;\\n  }\\n\\n  return '';\\n}\\n/**\\n * Normalize a URL (such as used in definitions).\\n *\\n * Encode unsafe characters with percent-encoding, skipping already encoded\\n * sequences.\\n *\\n * @param {string} value\\n * @returns {string}\\n */\\n\\n\\nfunction normalizeUri(value) {\\n  /** @type {Array<string>} */\\n  const result = [];\\n  let index = -1;\\n  let start = 0;\\n  let skip = 0;\\n\\n  while (++index < value.length) {\\n    const code = value.charCodeAt(index);\\n    /** @type {string} */\\n\\n    let replace = ''; // A correct percent encoded value.\\n\\n    if (code === 37 && (0, _micromarkUtilCharacter.asciiAlphanumeric)(value.charCodeAt(index + 1)) && (0, _micromarkUtilCharacter.asciiAlphanumeric)(value.charCodeAt(index + 2))) {\\n      skip = 2;\\n    } // ASCII.\\n    else if (code < 128) {\\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\\n        replace = String.fromCharCode(code);\\n      }\\n    } // Astral.\\n    else if (code > 55295 && code < 57344) {\\n      const next = value.charCodeAt(index + 1); // A correct surrogate pair.\\n\\n      if (code < 56320 && next > 56319 && next < 57344) {\\n        replace = String.fromCharCode(code, next);\\n        skip = 1;\\n      } // Lone surrogate.\\n      else {\\n        replace = '\\\\uFFFD';\\n      }\\n    } // Unicode.\\n    else {\\n      replace = String.fromCharCode(code);\\n    }\\n\\n    if (replace) {\\n      result.push(value.slice(start, index), encodeURIComponent(replace));\\n      start = index + skip + 1;\\n      replace = '';\\n    }\\n\\n    if (skip) {\\n      index += skip;\\n      skip = 0;\\n    }\\n  }\\n\\n  return result.join('') + value.slice(start);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"normalizeUri\",\"value\",\"result\",\"index\",\"start\",\"skip\",\"length\",\"code\",\"charCodeAt\",\"replace\",\"_micromarkUtilCharacter\",\"asciiAlphanumeric\",\"test\",\"String\",\"fromCharCode\",\"next\",\"push\",\"slice\",\"encodeURIComponent\",\"join\",\"Object\",\"defineProperty\",\"sanitizeUri\",\"url\",\"protocol\",\"_micromarkUtilEncode\",\"encode\",\"colon\",\"indexOf\",\"questionMark\",\"numberSign\",\"slash\"]\n}\n"]