["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/elixir.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$elixir=function(global,require,module,exports){function elixir(Prism){Prism.languages.elixir={doc:{pattern:/@(?:doc|moduledoc)\\s+(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2)/,inside:{attribute:/^@\\w+/,string:/['\"][\\s\\S]+/}},comment:{pattern:/#.*/,greedy:!0},regex:{pattern:/~[rR](?:(\"\"\"|''')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1|([\\/|\"'])(?:\\\\.|(?!\\2)[^\\\\\\r\\n])+\\2|\\((?:\\\\.|[^\\\\)\\r\\n])+\\)|\\[(?:\\\\.|[^\\\\\\]\\r\\n])+\\]|\\{(?:\\\\.|[^\\\\}\\r\\n])+\\}|<(?:\\\\.|[^\\\\>\\r\\n])+>)[uismxfr]*/,\ngreedy:!0},string:[{pattern:/~[cCsSwW](?:(\"\"\"|''')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1|([\\/|\"'])(?:\\\\.|(?!\\2)[^\\\\\\r\\n])+\\2|\\((?:\\\\.|[^\\\\)\\r\\n])+\\)|\\[(?:\\\\.|[^\\\\\\]\\r\\n])+\\]|\\{(?:\\\\.|#\\{[^}]+\\}|#(?!\\{)|[^#\\\\}\\r\\n])+\\}|<(?:\\\\.|[^\\\\>\\r\\n])+>)[csa]?/,greedy:!0,inside:{}},{pattern:/(\"\"\"|''')[\\s\\S]*?\\1/,greedy:!0,inside:{}},{pattern:/(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,greedy:!0,inside:{}}],atom:{pattern:/(^|[^:]):\\w+/,lookbehind:!0,alias:\"symbol\"},module:{pattern:/\\b[A-Z]\\w*\\b/,alias:\"class-name\"},\"attr-name\":/\\b\\w+\\??:(?!:)/,\nargument:{pattern:/(^|[^&])&\\d+/,lookbehind:!0,alias:\"variable\"},attribute:{pattern:/@\\w+/,alias:\"variable\"},function:/\\b[_a-zA-Z]\\w*[?!]?(?:(?=\\s*(?:\\.\\s*)?\\()|(?=\\/\\d))/,number:/\\b(?:0[box][a-f\\d_]+|\\d[\\d_]*)(?:\\.[\\d_]+)?(?:e[+-]?[\\d_]+)?\\b/i,keyword:/\\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\\b/,boolean:/\\b(?:false|nil|true)\\b/,operator:[/\\bin\\b|&&?|\\|[|>]?|\\\\\\\\|::|\\.\\.\\.?|\\+\\+?|-[->]?|<[-=>]|>=|!==?|\\B!|=(?:==?|[>~])?|[*\\/^]/,\n{pattern:/([^<])<(?!<)/,lookbehind:!0},{pattern:/([^>])>(?!>)/,lookbehind:!0}],punctuation:/<<|>>|[.,%\\[\\]{}()]/};Prism.languages.elixir.string.forEach(function(o){o.inside={interpolation:{pattern:/#\\{[^}]+\\}/,inside:{delimiter:{pattern:/^#\\{|\\}$/,alias:\"punctuation\"},rest:Prism.languages.elixir}}}})}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=elixir;elixir.displayName=\"elixir\";elixir.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$elixir\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = elixir;\n// @ts-nocheck\nelixir.displayName = 'elixir';\nelixir.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction elixir(Prism) {\n  Prism.languages.elixir = {\n    doc: {\n      pattern: /@(?:doc|moduledoc)\\s+(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2)/,\n      inside: {\n        attribute: /^@\\w+/,\n        string: /['\"][\\s\\S]+/\n      }\n    },\n    comment: {\n      pattern: /#.*/,\n      greedy: true\n    },\n    // ~r\"\"\"foo\"\"\" (multi-line), ~r'''foo''' (multi-line), ~r/foo/, ~r|foo|, ~r\"foo\", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>\n    regex: {\n      pattern: /~[rR](?:(\"\"\"|''')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1|([\\/|\"'])(?:\\\\.|(?!\\2)[^\\\\\\r\\n])+\\2|\\((?:\\\\.|[^\\\\)\\r\\n])+\\)|\\[(?:\\\\.|[^\\\\\\]\\r\\n])+\\]|\\{(?:\\\\.|[^\\\\}\\r\\n])+\\}|<(?:\\\\.|[^\\\\>\\r\\n])+>)[uismxfr]*/,\n      greedy: true\n    },\n    string: [{\n      // ~s\"\"\"foo\"\"\" (multi-line), ~s'''foo''' (multi-line), ~s/foo/, ~s|foo|, ~s\"foo\", ~s'foo', ~s(foo), ~s[foo], ~s{foo} (with interpolation care), ~s<foo>\n      pattern: /~[cCsSwW](?:(\"\"\"|''')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1|([\\/|\"'])(?:\\\\.|(?!\\2)[^\\\\\\r\\n])+\\2|\\((?:\\\\.|[^\\\\)\\r\\n])+\\)|\\[(?:\\\\.|[^\\\\\\]\\r\\n])+\\]|\\{(?:\\\\.|#\\{[^}]+\\}|#(?!\\{)|[^#\\\\}\\r\\n])+\\}|<(?:\\\\.|[^\\\\>\\r\\n])+>)[csa]?/,\n      greedy: true,\n      inside: {// See interpolation below\n      }\n    }, {\n      pattern: /(\"\"\"|''')[\\s\\S]*?\\1/,\n      greedy: true,\n      inside: {// See interpolation below\n      }\n    }, {\n      // Multi-line strings are allowed\n      pattern: /(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n      greedy: true,\n      inside: {// See interpolation below\n      }\n    }],\n    atom: {\n      // Look-behind prevents bad highlighting of the :: operator\n      pattern: /(^|[^:]):\\w+/,\n      lookbehind: true,\n      alias: 'symbol'\n    },\n    module: {\n      pattern: /\\b[A-Z]\\w*\\b/,\n      alias: 'class-name'\n    },\n    // Look-ahead prevents bad highlighting of the :: operator\n    'attr-name': /\\b\\w+\\??:(?!:)/,\n    argument: {\n      // Look-behind prevents bad highlighting of the && operator\n      pattern: /(^|[^&])&\\d+/,\n      lookbehind: true,\n      alias: 'variable'\n    },\n    attribute: {\n      pattern: /@\\w+/,\n      alias: 'variable'\n    },\n    function: /\\b[_a-zA-Z]\\w*[?!]?(?:(?=\\s*(?:\\.\\s*)?\\()|(?=\\/\\d))/,\n    number: /\\b(?:0[box][a-f\\d_]+|\\d[\\d_]*)(?:\\.[\\d_]+)?(?:e[+-]?[\\d_]+)?\\b/i,\n    keyword: /\\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\\b/,\n    boolean: /\\b(?:false|nil|true)\\b/,\n    operator: [/\\bin\\b|&&?|\\|[|>]?|\\\\\\\\|::|\\.\\.\\.?|\\+\\+?|-[->]?|<[-=>]|>=|!==?|\\B!|=(?:==?|[>~])?|[*\\/^]/, {\n      // We don't want to match <<\n      pattern: /([^<])<(?!<)/,\n      lookbehind: true\n    }, {\n      // We don't want to match >>\n      pattern: /([^>])>(?!>)/,\n      lookbehind: true\n    }],\n    punctuation: /<<|>>|[.,%\\[\\]{}()]/\n  };\n  Prism.languages.elixir.string.forEach(function (o) {\n    o.inside = {\n      interpolation: {\n        pattern: /#\\{[^}]+\\}/,\n        inside: {\n          delimiter: {\n            pattern: /^#\\{|\\}$/,\n            alias: 'punctuation'\n          },\n          rest: Prism.languages.elixir\n        }\n      }\n    };\n  });\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["boolean","punctuation","string","aliases","operator","displayName","__esModule","attribute","regex","rest","lookbehind","value","elixir","atom","delimiter","keyword","number","greedy","function","pattern","argument","inside","alias","comment","interpolation","default","doc"]],"~:compiled-at",1676841365407,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$elixir.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAA,yCAAA,CAA8D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAYtGC,QAASA,OAAM,CAACC,KAAD,CAAQ,CACrBA,KAAMC,CAAAA,SAAUF,CAAAA,MAAhB,CAAyB,CACvBG,IAAK,CACHC,QAAS,4FADN,CAEHC,OAAQ,CACNC,UAAW,OADL,CAENC,OAAQ,aAFF,CAFL,CADkB,CAQvBC,QAAS,CACPJ,QAAS,KADF,CAEPK,OAAQ,CAAA,CAFD,CARc,CAavBC,MAAO,CACLN,QAAS,4LADJ;AAELK,OAAQ,CAAA,CAFH,CAbgB,CAiBvBF,OAAQ,CAAC,CAEPH,QAAS,gNAFF,CAGPK,OAAQ,CAAA,CAHD,CAIPJ,OAAQ,EAJD,CAAD,CAML,CACDD,QAAS,qBADR,CAEDK,OAAQ,CAAA,CAFP,CAGDJ,OAAQ,EAHP,CANK,CAWL,CAEDD,QAAS,+CAFR,CAGDK,OAAQ,CAAA,CAHP,CAIDJ,OAAQ,EAJP,CAXK,CAjBe,CAmCvBM,KAAM,CAEJP,QAAS,cAFL,CAGJQ,WAAY,CAAA,CAHR,CAIJC,MAAO,QAJH,CAnCiB,CAyCvBf,OAAQ,CACNM,QAAS,cADH,CAENS,MAAO,YAFD,CAzCe,CA8CvB,YAAa,gBA9CU;AA+CvBC,SAAU,CAERV,QAAS,cAFD,CAGRQ,WAAY,CAAA,CAHJ,CAIRC,MAAO,UAJC,CA/Ca,CAqDvBP,UAAW,CACTF,QAAS,MADA,CAETS,MAAO,UAFE,CArDY,CAyDvBE,SAAU,qDAzDa,CA0DvBC,OAAQ,iEA1De,CA2DvBC,QAAS,iNA3Dc,CA4DvBC,QAAS,wBA5Dc,CA6DvBC,SAAU,CAAC,0FAAD;AAA6F,CAErGf,QAAS,cAF4F,CAGrGQ,WAAY,CAAA,CAHyF,CAA7F,CAIP,CAEDR,QAAS,cAFR,CAGDQ,WAAY,CAAA,CAHX,CAJO,CA7Da,CAsEvBQ,YAAa,qBAtEU,CAwEzBnB,MAAMC,CAAAA,SAAUF,CAAAA,MAAOO,CAAAA,MAAOc,CAAAA,OAA9B,CAAsC,QAAS,CAACC,CAAD,CAAI,CACjDA,CAAEjB,CAAAA,MAAF,CAAW,CACTkB,cAAe,CACbnB,QAAS,YADI,CAEbC,OAAQ,CACNmB,UAAW,CACTpB,QAAS,UADA,CAETS,MAAO,aAFE,CADL,CAKNY,KAAMxB,KAAMC,CAAAA,SAAUF,CAAAA,MALhB,CAFK,CADN,CADsC,CAAnD,CAzEqB,CATvB0B,MAAOC,CAAAA,cAAP,CAAsB5B,OAAtB,CAA+B,YAA/B,CAA6C,CAC3C6B,MAAO,CAAA,CADoC,CAA7C,CAGA7B,QAAQ8B,CAAAA,OAAR,CAAkB7B,MAElBA,OAAO8B,CAAAA,WAAP,CAAqB,QACrB9B,OAAO+B,CAAAA,OAAP,CAAiB,EATqF;\",\n\"sources\":[\"node_modules/refractor/lang/elixir.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$elixir\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = elixir;\\n// @ts-nocheck\\nelixir.displayName = 'elixir';\\nelixir.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction elixir(Prism) {\\n  Prism.languages.elixir = {\\n    doc: {\\n      pattern: /@(?:doc|moduledoc)\\\\s+(?:(\\\"\\\"\\\"|''')[\\\\s\\\\S]*?\\\\1|(\\\"|')(?:\\\\\\\\(?:\\\\r\\\\n|[\\\\s\\\\S])|(?!\\\\2)[^\\\\\\\\\\\\r\\\\n])*\\\\2)/,\\n      inside: {\\n        attribute: /^@\\\\w+/,\\n        string: /['\\\"][\\\\s\\\\S]+/\\n      }\\n    },\\n    comment: {\\n      pattern: /#.*/,\\n      greedy: true\\n    },\\n    // ~r\\\"\\\"\\\"foo\\\"\\\"\\\" (multi-line), ~r'''foo''' (multi-line), ~r/foo/, ~r|foo|, ~r\\\"foo\\\", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>\\n    regex: {\\n      pattern: /~[rR](?:(\\\"\\\"\\\"|''')(?:\\\\\\\\[\\\\s\\\\S]|(?!\\\\1)[^\\\\\\\\])+\\\\1|([\\\\/|\\\"'])(?:\\\\\\\\.|(?!\\\\2)[^\\\\\\\\\\\\r\\\\n])+\\\\2|\\\\((?:\\\\\\\\.|[^\\\\\\\\)\\\\r\\\\n])+\\\\)|\\\\[(?:\\\\\\\\.|[^\\\\\\\\\\\\]\\\\r\\\\n])+\\\\]|\\\\{(?:\\\\\\\\.|[^\\\\\\\\}\\\\r\\\\n])+\\\\}|<(?:\\\\\\\\.|[^\\\\\\\\>\\\\r\\\\n])+>)[uismxfr]*/,\\n      greedy: true\\n    },\\n    string: [{\\n      // ~s\\\"\\\"\\\"foo\\\"\\\"\\\" (multi-line), ~s'''foo''' (multi-line), ~s/foo/, ~s|foo|, ~s\\\"foo\\\", ~s'foo', ~s(foo), ~s[foo], ~s{foo} (with interpolation care), ~s<foo>\\n      pattern: /~[cCsSwW](?:(\\\"\\\"\\\"|''')(?:\\\\\\\\[\\\\s\\\\S]|(?!\\\\1)[^\\\\\\\\])+\\\\1|([\\\\/|\\\"'])(?:\\\\\\\\.|(?!\\\\2)[^\\\\\\\\\\\\r\\\\n])+\\\\2|\\\\((?:\\\\\\\\.|[^\\\\\\\\)\\\\r\\\\n])+\\\\)|\\\\[(?:\\\\\\\\.|[^\\\\\\\\\\\\]\\\\r\\\\n])+\\\\]|\\\\{(?:\\\\\\\\.|#\\\\{[^}]+\\\\}|#(?!\\\\{)|[^#\\\\\\\\}\\\\r\\\\n])+\\\\}|<(?:\\\\\\\\.|[^\\\\\\\\>\\\\r\\\\n])+>)[csa]?/,\\n      greedy: true,\\n      inside: {// See interpolation below\\n      }\\n    }, {\\n      pattern: /(\\\"\\\"\\\"|''')[\\\\s\\\\S]*?\\\\1/,\\n      greedy: true,\\n      inside: {// See interpolation below\\n      }\\n    }, {\\n      // Multi-line strings are allowed\\n      pattern: /(\\\"|')(?:\\\\\\\\(?:\\\\r\\\\n|[\\\\s\\\\S])|(?!\\\\1)[^\\\\\\\\\\\\r\\\\n])*\\\\1/,\\n      greedy: true,\\n      inside: {// See interpolation below\\n      }\\n    }],\\n    atom: {\\n      // Look-behind prevents bad highlighting of the :: operator\\n      pattern: /(^|[^:]):\\\\w+/,\\n      lookbehind: true,\\n      alias: 'symbol'\\n    },\\n    module: {\\n      pattern: /\\\\b[A-Z]\\\\w*\\\\b/,\\n      alias: 'class-name'\\n    },\\n    // Look-ahead prevents bad highlighting of the :: operator\\n    'attr-name': /\\\\b\\\\w+\\\\??:(?!:)/,\\n    argument: {\\n      // Look-behind prevents bad highlighting of the && operator\\n      pattern: /(^|[^&])&\\\\d+/,\\n      lookbehind: true,\\n      alias: 'variable'\\n    },\\n    attribute: {\\n      pattern: /@\\\\w+/,\\n      alias: 'variable'\\n    },\\n    function: /\\\\b[_a-zA-Z]\\\\w*[?!]?(?:(?=\\\\s*(?:\\\\.\\\\s*)?\\\\()|(?=\\\\/\\\\d))/,\\n    number: /\\\\b(?:0[box][a-f\\\\d_]+|\\\\d[\\\\d_]*)(?:\\\\.[\\\\d_]+)?(?:e[+-]?[\\\\d_]+)?\\\\b/i,\\n    keyword: /\\\\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\\\\b/,\\n    boolean: /\\\\b(?:false|nil|true)\\\\b/,\\n    operator: [/\\\\bin\\\\b|&&?|\\\\|[|>]?|\\\\\\\\\\\\\\\\|::|\\\\.\\\\.\\\\.?|\\\\+\\\\+?|-[->]?|<[-=>]|>=|!==?|\\\\B!|=(?:==?|[>~])?|[*\\\\/^]/, {\\n      // We don't want to match <<\\n      pattern: /([^<])<(?!<)/,\\n      lookbehind: true\\n    }, {\\n      // We don't want to match >>\\n      pattern: /([^>])>(?!>)/,\\n      lookbehind: true\\n    }],\\n    punctuation: /<<|>>|[.,%\\\\[\\\\]{}()]/\\n  };\\n  Prism.languages.elixir.string.forEach(function (o) {\\n    o.inside = {\\n      interpolation: {\\n        pattern: /#\\\\{[^}]+\\\\}/,\\n        inside: {\\n          delimiter: {\\n            pattern: /^#\\\\{|\\\\}$/,\\n            alias: 'punctuation'\\n          },\\n          rest: Prism.languages.elixir\\n        }\\n      }\\n    };\\n  });\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"elixir\",\"Prism\",\"languages\",\"doc\",\"pattern\",\"inside\",\"attribute\",\"string\",\"comment\",\"greedy\",\"regex\",\"atom\",\"lookbehind\",\"alias\",\"argument\",\"function\",\"number\",\"keyword\",\"boolean\",\"operator\",\"punctuation\",\"forEach\",\"o\",\"interpolation\",\"delimiter\",\"rest\",\"Object\",\"defineProperty\",\"value\",\"default\",\"displayName\",\"aliases\"]\n}\n"]