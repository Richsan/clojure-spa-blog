["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/xquery.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$xquery=function(global,require,module,exports){function xquery(Prism$jscomp$0){Prism$jscomp$0.register(_markup.default);(function(Prism){Prism.languages.xquery=Prism.languages.extend(\"markup\",{\"xquery-comment\":{pattern:/\\(:[\\s\\S]*?:\\)/,greedy:!0,alias:\"comment\"},string:{pattern:/([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,greedy:!0},extension:{pattern:/\\(#.+?#\\)/,alias:\"symbol\"},variable:/\\$[-\\w:]+/,axis:{pattern:/(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\nlookbehind:!0,alias:\"operator\"},\"keyword-operator\":{pattern:/(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,lookbehind:!0,alias:\"operator\"},keyword:{pattern:/(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\nlookbehind:!0},function:/[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\"xquery-element\":{pattern:/(element\\s+)[\\w-]+(?::[\\w-]+)*/,lookbehind:!0,alias:\"tag\"},\"xquery-attribute\":{pattern:/(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,lookbehind:!0,alias:\"attr-name\"},builtin:{pattern:/(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\nlookbehind:!0},number:/\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,operator:[/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/,{pattern:/(\\s)-(?=\\s)/,lookbehind:!0}],punctuation:/[[\\](){},;:/]/});Prism.languages.xquery.tag.pattern=/<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/;Prism.languages.xquery.tag.inside[\"attr-value\"].pattern=/=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/;\nPrism.languages.xquery.tag.inside[\"attr-value\"].inside.punctuation=/^=\"|\"$/;Prism.languages.xquery.tag.inside[\"attr-value\"].inside.expression={pattern:/\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}/,inside:Prism.languages.xquery,alias:\"language-xquery\"};var stringifyToken=function(token){return\"string\"===typeof token?token:\"string\"===typeof token.content?token.content:token.content.map(stringifyToken).join(\"\")},walkTokens=function(tokens){for(var openedTags=[],i=0;i<tokens.length;i++){var token=\ntokens[i],notTagNorBrace=!1;\"string\"!==typeof token&&(\"tag\"===token.type&&token.content[0]&&\"tag\"===token.content[0].type?\"\\x3c/\"===token.content[0].content[0].content?0<openedTags.length&&openedTags[openedTags.length-1].tagName===stringifyToken(token.content[0].content[1])&&openedTags.pop():\"/\\x3e\"!==token.content[token.content.length-1].content&&openedTags.push({tagName:stringifyToken(token.content[0].content[1]),openedBraces:0}):!(0<openedTags.length&&\"punctuation\"===token.type&&\"{\"===token.content)||\ntokens[i+1]&&\"punctuation\"===tokens[i+1].type&&\"{\"===tokens[i+1].content||tokens[i-1]&&\"plain-text\"===tokens[i-1].type&&\"{\"===tokens[i-1].content?0<openedTags.length&&0<openedTags[openedTags.length-1].openedBraces&&\"punctuation\"===token.type&&\"}\"===token.content?openedTags[openedTags.length-1].openedBraces--:\"comment\"!==token.type&&(notTagNorBrace=!0):openedTags[openedTags.length-1].openedBraces++);(notTagNorBrace||\"string\"===typeof token)&&0<openedTags.length&&0===openedTags[openedTags.length-1].openedBraces&&\n(notTagNorBrace=stringifyToken(token),i<tokens.length-1&&(\"string\"===typeof tokens[i+1]||\"plain-text\"===tokens[i+1].type)&&(notTagNorBrace+=stringifyToken(tokens[i+1]),tokens.splice(i+1,1)),0<i&&(\"string\"===typeof tokens[i-1]||\"plain-text\"===tokens[i-1].type)&&(notTagNorBrace=stringifyToken(tokens[i-1])+notTagNorBrace,tokens.splice(i-1,1),i--),/^\\s+$/.test(notTagNorBrace)?tokens[i]=notTagNorBrace:tokens[i]=new Prism.Token(\"plain-text\",notTagNorBrace,null,notTagNorBrace));token.content&&\"string\"!==\ntypeof token.content&&walkTokens(token.content)}};Prism.hooks.add(\"after-tokenize\",function(env){\"xquery\"===env.language&&walkTokens(env.tokens)})})(Prism$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=xquery;var _markup=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(require(\"module$node_modules$refractor$lang$markup\"));xquery.displayName=\"xquery\";xquery.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$xquery\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = xquery;\n\nvar _markup = _interopRequireDefault(require(\"./markup.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// @ts-nocheck\nxquery.displayName = 'xquery';\nxquery.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction xquery(Prism) {\n  Prism.register(_markup.default);\n\n  (function (Prism) {\n    Prism.languages.xquery = Prism.languages.extend('markup', {\n      'xquery-comment': {\n        pattern: /\\(:[\\s\\S]*?:\\)/,\n        greedy: true,\n        alias: 'comment'\n      },\n      string: {\n        pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n        greedy: true\n      },\n      extension: {\n        pattern: /\\(#.+?#\\)/,\n        alias: 'symbol'\n      },\n      variable: /\\$[-\\w:]+/,\n      axis: {\n        pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      'keyword-operator': {\n        pattern: /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      keyword: {\n        pattern: /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      function: /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n      'xquery-element': {\n        pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'tag'\n      },\n      'xquery-attribute': {\n        pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'attr-name'\n      },\n      builtin: {\n        pattern: /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      number: /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n      operator: [/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/, {\n        pattern: /(\\s)-(?=\\s)/,\n        lookbehind: true\n      }],\n      punctuation: /[[\\](){},;:/]/\n    });\n    Prism.languages.xquery.tag.pattern = /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/;\n    Prism.languages.xquery['tag'].inside['attr-value'].pattern = /=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/;\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^=\"|\"$/;\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n      // Allow for two levels of nesting\n      pattern: /\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}/,\n      inside: Prism.languages.xquery,\n      alias: 'language-xquery'\n    }; // The following will handle plain text inside tags\n\n    var stringifyToken = function (token) {\n      if (typeof token === 'string') {\n        return token;\n      }\n\n      if (typeof token.content === 'string') {\n        return token.content;\n      }\n\n      return token.content.map(stringifyToken).join('');\n    };\n\n    var walkTokens = function (tokens) {\n      var openedTags = [];\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        var notTagNorBrace = false;\n\n        if (typeof token !== 'string') {\n          if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n                // Pop matching opening tag\n                openedTags.pop();\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {// Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                });\n              }\n            }\n          } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{' && (!tokens[i + 1] || tokens[i + 1].type !== 'punctuation' || tokens[i + 1].content !== '{') && (!tokens[i - 1] || tokens[i - 1].type !== 'plain-text' || tokens[i - 1].content !== '{')) {\n            // Here we might have entered an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces++;\n          } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n            // Here we might have left an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces--;\n          } else if (token.type !== 'comment') {\n            notTagNorBrace = true;\n          }\n        }\n\n        if (notTagNorBrace || typeof token === 'string') {\n          if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n            // Here we are inside a tag, and not inside an XQuery expression.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token); // And merge text with adjacent text\n\n            if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n              plainText += stringifyToken(tokens[i + 1]);\n              tokens.splice(i + 1, 1);\n            }\n\n            if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText;\n              tokens.splice(i - 1, 1);\n              i--;\n            }\n\n            if (/^\\s+$/.test(plainText)) {\n              tokens[i] = plainText;\n            } else {\n              tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n            }\n          }\n        }\n\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content);\n        }\n      }\n    };\n\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'xquery') {\n        return;\n      }\n\n      walkTokens(env.tokens);\n    });\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$refractor$lang$markup","~$shadow.js"]],"~:properties",["^5",["punctuation","string","aliases","operator","displayName","__esModule","axis","lookbehind","extension","value","variable","keyword","number","greedy","function","pattern","xquery","tagName","inside","alias","builtin","openedBraces","default"]],"~:compiled-at",1676841365477,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$xquery.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lang/xquery.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$xquery\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = xquery;\\n\\nvar _markup = _interopRequireDefault(require(\\\"./markup.js\\\"));\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n// @ts-nocheck\\nxquery.displayName = 'xquery';\\nxquery.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction xquery(Prism) {\\n  Prism.register(_markup.default);\\n\\n  (function (Prism) {\\n    Prism.languages.xquery = Prism.languages.extend('markup', {\\n      'xquery-comment': {\\n        pattern: /\\\\(:[\\\\s\\\\S]*?:\\\\)/,\\n        greedy: true,\\n        alias: 'comment'\\n      },\\n      string: {\\n        pattern: /([\\\"'])(?:\\\\1\\\\1|(?!\\\\1)[\\\\s\\\\S])*\\\\1/,\\n        greedy: true\\n      },\\n      extension: {\\n        pattern: /\\\\(#.+?#\\\\)/,\\n        alias: 'symbol'\\n      },\\n      variable: /\\\\$[-\\\\w:]+/,\\n      axis: {\\n        pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\\n        lookbehind: true,\\n        alias: 'operator'\\n      },\\n      'keyword-operator': {\\n        pattern: /(^|[^:-])\\\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\\\b(?=$|[^:-])/,\\n        lookbehind: true,\\n        alias: 'operator'\\n      },\\n      keyword: {\\n        pattern: /(^|[^:-])\\\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\\\b(?=$|[^:-])/,\\n        lookbehind: true\\n      },\\n      function: /[\\\\w-]+(?::[\\\\w-]+)*(?=\\\\s*\\\\()/,\\n      'xquery-element': {\\n        pattern: /(element\\\\s+)[\\\\w-]+(?::[\\\\w-]+)*/,\\n        lookbehind: true,\\n        alias: 'tag'\\n      },\\n      'xquery-attribute': {\\n        pattern: /(attribute\\\\s+)[\\\\w-]+(?::[\\\\w-]+)*/,\\n        lookbehind: true,\\n        alias: 'attr-name'\\n      },\\n      builtin: {\\n        pattern: /(^|[^:-])\\\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\\\b(?=$|[^:-])/,\\n        lookbehind: true\\n      },\\n      number: /\\\\b\\\\d+(?:\\\\.\\\\d+)?(?:E[+-]?\\\\d+)?/,\\n      operator: [/[+*=?|@]|\\\\.\\\\.?|:=|!=|<[=<]?|>[=>]?/, {\\n        pattern: /(\\\\s)-(?=\\\\s)/,\\n        lookbehind: true\\n      }],\\n      punctuation: /[[\\\\](){},;:/]/\\n    });\\n    Prism.languages.xquery.tag.pattern = /<\\\\/?(?!\\\\d)[^\\\\s>\\\\/=$<%]+(?:\\\\s+[^\\\\s>\\\\/=]+(?:=(?:(\\\"|')(?:\\\\\\\\[\\\\s\\\\S]|\\\\{(?!\\\\{)(?:\\\\{(?:\\\\{[^{}]*\\\\}|[^{}])*\\\\}|[^{}])+\\\\}|(?!\\\\1)[^\\\\\\\\])*\\\\1|[^\\\\s'\\\">=]+))?)*\\\\s*\\\\/?>/;\\n    Prism.languages.xquery['tag'].inside['attr-value'].pattern = /=(?:(\\\"|')(?:\\\\\\\\[\\\\s\\\\S]|\\\\{(?!\\\\{)(?:\\\\{(?:\\\\{[^{}]*\\\\}|[^{}])*\\\\}|[^{}])+\\\\}|(?!\\\\1)[^\\\\\\\\])*\\\\1|[^\\\\s'\\\">=]+)/;\\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^=\\\"|\\\"$/;\\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\\n      // Allow for two levels of nesting\\n      pattern: /\\\\{(?!\\\\{)(?:\\\\{(?:\\\\{[^{}]*\\\\}|[^{}])*\\\\}|[^{}])+\\\\}/,\\n      inside: Prism.languages.xquery,\\n      alias: 'language-xquery'\\n    }; // The following will handle plain text inside tags\\n\\n    var stringifyToken = function (token) {\\n      if (typeof token === 'string') {\\n        return token;\\n      }\\n\\n      if (typeof token.content === 'string') {\\n        return token.content;\\n      }\\n\\n      return token.content.map(stringifyToken).join('');\\n    };\\n\\n    var walkTokens = function (tokens) {\\n      var openedTags = [];\\n\\n      for (var i = 0; i < tokens.length; i++) {\\n        var token = tokens[i];\\n        var notTagNorBrace = false;\\n\\n        if (typeof token !== 'string') {\\n          if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\\n            // We found a tag, now find its kind\\n            if (token.content[0].content[0].content === '</') {\\n              // Closing tag\\n              if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\\n                // Pop matching opening tag\\n                openedTags.pop();\\n              }\\n            } else {\\n              if (token.content[token.content.length - 1].content === '/>') {// Autoclosed tag, ignore\\n              } else {\\n                // Opening tag\\n                openedTags.push({\\n                  tagName: stringifyToken(token.content[0].content[1]),\\n                  openedBraces: 0\\n                });\\n              }\\n            }\\n          } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{' && (!tokens[i + 1] || tokens[i + 1].type !== 'punctuation' || tokens[i + 1].content !== '{') && (!tokens[i - 1] || tokens[i - 1].type !== 'plain-text' || tokens[i - 1].content !== '{')) {\\n            // Here we might have entered an XQuery expression inside a tag\\n            openedTags[openedTags.length - 1].openedBraces++;\\n          } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\\n            // Here we might have left an XQuery expression inside a tag\\n            openedTags[openedTags.length - 1].openedBraces--;\\n          } else if (token.type !== 'comment') {\\n            notTagNorBrace = true;\\n          }\\n        }\\n\\n        if (notTagNorBrace || typeof token === 'string') {\\n          if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\\n            // Here we are inside a tag, and not inside an XQuery expression.\\n            // That's plain text: drop any tokens matched.\\n            var plainText = stringifyToken(token); // And merge text with adjacent text\\n\\n            if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\\n              plainText += stringifyToken(tokens[i + 1]);\\n              tokens.splice(i + 1, 1);\\n            }\\n\\n            if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\\n              plainText = stringifyToken(tokens[i - 1]) + plainText;\\n              tokens.splice(i - 1, 1);\\n              i--;\\n            }\\n\\n            if (/^\\\\s+$/.test(plainText)) {\\n              tokens[i] = plainText;\\n            } else {\\n              tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\\n            }\\n          }\\n        }\\n\\n        if (token.content && typeof token.content !== 'string') {\\n          walkTokens(token.content);\\n        }\\n      }\\n    };\\n\\n    Prism.hooks.add('after-tokenize', function (env) {\\n      if (env.language !== 'xquery') {\\n        return;\\n      }\\n\\n      walkTokens(env.tokens);\\n    });\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"xquery\",\"Prism\",\"register\",\"_markup\",\"default\",\"languages\",\"extend\",\"pattern\",\"greedy\",\"alias\",\"string\",\"extension\",\"variable\",\"axis\",\"lookbehind\",\"keyword\",\"function\",\"builtin\",\"number\",\"operator\",\"punctuation\",\"tag\",\"inside\",\"stringifyToken\",\"token\",\"content\",\"map\",\"join\",\"walkTokens\",\"tokens\",\"openedTags\",\"i\",\"length\",\"notTagNorBrace\",\"type\",\"tagName\",\"pop\",\"push\",\"openedBraces\",\"plainText\",\"splice\",\"test\",\"Token\",\"hooks\",\"add\",\"env\",\"language\",\"Object\",\"defineProperty\",\"value\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"displayName\",\"aliases\"]\n}\n"]