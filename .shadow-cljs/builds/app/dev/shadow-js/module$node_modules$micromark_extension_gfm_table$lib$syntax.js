["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-extension-gfm-table/lib/syntax.js"],"~:js","shadow$provide.module$node_modules$micromark_extension_gfm_table$lib$syntax=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.gfmTable=void 0;var _micromarkFactorySpace=require(\"module$node_modules$micromark_factory_space$index\"),_micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\");exports.gfmTable={flow:{null:{tokenize:function(effects$jscomp$0,ok$jscomp$0,nok$jscomp$0){function cellDividerHead(code){effects$jscomp$0.enter(\"tableCellDivider\");\neffects$jscomp$0.consume(code);effects$jscomp$0.exit(\"tableCellDivider\");seenDelimiter=!0;return cellBreakHead}function cellBreakHead(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return atRowEndHead(code);if((0,_micromarkUtilCharacter.markdownSpace)(code))return effects$jscomp$0.enter(\"whitespace\"),effects$jscomp$0.consume(code),inWhitespaceHead;seenDelimiter&&(seenDelimiter=void 0,tableHeaderCount++);if(124===code)return cellDividerHead(code);effects$jscomp$0.enter(\"temporaryTableCellContent\");\nreturn inCellContentHead(code)}function inWhitespaceHead(code){if((0,_micromarkUtilCharacter.markdownSpace)(code))return effects$jscomp$0.consume(code),inWhitespaceHead;effects$jscomp$0.exit(\"whitespace\");return cellBreakHead(code)}function inCellContentHead(code){if(null===code||124===code||(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code))return effects$jscomp$0.exit(\"temporaryTableCellContent\"),cellBreakHead(code);effects$jscomp$0.consume(code);return 92===code?inCellContentEscapeHead:\ninCellContentHead}function inCellContentEscapeHead(code){return 92===code||124===code?(effects$jscomp$0.consume(code),inCellContentHead):inCellContentHead(code)}function atRowEndHead(code$jscomp$0){if(null===code$jscomp$0)return nok$jscomp$0(code$jscomp$0);effects$jscomp$0.exit(\"tableRow\");effects$jscomp$0.exit(\"tableHead\");const originalInterrupt=self.interrupt;self.interrupt=!0;return effects$jscomp$0.attempt({tokenize:tokenizeRowEnd,partial:!0},function(code){self.interrupt=originalInterrupt;effects$jscomp$0.enter(\"tableDelimiterRow\");\nreturn atDelimiterRowBreak(code)},function(code){self.interrupt=originalInterrupt;return nok$jscomp$0(code)})(code$jscomp$0)}function atDelimiterRowBreak(code){return null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code)?rowEndDelimiter(code):(0,_micromarkUtilCharacter.markdownSpace)(code)?(effects$jscomp$0.enter(\"whitespace\"),effects$jscomp$0.consume(code),inWhitespaceDelimiter):45===code?(effects$jscomp$0.enter(\"tableDelimiterFiller\"),effects$jscomp$0.consume(code),hasDash=!0,align.push(\"none\"),\ninFillerDelimiter):58===code?(effects$jscomp$0.enter(\"tableDelimiterAlignment\"),effects$jscomp$0.consume(code),effects$jscomp$0.exit(\"tableDelimiterAlignment\"),align.push(\"left\"),afterLeftAlignment):124===code?(effects$jscomp$0.enter(\"tableCellDivider\"),effects$jscomp$0.consume(code),effects$jscomp$0.exit(\"tableCellDivider\"),atDelimiterRowBreak):nok$jscomp$0(code)}function inWhitespaceDelimiter(code){if((0,_micromarkUtilCharacter.markdownSpace)(code))return effects$jscomp$0.consume(code),inWhitespaceDelimiter;\neffects$jscomp$0.exit(\"whitespace\");return atDelimiterRowBreak(code)}function inFillerDelimiter(code){if(45===code)return effects$jscomp$0.consume(code),inFillerDelimiter;effects$jscomp$0.exit(\"tableDelimiterFiller\");return 58===code?(effects$jscomp$0.enter(\"tableDelimiterAlignment\"),effects$jscomp$0.consume(code),effects$jscomp$0.exit(\"tableDelimiterAlignment\"),align[align.length-1]=\"left\"===align[align.length-1]?\"center\":\"right\",afterRightAlignment):atDelimiterRowBreak(code)}function afterLeftAlignment(code){return 45===\ncode?(effects$jscomp$0.enter(\"tableDelimiterFiller\"),effects$jscomp$0.consume(code),hasDash=!0,inFillerDelimiter):nok$jscomp$0(code)}function afterRightAlignment(code){return null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code)?rowEndDelimiter(code):(0,_micromarkUtilCharacter.markdownSpace)(code)?(effects$jscomp$0.enter(\"whitespace\"),effects$jscomp$0.consume(code),inWhitespaceDelimiter):124===code?(effects$jscomp$0.enter(\"tableCellDivider\"),effects$jscomp$0.consume(code),effects$jscomp$0.exit(\"tableCellDivider\"),\natDelimiterRowBreak):nok$jscomp$0(code)}function rowEndDelimiter(code){effects$jscomp$0.exit(\"tableDelimiterRow\");return hasDash&&tableHeaderCount===align.length?null===code?tableClose(code):effects$jscomp$0.check(nextPrefixedOrBlank,tableClose,effects$jscomp$0.attempt({tokenize:tokenizeRowEnd,partial:!0},(0,_micromarkFactorySpace.factorySpace)(effects$jscomp$0,bodyStart,\"linePrefix\",4),tableClose))(code):nok$jscomp$0(code)}function tableClose(code){effects$jscomp$0.exit(\"table\");return ok$jscomp$0(code)}\nfunction bodyStart(code){effects$jscomp$0.enter(\"tableBody\");return rowStartBody(code)}function rowStartBody(code){effects$jscomp$0.enter(\"tableRow\");if(124===code)return cellDividerBody(code);effects$jscomp$0.enter(\"temporaryTableCellContent\");return inCellContentBody(code)}function cellDividerBody(code){effects$jscomp$0.enter(\"tableCellDivider\");effects$jscomp$0.consume(code);effects$jscomp$0.exit(\"tableCellDivider\");return cellBreakBody}function cellBreakBody(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects$jscomp$0.exit(\"tableRow\"),\ncode=null===code?tableBodyClose(code):effects$jscomp$0.check(nextPrefixedOrBlank,tableBodyClose,effects$jscomp$0.attempt({tokenize:tokenizeRowEnd,partial:!0},(0,_micromarkFactorySpace.factorySpace)(effects$jscomp$0,rowStartBody,\"linePrefix\",4),tableBodyClose))(code),code;if((0,_micromarkUtilCharacter.markdownSpace)(code))return effects$jscomp$0.enter(\"whitespace\"),effects$jscomp$0.consume(code),inWhitespaceBody;if(124===code)return cellDividerBody(code);effects$jscomp$0.enter(\"temporaryTableCellContent\");\nreturn inCellContentBody(code)}function inWhitespaceBody(code){if((0,_micromarkUtilCharacter.markdownSpace)(code))return effects$jscomp$0.consume(code),inWhitespaceBody;effects$jscomp$0.exit(\"whitespace\");return cellBreakBody(code)}function inCellContentBody(code){if(null===code||124===code||(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code))return effects$jscomp$0.exit(\"temporaryTableCellContent\"),cellBreakBody(code);effects$jscomp$0.consume(code);return 92===code?inCellContentEscapeBody:\ninCellContentBody}function inCellContentEscapeBody(code){return 92===code||124===code?(effects$jscomp$0.consume(code),inCellContentBody):inCellContentBody(code)}function tableBodyClose(code){effects$jscomp$0.exit(\"tableBody\");return tableClose(code)}function tokenizeRowEnd(effects,ok,nok){function prefixed(code$jscomp$0){if(self.parser.lazy[self.now().line]||null===code$jscomp$0||(0,_micromarkUtilCharacter.markdownLineEnding)(code$jscomp$0))return nok(code$jscomp$0);const tail=self.events[self.events.length-\n1];if(!self.parser.constructs.disable.null.includes(\"codeIndented\")&&tail&&\"linePrefix\"===tail[1].type&&4<=tail[2].sliceSerialize(tail[1],!0).length)return nok(code$jscomp$0);self._gfmTableDynamicInterruptHack=!0;return effects.check(self.parser.constructs.flow,function(code){self._gfmTableDynamicInterruptHack=!1;return nok(code)},function(code){self._gfmTableDynamicInterruptHack=!1;return ok(code)})(code$jscomp$0)}return function(code){effects.enter(\"lineEnding\");effects.consume(code);effects.exit(\"lineEnding\");\nreturn(0,_micromarkFactorySpace.factorySpace)(effects,prefixed,\"linePrefix\")}}const self=this,align=[];let tableHeaderCount=0,seenDelimiter,hasDash;return function(code){effects$jscomp$0.enter(\"table\")._align=align;effects$jscomp$0.enter(\"tableHead\");effects$jscomp$0.enter(\"tableRow\");if(124===code)return cellDividerHead(code);tableHeaderCount++;effects$jscomp$0.enter(\"temporaryTableCellContent\");return inCellContentHead(code)}},resolve:function(events,context){let index=-1,inHead,inDelimiterRow,\ninRow,contentStart,contentEnd,cellStart;for(var seenCellInRow;++index<events.length;){const token=events[index][1];if(inRow&&(\"temporaryTableCellContent\"===token.type&&(contentStart=contentStart||index,contentEnd=index),(\"tableCellDivider\"===token.type||\"tableRow\"===token.type)&&contentEnd)){const content={type:\"tableContent\",start:events[contentStart][1].start,end:events[contentEnd][1].end},text={type:\"chunkText\",start:content.start,end:content.end,contentType:\"text\"};events.splice(contentStart,\ncontentEnd-contentStart+1,[\"enter\",content,context],[\"enter\",text,context],[\"exit\",text,context],[\"exit\",content,context]);index-=contentEnd-contentStart-3;contentEnd=contentStart=void 0}\"exit\"===events[index][0]&&void 0!==cellStart&&cellStart+(seenCellInRow?0:1)<index&&(\"tableCellDivider\"===token.type||\"tableRow\"===token.type&&(cellStart+3<index||\"whitespace\"!==events[cellStart][1].type))&&(seenCellInRow={type:inDelimiterRow?\"tableDelimiter\":inHead?\"tableHeader\":\"tableData\",start:events[cellStart][1].start,\nend:events[index][1].end},events.splice(index+(\"tableCellDivider\"===token.type?1:0),0,[\"exit\",seenCellInRow,context]),events.splice(cellStart,0,[\"enter\",seenCellInRow,context]),index+=2,cellStart=index+1,seenCellInRow=!0);\"tableRow\"===token.type&&(inRow=\"enter\"===events[index][0])&&(cellStart=index+1,seenCellInRow=!1);\"tableDelimiterRow\"===token.type&&(inDelimiterRow=\"enter\"===events[index][0])&&(cellStart=index+1,seenCellInRow=!1);\"tableHead\"===token.type&&(inHead=\"enter\"===events[index][0])}return events}}}};\nconst nextPrefixedOrBlank={tokenize:function(effects,ok,nok){function whitespace(code){return-1===code||32===code?(effects.consume(code),size++,4===size?ok:whitespace):null===code||(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code)?ok(code):nok(code)}let size=0;return function(code){effects.enter(\"check\");effects.consume(code);return whitespace}},partial:!0}}","~:source","shadow$provide[\"module$node_modules$micromark_extension_gfm_table$lib$syntax\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gfmTable = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\n\n/** @type {Extension} */\nconst gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n};\nexports.gfmTable = gfmTable;\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n};\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1;\n  /** @type {boolean|undefined} */\n\n  let inHead;\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow;\n  /** @type {boolean|undefined} */\n\n  let inRow;\n  /** @type {number|undefined} */\n\n  let contentStart;\n  /** @type {number|undefined} */\n\n  let contentEnd;\n  /** @type {number|undefined} */\n\n  let cellStart;\n  /** @type {boolean|undefined} */\n\n  let seenCellInRow;\n\n  while (++index < events.length) {\n    const token = events[index][1];\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index;\n        contentEnd = index;\n      }\n\n      if ( // Combine separate content parts into one.\n      (token.type === 'tableCellDivider' || token.type === 'tableRow') && contentEnd) {\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        };\n        /** @type {Token} */\n\n        const text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: 'text'\n        };\n        events.splice(contentStart, contentEnd - contentStart + 1, ['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]);\n        index -= contentEnd - contentStart - 3;\n        contentStart = undefined;\n        contentEnd = undefined;\n      }\n    }\n\n    if (events[index][0] === 'exit' && cellStart !== undefined && cellStart + (seenCellInRow ? 0 : 1) < index && (token.type === 'tableCellDivider' || token.type === 'tableRow' && (cellStart + 3 < index || events[cellStart][1].type !== 'whitespace'))) {\n      const cell = {\n        type: inDelimiterRow ? 'tableDelimiter' : inHead ? 'tableHeader' : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      };\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, ['exit', cell, context]);\n      events.splice(cellStart, 0, ['enter', cell, context]);\n      index += 2;\n      cellStart = index + 1;\n      seenCellInRow = true;\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter';\n\n      if (inRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter';\n\n      if (inDelimiterRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter';\n    }\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this;\n  /** @type {Array<Align>} */\n\n  const align = [];\n  let tableHeaderCount = 0;\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter;\n  /** @type {boolean|undefined} */\n\n  let hasDash;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align;\n    effects.enter('tableHead');\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    }\n\n    tableHeaderCount++;\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    seenDelimiter = true;\n    return cellBreakHead;\n  }\n  /** @type {State} */\n\n\n  function cellBreakHead(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return atRowEndHead(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined;\n      tableHeaderCount++;\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceHead(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    effects.exit('whitespace');\n    return cellBreakHead(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakHead(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentHead;\n    } // Anything else.\n\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code);\n    }\n\n    effects.exit('tableRow');\n    effects.exit('tableHead');\n    const originalInterrupt = self.interrupt;\n    self.interrupt = true;\n    return effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      effects.enter('tableDelimiterRow');\n      return atDelimiterRowBreak(code);\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      return nok(code);\n    })(code);\n  }\n  /** @type {State} */\n\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      align.push('none');\n      return inFillerDelimiter;\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align.push('left');\n      return afterLeftAlignment;\n    } // If we start with a pipe, we open a cell marker.\n\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceDelimiter(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    effects.exit('whitespace');\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return inFillerDelimiter;\n    }\n\n    effects.exit('tableDelimiterFiller');\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align[align.length - 1] = align[align.length - 1] === 'left' ? 'center' : 'right';\n      return afterRightAlignment;\n    }\n\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      return inFillerDelimiter;\n    } // Anything else is not ok.\n\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function afterRightAlignment(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    } // `|`\n\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow'); // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code);\n    }\n\n    if (code === null) {\n      return tableClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, (0, _micromarkFactorySpace.factorySpace)(effects, bodyStart, 'linePrefix', 4), tableClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableClose(code) {\n    effects.exit('table');\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function bodyStart(code) {\n    effects.enter('tableBody');\n    return rowStartBody(code);\n  }\n  /** @type {State} */\n\n\n  function rowStartBody(code) {\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    }\n\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    return cellBreakBody;\n  }\n  /** @type {State} */\n\n\n  function cellBreakBody(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return atRowEndBody(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceBody;\n    } // `|`\n\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceBody(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n\n    effects.exit('whitespace');\n    return cellBreakBody(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakBody(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentBody;\n    } // Anything else.\n\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow');\n\n    if (code === null) {\n      return tableBodyClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, (0, _micromarkFactorySpace.factorySpace)(effects, rowStartBody, 'linePrefix', 4), tableBodyClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody');\n    return tableClose(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return (0, _micromarkFactorySpace.factorySpace)(effects, prefixed, 'linePrefix');\n    }\n    /** @type {State} */\n\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (self.parser.lazy[self.now().line] || code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n        return nok(code);\n      }\n\n      const tail = self.events[self.events.length - 1]; // Indented code can interrupt delimiter and body rows.\n\n      if (!self.parser.constructs.disable.null.includes('codeIndented') && tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4) {\n        return nok(code);\n      }\n\n      self._gfmTableDynamicInterruptHack = true;\n      return effects.check(self.parser.constructs.flow, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return nok(code);\n      }, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return ok(code);\n      })(code);\n    }\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check'); // EOL.\n\n    effects.consume(code);\n    return whitespace;\n  }\n  /** @type {State} */\n\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code);\n      size++;\n      return size === 4 ? ok : whitespace;\n    } // EOF or whitespace\n\n\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      return ok(code);\n    } // Anything else.\n\n\n    return nok(code);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js","~$module$node_modules$micromark_factory_space$index"]],"~:properties",["^5",["partial","resolve","tokenize","null","__esModule","_gfmTableDynamicInterruptHack","_align","value","start","interrupt","type","contentType","gfmTable","flow","end"]],"~:compiled-at",1676841365330,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_extension_gfm_table$lib$syntax.js\",\n\"lineCount\":19,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-extension-gfm-table/lib/syntax.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_extension_gfm_table$lib$syntax\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.gfmTable = void 0;\\n\\nvar _micromarkFactorySpace = require(\\\"micromark-factory-space\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Extension} Extension\\n * @typedef {import('micromark-util-types').Resolver} Resolver\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').State} State\\n * @typedef {import('micromark-util-types').Token} Token\\n */\\n\\n/**\\n * @typedef {'left'|'center'|'right'|'none'} Align\\n */\\n\\n/** @type {Extension} */\\nconst gfmTable = {\\n  flow: {\\n    null: {\\n      tokenize: tokenizeTable,\\n      resolve: resolveTable\\n    }\\n  }\\n};\\nexports.gfmTable = gfmTable;\\nconst nextPrefixedOrBlank = {\\n  tokenize: tokenizeNextPrefixedOrBlank,\\n  partial: true\\n};\\n/** @type {Resolver} */\\n\\nfunction resolveTable(events, context) {\\n  let index = -1;\\n  /** @type {boolean|undefined} */\\n\\n  let inHead;\\n  /** @type {boolean|undefined} */\\n\\n  let inDelimiterRow;\\n  /** @type {boolean|undefined} */\\n\\n  let inRow;\\n  /** @type {number|undefined} */\\n\\n  let contentStart;\\n  /** @type {number|undefined} */\\n\\n  let contentEnd;\\n  /** @type {number|undefined} */\\n\\n  let cellStart;\\n  /** @type {boolean|undefined} */\\n\\n  let seenCellInRow;\\n\\n  while (++index < events.length) {\\n    const token = events[index][1];\\n\\n    if (inRow) {\\n      if (token.type === 'temporaryTableCellContent') {\\n        contentStart = contentStart || index;\\n        contentEnd = index;\\n      }\\n\\n      if ( // Combine separate content parts into one.\\n      (token.type === 'tableCellDivider' || token.type === 'tableRow') && contentEnd) {\\n        const content = {\\n          type: 'tableContent',\\n          start: events[contentStart][1].start,\\n          end: events[contentEnd][1].end\\n        };\\n        /** @type {Token} */\\n\\n        const text = {\\n          type: 'chunkText',\\n          start: content.start,\\n          end: content.end,\\n          // @ts-expect-error It\\u2019s fine.\\n          contentType: 'text'\\n        };\\n        events.splice(contentStart, contentEnd - contentStart + 1, ['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]);\\n        index -= contentEnd - contentStart - 3;\\n        contentStart = undefined;\\n        contentEnd = undefined;\\n      }\\n    }\\n\\n    if (events[index][0] === 'exit' && cellStart !== undefined && cellStart + (seenCellInRow ? 0 : 1) < index && (token.type === 'tableCellDivider' || token.type === 'tableRow' && (cellStart + 3 < index || events[cellStart][1].type !== 'whitespace'))) {\\n      const cell = {\\n        type: inDelimiterRow ? 'tableDelimiter' : inHead ? 'tableHeader' : 'tableData',\\n        start: events[cellStart][1].start,\\n        end: events[index][1].end\\n      };\\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, ['exit', cell, context]);\\n      events.splice(cellStart, 0, ['enter', cell, context]);\\n      index += 2;\\n      cellStart = index + 1;\\n      seenCellInRow = true;\\n    }\\n\\n    if (token.type === 'tableRow') {\\n      inRow = events[index][0] === 'enter';\\n\\n      if (inRow) {\\n        cellStart = index + 1;\\n        seenCellInRow = false;\\n      }\\n    }\\n\\n    if (token.type === 'tableDelimiterRow') {\\n      inDelimiterRow = events[index][0] === 'enter';\\n\\n      if (inDelimiterRow) {\\n        cellStart = index + 1;\\n        seenCellInRow = false;\\n      }\\n    }\\n\\n    if (token.type === 'tableHead') {\\n      inHead = events[index][0] === 'enter';\\n    }\\n  }\\n\\n  return events;\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeTable(effects, ok, nok) {\\n  const self = this;\\n  /** @type {Array<Align>} */\\n\\n  const align = [];\\n  let tableHeaderCount = 0;\\n  /** @type {boolean|undefined} */\\n\\n  let seenDelimiter;\\n  /** @type {boolean|undefined} */\\n\\n  let hasDash;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    // @ts-expect-error Custom.\\n    effects.enter('table')._align = align;\\n    effects.enter('tableHead');\\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\\n\\n    if (code === 124) {\\n      return cellDividerHead(code);\\n    }\\n\\n    tableHeaderCount++;\\n    effects.enter('temporaryTableCellContent'); // Can\\u2019t be space or eols at the start of a construct, so we\\u2019re in a cell.\\n\\n    return inCellContentHead(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function cellDividerHead(code) {\\n    effects.enter('tableCellDivider');\\n    effects.consume(code);\\n    effects.exit('tableCellDivider');\\n    seenDelimiter = true;\\n    return cellBreakHead;\\n  }\\n  /** @type {State} */\\n\\n\\n  function cellBreakHead(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      return atRowEndHead(code);\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\\n      effects.enter('whitespace');\\n      effects.consume(code);\\n      return inWhitespaceHead;\\n    }\\n\\n    if (seenDelimiter) {\\n      seenDelimiter = undefined;\\n      tableHeaderCount++;\\n    }\\n\\n    if (code === 124) {\\n      return cellDividerHead(code);\\n    } // Anything else is cell content.\\n\\n\\n    effects.enter('temporaryTableCellContent');\\n    return inCellContentHead(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function inWhitespaceHead(code) {\\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\\n      effects.consume(code);\\n      return inWhitespaceHead;\\n    }\\n\\n    effects.exit('whitespace');\\n    return cellBreakHead(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function inCellContentHead(code) {\\n    // EOF, whitespace, pipe\\n    if (code === null || code === 124 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\\n      effects.exit('temporaryTableCellContent');\\n      return cellBreakHead(code);\\n    }\\n\\n    effects.consume(code);\\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead;\\n  }\\n  /** @type {State} */\\n\\n\\n  function inCellContentEscapeHead(code) {\\n    if (code === 92 || code === 124) {\\n      effects.consume(code);\\n      return inCellContentHead;\\n    } // Anything else.\\n\\n\\n    return inCellContentHead(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function atRowEndHead(code) {\\n    if (code === null) {\\n      return nok(code);\\n    }\\n\\n    effects.exit('tableRow');\\n    effects.exit('tableHead');\\n    const originalInterrupt = self.interrupt;\\n    self.interrupt = true;\\n    return effects.attempt({\\n      tokenize: tokenizeRowEnd,\\n      partial: true\\n    }, function (code) {\\n      self.interrupt = originalInterrupt;\\n      effects.enter('tableDelimiterRow');\\n      return atDelimiterRowBreak(code);\\n    }, function (code) {\\n      self.interrupt = originalInterrupt;\\n      return nok(code);\\n    })(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function atDelimiterRowBreak(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      return rowEndDelimiter(code);\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\\n      effects.enter('whitespace');\\n      effects.consume(code);\\n      return inWhitespaceDelimiter;\\n    }\\n\\n    if (code === 45) {\\n      effects.enter('tableDelimiterFiller');\\n      effects.consume(code);\\n      hasDash = true;\\n      align.push('none');\\n      return inFillerDelimiter;\\n    }\\n\\n    if (code === 58) {\\n      effects.enter('tableDelimiterAlignment');\\n      effects.consume(code);\\n      effects.exit('tableDelimiterAlignment');\\n      align.push('left');\\n      return afterLeftAlignment;\\n    } // If we start with a pipe, we open a cell marker.\\n\\n\\n    if (code === 124) {\\n      effects.enter('tableCellDivider');\\n      effects.consume(code);\\n      effects.exit('tableCellDivider');\\n      return atDelimiterRowBreak;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function inWhitespaceDelimiter(code) {\\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\\n      effects.consume(code);\\n      return inWhitespaceDelimiter;\\n    }\\n\\n    effects.exit('whitespace');\\n    return atDelimiterRowBreak(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function inFillerDelimiter(code) {\\n    if (code === 45) {\\n      effects.consume(code);\\n      return inFillerDelimiter;\\n    }\\n\\n    effects.exit('tableDelimiterFiller');\\n\\n    if (code === 58) {\\n      effects.enter('tableDelimiterAlignment');\\n      effects.consume(code);\\n      effects.exit('tableDelimiterAlignment');\\n      align[align.length - 1] = align[align.length - 1] === 'left' ? 'center' : 'right';\\n      return afterRightAlignment;\\n    }\\n\\n    return atDelimiterRowBreak(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function afterLeftAlignment(code) {\\n    if (code === 45) {\\n      effects.enter('tableDelimiterFiller');\\n      effects.consume(code);\\n      hasDash = true;\\n      return inFillerDelimiter;\\n    } // Anything else is not ok.\\n\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function afterRightAlignment(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      return rowEndDelimiter(code);\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\\n      effects.enter('whitespace');\\n      effects.consume(code);\\n      return inWhitespaceDelimiter;\\n    } // `|`\\n\\n\\n    if (code === 124) {\\n      effects.enter('tableCellDivider');\\n      effects.consume(code);\\n      effects.exit('tableCellDivider');\\n      return atDelimiterRowBreak;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function rowEndDelimiter(code) {\\n    effects.exit('tableDelimiterRow'); // Exit if there was no dash at all, or if the header cell count is not the\\n    // delimiter cell count.\\n\\n    if (!hasDash || tableHeaderCount !== align.length) {\\n      return nok(code);\\n    }\\n\\n    if (code === null) {\\n      return tableClose(code);\\n    }\\n\\n    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({\\n      tokenize: tokenizeRowEnd,\\n      partial: true\\n    }, (0, _micromarkFactorySpace.factorySpace)(effects, bodyStart, 'linePrefix', 4), tableClose))(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function tableClose(code) {\\n    effects.exit('table');\\n    return ok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function bodyStart(code) {\\n    effects.enter('tableBody');\\n    return rowStartBody(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function rowStartBody(code) {\\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\\n\\n    if (code === 124) {\\n      return cellDividerBody(code);\\n    }\\n\\n    effects.enter('temporaryTableCellContent'); // Can\\u2019t be space or eols at the start of a construct, so we\\u2019re in a cell.\\n\\n    return inCellContentBody(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function cellDividerBody(code) {\\n    effects.enter('tableCellDivider');\\n    effects.consume(code);\\n    effects.exit('tableCellDivider');\\n    return cellBreakBody;\\n  }\\n  /** @type {State} */\\n\\n\\n  function cellBreakBody(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      return atRowEndBody(code);\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\\n      effects.enter('whitespace');\\n      effects.consume(code);\\n      return inWhitespaceBody;\\n    } // `|`\\n\\n\\n    if (code === 124) {\\n      return cellDividerBody(code);\\n    } // Anything else is cell content.\\n\\n\\n    effects.enter('temporaryTableCellContent');\\n    return inCellContentBody(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function inWhitespaceBody(code) {\\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\\n      effects.consume(code);\\n      return inWhitespaceBody;\\n    }\\n\\n    effects.exit('whitespace');\\n    return cellBreakBody(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function inCellContentBody(code) {\\n    // EOF, whitespace, pipe\\n    if (code === null || code === 124 || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\\n      effects.exit('temporaryTableCellContent');\\n      return cellBreakBody(code);\\n    }\\n\\n    effects.consume(code);\\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody;\\n  }\\n  /** @type {State} */\\n\\n\\n  function inCellContentEscapeBody(code) {\\n    if (code === 92 || code === 124) {\\n      effects.consume(code);\\n      return inCellContentBody;\\n    } // Anything else.\\n\\n\\n    return inCellContentBody(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function atRowEndBody(code) {\\n    effects.exit('tableRow');\\n\\n    if (code === null) {\\n      return tableBodyClose(code);\\n    }\\n\\n    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({\\n      tokenize: tokenizeRowEnd,\\n      partial: true\\n    }, (0, _micromarkFactorySpace.factorySpace)(effects, rowStartBody, 'linePrefix', 4), tableBodyClose))(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function tableBodyClose(code) {\\n    effects.exit('tableBody');\\n    return tableClose(code);\\n  }\\n  /** @type {Tokenizer} */\\n\\n\\n  function tokenizeRowEnd(effects, ok, nok) {\\n    return start;\\n    /** @type {State} */\\n\\n    function start(code) {\\n      effects.enter('lineEnding');\\n      effects.consume(code);\\n      effects.exit('lineEnding');\\n      return (0, _micromarkFactorySpace.factorySpace)(effects, prefixed, 'linePrefix');\\n    }\\n    /** @type {State} */\\n\\n\\n    function prefixed(code) {\\n      // Blank or interrupting line.\\n      if (self.parser.lazy[self.now().line] || code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n        return nok(code);\\n      }\\n\\n      const tail = self.events[self.events.length - 1]; // Indented code can interrupt delimiter and body rows.\\n\\n      if (!self.parser.constructs.disable.null.includes('codeIndented') && tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4) {\\n        return nok(code);\\n      }\\n\\n      self._gfmTableDynamicInterruptHack = true;\\n      return effects.check(self.parser.constructs.flow, function (code) {\\n        self._gfmTableDynamicInterruptHack = false;\\n        return nok(code);\\n      }, function (code) {\\n        self._gfmTableDynamicInterruptHack = false;\\n        return ok(code);\\n      })(code);\\n    }\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\\n  let size = 0;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    // This is a check, so we don\\u2019t care about tokens, but we open a bogus one\\n    // so we\\u2019re valid.\\n    effects.enter('check'); // EOL.\\n\\n    effects.consume(code);\\n    return whitespace;\\n  }\\n  /** @type {State} */\\n\\n\\n  function whitespace(code) {\\n    if (code === -1 || code === 32) {\\n      effects.consume(code);\\n      size++;\\n      return size === 4 ? ok : whitespace;\\n    } // EOF or whitespace\\n\\n\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\\n      return ok(code);\\n    } // Anything else.\\n\\n\\n    return nok(code);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"gfmTable\",\"_micromarkFactorySpace\",\"_micromarkUtilCharacter\",\"flow\",\"null\",\"tokenize\",\"tokenizeTable\",\"effects\",\"ok\",\"nok\",\"cellDividerHead\",\"code\",\"enter\",\"consume\",\"exit\",\"seenDelimiter\",\"cellBreakHead\",\"markdownLineEnding\",\"atRowEndHead\",\"markdownSpace\",\"inWhitespaceHead\",\"undefined\",\"tableHeaderCount\",\"inCellContentHead\",\"markdownLineEndingOrSpace\",\"inCellContentEscapeHead\",\"originalInterrupt\",\"self\",\"interrupt\",\"attempt\",\"tokenizeRowEnd\",\"partial\",\"atDelimiterRowBreak\",\"rowEndDelimiter\",\"inWhitespaceDelimiter\",\"inFillerDelimiter\",\"hasDash\",\"align\",\"push\",\"afterLeftAlignment\",\"afterRightAlignment\",\"length\",\"tableClose\",\"check\",\"nextPrefixedOrBlank\",\"factorySpace\",\"bodyStart\",\"rowStartBody\",\"cellDividerBody\",\"inCellContentBody\",\"cellBreakBody\",\"tableBodyClose\",\"inWhitespaceBody\",\"inCellContentEscapeBody\",\"prefixed\",\"parser\",\"lazy\",\"now\",\"line\",\"tail\",\"events\",\"constructs\",\"disable\",\"includes\",\"type\",\"sliceSerialize\",\"_gfmTableDynamicInterruptHack\",\"start\",\"_align\",\"resolve\",\"resolveTable\",\"context\",\"index\",\"inHead\",\"inDelimiterRow\",\"inRow\",\"contentStart\",\"contentEnd\",\"cellStart\",\"seenCellInRow\",\"token\",\"content\",\"end\",\"text\",\"contentType\",\"splice\",\"cell\",\"tokenizeNextPrefixedOrBlank\",\"whitespace\",\"size\"]\n}\n"]