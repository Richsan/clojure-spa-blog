["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-core-commonmark/lib/code-text.js"],"~:js","shadow$provide.module$node_modules$micromark_core_commonmark$lib$code_text=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.codeText=void 0;var _micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\");exports.codeText={name:\"codeText\",tokenize:function(effects,ok,nok){function openingSequence(code){if(96===code)return effects.consume(code),sizeOpen++,openingSequence;effects.exit(\"codeTextSequence\");return gap(code)}\nfunction gap(code){if(null===code)return nok(code);if(96===code)return token=effects.enter(\"codeTextSequence\"),size=0,closingSequence(code);if(32===code)return effects.enter(\"space\"),effects.consume(code),effects.exit(\"space\"),gap;if((0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.enter(\"lineEnding\"),effects.consume(code),effects.exit(\"lineEnding\"),gap;effects.enter(\"codeTextData\");return data(code)}function data(code){if(null===code||32===code||96===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.exit(\"codeTextData\"),\ngap(code);effects.consume(code);return data}function closingSequence(code){if(96===code)return effects.consume(code),size++,closingSequence;if(size===sizeOpen)return effects.exit(\"codeTextSequence\"),effects.exit(\"codeText\"),ok(code);token.type=\"codeTextData\";return data(code)}let sizeOpen=0,size,token;return function(code){effects.enter(\"codeText\");effects.enter(\"codeTextSequence\");return openingSequence(code)}},resolve:function(events){let tailExitIndex=events.length-4,headEnterIndex=3,index,enter;\nif(!(\"lineEnding\"!==events[headEnterIndex][1].type&&\"space\"!==events[headEnterIndex][1].type||\"lineEnding\"!==events[tailExitIndex][1].type&&\"space\"!==events[tailExitIndex][1].type))for(index=headEnterIndex;++index<tailExitIndex;)if(\"codeTextData\"===events[index][1].type){events[headEnterIndex][1].type=\"codeTextPadding\";events[tailExitIndex][1].type=\"codeTextPadding\";headEnterIndex+=2;tailExitIndex-=2;break}index=headEnterIndex-1;for(tailExitIndex++;++index<=tailExitIndex;)if(void 0===enter)index!==\ntailExitIndex&&\"lineEnding\"!==events[index][1].type&&(enter=index);else if(index===tailExitIndex||\"lineEnding\"===events[index][1].type)events[enter][1].type=\"codeTextData\",index!==enter+2&&(events[enter][1].end=events[index-1][1].end,events.splice(enter+2,index-enter-2),tailExitIndex-=index-enter-2,index=enter+2),enter=void 0;return events},previous:function(code){return 96!==code||\"characterEscape\"===this.events[this.events.length-1][1].type}}}","~:source","shadow$provide[\"module$node_modules$micromark_core_commonmark$lib$code_text\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.codeText = void 0;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\n\n/** @type {Construct} */\nconst codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous\n};\n/** @type {Resolver} */\n\nexports.codeText = codeText;\n\nfunction resolveCodeText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n\n  let index;\n  /** @type {number|undefined} */\n\n  let enter; // If we start and end with an EOL or a space.\n\n  if ((events[headEnterIndex][1].type === 'lineEnding' || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === 'lineEnding' || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex; // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'codeTextData') {\n        // Then we have padding.\n        events[headEnterIndex][1].type = 'codeTextPadding';\n        events[tailExitIndex][1].type = 'codeTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === 'lineEnding') {\n      events[enter][1].type = 'codeTextData';\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n\n      enter = undefined;\n    }\n  }\n\n  return events;\n}\n/** @type {Previous} */\n\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 96 || this.events[this.events.length - 1][1].type === 'characterEscape';\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeCodeText(effects, ok, nok) {\n  const self = this;\n  let sizeOpen = 0;\n  /** @type {number} */\n\n  let size;\n  /** @type {Token} */\n\n  let token;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeText');\n    effects.enter('codeTextSequence');\n    return openingSequence(code);\n  }\n  /** @type {State} */\n\n\n  function openingSequence(code) {\n    if (code === 96) {\n      effects.consume(code);\n      sizeOpen++;\n      return openingSequence;\n    }\n\n    effects.exit('codeTextSequence');\n    return gap(code);\n  }\n  /** @type {State} */\n\n\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code);\n    } // Closing fence?\n    // Could also be data.\n\n\n    if (code === 96) {\n      token = effects.enter('codeTextSequence');\n      size = 0;\n      return closingSequence(code);\n    } // Tabs don’t work, and virtual spaces don’t make sense.\n\n\n    if (code === 32) {\n      effects.enter('space');\n      effects.consume(code);\n      effects.exit('space');\n      return gap;\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return gap;\n    } // Data.\n\n\n    effects.enter('codeTextData');\n    return data(code);\n  } // In code.\n\n  /** @type {State} */\n\n\n  function data(code) {\n    if (code === null || code === 32 || code === 96 || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      effects.exit('codeTextData');\n      return gap(code);\n    }\n\n    effects.consume(code);\n    return data;\n  } // Closing fence.\n\n  /** @type {State} */\n\n\n  function closingSequence(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code);\n      size++;\n      return closingSequence;\n    } // Done!\n\n\n    if (size === sizeOpen) {\n      effects.exit('codeTextSequence');\n      effects.exit('codeText');\n      return ok(code);\n    } // More or less accents: mark as data.\n\n\n    token.type = 'codeTextData';\n    return data(code);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js"]],"~:properties",["^5",["resolve","tokenize","__esModule","name","value","previous","codeText","type","end"]],"~:compiled-at",1676665867282,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_core_commonmark$lib$code_text.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-core-commonmark/lib/code-text.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_core_commonmark$lib$code_text\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.codeText = void 0;\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').Resolver} Resolver\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').Previous} Previous\\n * @typedef {import('micromark-util-types').Token} Token\\n * @typedef {import('micromark-util-types').State} State\\n */\\n\\n/** @type {Construct} */\\nconst codeText = {\\n  name: 'codeText',\\n  tokenize: tokenizeCodeText,\\n  resolve: resolveCodeText,\\n  previous\\n};\\n/** @type {Resolver} */\\n\\nexports.codeText = codeText;\\n\\nfunction resolveCodeText(events) {\\n  let tailExitIndex = events.length - 4;\\n  let headEnterIndex = 3;\\n  /** @type {number} */\\n\\n  let index;\\n  /** @type {number|undefined} */\\n\\n  let enter; // If we start and end with an EOL or a space.\\n\\n  if ((events[headEnterIndex][1].type === 'lineEnding' || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === 'lineEnding' || events[tailExitIndex][1].type === 'space')) {\\n    index = headEnterIndex; // And we have data.\\n\\n    while (++index < tailExitIndex) {\\n      if (events[index][1].type === 'codeTextData') {\\n        // Then we have padding.\\n        events[headEnterIndex][1].type = 'codeTextPadding';\\n        events[tailExitIndex][1].type = 'codeTextPadding';\\n        headEnterIndex += 2;\\n        tailExitIndex -= 2;\\n        break;\\n      }\\n    }\\n  } // Merge adjacent spaces and data.\\n\\n\\n  index = headEnterIndex - 1;\\n  tailExitIndex++;\\n\\n  while (++index <= tailExitIndex) {\\n    if (enter === undefined) {\\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\\n        enter = index;\\n      }\\n    } else if (index === tailExitIndex || events[index][1].type === 'lineEnding') {\\n      events[enter][1].type = 'codeTextData';\\n\\n      if (index !== enter + 2) {\\n        events[enter][1].end = events[index - 1][1].end;\\n        events.splice(enter + 2, index - enter - 2);\\n        tailExitIndex -= index - enter - 2;\\n        index = enter + 2;\\n      }\\n\\n      enter = undefined;\\n    }\\n  }\\n\\n  return events;\\n}\\n/** @type {Previous} */\\n\\n\\nfunction previous(code) {\\n  // If there is a previous code, there will always be a tail.\\n  return code !== 96 || this.events[this.events.length - 1][1].type === 'characterEscape';\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeCodeText(effects, ok, nok) {\\n  const self = this;\\n  let sizeOpen = 0;\\n  /** @type {number} */\\n\\n  let size;\\n  /** @type {Token} */\\n\\n  let token;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('codeText');\\n    effects.enter('codeTextSequence');\\n    return openingSequence(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function openingSequence(code) {\\n    if (code === 96) {\\n      effects.consume(code);\\n      sizeOpen++;\\n      return openingSequence;\\n    }\\n\\n    effects.exit('codeTextSequence');\\n    return gap(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function gap(code) {\\n    // EOF.\\n    if (code === null) {\\n      return nok(code);\\n    } // Closing fence?\\n    // Could also be data.\\n\\n\\n    if (code === 96) {\\n      token = effects.enter('codeTextSequence');\\n      size = 0;\\n      return closingSequence(code);\\n    } // Tabs don\\u2019t work, and virtual spaces don\\u2019t make sense.\\n\\n\\n    if (code === 32) {\\n      effects.enter('space');\\n      effects.consume(code);\\n      effects.exit('space');\\n      return gap;\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.enter('lineEnding');\\n      effects.consume(code);\\n      effects.exit('lineEnding');\\n      return gap;\\n    } // Data.\\n\\n\\n    effects.enter('codeTextData');\\n    return data(code);\\n  } // In code.\\n\\n  /** @type {State} */\\n\\n\\n  function data(code) {\\n    if (code === null || code === 32 || code === 96 || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      effects.exit('codeTextData');\\n      return gap(code);\\n    }\\n\\n    effects.consume(code);\\n    return data;\\n  } // Closing fence.\\n\\n  /** @type {State} */\\n\\n\\n  function closingSequence(code) {\\n    // More.\\n    if (code === 96) {\\n      effects.consume(code);\\n      size++;\\n      return closingSequence;\\n    } // Done!\\n\\n\\n    if (size === sizeOpen) {\\n      effects.exit('codeTextSequence');\\n      effects.exit('codeText');\\n      return ok(code);\\n    } // More or less accents: mark as data.\\n\\n\\n    token.type = 'codeTextData';\\n    return data(code);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"codeText\",\"_micromarkUtilCharacter\",\"name\",\"tokenize\",\"tokenizeCodeText\",\"effects\",\"ok\",\"nok\",\"openingSequence\",\"code\",\"consume\",\"sizeOpen\",\"exit\",\"gap\",\"token\",\"enter\",\"size\",\"closingSequence\",\"markdownLineEnding\",\"data\",\"type\",\"start\",\"resolve\",\"resolveCodeText\",\"events\",\"tailExitIndex\",\"length\",\"headEnterIndex\",\"index\",\"undefined\",\"end\",\"splice\",\"previous\"]\n}\n"]