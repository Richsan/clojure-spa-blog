["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/sml.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$sml=function(global,require,module,exports){function sml(Prism$jscomp$0){(function(Prism){var keywords=/\\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\b/i;Prism.languages.sml={comment:/\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*)|\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*))*\\*\\))*\\*\\)/,\nstring:{pattern:/#?\"(?:[^\"\\\\]|\\\\.)*\"/,greedy:!0},\"class-name\":[{pattern:RegExp(/((?:^|[^:]):\\s*)<TERMINAL>(?:\\s*(?:(?:\\*|->)\\s*<TERMINAL>|,\\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g,function(){return/\\s*(?:[*,]|->)/.source}).replace(/<TERMINAL>/g,function(){return/(?:'[\\w']*|<LONG-ID>|\\((?:[^()]|\\([^()]*\\))*\\)|\\{(?:[^{}]|\\{[^{}]*\\})*\\})(?:\\s+<LONG-ID>)*/.source}).replace(/<LONG-ID>/g,function(){return/(?!<KEYWORD>)[a-z\\d_][\\w'.]*/.source}).replace(/<KEYWORD>/g,\nfunction(){return keywords.source}),\"i\"),lookbehind:!0,greedy:!0,inside:null},{pattern:/((?:^|[^\\w'])(?:datatype|exception|functor|signature|structure|type)\\s+)[a-z_][\\w'.]*/i,lookbehind:!0}],function:{pattern:/((?:^|[^\\w'])fun\\s+)[a-z_][\\w'.]*/i,lookbehind:!0},keyword:keywords,variable:{pattern:/(^|[^\\w'])'[\\w']*/,lookbehind:!0},number:/~?\\b(?:\\d+(?:\\.\\d+)?(?:e~?\\d+)?|0x[\\da-f]+)\\b/i,word:{pattern:/\\b0w(?:\\d+|x[\\da-f]+)\\b/i,alias:\"constant\"},boolean:/\\b(?:false|true)\\b/i,operator:/\\.\\.\\.|:[>=:]|=>?|->|[<>]=?|[!+\\-*/^#|@~]/,\npunctuation:/[(){}\\[\\].:,;]/};Prism.languages.sml[\"class-name\"][0].inside=Prism.languages.sml;Prism.languages.smlnj=Prism.languages.sml})(Prism$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=sml;sml.displayName=\"sml\";sml.aliases=[\"smlnj\"]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$sml\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = sml;\n// @ts-nocheck\nsml.displayName = 'sml';\nsml.aliases = ['smlnj'];\n/** @type {import('../core.js').Syntax} */\n\nfunction sml(Prism) {\n  // https://smlfamily.github.io/sml97-defn.pdf\n  // https://people.mpi-sws.org/~rossberg/sml.html\n  ;\n\n  (function (Prism) {\n    var keywords = /\\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\b/i;\n    Prism.languages.sml = {\n      // allow one level of nesting\n      comment: /\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*)|\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*))*\\*\\))*\\*\\)/,\n      string: {\n        pattern: /#?\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true\n      },\n      'class-name': [{\n        // This is only an approximation since the real grammar is context-free\n        //\n        // Why the main loop so complex?\n        // The main loop is approximately the same as /(?:\\s*(?:[*,]|->)\\s*<TERMINAL>)*/ which is, obviously, a lot\n        // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be\n        // followed by a long identifier.\n        pattern: RegExp(/((?:^|[^:]):\\s*)<TERMINAL>(?:\\s*(?:(?:\\*|->)\\s*<TERMINAL>|,\\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function () {\n          return /\\s*(?:[*,]|->)/.source;\n        }).replace(/<TERMINAL>/g, function () {\n          return /(?:'[\\w']*|<LONG-ID>|\\((?:[^()]|\\([^()]*\\))*\\)|\\{(?:[^{}]|\\{[^{}]*\\})*\\})(?:\\s+<LONG-ID>)*/.source;\n        }).replace(/<LONG-ID>/g, function () {\n          return /(?!<KEYWORD>)[a-z\\d_][\\w'.]*/.source;\n        }).replace(/<KEYWORD>/g, function () {\n          return keywords.source;\n        }), 'i'),\n        lookbehind: true,\n        greedy: true,\n        inside: null // see below\n\n      }, {\n        pattern: /((?:^|[^\\w'])(?:datatype|exception|functor|signature|structure|type)\\s+)[a-z_][\\w'.]*/i,\n        lookbehind: true\n      }],\n      function: {\n        pattern: /((?:^|[^\\w'])fun\\s+)[a-z_][\\w'.]*/i,\n        lookbehind: true\n      },\n      keyword: keywords,\n      variable: {\n        pattern: /(^|[^\\w'])'[\\w']*/,\n        lookbehind: true\n      },\n      number: /~?\\b(?:\\d+(?:\\.\\d+)?(?:e~?\\d+)?|0x[\\da-f]+)\\b/i,\n      word: {\n        pattern: /\\b0w(?:\\d+|x[\\da-f]+)\\b/i,\n        alias: 'constant'\n      },\n      boolean: /\\b(?:false|true)\\b/i,\n      operator: /\\.\\.\\.|:[>=:]|=>?|->|[<>]=?|[!+\\-*/^#|@~]/,\n      punctuation: /[(){}\\[\\].:,;]/\n    };\n    Prism.languages.sml['class-name'][0].inside = Prism.languages.sml;\n    Prism.languages.smlnj = Prism.languages.sml;\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["boolean","punctuation","word","string","aliases","operator","displayName","__esModule","sml","lookbehind","value","variable","keyword","number","greedy","function","pattern","inside","smlnj","alias","comment","default"]],"~:compiled-at",1676841365461,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$sml.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAA,sCAAA,CAA2D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAYnGC,QAASA,IAAG,CAACC,cAAD,CAAQ,CAKjB,SAAS,CAACA,KAAD,CAAQ,CAChB,IAAIC,SAAW,yPACfD,MAAME,CAAAA,SAAUH,CAAAA,GAAhB,CAAsB,CAEpBI,QAAS,2EAFW;AAGpBC,OAAQ,CACNC,QAAS,qBADH,CAENC,OAAQ,CAAA,CAFF,CAHY,CAOpB,aAAc,CAAC,CAObD,QAASE,MAAA,CAAO,0HAA2HC,CAAAA,MAAOC,CAAAA,OAAlI,CAA0I,aAA1I,CAAyJ,QAAS,EAAG,CACnL,MAAO,gBAAiBD,CAAAA,MAD2J,CAArK,CAEbC,CAAAA,OAFa,CAEL,aAFK,CAEU,QAAS,EAAG,CACpC,MAAO,4FAA6FD,CAAAA,MADhE,CAFtB,CAIbC,CAAAA,OAJa,CAIL,YAJK,CAIS,QAAS,EAAG,CACnC,MAAO,8BAA+BD,CAAAA,MADH,CAJrB,CAMbC,CAAAA,OANa,CAML,YANK;AAMS,QAAS,EAAG,CACnC,MAAOR,SAASO,CAAAA,MADmB,CANrB,CAAP,CAQL,GARK,CAPI,CAgBbE,WAAY,CAAA,CAhBC,CAiBbJ,OAAQ,CAAA,CAjBK,CAkBbK,OAAQ,IAlBK,CAAD,CAoBX,CACDN,QAAS,wFADR,CAEDK,WAAY,CAAA,CAFX,CApBW,CAPM,CA+BpBE,SAAU,CACRP,QAAS,oCADD,CAERK,WAAY,CAAA,CAFJ,CA/BU,CAmCpBG,QAASZ,QAnCW,CAoCpBa,SAAU,CACRT,QAAS,mBADD,CAERK,WAAY,CAAA,CAFJ,CApCU,CAwCpBK,OAAQ,gDAxCY,CAyCpBC,KAAM,CACJX,QAAS,0BADL,CAEJY,MAAO,UAFH,CAzCc,CA6CpBC,QAAS,qBA7CW,CA8CpBC,SAAU,2CA9CU;AA+CpBC,YAAa,gBA/CO,CAiDtBpB,MAAME,CAAAA,SAAUH,CAAAA,GAAhB,CAAoB,YAApB,CAAA,CAAkC,CAAlC,CAAqCY,CAAAA,MAArC,CAA8CX,KAAME,CAAAA,SAAUH,CAAAA,GAC9DC,MAAME,CAAAA,SAAUmB,CAAAA,KAAhB,CAAwBrB,KAAME,CAAAA,SAAUH,CAAAA,GApDxB,CAAjB,CAAD,CAqDGC,cArDH,CALkB,CATpBsB,MAAOC,CAAAA,cAAP,CAAsBzB,OAAtB,CAA+B,YAA/B,CAA6C,CAC3C0B,MAAO,CAAA,CADoC,CAA7C,CAGA1B,QAAQ2B,CAAAA,OAAR,CAAkB1B,GAElBA,IAAI2B,CAAAA,WAAJ,CAAkB,KAClB3B,IAAI4B,CAAAA,OAAJ,CAAc,CAAC,OAAD,CATqF;\",\n\"sources\":[\"node_modules/refractor/lang/sml.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$sml\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = sml;\\n// @ts-nocheck\\nsml.displayName = 'sml';\\nsml.aliases = ['smlnj'];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction sml(Prism) {\\n  // https://smlfamily.github.io/sml97-defn.pdf\\n  // https://people.mpi-sws.org/~rossberg/sml.html\\n  ;\\n\\n  (function (Prism) {\\n    var keywords = /\\\\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\\\b/i;\\n    Prism.languages.sml = {\\n      // allow one level of nesting\\n      comment: /\\\\(\\\\*(?:[^*(]|\\\\*(?!\\\\))|\\\\((?!\\\\*)|\\\\(\\\\*(?:[^*(]|\\\\*(?!\\\\))|\\\\((?!\\\\*))*\\\\*\\\\))*\\\\*\\\\)/,\\n      string: {\\n        pattern: /#?\\\"(?:[^\\\"\\\\\\\\]|\\\\\\\\.)*\\\"/,\\n        greedy: true\\n      },\\n      'class-name': [{\\n        // This is only an approximation since the real grammar is context-free\\n        //\\n        // Why the main loop so complex?\\n        // The main loop is approximately the same as /(?:\\\\s*(?:[*,]|->)\\\\s*<TERMINAL>)*/ which is, obviously, a lot\\n        // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be\\n        // followed by a long identifier.\\n        pattern: RegExp(/((?:^|[^:]):\\\\s*)<TERMINAL>(?:\\\\s*(?:(?:\\\\*|->)\\\\s*<TERMINAL>|,\\\\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\\\\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function () {\\n          return /\\\\s*(?:[*,]|->)/.source;\\n        }).replace(/<TERMINAL>/g, function () {\\n          return /(?:'[\\\\w']*|<LONG-ID>|\\\\((?:[^()]|\\\\([^()]*\\\\))*\\\\)|\\\\{(?:[^{}]|\\\\{[^{}]*\\\\})*\\\\})(?:\\\\s+<LONG-ID>)*/.source;\\n        }).replace(/<LONG-ID>/g, function () {\\n          return /(?!<KEYWORD>)[a-z\\\\d_][\\\\w'.]*/.source;\\n        }).replace(/<KEYWORD>/g, function () {\\n          return keywords.source;\\n        }), 'i'),\\n        lookbehind: true,\\n        greedy: true,\\n        inside: null // see below\\n\\n      }, {\\n        pattern: /((?:^|[^\\\\w'])(?:datatype|exception|functor|signature|structure|type)\\\\s+)[a-z_][\\\\w'.]*/i,\\n        lookbehind: true\\n      }],\\n      function: {\\n        pattern: /((?:^|[^\\\\w'])fun\\\\s+)[a-z_][\\\\w'.]*/i,\\n        lookbehind: true\\n      },\\n      keyword: keywords,\\n      variable: {\\n        pattern: /(^|[^\\\\w'])'[\\\\w']*/,\\n        lookbehind: true\\n      },\\n      number: /~?\\\\b(?:\\\\d+(?:\\\\.\\\\d+)?(?:e~?\\\\d+)?|0x[\\\\da-f]+)\\\\b/i,\\n      word: {\\n        pattern: /\\\\b0w(?:\\\\d+|x[\\\\da-f]+)\\\\b/i,\\n        alias: 'constant'\\n      },\\n      boolean: /\\\\b(?:false|true)\\\\b/i,\\n      operator: /\\\\.\\\\.\\\\.|:[>=:]|=>?|->|[<>]=?|[!+\\\\-*/^#|@~]/,\\n      punctuation: /[(){}\\\\[\\\\].:,;]/\\n    };\\n    Prism.languages.sml['class-name'][0].inside = Prism.languages.sml;\\n    Prism.languages.smlnj = Prism.languages.sml;\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"sml\",\"Prism\",\"keywords\",\"languages\",\"comment\",\"string\",\"pattern\",\"greedy\",\"RegExp\",\"source\",\"replace\",\"lookbehind\",\"inside\",\"function\",\"keyword\",\"variable\",\"number\",\"word\",\"alias\",\"boolean\",\"operator\",\"punctuation\",\"smlnj\",\"Object\",\"defineProperty\",\"value\",\"default\",\"displayName\",\"aliases\"]\n}\n"]