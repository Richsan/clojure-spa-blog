["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/unist-util-visit-parents/lib/index.js"],"~:js","shadow$provide.module$node_modules$unist_util_visit_parents$lib$index=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.visitParents=exports.SKIP=exports.EXIT=exports.CONTINUE=void 0;var _unistUtilIs=require(\"module$node_modules$unist_util_is$index\"),_color=require(\"module$node_modules$unist_util_visit_parents$lib$color_browser\");exports.CONTINUE=!0;exports.EXIT=!1;exports.SKIP=\"skip\";exports.visitParents=function(tree,test,visitor,reverse){function factory(node,\nindex,parents){function visit(){var result=[];let subresult,offset,grandparents;if(!test||is(node,index,parents[parents.length-1]||null))if(result=visitor(node,parents),result=Array.isArray(result)?result:\"number\"===typeof result?[!0,result]:[result],!1===result[0])return result;if(node.children&&\"skip\"!==result[0])for(offset=(reverse?node.children.length:-1)+step,grandparents=parents.concat(node);-1<offset&&offset<node.children.length;){subresult=factory(node.children[offset],offset,grandparents)();\nif(!1===subresult[0])return subresult;offset=\"number\"===typeof subresult[1]?subresult[1]:offset+step}return result}var value=node&&\"object\"===typeof node?node:{};\"string\"===typeof value.type&&(value=\"string\"===typeof value.tagName?value.tagName:\"string\"===typeof value.name?value.name:void 0,Object.defineProperty(visit,\"name\",{value:\"node (\"+(0,_color.color)(node.type+(value?\"\\x3c\"+value+\"\\x3e\":\"\"))+\")\"}));return visit}\"function\"===typeof test&&\"function\"!==typeof visitor&&(reverse=visitor,visitor=\ntest,test=null);const is=(0,_unistUtilIs.convert)(test),step=reverse?-1:1;factory(tree,void 0,[])()}}","~:source","shadow$provide[\"module$node_modules$unist_util_visit_parents$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visitParents = exports.SKIP = exports.EXIT = exports.CONTINUE = void 0;\n\nvar _unistUtilIs = require(\"unist-util-is\");\n\nvar _color = require(\"./color.js\");\n\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\n/**\n * Continue traversing as normal.\n */\nconst CONTINUE = true;\n/**\n * Stop traversing immediately.\n */\n\nexports.CONTINUE = CONTINUE;\nconst EXIT = false;\n/**\n * Do not traverse this nodeâ€™s children.\n */\n\nexports.EXIT = EXIT;\nconst SKIP = 'skip';\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\n\nexports.SKIP = SKIP;\n\nconst visitParents =\n/**\n * @param {Node} tree\n * @param {Test} test\n * @param {Visitor<Node>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {void}\n */\nfunction (tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor; // @ts-expect-error no visitor given, so `visitor` is test.\n\n    visitor = test;\n    test = null;\n  }\n\n  const is = (0, _unistUtilIs.convert)(test);\n  const step = reverse ? -1 : 1;\n  factory(tree, undefined, [])();\n  /**\n   * @param {Node} node\n   * @param {number | undefined} index\n   * @param {Array<Parent>} parents\n   */\n\n  function factory(node, index, parents) {\n    /** @type {Record<string, unknown>} */\n    // @ts-expect-error: hush\n    const value = node && typeof node === 'object' ? node : {};\n\n    if (typeof value.type === 'string') {\n      const name = // `hast`\n      typeof value.tagName === 'string' ? value.tagName : // `xast`\n      typeof value.name === 'string' ? value.name : undefined;\n      Object.defineProperty(visit, 'name', {\n        value: 'node (' + (0, _color.color)(node.type + (name ? '<' + name + '>' : '')) + ')'\n      });\n    }\n\n    return visit;\n\n    function visit() {\n      /** @type {ActionTuple} */\n      let result = [];\n      /** @type {ActionTuple} */\n\n      let subresult;\n      /** @type {number} */\n\n      let offset;\n      /** @type {Array<Parent>} */\n\n      let grandparents;\n\n      if (!test || is(node, index, parents[parents.length - 1] || null)) {\n        result = toResult(visitor(node, parents));\n\n        if (result[0] === EXIT) {\n          return result;\n        }\n      } // @ts-expect-error looks like a parent.\n\n\n      if (node.children && result[0] !== SKIP) {\n        // @ts-expect-error looks like a parent.\n        offset = (reverse ? node.children.length : -1) + step; // @ts-expect-error looks like a parent.\n\n        grandparents = parents.concat(node); // @ts-expect-error looks like a parent.\n\n        while (offset > -1 && offset < node.children.length) {\n          // @ts-expect-error looks like a parent.\n          subresult = factory(node.children[offset], offset, grandparents)();\n\n          if (subresult[0] === EXIT) {\n            return subresult;\n          }\n\n          offset = typeof subresult[1] === 'number' ? subresult[1] : offset + step;\n        }\n      }\n\n      return result;\n    }\n  }\n};\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\n\n\nexports.visitParents = visitParents;\n\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value];\n  }\n\n  return [value];\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$unist_util_visit_parents$lib$color_browser","~$shadow.js","~$module$node_modules$unist_util_is$index"]],"~:properties",["^5",["CONTINUE","__esModule","visitParents","name","SKIP","value","EXIT"]],"~:compiled-at",1676665867319,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$unist_util_visit_parents$lib$index.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAA,sDAAA,CAA2E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGnHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,YAAR,CAAuBJ,OAAQK,CAAAA,IAA/B,CAAsCL,OAAQM,CAAAA,IAA9C,CAAqDN,OAAQO,CAAAA,QAA7D,CAAwE,IAAK,EAE7E,KAAIC,aAAeV,OAAA,CAAQ,yCAAR,CAAnB,CAEIW,OAASX,OAAA,CAAQ,gEAAR,CAoFbE,QAAQO,CAAAA,QAAR,CALiBA,CAAAA,CAWjBP,QAAQM,CAAAA,IAAR,CALaA,CAAAA,CAqCbN,QAAQK,CAAAA,IAAR,CA/BaA,MAgIbL,QAAQI,CAAAA,YAAR,CAvFAA,QAAS,CAACM,IAAD,CAAOC,IAAP,CAAaC,OAAb,CAAsBC,OAAtB,CAA+B,CAiBtCC,QAASA,QAAO,CAACC,IAAD;AAAOC,KAAP,CAAcC,OAAd,CAAuB,CAgBrCC,QAASA,MAAK,EAAG,CAEf,IAAIC,OAAS,EAGb,KAAIC,SAAJ,CAGIC,MAHJ,CAMIC,YAEJ,IAAI,CAACX,IAAL,EAAaY,EAAA,CAAGR,IAAH,CAASC,KAAT,CAAgBC,OAAA,CAAQA,OAAQO,CAAAA,MAAhB,CAAyB,CAAzB,CAAhB,EAA+C,IAA/C,CAAb,CAGE,GAFkB,MAEd,CAFcZ,OAAA,CAAQG,IAAR,CAAcE,OAAd,CAEd,CA0CR,MA1CQ,CAyCNQ,KAAMC,CAAAA,OAAN,CAAcvB,MAAd,CAAJ,CACSA,MADT,CAIqB,QAArB,GAAI,MAAOA,OAAX,CACS,CApJMI,CAAAA,CAoJN,CAAWJ,MAAX,CADT,CAIO,CAACA,MAAD,CAjDG,CAhGCG,CAAAA,CAgGD,GAAAa,MAAA,CAAO,CAAP,CAAJ,CACE,MAAOA,OAKX,IAAIJ,IAAKY,CAAAA,QAAT,EAhGOtB,MAgGP,GAAqBc,MAAA,CAAO,CAAP,CAArB,CAME,IAJAE,MAEA,EAFUR,OAAA,CAAUE,IAAKY,CAAAA,QAASH,CAAAA,MAAxB,CAAiC,CAAC,CAE5C,EAFiDI,IAEjD,CAAAN,YAAA,CAAeL,OAAQY,CAAAA,MAAR,CAAed,IAAf,CAEf,CAAgB,CAAC,CAAjB,CAAOM,MAAP,EAAsBA,MAAtB,CAA+BN,IAAKY,CAAAA,QAASH,CAAAA,MAA7C,CAAA,CAAqD,CAEnDJ,SAAA,CAAYN,OAAA,CAAQC,IAAKY,CAAAA,QAAL,CAAcN,MAAd,CAAR,CAA+BA,MAA/B,CAAuCC,YAAvC,CAAA,EAEZ;GAhHGhB,CAAAA,CAgHH,GAAIc,SAAA,CAAU,CAAV,CAAJ,CACE,MAAOA,UAGTC,OAAA,CAAiC,QAAxB,GAAA,MAAOD,UAAA,CAAU,CAAV,CAAP,CAAmCA,SAAA,CAAU,CAAV,CAAnC,CAAkDC,MAAlD,CAA2DO,IARjB,CAYvD,MAAOT,OAxCQ,CAbjB,IAAMhB,MAAQY,IAAA,EAAwB,QAAxB,GAAQ,MAAOA,KAAf,CAAmCA,IAAnC,CAA0C,EAE9B,SAA1B,GAAI,MAAOZ,MAAM2B,CAAAA,IAAjB,GACQC,KAGN,CAFyB,QAAzB,GAAA,MAAO5B,MAAM6B,CAAAA,OAAb,CAAoC7B,KAAM6B,CAAAA,OAA1C,CACsB,QAAtB,GAAA,MAAO7B,MAAM4B,CAAAA,IAAb,CAAiC5B,KAAM4B,CAAAA,IAAvC,CAA8CE,IAAAA,EAC9C,CAAAhC,MAAOC,CAAAA,cAAP,CAAsBgB,KAAtB,CAA6B,MAA7B,CAAqC,CACnCf,MAAO,QAAPA,CAAkB,GAAIM,MAAOyB,CAAAA,KAAX,EAAkBnB,IAAKe,CAAAA,IAAvB,EAA+BC,KAAA,CAAO,MAAP,CAAaA,KAAb,CAAoB,MAApB,CAA0B,EAAzD,EAAlB5B,CAAkF,GAD/C,CAArC,CAJF,CASA,OAAOe,MAd8B,CAhBnB,UAApB,GAAI,MAAOP,KAAX,EAAqD,UAArD,GAAkC,MAAOC,QAAzC,GACEC,OAGA,CAHUD,OAGV,CADAA,OACA;AADUD,IACV,CAAAA,IAAA,CAAO,IAJT,CAOA,OAAMY,GAAK,GAAIf,YAAa2B,CAAAA,OAAjB,EAA0BxB,IAA1B,CAAX,CACMiB,KAAOf,OAAA,CAAU,CAAC,CAAX,CAAe,CAC5BC,QAAA,CAAQJ,IAAR,CAAcuB,IAAAA,EAAd,CAAyB,EAAzB,CAAA,EAVsC,CA9I2E;\",\n\"sources\":[\"node_modules/unist-util-visit-parents/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$unist_util_visit_parents$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.visitParents = exports.SKIP = exports.EXIT = exports.CONTINUE = void 0;\\n\\nvar _unistUtilIs = require(\\\"unist-util-is\\\");\\n\\nvar _color = require(\\\"./color.js\\\");\\n\\n/**\\n * @typedef {import('unist').Node} Node\\n * @typedef {import('unist').Parent} Parent\\n * @typedef {import('unist-util-is').Test} Test\\n */\\n\\n/**\\n * @typedef {boolean | 'skip'} Action\\n *   Union of the action types.\\n *\\n * @typedef {number} Index\\n *   Move to the sibling at `index` next (after node itself is completely\\n *   traversed).\\n *\\n *   Useful if mutating the tree, such as removing the node the visitor is\\n *   currently on, or any of its previous siblings.\\n *   Results less than 0 or greater than or equal to `children.length` stop\\n *   traversing the parent.\\n *\\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\\n *   List with one or two values, the first an action, the second an index.\\n *\\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\\n *   Any value that can be returned from a visitor.\\n */\\n\\n/**\\n * @template {Node} [Visited=Node]\\n *   Visited node type.\\n * @template {Parent} [Ancestor=Parent]\\n *   Ancestor type.\\n * @callback Visitor\\n *   Handle a node (matching `test`, if given).\\n *\\n *   Visitors are free to transform `node`.\\n *   They can also transform the parent of node (the last of `ancestors`).\\n *\\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\\n *   descendants to be walked (which is a bug).\\n *\\n *   When adding or removing previous siblings of `node` (or next siblings, in\\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\\n *   sibling to traverse after `node` is traversed.\\n *   Adding or removing next siblings of `node` (or previous siblings, in case\\n *   of reverse) is handled as expected without needing to return a new `Index`.\\n *\\n *   Removing the children property of an ancestor still results in them being\\n *   traversed.\\n * @param {Visited} node\\n *   Found node.\\n * @param {Array<Ancestor>} ancestors\\n *   Ancestors of `node`.\\n * @returns {VisitorResult}\\n *   What to do next.\\n *\\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\\n *   An `Action` is treated as a tuple of `[Action]`.\\n *\\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\\n *   When the `Action` is `EXIT`, that action can be returned.\\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\\n */\\n\\n/**\\n * @template {Node} [Tree=Node]\\n *   Tree type.\\n * @template {Test} [Check=string]\\n *   Test type.\\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\\n *   Build a typed `Visitor` function from a tree and a test.\\n *\\n *   It will infer which values are passed as `node` and which as `parents`.\\n */\\n\\n/**\\n * Continue traversing as normal.\\n */\\nconst CONTINUE = true;\\n/**\\n * Stop traversing immediately.\\n */\\n\\nexports.CONTINUE = CONTINUE;\\nconst EXIT = false;\\n/**\\n * Do not traverse this node\\u2019s children.\\n */\\n\\nexports.EXIT = EXIT;\\nconst SKIP = 'skip';\\n/**\\n * Visit nodes, with ancestral information.\\n *\\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\\n *\\n * You can choose for which nodes `visitor` is called by passing a `test`.\\n * For complex tests, you should test yourself in `visitor`, as it will be\\n * faster and will have improved type information.\\n *\\n * Walking the tree is an intensive task.\\n * Make use of the return values of the visitor when possible.\\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\\n * to check if a node matches, and then perform different operations.\\n *\\n * You can change the tree.\\n * See `Visitor` for more info.\\n *\\n * @param tree\\n *   Tree to traverse.\\n * @param test\\n *   `unist-util-is`-compatible test\\n * @param visitor\\n *   Handle each node.\\n * @param reverse\\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\\n * @returns\\n *   Nothing.\\n */\\n\\nexports.SKIP = SKIP;\\n\\nconst visitParents =\\n/**\\n * @param {Node} tree\\n * @param {Test} test\\n * @param {Visitor<Node>} visitor\\n * @param {boolean | null | undefined} [reverse]\\n * @returns {void}\\n */\\nfunction (tree, test, visitor, reverse) {\\n  if (typeof test === 'function' && typeof visitor !== 'function') {\\n    reverse = visitor; // @ts-expect-error no visitor given, so `visitor` is test.\\n\\n    visitor = test;\\n    test = null;\\n  }\\n\\n  const is = (0, _unistUtilIs.convert)(test);\\n  const step = reverse ? -1 : 1;\\n  factory(tree, undefined, [])();\\n  /**\\n   * @param {Node} node\\n   * @param {number | undefined} index\\n   * @param {Array<Parent>} parents\\n   */\\n\\n  function factory(node, index, parents) {\\n    /** @type {Record<string, unknown>} */\\n    // @ts-expect-error: hush\\n    const value = node && typeof node === 'object' ? node : {};\\n\\n    if (typeof value.type === 'string') {\\n      const name = // `hast`\\n      typeof value.tagName === 'string' ? value.tagName : // `xast`\\n      typeof value.name === 'string' ? value.name : undefined;\\n      Object.defineProperty(visit, 'name', {\\n        value: 'node (' + (0, _color.color)(node.type + (name ? '<' + name + '>' : '')) + ')'\\n      });\\n    }\\n\\n    return visit;\\n\\n    function visit() {\\n      /** @type {ActionTuple} */\\n      let result = [];\\n      /** @type {ActionTuple} */\\n\\n      let subresult;\\n      /** @type {number} */\\n\\n      let offset;\\n      /** @type {Array<Parent>} */\\n\\n      let grandparents;\\n\\n      if (!test || is(node, index, parents[parents.length - 1] || null)) {\\n        result = toResult(visitor(node, parents));\\n\\n        if (result[0] === EXIT) {\\n          return result;\\n        }\\n      } // @ts-expect-error looks like a parent.\\n\\n\\n      if (node.children && result[0] !== SKIP) {\\n        // @ts-expect-error looks like a parent.\\n        offset = (reverse ? node.children.length : -1) + step; // @ts-expect-error looks like a parent.\\n\\n        grandparents = parents.concat(node); // @ts-expect-error looks like a parent.\\n\\n        while (offset > -1 && offset < node.children.length) {\\n          // @ts-expect-error looks like a parent.\\n          subresult = factory(node.children[offset], offset, grandparents)();\\n\\n          if (subresult[0] === EXIT) {\\n            return subresult;\\n          }\\n\\n          offset = typeof subresult[1] === 'number' ? subresult[1] : offset + step;\\n        }\\n      }\\n\\n      return result;\\n    }\\n  }\\n};\\n/**\\n * Turn a return value into a clean result.\\n *\\n * @param {VisitorResult} value\\n *   Valid return values from visitors.\\n * @returns {ActionTuple}\\n *   Clean result.\\n */\\n\\n\\nexports.visitParents = visitParents;\\n\\nfunction toResult(value) {\\n  if (Array.isArray(value)) {\\n    return value;\\n  }\\n\\n  if (typeof value === 'number') {\\n    return [CONTINUE, value];\\n  }\\n\\n  return [value];\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"visitParents\",\"SKIP\",\"EXIT\",\"CONTINUE\",\"_unistUtilIs\",\"_color\",\"tree\",\"test\",\"visitor\",\"reverse\",\"factory\",\"node\",\"index\",\"parents\",\"visit\",\"result\",\"subresult\",\"offset\",\"grandparents\",\"is\",\"length\",\"Array\",\"isArray\",\"children\",\"step\",\"concat\",\"type\",\"name\",\"tagName\",\"undefined\",\"color\",\"convert\"]\n}\n"]