["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hast-util-is-element/index.js"],"~:js","shadow$provide.module$node_modules$hast_util_is_element$index=function(global,require,module,exports){function anyFactory(tests){const checks=[];let index$jscomp$0=-1;for(;++index$jscomp$0<tests.length;)checks[index$jscomp$0]=convertElement(tests[index$jscomp$0]);return castFactory(function(...parameters){let index=-1;for(;++index<checks.length;)if(checks[index].call(this,...parameters))return!0;return!1})}function tagNameFactory(check){return function(node){return element(node)&&node.tagName===check}}\nfunction castFactory(check){return function(node,...parameters){return element(node)&&!!check.call(this,node,...parameters)}}function element(node){return!(!node||\"object\"!==typeof node||\"element\"!==node.type||\"string\"!==typeof node.tagName)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.convertElement=exports.isElement=void 0;exports.isElement=function(node,test,index,parent,context){test=convertElement(test);if(void 0!==index&&null!==index&&(\"number\"!==typeof index||0>index||index===\nNumber.POSITIVE_INFINITY))throw Error(\"Expected positive finite index for child node\");if(!(void 0===parent||null===parent||parent.type&&parent.children))throw Error(\"Expected parent node\");if(!node||!node.type||\"string\"!==typeof node.type)return!1;if((void 0===parent||null===parent)!==(void 0===index||null===index))throw Error(\"Expected both parent and index\");return test.call(context,node,index,parent)};const convertElement=function(test){if(void 0===test||null===test)return element;if(\"string\"===\ntypeof test)return tagNameFactory(test);if(\"object\"===typeof test)return anyFactory(test);if(\"function\"===typeof test)return castFactory(test);throw Error(\"Expected function, string, or array as test\");};exports.convertElement=convertElement}","~:source","shadow$provide[\"module$node_modules$hast_util_is_element$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertElement = exports.isElement = void 0;\n\n/**\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('hast').Element} Element\n */\n\n/**\n * @typedef {null | undefined | string | TestFunctionAnything | Array<string | TestFunctionAnything>} Test\n *   Check for an arbitrary element, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if an element passes a test, unaware of TypeScript inferral.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {boolean | void}\n *   Whether this element passes the test.\n */\n\n/**\n * @template {Element} T\n *   Element type.\n * @typedef {T['tagName'] | TestFunctionPredicate<T> | Array<T['tagName'] | TestFunctionPredicate<T>>} PredicateTest\n *   Check for an element that can be inferred by TypeScript.\n */\n\n/**\n * Check if an element passes a certain node test.\n *\n * @template {Element} T\n *   Element type.\n * @callback TestFunctionPredicate\n *   Complex test function for an element that can be inferred by TypeScript.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {element is T}\n *   Whether this element passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is an element, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @template {Element} T\n *   Element type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific element, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is T}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if `node` is an `Element` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific element.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is an element and passes a test.\n */\nconst isElement =\n/**\n * @param {unknown} [node]\n * @param {Test | undefined} [test]\n * @param {number | null | undefined} [index]\n * @param {Parent | null | undefined} [parent]\n * @param {unknown} [context]\n * @returns {boolean}\n */\n// eslint-disable-next-line max-params\nfunction (node, test, index, parent, context) {\n  const check = convertElement(test);\n\n  if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\n    throw new Error('Expected positive finite index for child node');\n  }\n\n  if (parent !== undefined && parent !== null && (!parent.type || !parent.children)) {\n    throw new Error('Expected parent node');\n  } // @ts-expect-error Looks like a node.\n\n\n  if (!node || !node.type || typeof node.type !== 'string') {\n    return false;\n  }\n\n  if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\n    throw new Error('Expected both parent and index');\n  }\n\n  return check.call(context, node, index, parent);\n};\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *  When nullish, checks if `node` is an `Element`.\n *   *  When `string`, works like passing `(element) => element.tagName === test`.\n *   *  When `function` checks if function passed the element is true.\n *   *  When `array`, checks any one of the subtests pass.\n * @returns\n *   An assertion.\n */\n\n\nexports.isElement = isElement;\n\nconst convertElement =\n/**\n * @param {Test | null | undefined} [test]\n * @returns {AssertAnything}\n */\nfunction (test) {\n  if (test === undefined || test === null) {\n    return element;\n  }\n\n  if (typeof test === 'string') {\n    return tagNameFactory(test);\n  }\n\n  if (typeof test === 'object') {\n    return anyFactory(test);\n  }\n\n  if (typeof test === 'function') {\n    return castFactory(test);\n  }\n\n  throw new Error('Expected function, string, or array as test');\n};\n/**\n * Handle multiple tests.\n *\n * @param {Array<string | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\n\n\nexports.convertElement = convertElement;\n\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = [];\n  let index = -1;\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index]);\n  }\n\n  return castFactory(any);\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n\n  function any(...parameters) {\n    let index = -1;\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n/**\n * Turn a string into a test for an element with a certain tag name.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\n\n\nfunction tagNameFactory(check) {\n  return tagName;\n  /**\n   * @param {unknown} node\n   * @returns {boolean}\n   */\n\n  function tagName(node) {\n    return element(node) && node.tagName === check;\n  }\n}\n/**\n * Turn a custom test into a test for an element that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\n\n\nfunction castFactory(check) {\n  return assertion;\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n\n  function assertion(node, ...parameters) {\n    // @ts-expect-error: fine.\n    return element(node) && Boolean(check.call(this, node, ...parameters));\n  }\n}\n/**\n * Make sure something is an element.\n *\n * @param {unknown} node\n * @returns {node is Element}\n */\n\n\nfunction element(node) {\n  return Boolean(node && typeof node === 'object' && // @ts-expect-error Looks like a node.\n  node.type === 'element' && // @ts-expect-error Looks like an element.\n  typeof node.tagName === 'string');\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["__esModule","convertElement","value","isElement"]],"~:compiled-at",1676667638368,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hast_util_is_element$index.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/hast-util-is-element/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hast_util_is_element$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.convertElement = exports.isElement = void 0;\\n\\n/**\\n * @typedef {import('unist').Parent} Parent\\n * @typedef {import('hast').Element} Element\\n */\\n\\n/**\\n * @typedef {null | undefined | string | TestFunctionAnything | Array<string | TestFunctionAnything>} Test\\n *   Check for an arbitrary element, unaware of TypeScript inferral.\\n *\\n * @callback TestFunctionAnything\\n *   Check if an element passes a test, unaware of TypeScript inferral.\\n * @param {Element} element\\n *   An element.\\n * @param {number | null | undefined} [index]\\n *   The element\\u2019s position in its parent.\\n * @param {Parent | null | undefined} [parent]\\n *   The element\\u2019s parent.\\n * @returns {boolean | void}\\n *   Whether this element passes the test.\\n */\\n\\n/**\\n * @template {Element} T\\n *   Element type.\\n * @typedef {T['tagName'] | TestFunctionPredicate<T> | Array<T['tagName'] | TestFunctionPredicate<T>>} PredicateTest\\n *   Check for an element that can be inferred by TypeScript.\\n */\\n\\n/**\\n * Check if an element passes a certain node test.\\n *\\n * @template {Element} T\\n *   Element type.\\n * @callback TestFunctionPredicate\\n *   Complex test function for an element that can be inferred by TypeScript.\\n * @param {Element} element\\n *   An element.\\n * @param {number | null | undefined} [index]\\n *   The element\\u2019s position in its parent.\\n * @param {Parent | null | undefined} [parent]\\n *   The element\\u2019s parent.\\n * @returns {element is T}\\n *   Whether this element passes the test.\\n */\\n\\n/**\\n * @callback AssertAnything\\n *   Check that an arbitrary value is an element, unaware of TypeScript inferral.\\n * @param {unknown} [node]\\n *   Anything (typically a node).\\n * @param {number | null | undefined} [index]\\n *   The node\\u2019s position in its parent.\\n * @param {Parent | null | undefined} [parent]\\n *   The node\\u2019s parent.\\n * @returns {boolean}\\n *   Whether this is an element and passes a test.\\n */\\n\\n/**\\n * Check if a node is an element and passes a certain node test\\n *\\n * @template {Element} T\\n *   Element type.\\n * @callback AssertPredicate\\n *   Check that an arbitrary value is a specific element, aware of TypeScript.\\n * @param {unknown} [node]\\n *   Anything (typically a node).\\n * @param {number | null | undefined} [index]\\n *   The node\\u2019s position in its parent.\\n * @param {Parent | null | undefined} [parent]\\n *   The node\\u2019s parent.\\n * @returns {node is T}\\n *   Whether this is an element and passes a test.\\n */\\n\\n/**\\n * Check if `node` is an `Element` and whether it passes the given test.\\n *\\n * @param node\\n *   Thing to check, typically `Node`.\\n * @param test\\n *   A check for a specific element.\\n * @param index\\n *   The node\\u2019s position in its parent.\\n * @param parent\\n *   The node\\u2019s parent.\\n * @returns\\n *   Whether `node` is an element and passes a test.\\n */\\nconst isElement =\\n/**\\n * @param {unknown} [node]\\n * @param {Test | undefined} [test]\\n * @param {number | null | undefined} [index]\\n * @param {Parent | null | undefined} [parent]\\n * @param {unknown} [context]\\n * @returns {boolean}\\n */\\n// eslint-disable-next-line max-params\\nfunction (node, test, index, parent, context) {\\n  const check = convertElement(test);\\n\\n  if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\\n    throw new Error('Expected positive finite index for child node');\\n  }\\n\\n  if (parent !== undefined && parent !== null && (!parent.type || !parent.children)) {\\n    throw new Error('Expected parent node');\\n  } // @ts-expect-error Looks like a node.\\n\\n\\n  if (!node || !node.type || typeof node.type !== 'string') {\\n    return false;\\n  }\\n\\n  if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\\n    throw new Error('Expected both parent and index');\\n  }\\n\\n  return check.call(context, node, index, parent);\\n};\\n/**\\n * Generate an assertion from a test.\\n *\\n * Useful if you\\u2019re going to test many nodes, for example when creating a\\n * utility where something else passes a compatible test.\\n *\\n * The created function is a bit faster because it expects valid input only:\\n * a `node`, `index`, and `parent`.\\n *\\n * @param test\\n *   *  When nullish, checks if `node` is an `Element`.\\n *   *  When `string`, works like passing `(element) => element.tagName === test`.\\n *   *  When `function` checks if function passed the element is true.\\n *   *  When `array`, checks any one of the subtests pass.\\n * @returns\\n *   An assertion.\\n */\\n\\n\\nexports.isElement = isElement;\\n\\nconst convertElement =\\n/**\\n * @param {Test | null | undefined} [test]\\n * @returns {AssertAnything}\\n */\\nfunction (test) {\\n  if (test === undefined || test === null) {\\n    return element;\\n  }\\n\\n  if (typeof test === 'string') {\\n    return tagNameFactory(test);\\n  }\\n\\n  if (typeof test === 'object') {\\n    return anyFactory(test);\\n  }\\n\\n  if (typeof test === 'function') {\\n    return castFactory(test);\\n  }\\n\\n  throw new Error('Expected function, string, or array as test');\\n};\\n/**\\n * Handle multiple tests.\\n *\\n * @param {Array<string | TestFunctionAnything>} tests\\n * @returns {AssertAnything}\\n */\\n\\n\\nexports.convertElement = convertElement;\\n\\nfunction anyFactory(tests) {\\n  /** @type {Array<AssertAnything>} */\\n  const checks = [];\\n  let index = -1;\\n\\n  while (++index < tests.length) {\\n    checks[index] = convertElement(tests[index]);\\n  }\\n\\n  return castFactory(any);\\n  /**\\n   * @this {unknown}\\n   * @param {Array<unknown>} parameters\\n   * @returns {boolean}\\n   */\\n\\n  function any(...parameters) {\\n    let index = -1;\\n\\n    while (++index < checks.length) {\\n      if (checks[index].call(this, ...parameters)) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n}\\n/**\\n * Turn a string into a test for an element with a certain tag name.\\n *\\n * @param {string} check\\n * @returns {AssertAnything}\\n */\\n\\n\\nfunction tagNameFactory(check) {\\n  return tagName;\\n  /**\\n   * @param {unknown} node\\n   * @returns {boolean}\\n   */\\n\\n  function tagName(node) {\\n    return element(node) && node.tagName === check;\\n  }\\n}\\n/**\\n * Turn a custom test into a test for an element that passes that test.\\n *\\n * @param {TestFunctionAnything} check\\n * @returns {AssertAnything}\\n */\\n\\n\\nfunction castFactory(check) {\\n  return assertion;\\n  /**\\n   * @this {unknown}\\n   * @param {unknown} node\\n   * @param {Array<unknown>} parameters\\n   * @returns {boolean}\\n   */\\n\\n  function assertion(node, ...parameters) {\\n    // @ts-expect-error: fine.\\n    return element(node) && Boolean(check.call(this, node, ...parameters));\\n  }\\n}\\n/**\\n * Make sure something is an element.\\n *\\n * @param {unknown} node\\n * @returns {node is Element}\\n */\\n\\n\\nfunction element(node) {\\n  return Boolean(node && typeof node === 'object' && // @ts-expect-error Looks like a node.\\n  node.type === 'element' && // @ts-expect-error Looks like an element.\\n  typeof node.tagName === 'string');\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"anyFactory\",\"tests\",\"checks\",\"index\",\"length\",\"convertElement\",\"castFactory\",\"any\",\"parameters\",\"call\",\"tagNameFactory\",\"check\",\"tagName\",\"node\",\"element\",\"assertion\",\"type\",\"Object\",\"defineProperty\",\"value\",\"isElement\",\"test\",\"parent\",\"context\",\"undefined\",\"Number\",\"POSITIVE_INFINITY\",\"Error\",\"children\"]\n}\n"]