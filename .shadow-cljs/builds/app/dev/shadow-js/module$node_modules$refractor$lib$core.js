["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lib/core.js"],"~:js","shadow$provide.module$node_modules$refractor$lib$core=function(global,require,module,exports){function Refractor(){}function stringify(value,language){if(\"string\"===typeof value)return{type:\"text\",value};if(Array.isArray(value)){for(var result=[],index=-1;++index<value.length;)\"\"!==value[index]&&null!==value[index]&&void 0!==value[index]&&result.push(stringify(value[index],language));return result}language={type:value.type,content:stringify(value.content,language),tag:\"span\",classes:[\"token\",value.type],\nattributes:{},language};value.alias&&language.classes.push(...(\"string\"===typeof value.alias?[value.alias]:value.alias));refractor.hooks.run(\"wrap\",language);value=_hastscript;index=value.h;var JSCompiler_temp_const=language.tag+\".\"+language.classes.join(\".\"),attrs=language.attributes;for(result in attrs)own.call(attrs,result)&&(attrs[result]=(0,_parseEntities.parseEntities)(attrs[result]));return index.call(value,JSCompiler_temp_const,attrs,language.content)}Object.defineProperty(exports,\"__esModule\",\n{value:!0});exports.refractor=void 0;var _hastscript=require(\"module$node_modules$hastscript$index\"),_parseEntities=require(\"module$node_modules$parse_entities$index\"),_prismCore=require(\"module$node_modules$refractor$lib$prism_core\");const own={}.hasOwnProperty;Refractor.prototype=_prismCore.Prism;const refractor=new Refractor;exports.refractor=refractor;refractor.highlight=function(value,language){if(\"string\"!==typeof value)throw new TypeError(\"Expected `string` for `value`, got `\"+value+\"`\");let name;\nif(!language||\"object\"!==typeof language){name=language;if(\"string\"!==typeof name)throw new TypeError(\"Expected `string` for `name`, got `\"+name+\"`\");if(own.call(refractor.languages,name))language=refractor.languages[name];else throw Error(\"Unknown language: `\"+name+\"` is not registered\");}return{type:\"root\",children:_prismCore.Prism.highlight.call(refractor,value,language,name)}};refractor.register=function(syntax){if(\"function\"!==typeof syntax||!syntax.displayName)throw Error(\"Expected `function` for `syntax`, got `\"+\nsyntax+\"`\");own.call(refractor.languages,syntax.displayName)||syntax(refractor)};refractor.alias=function(language,alias){const languages=refractor.languages;let map={};\"string\"===typeof language?alias&&(map[language]=alias):map=language;let key;for(key in map)if(own.call(map,key))for(language=map[key],language=\"string\"===typeof language?[language]:language,alias=-1;++alias<language.length;)languages[language[alias]]=languages[key]};refractor.registered=function(aliasOrLanguage){if(\"string\"!==typeof aliasOrLanguage)throw new TypeError(\"Expected `string` for `aliasOrLanguage`, got `\"+\naliasOrLanguage+\"`\");return own.call(refractor.languages,aliasOrLanguage)};refractor.listLanguages=function(){const languages=refractor.languages,list=[];let language;for(language in languages)own.call(languages,language)&&\"object\"===typeof languages[language]&&list.push(language);return list};refractor.util.encode=function(tokens){return tokens};refractor.Token.stringify=stringify}","~:source","shadow$provide[\"module$node_modules$refractor$lib$core\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.refractor = void 0;\n\nvar _hastscript = require(\"hastscript\");\n\nvar _parseEntities = require(\"parse-entities\");\n\nvar _prismCore = require(\"./prism-core.js\");\n\n/**\n * @typedef _Token A hidden Prism token\n * @property {string} type\n * @property {string} content\n * @property {string} alias\n * @property {number} length\n *\n * @typedef _Env A hidden Prism environment\n * @property {string} type\n * @property {string} tag\n * @property {Text|RefractorElement|Array<Text|RefractorElement>} content\n * @property {Array<string>} classes\n * @property {Record<string, string>} attributes\n * @property {string} language\n *\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {Omit<Element, 'children'> & {children: Array<RefractorElement|Text>}} RefractorElement\n * @typedef {Omit<Root, 'children'> & {children: Array<RefractorElement|Text>}} RefractorRoot\n *\n * @typedef {import('prismjs').Languages} Languages\n * @typedef {import('prismjs').Grammar} Grammar Whatever this is, Prism handles it.\n * @typedef {((prism: unknown) => void) & {displayName: string, aliases?: Array<string>}} Syntax A refractor syntax function\n *\n * @typedef Refractor Virtual syntax highlighting\n * @property {highlight} highlight\n * @property {alias} alias\n * @property {register} register\n * @property {registered} registered\n * @property {listLanguages} listLanguages\n * @property {Languages} languages\n */\n// Load all stuff in `prism.js` itself, except for `prism-file-highlight.js`.\n// The wrapped non-leaky grammars are loaded instead of Prism’s originals.\nconst own = {}.hasOwnProperty; // Inherit.\n\nfunction Refractor() {}\n\nRefractor.prototype = _prismCore.Prism;\n/** @type {Refractor} */\n// @ts-expect-error: TS is wrong.\n\nconst refractor = new Refractor(); // Create.\n\nexports.refractor = refractor;\nrefractor.highlight = highlight;\nrefractor.register = register;\nrefractor.alias = alias;\nrefractor.registered = registered;\nrefractor.listLanguages = listLanguages; // @ts-expect-error Overwrite Prism.\n\nrefractor.util.encode = encode; // @ts-expect-error Overwrite Prism.\n\nrefractor.Token.stringify = stringify;\n/**\n * Highlight `value` (code) as `language` (programming language).\n *\n * @param {string} value\n *   Code to highlight.\n * @param {string|Grammar} language\n *   Programming language name, alias, or grammar.\n * @returns {RefractorRoot}\n *   Node representing highlighted code.\n */\n\nfunction highlight(value, language) {\n  if (typeof value !== 'string') {\n    throw new TypeError('Expected `string` for `value`, got `' + value + '`');\n  }\n  /** @type {Grammar} */\n\n\n  let grammar;\n  /** @type {string|undefined} */\n\n  let name; // `name` is a grammar object.\n  // This was called internally by Prism.js before 1.28.0.\n\n  /* c8 ignore next 2 */\n\n  if (language && typeof language === 'object') {\n    grammar = language;\n  } else {\n    name = language;\n\n    if (typeof name !== 'string') {\n      throw new TypeError('Expected `string` for `name`, got `' + name + '`');\n    }\n\n    if (own.call(refractor.languages, name)) {\n      grammar = refractor.languages[name];\n    } else {\n      throw new Error('Unknown language: `' + name + '` is not registered');\n    }\n  }\n\n  return {\n    type: 'root',\n    // @ts-expect-error: we hacked Prism to accept and return the things we want.\n    children: _prismCore.Prism.highlight.call(refractor, value, grammar, name)\n  };\n}\n/**\n * Register a syntax.\n *\n * @param {Syntax} syntax\n *   Language function made for refractor, as in, the files in\n *   `refractor/lang/*.js`.\n * @returns {void}\n */\n\n\nfunction register(syntax) {\n  if (typeof syntax !== 'function' || !syntax.displayName) {\n    throw new Error('Expected `function` for `syntax`, got `' + syntax + '`');\n  } // Do not duplicate registrations.\n\n\n  if (!own.call(refractor.languages, syntax.displayName)) {\n    syntax(refractor);\n  }\n}\n/**\n * Register aliases for already registered languages.\n *\n * @param {Record<string, string|Array<string>>|string} language\n * @param {string|Array<string>} [alias]\n * @returns {void}\n */\n\n\nfunction alias(language, alias) {\n  const languages = refractor.languages;\n  /** @type {Record<string, string|Array<string>>} */\n\n  let map = {};\n\n  if (typeof language === 'string') {\n    if (alias) {\n      map[language] = alias;\n    }\n  } else {\n    map = language;\n  }\n  /** @type {string} */\n\n\n  let key;\n\n  for (key in map) {\n    if (own.call(map, key)) {\n      const value = map[key];\n      const list = typeof value === 'string' ? [value] : value;\n      let index = -1;\n\n      while (++index < list.length) {\n        languages[list[index]] = languages[key];\n      }\n    }\n  }\n}\n/**\n * Check whether an `alias` or `language` is registered.\n *\n * @param {string} aliasOrLanguage\n * @returns {boolean}\n */\n\n\nfunction registered(aliasOrLanguage) {\n  if (typeof aliasOrLanguage !== 'string') {\n    throw new TypeError('Expected `string` for `aliasOrLanguage`, got `' + aliasOrLanguage + '`');\n  }\n\n  return own.call(refractor.languages, aliasOrLanguage);\n}\n/**\n * List all registered languages (names and aliases).\n *\n * @returns {Array<string>}\n */\n\n\nfunction listLanguages() {\n  const languages = refractor.languages;\n  /** @type {Array<string>} */\n\n  const list = [];\n  /** @type {string} */\n\n  let language;\n\n  for (language in languages) {\n    if (own.call(languages, language) && typeof languages[language] === 'object') {\n      list.push(language);\n    }\n  }\n\n  return list;\n}\n/**\n * @param {string|_Token|Array<string|_Token>} value\n * @param {string} language\n * @returns {Text|RefractorElement|Array<Text|RefractorElement>}\n */\n\n\nfunction stringify(value, language) {\n  if (typeof value === 'string') {\n    return {\n      type: 'text',\n      value\n    };\n  }\n\n  if (Array.isArray(value)) {\n    /** @type {Array<Text|RefractorElement>} */\n    const result = [];\n    let index = -1;\n\n    while (++index < value.length) {\n      if (value[index] !== '' && value[index] !== null && value[index] !== undefined) {\n        // @ts-expect-error Assume no sub-arrays.\n        result.push(stringify(value[index], language));\n      }\n    }\n\n    return result;\n  }\n  /** @type {_Env} */\n\n\n  const env = {\n    type: value.type,\n    content: stringify(value.content, language),\n    tag: 'span',\n    classes: ['token', value.type],\n    attributes: {},\n    language\n  };\n\n  if (value.alias) {\n    env.classes.push(...(typeof value.alias === 'string' ? [value.alias] : value.alias));\n  } // @ts-expect-error Prism.\n\n\n  refractor.hooks.run('wrap', env); // @ts-expect-error Hush, it’s fine.\n\n  return (0, _hastscript.h)(env.tag + '.' + env.classes.join('.'), attributes(env.attributes), env.content);\n}\n/**\n * @template {unknown} T\n * @param {T} tokens\n * @returns {T}\n */\n\n\nfunction encode(tokens) {\n  return tokens;\n}\n/**\n * @param {Record<string, string>} attrs\n * @returns {Record<string, string>}\n */\n\n\nfunction attributes(attrs) {\n  /** @type {string} */\n  let key;\n\n  for (key in attrs) {\n    if (own.call(attrs, key)) {\n      attrs[key] = (0, _parseEntities.parseEntities)(attrs[key]);\n    }\n  }\n\n  return attrs;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$parse_entities$index","~$shadow.js","~$module$node_modules$refractor$lib$prism_core","~$module$node_modules$hastscript$index"]],"~:properties",["^5",["prototype","children","__esModule","tag","value","classes","content","register","attributes","listLanguages","type","stringify","refractor","alias","registered","highlight","language","encode"]],"~:compiled-at",1676841365383,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lib$core.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lib/core.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lib$core\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.refractor = void 0;\\n\\nvar _hastscript = require(\\\"hastscript\\\");\\n\\nvar _parseEntities = require(\\\"parse-entities\\\");\\n\\nvar _prismCore = require(\\\"./prism-core.js\\\");\\n\\n/**\\n * @typedef _Token A hidden Prism token\\n * @property {string} type\\n * @property {string} content\\n * @property {string} alias\\n * @property {number} length\\n *\\n * @typedef _Env A hidden Prism environment\\n * @property {string} type\\n * @property {string} tag\\n * @property {Text|RefractorElement|Array<Text|RefractorElement>} content\\n * @property {Array<string>} classes\\n * @property {Record<string, string>} attributes\\n * @property {string} language\\n *\\n * @typedef {import('hast').Root} Root\\n * @typedef {import('hast').Element} Element\\n * @typedef {import('hast').Text} Text\\n * @typedef {Omit<Element, 'children'> & {children: Array<RefractorElement|Text>}} RefractorElement\\n * @typedef {Omit<Root, 'children'> & {children: Array<RefractorElement|Text>}} RefractorRoot\\n *\\n * @typedef {import('prismjs').Languages} Languages\\n * @typedef {import('prismjs').Grammar} Grammar Whatever this is, Prism handles it.\\n * @typedef {((prism: unknown) => void) & {displayName: string, aliases?: Array<string>}} Syntax A refractor syntax function\\n *\\n * @typedef Refractor Virtual syntax highlighting\\n * @property {highlight} highlight\\n * @property {alias} alias\\n * @property {register} register\\n * @property {registered} registered\\n * @property {listLanguages} listLanguages\\n * @property {Languages} languages\\n */\\n// Load all stuff in `prism.js` itself, except for `prism-file-highlight.js`.\\n// The wrapped non-leaky grammars are loaded instead of Prism\\u2019s originals.\\nconst own = {}.hasOwnProperty; // Inherit.\\n\\nfunction Refractor() {}\\n\\nRefractor.prototype = _prismCore.Prism;\\n/** @type {Refractor} */\\n// @ts-expect-error: TS is wrong.\\n\\nconst refractor = new Refractor(); // Create.\\n\\nexports.refractor = refractor;\\nrefractor.highlight = highlight;\\nrefractor.register = register;\\nrefractor.alias = alias;\\nrefractor.registered = registered;\\nrefractor.listLanguages = listLanguages; // @ts-expect-error Overwrite Prism.\\n\\nrefractor.util.encode = encode; // @ts-expect-error Overwrite Prism.\\n\\nrefractor.Token.stringify = stringify;\\n/**\\n * Highlight `value` (code) as `language` (programming language).\\n *\\n * @param {string} value\\n *   Code to highlight.\\n * @param {string|Grammar} language\\n *   Programming language name, alias, or grammar.\\n * @returns {RefractorRoot}\\n *   Node representing highlighted code.\\n */\\n\\nfunction highlight(value, language) {\\n  if (typeof value !== 'string') {\\n    throw new TypeError('Expected `string` for `value`, got `' + value + '`');\\n  }\\n  /** @type {Grammar} */\\n\\n\\n  let grammar;\\n  /** @type {string|undefined} */\\n\\n  let name; // `name` is a grammar object.\\n  // This was called internally by Prism.js before 1.28.0.\\n\\n  /* c8 ignore next 2 */\\n\\n  if (language && typeof language === 'object') {\\n    grammar = language;\\n  } else {\\n    name = language;\\n\\n    if (typeof name !== 'string') {\\n      throw new TypeError('Expected `string` for `name`, got `' + name + '`');\\n    }\\n\\n    if (own.call(refractor.languages, name)) {\\n      grammar = refractor.languages[name];\\n    } else {\\n      throw new Error('Unknown language: `' + name + '` is not registered');\\n    }\\n  }\\n\\n  return {\\n    type: 'root',\\n    // @ts-expect-error: we hacked Prism to accept and return the things we want.\\n    children: _prismCore.Prism.highlight.call(refractor, value, grammar, name)\\n  };\\n}\\n/**\\n * Register a syntax.\\n *\\n * @param {Syntax} syntax\\n *   Language function made for refractor, as in, the files in\\n *   `refractor/lang/*.js`.\\n * @returns {void}\\n */\\n\\n\\nfunction register(syntax) {\\n  if (typeof syntax !== 'function' || !syntax.displayName) {\\n    throw new Error('Expected `function` for `syntax`, got `' + syntax + '`');\\n  } // Do not duplicate registrations.\\n\\n\\n  if (!own.call(refractor.languages, syntax.displayName)) {\\n    syntax(refractor);\\n  }\\n}\\n/**\\n * Register aliases for already registered languages.\\n *\\n * @param {Record<string, string|Array<string>>|string} language\\n * @param {string|Array<string>} [alias]\\n * @returns {void}\\n */\\n\\n\\nfunction alias(language, alias) {\\n  const languages = refractor.languages;\\n  /** @type {Record<string, string|Array<string>>} */\\n\\n  let map = {};\\n\\n  if (typeof language === 'string') {\\n    if (alias) {\\n      map[language] = alias;\\n    }\\n  } else {\\n    map = language;\\n  }\\n  /** @type {string} */\\n\\n\\n  let key;\\n\\n  for (key in map) {\\n    if (own.call(map, key)) {\\n      const value = map[key];\\n      const list = typeof value === 'string' ? [value] : value;\\n      let index = -1;\\n\\n      while (++index < list.length) {\\n        languages[list[index]] = languages[key];\\n      }\\n    }\\n  }\\n}\\n/**\\n * Check whether an `alias` or `language` is registered.\\n *\\n * @param {string} aliasOrLanguage\\n * @returns {boolean}\\n */\\n\\n\\nfunction registered(aliasOrLanguage) {\\n  if (typeof aliasOrLanguage !== 'string') {\\n    throw new TypeError('Expected `string` for `aliasOrLanguage`, got `' + aliasOrLanguage + '`');\\n  }\\n\\n  return own.call(refractor.languages, aliasOrLanguage);\\n}\\n/**\\n * List all registered languages (names and aliases).\\n *\\n * @returns {Array<string>}\\n */\\n\\n\\nfunction listLanguages() {\\n  const languages = refractor.languages;\\n  /** @type {Array<string>} */\\n\\n  const list = [];\\n  /** @type {string} */\\n\\n  let language;\\n\\n  for (language in languages) {\\n    if (own.call(languages, language) && typeof languages[language] === 'object') {\\n      list.push(language);\\n    }\\n  }\\n\\n  return list;\\n}\\n/**\\n * @param {string|_Token|Array<string|_Token>} value\\n * @param {string} language\\n * @returns {Text|RefractorElement|Array<Text|RefractorElement>}\\n */\\n\\n\\nfunction stringify(value, language) {\\n  if (typeof value === 'string') {\\n    return {\\n      type: 'text',\\n      value\\n    };\\n  }\\n\\n  if (Array.isArray(value)) {\\n    /** @type {Array<Text|RefractorElement>} */\\n    const result = [];\\n    let index = -1;\\n\\n    while (++index < value.length) {\\n      if (value[index] !== '' && value[index] !== null && value[index] !== undefined) {\\n        // @ts-expect-error Assume no sub-arrays.\\n        result.push(stringify(value[index], language));\\n      }\\n    }\\n\\n    return result;\\n  }\\n  /** @type {_Env} */\\n\\n\\n  const env = {\\n    type: value.type,\\n    content: stringify(value.content, language),\\n    tag: 'span',\\n    classes: ['token', value.type],\\n    attributes: {},\\n    language\\n  };\\n\\n  if (value.alias) {\\n    env.classes.push(...(typeof value.alias === 'string' ? [value.alias] : value.alias));\\n  } // @ts-expect-error Prism.\\n\\n\\n  refractor.hooks.run('wrap', env); // @ts-expect-error Hush, it\\u2019s fine.\\n\\n  return (0, _hastscript.h)(env.tag + '.' + env.classes.join('.'), attributes(env.attributes), env.content);\\n}\\n/**\\n * @template {unknown} T\\n * @param {T} tokens\\n * @returns {T}\\n */\\n\\n\\nfunction encode(tokens) {\\n  return tokens;\\n}\\n/**\\n * @param {Record<string, string>} attrs\\n * @returns {Record<string, string>}\\n */\\n\\n\\nfunction attributes(attrs) {\\n  /** @type {string} */\\n  let key;\\n\\n  for (key in attrs) {\\n    if (own.call(attrs, key)) {\\n      attrs[key] = (0, _parseEntities.parseEntities)(attrs[key]);\\n    }\\n  }\\n\\n  return attrs;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Refractor\",\"stringify\",\"value\",\"language\",\"type\",\"Array\",\"isArray\",\"result\",\"index\",\"length\",\"undefined\",\"push\",\"env\",\"content\",\"tag\",\"classes\",\"attributes\",\"alias\",\"refractor\",\"hooks\",\"run\",\"_hastscript\",\"h\",\"join\",\"key\",\"attrs\",\"own\",\"call\",\"_parseEntities\",\"parseEntities\",\"Object\",\"defineProperty\",\"_prismCore\",\"hasOwnProperty\",\"prototype\",\"Prism\",\"highlight\",\"TypeError\",\"name\",\"languages\",\"grammar\",\"Error\",\"children\",\"register\",\"syntax\",\"displayName\",\"map\",\"list\",\"registered\",\"aliasOrLanguage\",\"listLanguages\",\"util\",\"encode\",\"tokens\",\"Token\"]\n}\n"]