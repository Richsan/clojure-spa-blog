["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js"],"~:js","shadow$provide.module$node_modules$micromark_extension_gfm_task_list_item$lib$syntax=function(global,require,module,exports){function spaceThenNonSpace(effects,ok,nok){const self=this;return(0,_micromarkFactorySpace.factorySpace)(effects,function(code){const tail=self.events[self.events.length-1];return(tail&&\"whitespace\"===tail[1].type||(0,_micromarkUtilCharacter.markdownLineEnding)(code))&&null!==code?ok(code):nok(code)},\"whitespace\")}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.gfmTaskListItem=\nvoid 0;var _micromarkFactorySpace=require(\"module$node_modules$micromark_factory_space$index\"),_micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\");exports.gfmTaskListItem={text:{[91]:{tokenize:function(effects,ok,nok){function inside(code){return(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code)?(effects.enter(\"taskListCheckValueUnchecked\"),effects.consume(code),effects.exit(\"taskListCheckValueUnchecked\"),close):88===code||120===code?(effects.enter(\"taskListCheckValueChecked\"),\neffects.consume(code),effects.exit(\"taskListCheckValueChecked\"),close):nok(code)}function close(code){return 93===code?(effects.enter(\"taskListCheckMarker\"),effects.consume(code),effects.exit(\"taskListCheckMarker\"),effects.exit(\"taskListCheck\"),effects.check({tokenize:spaceThenNonSpace},ok,nok)):nok(code)}const self=this;return function(code){if(null!==self.previous||!self._gfmTasklistFirstContentOfListItem)return nok(code);effects.enter(\"taskListCheck\");effects.enter(\"taskListCheckMarker\");effects.consume(code);\neffects.exit(\"taskListCheckMarker\");return inside}}}}}}","~:source","shadow$provide[\"module$node_modules$micromark_extension_gfm_task_list_item$lib$syntax\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gfmTaskListItem = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n};\nconst gfmTaskListItem = {\n  text: {\n    [91]: tasklistCheck\n  }\n};\n/** @type {Tokenizer} */\n\nexports.gfmTaskListItem = gfmTaskListItem;\n\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this;\n  return open;\n  /** @type {State} */\n\n  function open(code) {\n    if ( // Exit if there’s stuff before.\n    self.previous !== null || // Exit if not in the first content that is the first child of a list\n    // item.\n    !self._gfmTasklistFirstContentOfListItem) {\n      return nok(code);\n    }\n\n    effects.enter('taskListCheck');\n    effects.enter('taskListCheckMarker');\n    effects.consume(code);\n    effects.exit('taskListCheckMarker');\n    return inside;\n  }\n  /** @type {State} */\n\n\n  function inside(code) {\n    // To match how GH works in comments, use `markdownSpace` (`[ \\t]`) instead\n    // of `markdownLineEndingOrSpace` (`[ \\t\\r\\n]`).\n    if ((0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\n      effects.enter('taskListCheckValueUnchecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueUnchecked');\n      return close;\n    }\n\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueChecked');\n      return close;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker');\n      effects.consume(code);\n      effects.exit('taskListCheckMarker');\n      effects.exit('taskListCheck');\n      return effects.check({\n        tokenize: spaceThenNonSpace\n      }, ok, nok);\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction spaceThenNonSpace(effects, ok, nok) {\n  const self = this;\n  return (0, _micromarkFactorySpace.factorySpace)(effects, after, 'whitespace');\n  /** @type {State} */\n\n  function after(code) {\n    const tail = self.events[self.events.length - 1];\n    return (// We either found spaces…\n      (tail && tail[1].type === 'whitespace' || // …or it was followed by a line ending, in which case, there has to be\n      // non-whitespace after that line ending, because otherwise we’d get an\n      // EOF as the content is closed with blank lines.\n      (0, _micromarkUtilCharacter.markdownLineEnding)(code)) && code !== null ? ok(code) : nok(code)\n    );\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js","~$module$node_modules$micromark_factory_space$index"]],"~:properties",["^5",["tokenize","__esModule","value","text","gfmTaskListItem"]],"~:compiled-at",1676841365331,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_extension_gfm_task_list_item$lib$syntax.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_extension_gfm_task_list_item$lib$syntax\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.gfmTaskListItem = void 0;\\n\\nvar _micromarkFactorySpace = require(\\\"micromark-factory-space\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Extension} Extension\\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').Previous} Previous\\n * @typedef {import('micromark-util-types').State} State\\n * @typedef {import('micromark-util-types').Event} Event\\n * @typedef {import('micromark-util-types').Code} Code\\n */\\nconst tasklistCheck = {\\n  tokenize: tokenizeTasklistCheck\\n};\\nconst gfmTaskListItem = {\\n  text: {\\n    [91]: tasklistCheck\\n  }\\n};\\n/** @type {Tokenizer} */\\n\\nexports.gfmTaskListItem = gfmTaskListItem;\\n\\nfunction tokenizeTasklistCheck(effects, ok, nok) {\\n  const self = this;\\n  return open;\\n  /** @type {State} */\\n\\n  function open(code) {\\n    if ( // Exit if there\\u2019s stuff before.\\n    self.previous !== null || // Exit if not in the first content that is the first child of a list\\n    // item.\\n    !self._gfmTasklistFirstContentOfListItem) {\\n      return nok(code);\\n    }\\n\\n    effects.enter('taskListCheck');\\n    effects.enter('taskListCheckMarker');\\n    effects.consume(code);\\n    effects.exit('taskListCheckMarker');\\n    return inside;\\n  }\\n  /** @type {State} */\\n\\n\\n  function inside(code) {\\n    // To match how GH works in comments, use `markdownSpace` (`[ \\\\t]`) instead\\n    // of `markdownLineEndingOrSpace` (`[ \\\\t\\\\r\\\\n]`).\\n    if ((0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code)) {\\n      effects.enter('taskListCheckValueUnchecked');\\n      effects.consume(code);\\n      effects.exit('taskListCheckValueUnchecked');\\n      return close;\\n    }\\n\\n    if (code === 88 || code === 120) {\\n      effects.enter('taskListCheckValueChecked');\\n      effects.consume(code);\\n      effects.exit('taskListCheckValueChecked');\\n      return close;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function close(code) {\\n    if (code === 93) {\\n      effects.enter('taskListCheckMarker');\\n      effects.consume(code);\\n      effects.exit('taskListCheckMarker');\\n      effects.exit('taskListCheck');\\n      return effects.check({\\n        tokenize: spaceThenNonSpace\\n      }, ok, nok);\\n    }\\n\\n    return nok(code);\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction spaceThenNonSpace(effects, ok, nok) {\\n  const self = this;\\n  return (0, _micromarkFactorySpace.factorySpace)(effects, after, 'whitespace');\\n  /** @type {State} */\\n\\n  function after(code) {\\n    const tail = self.events[self.events.length - 1];\\n    return (// We either found spaces\\u2026\\n      (tail && tail[1].type === 'whitespace' || // \\u2026or it was followed by a line ending, in which case, there has to be\\n      // non-whitespace after that line ending, because otherwise we\\u2019d get an\\n      // EOF as the content is closed with blank lines.\\n      (0, _micromarkUtilCharacter.markdownLineEnding)(code)) && code !== null ? ok(code) : nok(code)\\n    );\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"spaceThenNonSpace\",\"effects\",\"ok\",\"nok\",\"self\",\"_micromarkFactorySpace\",\"factorySpace\",\"after\",\"code\",\"tail\",\"events\",\"length\",\"type\",\"_micromarkUtilCharacter\",\"markdownLineEnding\",\"Object\",\"defineProperty\",\"value\",\"gfmTaskListItem\",\"text\",\"tasklistCheck\",\"tokenize\",\"tokenizeTasklistCheck\",\"inside\",\"markdownLineEndingOrSpace\",\"enter\",\"close\",\"consume\",\"exit\",\"check\",\"open\",\"previous\",\"_gfmTasklistFirstContentOfListItem\"]\n}\n"]