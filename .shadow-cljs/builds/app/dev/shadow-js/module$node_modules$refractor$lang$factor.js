["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/factor.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$factor=function(global,require,module,exports){function factor$jscomp$0(Prism$jscomp$0){(function(Prism){var comment_inside={function:/\\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\\?{2,}|!{2,})\\b/},string_inside={number:/\\\\[^\\s']|%\\w/},factor={comment:[{pattern:/(^|\\s)(?:! .*|!$)/,lookbehind:!0,inside:comment_inside},{pattern:/(^|\\s)\\/\\*\\s[\\s\\S]*?\\*\\/(?=\\s|$)/,lookbehind:!0,greedy:!0,inside:comment_inside},{pattern:/(^|\\s)!\\[(={0,6})\\[\\s[\\s\\S]*?\\]\\2\\](?=\\s|$)/,\nlookbehind:!0,greedy:!0,inside:comment_inside}],number:[{pattern:/(^|\\s)[+-]?\\d+(?=\\s|$)/,lookbehind:!0},{pattern:/(^|\\s)[+-]?0(?:b[01]+|o[0-7]+|d\\d+|x[\\dA-F]+)(?=\\s|$)/i,lookbehind:!0},{pattern:/(^|\\s)[+-]?\\d+\\/\\d+\\.?(?=\\s|$)/,lookbehind:!0},{pattern:/(^|\\s)\\+?\\d+\\+\\d+\\/\\d+(?=\\s|$)/,lookbehind:!0},{pattern:/(^|\\s)-\\d+-\\d+\\/\\d+(?=\\s|$)/,lookbehind:!0},{pattern:/(^|\\s)[+-]?(?:\\d*\\.\\d+|\\d+\\.\\d*|\\d+)(?:e[+-]?\\d+)?(?=\\s|$)/i,lookbehind:!0},{pattern:/(^|\\s)NAN:\\s+[\\da-fA-F]+(?=\\s|$)/,lookbehind:!0},{pattern:/(^|\\s)[+-]?0(?:b1\\.[01]*|o1\\.[0-7]*|d1\\.\\d*|x1\\.[\\dA-F]*)p\\d+(?=\\s|$)/i,\nlookbehind:!0}],regexp:{pattern:/(^|\\s)R\\/\\s(?:\\\\\\S|[^\\\\/])*\\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\\s|$)/,lookbehind:!0,alias:\"number\",inside:{variable:/\\\\\\S/,keyword:/[+?*\\[\\]^$(){}.|]/,operator:{pattern:/(\\/)[idmsr]+(?:-[idmsr]+)?/,lookbehind:!0}}},boolean:{pattern:/(^|\\s)[tf](?=\\s|$)/,lookbehind:!0},\"custom-string\":{pattern:/(^|\\s)[A-Z0-9\\-]+\"\\s(?:\\\\\\S|[^\"\\\\])*\"/,lookbehind:!0,greedy:!0,alias:\"string\",inside:{number:/\\\\\\S|%\\w|\\//}},\"multiline-string\":[{pattern:/(^|\\s)STRING:\\s+\\S+(?:\\n|\\r\\n).*(?:\\n|\\r\\n)\\s*;(?=\\s|$)/,\nlookbehind:!0,greedy:!0,alias:\"string\",inside:{number:string_inside.number,\"semicolon-or-setlocal\":{pattern:/([\\r\\n][ \\t]*);(?=\\s|$)/,lookbehind:!0,alias:\"function\"}}},{pattern:/(^|\\s)HEREDOC:\\s+\\S+(?:\\n|\\r\\n).*(?:\\n|\\r\\n)\\s*\\S+(?=\\s|$)/,lookbehind:!0,greedy:!0,alias:\"string\",inside:string_inside},{pattern:/(^|\\s)\\[(={0,6})\\[\\s[\\s\\S]*?\\]\\2\\](?=\\s|$)/,lookbehind:!0,greedy:!0,alias:\"string\",inside:string_inside}],\"special-using\":{pattern:/(^|\\s)USING:(?:\\s\\S+)*(?=\\s+;(?:\\s|$))/,lookbehind:!0,alias:\"function\",\ninside:{string:{pattern:/(\\s)[^:\\s]+/,lookbehind:!0}}},\"stack-effect-delimiter\":[{pattern:/(^|\\s)(?:call|eval|execute)?\\((?=\\s)/,lookbehind:!0,alias:\"operator\"},{pattern:/(\\s)--(?=\\s)/,lookbehind:!0,alias:\"operator\"},{pattern:/(\\s)\\)(?=\\s|$)/,lookbehind:!0,alias:\"operator\"}],combinators:{pattern:null,lookbehind:!0,alias:\"keyword\"},\"kernel-builtin\":{pattern:null,lookbehind:!0,alias:\"variable\"},\"sequences-builtin\":{pattern:null,lookbehind:!0,alias:\"variable\"},\"math-builtin\":{pattern:null,lookbehind:!0,\nalias:\"variable\"},\"constructor-word\":{pattern:/(^|\\s)<(?!=+>|-+>)\\S+>(?=\\s|$)/,lookbehind:!0,alias:\"keyword\"},\"other-builtin-syntax\":{pattern:null,lookbehind:!0,alias:\"operator\"},\"conventionally-named-word\":{pattern:/(^|\\s)(?!\")(?:(?:change|new|set|with)-\\S+|\\$\\S+|>[^>\\s]+|[^:>\\s]+>|[^>\\s]+>[^>\\s]+|\\+[^+\\s]+\\+|[^?\\s]+\\?|\\?[^?\\s]+|[^>\\s]+>>|>>[^>\\s]+|[^<\\s]+<<|\\([^()\\s]+\\)|[^!\\s]+!|[^*\\s]\\S*\\*|[^.\\s]\\S*\\.)(?=\\s|$)/,lookbehind:!0,alias:\"keyword\"},\"colon-syntax\":{pattern:/(^|\\s)(?:[A-Z0-9\\-]+#?)?:{1,2}\\s+(?:;\\S+|(?!;)\\S+)(?=\\s|$)/,\nlookbehind:!0,greedy:!0,alias:\"function\"},\"semicolon-or-setlocal\":{pattern:/(\\s)(?:;|:>)(?=\\s|$)/,lookbehind:!0,alias:\"function\"},\"curly-brace-literal-delimiter\":[{pattern:/(^|\\s)[a-z]*\\{(?=\\s)/i,lookbehind:!0,alias:\"operator\"},{pattern:/(\\s)\\}(?=\\s|$)/,lookbehind:!0,alias:\"operator\"}],\"quotation-delimiter\":[{pattern:/(^|\\s)\\[(?=\\s)/,lookbehind:!0,alias:\"operator\"},{pattern:/(\\s)\\](?=\\s|$)/,lookbehind:!0,alias:\"operator\"}],\"normal-word\":{pattern:/(^|\\s)[^\"\\s]\\S*(?=\\s|$)/,lookbehind:!0},string:{pattern:/\"(?:\\\\\\S|[^\"\\\\])*\"/,\ngreedy:!0,inside:string_inside}},escape=function(str){return(str+\"\").replace(/([.?*+\\^$\\[\\]\\\\(){}|\\-])/g,\"\\\\$1\")},arrToWordsRegExp=function(arr){return new RegExp(\"(^|\\\\s)(?:\"+arr.map(escape).join(\"|\")+\")(?\\x3d\\\\s|$)\")},builtins={\"kernel-builtin\":\"or 2nipd 4drop tuck wrapper nip wrapper? callstack\\x3earray die dupd callstack callstack? 3dup hashcode pick 4nip build \\x3eboolean nipd clone 5nip eq? ? \\x3d swapd 2over clear 2dup get-retainstack not tuple? dup 3nipd call -rotd object drop assert\\x3d assert? -rot execute boa get-callstack curried? 3drop pickd overd over roll 3nip swap and 2nip rotd throw (clone) hashcode* spin reach 4dup equal? get-datastack assert 2drop \\x3cwrapper\\x3e boolean? identity-hashcode identity-tuple? null composed? new 5drop rot -roll xor identity-tuple boolean\".split(\" \"),\n\"other-builtin-syntax\":\"\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d recursive flushable \\x3e\\x3e \\x3c\\x3c\\x3c\\x3c\\x3c\\x3c M\\\\ B PRIVATE\\x3e \\\\ \\x3d\\x3d\\x3d\\x3d\\x3d\\x3d final inline delimiter deprecated \\x3cPRIVATE \\x3e\\x3e\\x3e\\x3e\\x3e\\x3e \\x3c\\x3c\\x3c\\x3c\\x3c\\x3c\\x3c parse-complex malformed-complex read-only \\x3e\\x3e\\x3e\\x3e\\x3e\\x3e\\x3e call-next-method \\x3c\\x3c foldable $ $[ ${\".split(\" \"),\"sequences-builtin\":\"member-eq? mismatch append assert-sequence\\x3d longer repetition clone-like 3sequence assert-sequence? last-index-from reversed index-from cut* pad-tail join-as remove-eq! concat-as but-last snip nths nth sequence longest slice? \\x3cslice\\x3e remove-nth tail-slice empty? tail* member? virtual-sequence? set-length drop-prefix iota unclip bounds-error? unclip-last-slice non-negative-integer-expected non-negative-integer-expected? midpoint@ longer? ?set-nth ?first rest-slice prepend-as prepend fourth sift subseq-start new-sequence ?last like first4 1sequence reverse slice virtual@ repetition? set-last index 4sequence max-length set-second immutable-sequence first2 first3 supremum unclip-slice suffix! insert-nth tail 3append short suffix concat flip immutable? reverse! 2sequence sum delete-all indices snip-slice \\x3ciota\\x3e check-slice sequence? head append-as halves sequence\\x3d collapse-slice ?second slice-error? product bounds-check? bounds-check immutable virtual-exemplar harvest remove pad-head last set-fourth cartesian-product remove-eq shorten shorter reversed? shorter? shortest head-slice pop* tail-slice* but-last-slice iota? append! cut-slice new-resizable head-slice* sequence-hashcode pop set-nth ?nth second join immutable-sequence? \\x3creversed\\x3e 3append-as virtual-sequence subseq? remove-nth! length last-index lengthen assert-sequence copy move third first tail? set-first prefix bounds-error \\x3crepetition\\x3e exchange surround cut min-length set-third push-all head? subseq-start-from delete-slice rest sum-lengths head* infimum remove! glue slice-error subseq push replace-slice subseq-as unclip-last\".split(\" \"),\n\"math-builtin\":\"number\\x3d next-power-of-2 ?1+ fp-special? imaginary-part float\\x3ebits number? fp-infinity? bignum? fp-snan? denominator gcd * + fp-bitwise\\x3d - u\\x3e\\x3d / \\x3e\\x3d bitand power-of-2? log2-expects-positive neg? \\x3c log2 \\x3e integer? number bits\\x3edouble 2/ zero? bits\\x3efloat float? shift ratio? rect\\x3e even? ratio fp-sign bitnot \\x3efixnum complex? /i integer\\x3efixnum /f sgn \\x3ebignum next-float u\\x3c u\\x3e mod recip rational \\x3efloat 2^ integer fixnum? neg fixnum sq bignum \\x3erect bit? fp-qnan? simple-gcd complex \\x3cfp-nan\\x3e real \\x3efraction double\\x3ebits bitor rem fp-nan-payload real-part log2-expects-positive? prev-float align unordered? float fp-nan? abs bitxor integer\\x3efixnum-strict u\\x3c\\x3d odd? \\x3c\\x3d /mod \\x3einteger real? rational? numerator\".split(\" \")};\nObject.keys(builtins).forEach(function(k){factor[k].pattern=arrToWordsRegExp(builtins[k])});factor.combinators.pattern=arrToWordsRegExp(\"2bi while 2tri bi* 4dip both? same? tri@ curry prepose 3bi ?if tri* 2keep 3keep curried 2keepd when 2bi* 2tri* 4keep bi@ keepdd do unless* tri-curry if* loop bi-curry* when* 2bi@ 2tri@ with 2with either? bi until 3dip 3curry tri-curry* tri-curry@ bi-curry keepd compose 2dip if 3tri unless tuple keep 2curry tri most while* dip composed bi-curry@ find-last-from trim-head-slice map-as each-from none? trim-tail partition if-empty accumulate* reject! find-from accumulate-as collector-for-as reject map map-sum accumulate! 2each-from follow supremum-by map! unless-empty collector padding reduce-index replicate-as infimum-by trim-tail-slice count find-index filter accumulate*! reject-as map-integers map-find reduce selector interleave 2map filter-as binary-reduce map-index-as find produce filter! replicate cartesian-map cartesian-each find-index-from map-find-last 3map-as 3map find-last selector-as 2map-as 2map-reduce accumulate each each-index accumulate*-as when-empty all? collector-as push-either new-like collector-for 2selector push-if 2all? map-reduce 3each any? trim-slice 2reduce change-nth produce-as 2each trim trim-head cartesian-find map-index if-zero each-integer unless-zero (find-integer) when-zero find-last-integer (all-integers?) times (each-integer) find-integer all-integers? unless-negative if-positive when-positive when-negative unless-positive if-negative case 2cleave cond\\x3equot case\\x3equot 3cleave wrong-values to-fixed-point alist\\x3equot cond cleave call-effect recursive-hashcode spread deep-spread\\x3equot 2|| 0|| n|| 0\\x26\\x26 2\\x26\\x26 3|| 1|| 1\\x26\\x26 n\\x26\\x26 3\\x26\\x26 smart-unless* keep-inputs reduce-outputs smart-when* cleave\\x3earray smart-with smart-apply smart-if inputs/outputs output\\x3esequence-n map-outputs map-reduce-outputs dropping output\\x3earray smart-map-reduce smart-2map-reduce output\\x3earray-n nullary input\\x3csequence append-outputs drop-inputs inputs smart-2reduce drop-outputs smart-reduce preserving smart-when outputs append-outputs-as smart-unless smart-if* sum-outputs input\\x3csequence-unsafe output\\x3esequence\".split(\" \"));\nPrism.languages.factor=factor})(Prism$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=factor$jscomp$0;factor$jscomp$0.displayName=\"factor\";factor$jscomp$0.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$factor\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = factor;\n// @ts-nocheck\nfactor.displayName = 'factor';\nfactor.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction factor(Prism) {\n  ;\n\n  (function (Prism) {\n    var comment_inside = {\n      function: /\\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\\?{2,}|!{2,})\\b/\n    };\n    var string_inside = {\n      number: /\\\\[^\\s']|%\\w/\n    };\n    var factor = {\n      comment: [{\n        // ! single-line exclamation point comments with whitespace after/around the !\n        pattern: /(^|\\s)(?:! .*|!$)/,\n        lookbehind: true,\n        inside: comment_inside\n      },\n      /* from basis/multiline: */\n      {\n        // /* comment */, /* comment*/\n        pattern: /(^|\\s)\\/\\*\\s[\\s\\S]*?\\*\\/(?=\\s|$)/,\n        lookbehind: true,\n        greedy: true,\n        inside: comment_inside\n      }, {\n        // ![[ comment ]] , ![===[ comment]===]\n        pattern: /(^|\\s)!\\[(={0,6})\\[\\s[\\s\\S]*?\\]\\2\\](?=\\s|$)/,\n        lookbehind: true,\n        greedy: true,\n        inside: comment_inside\n      }],\n      number: [{\n        // basic base 10 integers 9, -9\n        pattern: /(^|\\s)[+-]?\\d+(?=\\s|$)/,\n        lookbehind: true\n      }, {\n        // base prefix integers 0b010 0o70 0xad 0d10 0XAD -0xa9\n        pattern: /(^|\\s)[+-]?0(?:b[01]+|o[0-7]+|d\\d+|x[\\dA-F]+)(?=\\s|$)/i,\n        lookbehind: true\n      }, {\n        // fractional ratios 1/5 -1/5 and the literal float approximations 1/5. -1/5.\n        pattern: /(^|\\s)[+-]?\\d+\\/\\d+\\.?(?=\\s|$)/,\n        lookbehind: true\n      }, {\n        // positive mixed numbers 23+1/5 +23+1/5\n        pattern: /(^|\\s)\\+?\\d+\\+\\d+\\/\\d+(?=\\s|$)/,\n        lookbehind: true\n      }, {\n        // negative mixed numbers -23-1/5\n        pattern: /(^|\\s)-\\d+-\\d+\\/\\d+(?=\\s|$)/,\n        lookbehind: true\n      }, {\n        // basic decimal floats -0.01 0. .0 .1 -.1 -1. -12.13 +12.13\n        // and scientific notation with base 10 exponents 3e4 3e-4 .3e-4\n        pattern: /(^|\\s)[+-]?(?:\\d*\\.\\d+|\\d+\\.\\d*|\\d+)(?:e[+-]?\\d+)?(?=\\s|$)/i,\n        lookbehind: true\n      }, {\n        // NAN literal syntax NAN: 80000deadbeef, NAN: a\n        pattern: /(^|\\s)NAN:\\s+[\\da-fA-F]+(?=\\s|$)/,\n        lookbehind: true\n      }, {\n        /*\n        base prefix floats 0x1.0p3 (8.0) 0b1.010p2 (5.0) 0x1.p1 0b1.11111111p11111...\n        \"The normalized hex form ±0x1.MMMMMMMMMMMMM[pP]±EEEE allows any floating-point number to be specified precisely.\n        The values of MMMMMMMMMMMMM and EEEE map directly to the mantissa and exponent fields of the binary IEEE 754 representation.\"\n        <https://docs.factorcode.org/content/article-syntax-floats.html>\n        */\n        pattern: /(^|\\s)[+-]?0(?:b1\\.[01]*|o1\\.[0-7]*|d1\\.\\d*|x1\\.[\\dA-F]*)p\\d+(?=\\s|$)/i,\n        lookbehind: true\n      }],\n      // R/ regexp?\\/\\\\/\n      regexp: {\n        pattern: /(^|\\s)R\\/\\s(?:\\\\\\S|[^\\\\/])*\\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\\s|$)/,\n        lookbehind: true,\n        alias: 'number',\n        inside: {\n          variable: /\\\\\\S/,\n          keyword: /[+?*\\[\\]^$(){}.|]/,\n          operator: {\n            pattern: /(\\/)[idmsr]+(?:-[idmsr]+)?/,\n            lookbehind: true\n          }\n        }\n      },\n      boolean: {\n        pattern: /(^|\\s)[tf](?=\\s|$)/,\n        lookbehind: true\n      },\n      // SBUF\" asd\", URL\" ://...\", P\" /etc/\"\n      'custom-string': {\n        pattern: /(^|\\s)[A-Z0-9\\-]+\"\\s(?:\\\\\\S|[^\"\\\\])*\"/,\n        lookbehind: true,\n        greedy: true,\n        alias: 'string',\n        inside: {\n          number: /\\\\\\S|%\\w|\\//\n        }\n      },\n      'multiline-string': [{\n        // STRING: name \\n content \\n ; -> CONSTANT: name \"content\" (symbol)\n        pattern: /(^|\\s)STRING:\\s+\\S+(?:\\n|\\r\\n).*(?:\\n|\\r\\n)\\s*;(?=\\s|$)/,\n        lookbehind: true,\n        greedy: true,\n        alias: 'string',\n        inside: {\n          number: string_inside.number,\n          // trailing semicolon on its own line\n          'semicolon-or-setlocal': {\n            pattern: /([\\r\\n][ \\t]*);(?=\\s|$)/,\n            lookbehind: true,\n            alias: 'function'\n          }\n        }\n      }, {\n        // HEREDOC: marker \\n content \\n marker ; -> \"content\" (immediate)\n        pattern: /(^|\\s)HEREDOC:\\s+\\S+(?:\\n|\\r\\n).*(?:\\n|\\r\\n)\\s*\\S+(?=\\s|$)/,\n        lookbehind: true,\n        greedy: true,\n        alias: 'string',\n        inside: string_inside\n      }, {\n        // [[ string ]], [==[ string]==]\n        pattern: /(^|\\s)\\[(={0,6})\\[\\s[\\s\\S]*?\\]\\2\\](?=\\s|$)/,\n        lookbehind: true,\n        greedy: true,\n        alias: 'string',\n        inside: string_inside\n      }],\n      'special-using': {\n        pattern: /(^|\\s)USING:(?:\\s\\S+)*(?=\\s+;(?:\\s|$))/,\n        lookbehind: true,\n        alias: 'function',\n        inside: {\n          // this is essentially a regex for vocab names, which i don't want to specify\n          // but the USING: gets picked up as a vocab name\n          string: {\n            pattern: /(\\s)[^:\\s]+/,\n            lookbehind: true\n          }\n        }\n      },\n\n      /* this description of stack effect literal syntax is not complete and not as specific as theoretically possible\n      trying to do better is more work and regex-computation-time than it's worth though.\n      - we'd like to have the \"delimiter\" parts of the stack effect [ (, --, and ) ] be a different (less-important or comment-like) colour to the stack effect contents\n      - we'd like if nested stack effects were treated as such rather than just appearing flat (with `inside`)\n      - we'd like if the following variable name conventions were recognised specifically:\n      special row variables = ..a b..\n      type and stack effect annotations end with a colon = ( quot: ( a: ( -- ) -- b ) -- x ), ( x: number -- )\n      word throws unconditional error = *\n      any other word-like variable name = a ? q' etc\n      https://docs.factorcode.org/content/article-effects.html\n      these are pretty complicated to highlight properly without a real parser, and therefore out of scope\n      the old pattern, which may be later useful, was: (^|\\s)(?:call|execute|eval)?\\((?:\\s+[^\"\\r\\n\\t ]\\S*)*?\\s+--(?:\\s+[^\"\\n\\t ]\\S*)*?\\s+\\)(?=\\s|$)\n      */\n      // current solution is not great\n      'stack-effect-delimiter': [{\n        // opening parenthesis\n        pattern: /(^|\\s)(?:call|eval|execute)?\\((?=\\s)/,\n        lookbehind: true,\n        alias: 'operator'\n      }, {\n        // middle --\n        pattern: /(\\s)--(?=\\s)/,\n        lookbehind: true,\n        alias: 'operator'\n      }, {\n        // closing parenthesis\n        pattern: /(\\s)\\)(?=\\s|$)/,\n        lookbehind: true,\n        alias: 'operator'\n      }],\n      combinators: {\n        pattern: null,\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      'kernel-builtin': {\n        pattern: null,\n        lookbehind: true,\n        alias: 'variable'\n      },\n      'sequences-builtin': {\n        pattern: null,\n        lookbehind: true,\n        alias: 'variable'\n      },\n      'math-builtin': {\n        pattern: null,\n        lookbehind: true,\n        alias: 'variable'\n      },\n      'constructor-word': {\n        // <array> but not <=>\n        pattern: /(^|\\s)<(?!=+>|-+>)\\S+>(?=\\s|$)/,\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      'other-builtin-syntax': {\n        pattern: null,\n        lookbehind: true,\n        alias: 'operator'\n      },\n\n      /*\n      full list of supported word naming conventions: (the convention appears outside of the [brackets])\n      set-[x]\n      change-[x]\n      with-[x]\n      new-[x]\n      >[string]\n      [base]>\n      [string]>[number]\n      +[symbol]+\n      [boolean-word]?\n      ?[of]\n      [slot-reader]>>\n      >>[slot-setter]\n      [slot-writer]<<\n      ([implementation-detail])\n      [mutater]!\n      [variant]*\n      [prettyprint].\n      $[help-markup]\n      <constructors>, SYNTAX:, etc are supported by their own patterns.\n      `with` and `new` from `kernel` are their own builtins.\n      see <https://docs.factorcode.org/content/article-conventions.html>\n      */\n      'conventionally-named-word': {\n        pattern: /(^|\\s)(?!\")(?:(?:change|new|set|with)-\\S+|\\$\\S+|>[^>\\s]+|[^:>\\s]+>|[^>\\s]+>[^>\\s]+|\\+[^+\\s]+\\+|[^?\\s]+\\?|\\?[^?\\s]+|[^>\\s]+>>|>>[^>\\s]+|[^<\\s]+<<|\\([^()\\s]+\\)|[^!\\s]+!|[^*\\s]\\S*\\*|[^.\\s]\\S*\\.)(?=\\s|$)/,\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      'colon-syntax': {\n        pattern: /(^|\\s)(?:[A-Z0-9\\-]+#?)?:{1,2}\\s+(?:;\\S+|(?!;)\\S+)(?=\\s|$)/,\n        lookbehind: true,\n        greedy: true,\n        alias: 'function'\n      },\n      'semicolon-or-setlocal': {\n        pattern: /(\\s)(?:;|:>)(?=\\s|$)/,\n        lookbehind: true,\n        alias: 'function'\n      },\n      // do not highlight leading } or trailing X{ at the begin/end of the file as it's invalid syntax\n      'curly-brace-literal-delimiter': [{\n        // opening\n        pattern: /(^|\\s)[a-z]*\\{(?=\\s)/i,\n        lookbehind: true,\n        alias: 'operator'\n      }, {\n        // closing\n        pattern: /(\\s)\\}(?=\\s|$)/,\n        lookbehind: true,\n        alias: 'operator'\n      }],\n      // do not highlight leading ] or trailing [ at the begin/end of the file as it's invalid syntax\n      'quotation-delimiter': [{\n        // opening\n        pattern: /(^|\\s)\\[(?=\\s)/,\n        lookbehind: true,\n        alias: 'operator'\n      }, {\n        // closing\n        pattern: /(\\s)\\](?=\\s|$)/,\n        lookbehind: true,\n        alias: 'operator'\n      }],\n      'normal-word': {\n        pattern: /(^|\\s)[^\"\\s]\\S*(?=\\s|$)/,\n        lookbehind: true\n      },\n\n      /*\n      basic first-class string \"a\"\n      with escaped double-quote \"a\\\"\"\n      escaped backslash \"\\\\\"\n      and general escapes since Factor has so many \"\\N\"\n      syntax that works in the reference implementation that isn't fully\n      supported because it's an implementation detail:\n      \"string 1\"\"string 2\" -> 2 strings (works anyway)\n      \"string\"5 -> string, 5\n      \"string\"[ ] -> string, quotation\n      { \"a\"} -> array<string>\n      the rest of those examples all properly recognise the string, but not\n      the other object (number, quotation, etc)\n      this is fine for a regex-only implementation.\n      */\n      string: {\n        pattern: /\"(?:\\\\\\S|[^\"\\\\])*\"/,\n        greedy: true,\n        inside: string_inside\n      }\n    };\n\n    var escape = function (str) {\n      return (str + '').replace(/([.?*+\\^$\\[\\]\\\\(){}|\\-])/g, '\\\\$1');\n    };\n\n    var arrToWordsRegExp = function (arr) {\n      return new RegExp('(^|\\\\s)(?:' + arr.map(escape).join('|') + ')(?=\\\\s|$)');\n    };\n\n    var builtins = {\n      'kernel-builtin': ['or', '2nipd', '4drop', 'tuck', 'wrapper', 'nip', 'wrapper?', 'callstack>array', 'die', 'dupd', 'callstack', 'callstack?', '3dup', 'hashcode', 'pick', '4nip', 'build', '>boolean', 'nipd', 'clone', '5nip', 'eq?', '?', '=', 'swapd', '2over', 'clear', '2dup', 'get-retainstack', 'not', 'tuple?', 'dup', '3nipd', 'call', '-rotd', 'object', 'drop', 'assert=', 'assert?', '-rot', 'execute', 'boa', 'get-callstack', 'curried?', '3drop', 'pickd', 'overd', 'over', 'roll', '3nip', 'swap', 'and', '2nip', 'rotd', 'throw', '(clone)', 'hashcode*', 'spin', 'reach', '4dup', 'equal?', 'get-datastack', 'assert', '2drop', '<wrapper>', 'boolean?', 'identity-hashcode', 'identity-tuple?', 'null', 'composed?', 'new', '5drop', 'rot', '-roll', 'xor', 'identity-tuple', 'boolean'],\n      'other-builtin-syntax': [// syntax\n      '=======', 'recursive', 'flushable', '>>', '<<<<<<', 'M\\\\', 'B', 'PRIVATE>', '\\\\', '======', 'final', 'inline', 'delimiter', 'deprecated', '<PRIVATE', '>>>>>>', '<<<<<<<', 'parse-complex', 'malformed-complex', 'read-only', '>>>>>>>', 'call-next-method', '<<', 'foldable', // literals\n      '$', '$[', '${'],\n      'sequences-builtin': ['member-eq?', 'mismatch', 'append', 'assert-sequence=', 'longer', 'repetition', 'clone-like', '3sequence', 'assert-sequence?', 'last-index-from', 'reversed', 'index-from', 'cut*', 'pad-tail', 'join-as', 'remove-eq!', 'concat-as', 'but-last', 'snip', 'nths', 'nth', 'sequence', 'longest', 'slice?', '<slice>', 'remove-nth', 'tail-slice', 'empty?', 'tail*', 'member?', 'virtual-sequence?', 'set-length', 'drop-prefix', 'iota', 'unclip', 'bounds-error?', 'unclip-last-slice', 'non-negative-integer-expected', 'non-negative-integer-expected?', 'midpoint@', 'longer?', '?set-nth', '?first', 'rest-slice', 'prepend-as', 'prepend', 'fourth', 'sift', 'subseq-start', 'new-sequence', '?last', 'like', 'first4', '1sequence', 'reverse', 'slice', 'virtual@', 'repetition?', 'set-last', 'index', '4sequence', 'max-length', 'set-second', 'immutable-sequence', 'first2', 'first3', 'supremum', 'unclip-slice', 'suffix!', 'insert-nth', 'tail', '3append', 'short', 'suffix', 'concat', 'flip', 'immutable?', 'reverse!', '2sequence', 'sum', 'delete-all', 'indices', 'snip-slice', '<iota>', 'check-slice', 'sequence?', 'head', 'append-as', 'halves', 'sequence=', 'collapse-slice', '?second', 'slice-error?', 'product', 'bounds-check?', 'bounds-check', 'immutable', 'virtual-exemplar', 'harvest', 'remove', 'pad-head', 'last', 'set-fourth', 'cartesian-product', 'remove-eq', 'shorten', 'shorter', 'reversed?', 'shorter?', 'shortest', 'head-slice', 'pop*', 'tail-slice*', 'but-last-slice', 'iota?', 'append!', 'cut-slice', 'new-resizable', 'head-slice*', 'sequence-hashcode', 'pop', 'set-nth', '?nth', 'second', 'join', 'immutable-sequence?', '<reversed>', '3append-as', 'virtual-sequence', 'subseq?', 'remove-nth!', 'length', 'last-index', 'lengthen', 'assert-sequence', 'copy', 'move', 'third', 'first', 'tail?', 'set-first', 'prefix', 'bounds-error', '<repetition>', 'exchange', 'surround', 'cut', 'min-length', 'set-third', 'push-all', 'head?', 'subseq-start-from', 'delete-slice', 'rest', 'sum-lengths', 'head*', 'infimum', 'remove!', 'glue', 'slice-error', 'subseq', 'push', 'replace-slice', 'subseq-as', 'unclip-last'],\n      'math-builtin': ['number=', 'next-power-of-2', '?1+', 'fp-special?', 'imaginary-part', 'float>bits', 'number?', 'fp-infinity?', 'bignum?', 'fp-snan?', 'denominator', 'gcd', '*', '+', 'fp-bitwise=', '-', 'u>=', '/', '>=', 'bitand', 'power-of-2?', 'log2-expects-positive', 'neg?', '<', 'log2', '>', 'integer?', 'number', 'bits>double', '2/', 'zero?', 'bits>float', 'float?', 'shift', 'ratio?', 'rect>', 'even?', 'ratio', 'fp-sign', 'bitnot', '>fixnum', 'complex?', '/i', 'integer>fixnum', '/f', 'sgn', '>bignum', 'next-float', 'u<', 'u>', 'mod', 'recip', 'rational', '>float', '2^', 'integer', 'fixnum?', 'neg', 'fixnum', 'sq', 'bignum', '>rect', 'bit?', 'fp-qnan?', 'simple-gcd', 'complex', '<fp-nan>', 'real', '>fraction', 'double>bits', 'bitor', 'rem', 'fp-nan-payload', 'real-part', 'log2-expects-positive?', 'prev-float', 'align', 'unordered?', 'float', 'fp-nan?', 'abs', 'bitxor', 'integer>fixnum-strict', 'u<=', 'odd?', '<=', '/mod', '>integer', 'real?', 'rational?', 'numerator'] // that's all for now\n\n    };\n    Object.keys(builtins).forEach(function (k) {\n      factor[k].pattern = arrToWordsRegExp(builtins[k]);\n    });\n    var combinators = [// kernel\n    '2bi', 'while', '2tri', 'bi*', '4dip', 'both?', 'same?', 'tri@', 'curry', 'prepose', '3bi', '?if', 'tri*', '2keep', '3keep', 'curried', '2keepd', 'when', '2bi*', '2tri*', '4keep', 'bi@', 'keepdd', 'do', 'unless*', 'tri-curry', 'if*', 'loop', 'bi-curry*', 'when*', '2bi@', '2tri@', 'with', '2with', 'either?', 'bi', 'until', '3dip', '3curry', 'tri-curry*', 'tri-curry@', 'bi-curry', 'keepd', 'compose', '2dip', 'if', '3tri', 'unless', 'tuple', 'keep', '2curry', 'tri', 'most', 'while*', 'dip', 'composed', 'bi-curry@', // sequences\n    'find-last-from', 'trim-head-slice', 'map-as', 'each-from', 'none?', 'trim-tail', 'partition', 'if-empty', 'accumulate*', 'reject!', 'find-from', 'accumulate-as', 'collector-for-as', 'reject', 'map', 'map-sum', 'accumulate!', '2each-from', 'follow', 'supremum-by', 'map!', 'unless-empty', 'collector', 'padding', 'reduce-index', 'replicate-as', 'infimum-by', 'trim-tail-slice', 'count', 'find-index', 'filter', 'accumulate*!', 'reject-as', 'map-integers', 'map-find', 'reduce', 'selector', 'interleave', '2map', 'filter-as', 'binary-reduce', 'map-index-as', 'find', 'produce', 'filter!', 'replicate', 'cartesian-map', 'cartesian-each', 'find-index-from', 'map-find-last', '3map-as', '3map', 'find-last', 'selector-as', '2map-as', '2map-reduce', 'accumulate', 'each', 'each-index', 'accumulate*-as', 'when-empty', 'all?', 'collector-as', 'push-either', 'new-like', 'collector-for', '2selector', 'push-if', '2all?', 'map-reduce', '3each', 'any?', 'trim-slice', '2reduce', 'change-nth', 'produce-as', '2each', 'trim', 'trim-head', 'cartesian-find', 'map-index', // math\n    'if-zero', 'each-integer', 'unless-zero', '(find-integer)', 'when-zero', 'find-last-integer', '(all-integers?)', 'times', '(each-integer)', 'find-integer', 'all-integers?', // math.combinators\n    'unless-negative', 'if-positive', 'when-positive', 'when-negative', 'unless-positive', 'if-negative', // combinators\n    'case', '2cleave', 'cond>quot', 'case>quot', '3cleave', 'wrong-values', 'to-fixed-point', 'alist>quot', 'cond', 'cleave', 'call-effect', 'recursive-hashcode', 'spread', 'deep-spread>quot', // combinators.short-circuit\n    '2||', '0||', 'n||', '0&&', '2&&', '3||', '1||', '1&&', 'n&&', '3&&', // combinators.smart\n    'smart-unless*', 'keep-inputs', 'reduce-outputs', 'smart-when*', 'cleave>array', 'smart-with', 'smart-apply', 'smart-if', 'inputs/outputs', 'output>sequence-n', 'map-outputs', 'map-reduce-outputs', 'dropping', 'output>array', 'smart-map-reduce', 'smart-2map-reduce', 'output>array-n', 'nullary', 'input<sequence', 'append-outputs', 'drop-inputs', 'inputs', 'smart-2reduce', 'drop-outputs', 'smart-reduce', 'preserving', 'smart-when', 'outputs', 'append-outputs-as', 'smart-unless', 'smart-if*', 'sum-outputs', 'input<sequence-unsafe', 'output>sequence' // tafn\n    ];\n    factor.combinators.pattern = arrToWordsRegExp(combinators);\n    Prism.languages.factor = factor;\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["boolean","string","aliases","operator","displayName","factor","__esModule","lookbehind","value","regexp","variable","keyword","number","greedy","function","pattern","inside","combinators","alias","comment","default"]],"~:compiled-at",1676841365411,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$factor.js\",\n\"lineCount\":12,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/refractor/lang/factor.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$factor\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = factor;\\n// @ts-nocheck\\nfactor.displayName = 'factor';\\nfactor.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction factor(Prism) {\\n  ;\\n\\n  (function (Prism) {\\n    var comment_inside = {\\n      function: /\\\\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\\\\?{2,}|!{2,})\\\\b/\\n    };\\n    var string_inside = {\\n      number: /\\\\\\\\[^\\\\s']|%\\\\w/\\n    };\\n    var factor = {\\n      comment: [{\\n        // ! single-line exclamation point comments with whitespace after/around the !\\n        pattern: /(^|\\\\s)(?:! .*|!$)/,\\n        lookbehind: true,\\n        inside: comment_inside\\n      },\\n      /* from basis/multiline: */\\n      {\\n        // /* comment */, /* comment*/\\n        pattern: /(^|\\\\s)\\\\/\\\\*\\\\s[\\\\s\\\\S]*?\\\\*\\\\/(?=\\\\s|$)/,\\n        lookbehind: true,\\n        greedy: true,\\n        inside: comment_inside\\n      }, {\\n        // ![[ comment ]] , ![===[ comment]===]\\n        pattern: /(^|\\\\s)!\\\\[(={0,6})\\\\[\\\\s[\\\\s\\\\S]*?\\\\]\\\\2\\\\](?=\\\\s|$)/,\\n        lookbehind: true,\\n        greedy: true,\\n        inside: comment_inside\\n      }],\\n      number: [{\\n        // basic base 10 integers 9, -9\\n        pattern: /(^|\\\\s)[+-]?\\\\d+(?=\\\\s|$)/,\\n        lookbehind: true\\n      }, {\\n        // base prefix integers 0b010 0o70 0xad 0d10 0XAD -0xa9\\n        pattern: /(^|\\\\s)[+-]?0(?:b[01]+|o[0-7]+|d\\\\d+|x[\\\\dA-F]+)(?=\\\\s|$)/i,\\n        lookbehind: true\\n      }, {\\n        // fractional ratios 1/5 -1/5 and the literal float approximations 1/5. -1/5.\\n        pattern: /(^|\\\\s)[+-]?\\\\d+\\\\/\\\\d+\\\\.?(?=\\\\s|$)/,\\n        lookbehind: true\\n      }, {\\n        // positive mixed numbers 23+1/5 +23+1/5\\n        pattern: /(^|\\\\s)\\\\+?\\\\d+\\\\+\\\\d+\\\\/\\\\d+(?=\\\\s|$)/,\\n        lookbehind: true\\n      }, {\\n        // negative mixed numbers -23-1/5\\n        pattern: /(^|\\\\s)-\\\\d+-\\\\d+\\\\/\\\\d+(?=\\\\s|$)/,\\n        lookbehind: true\\n      }, {\\n        // basic decimal floats -0.01 0. .0 .1 -.1 -1. -12.13 +12.13\\n        // and scientific notation with base 10 exponents 3e4 3e-4 .3e-4\\n        pattern: /(^|\\\\s)[+-]?(?:\\\\d*\\\\.\\\\d+|\\\\d+\\\\.\\\\d*|\\\\d+)(?:e[+-]?\\\\d+)?(?=\\\\s|$)/i,\\n        lookbehind: true\\n      }, {\\n        // NAN literal syntax NAN: 80000deadbeef, NAN: a\\n        pattern: /(^|\\\\s)NAN:\\\\s+[\\\\da-fA-F]+(?=\\\\s|$)/,\\n        lookbehind: true\\n      }, {\\n        /*\\n        base prefix floats 0x1.0p3 (8.0) 0b1.010p2 (5.0) 0x1.p1 0b1.11111111p11111...\\n        \\\"The normalized hex form \\u00b10x1.MMMMMMMMMMMMM[pP]\\u00b1EEEE allows any floating-point number to be specified precisely.\\n        The values of MMMMMMMMMMMMM and EEEE map directly to the mantissa and exponent fields of the binary IEEE 754 representation.\\\"\\n        <https://docs.factorcode.org/content/article-syntax-floats.html>\\n        */\\n        pattern: /(^|\\\\s)[+-]?0(?:b1\\\\.[01]*|o1\\\\.[0-7]*|d1\\\\.\\\\d*|x1\\\\.[\\\\dA-F]*)p\\\\d+(?=\\\\s|$)/i,\\n        lookbehind: true\\n      }],\\n      // R/ regexp?\\\\/\\\\\\\\/\\n      regexp: {\\n        pattern: /(^|\\\\s)R\\\\/\\\\s(?:\\\\\\\\\\\\S|[^\\\\\\\\/])*\\\\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\\\\s|$)/,\\n        lookbehind: true,\\n        alias: 'number',\\n        inside: {\\n          variable: /\\\\\\\\\\\\S/,\\n          keyword: /[+?*\\\\[\\\\]^$(){}.|]/,\\n          operator: {\\n            pattern: /(\\\\/)[idmsr]+(?:-[idmsr]+)?/,\\n            lookbehind: true\\n          }\\n        }\\n      },\\n      boolean: {\\n        pattern: /(^|\\\\s)[tf](?=\\\\s|$)/,\\n        lookbehind: true\\n      },\\n      // SBUF\\\" asd\\\", URL\\\" ://...\\\", P\\\" /etc/\\\"\\n      'custom-string': {\\n        pattern: /(^|\\\\s)[A-Z0-9\\\\-]+\\\"\\\\s(?:\\\\\\\\\\\\S|[^\\\"\\\\\\\\])*\\\"/,\\n        lookbehind: true,\\n        greedy: true,\\n        alias: 'string',\\n        inside: {\\n          number: /\\\\\\\\\\\\S|%\\\\w|\\\\//\\n        }\\n      },\\n      'multiline-string': [{\\n        // STRING: name \\\\n content \\\\n ; -> CONSTANT: name \\\"content\\\" (symbol)\\n        pattern: /(^|\\\\s)STRING:\\\\s+\\\\S+(?:\\\\n|\\\\r\\\\n).*(?:\\\\n|\\\\r\\\\n)\\\\s*;(?=\\\\s|$)/,\\n        lookbehind: true,\\n        greedy: true,\\n        alias: 'string',\\n        inside: {\\n          number: string_inside.number,\\n          // trailing semicolon on its own line\\n          'semicolon-or-setlocal': {\\n            pattern: /([\\\\r\\\\n][ \\\\t]*);(?=\\\\s|$)/,\\n            lookbehind: true,\\n            alias: 'function'\\n          }\\n        }\\n      }, {\\n        // HEREDOC: marker \\\\n content \\\\n marker ; -> \\\"content\\\" (immediate)\\n        pattern: /(^|\\\\s)HEREDOC:\\\\s+\\\\S+(?:\\\\n|\\\\r\\\\n).*(?:\\\\n|\\\\r\\\\n)\\\\s*\\\\S+(?=\\\\s|$)/,\\n        lookbehind: true,\\n        greedy: true,\\n        alias: 'string',\\n        inside: string_inside\\n      }, {\\n        // [[ string ]], [==[ string]==]\\n        pattern: /(^|\\\\s)\\\\[(={0,6})\\\\[\\\\s[\\\\s\\\\S]*?\\\\]\\\\2\\\\](?=\\\\s|$)/,\\n        lookbehind: true,\\n        greedy: true,\\n        alias: 'string',\\n        inside: string_inside\\n      }],\\n      'special-using': {\\n        pattern: /(^|\\\\s)USING:(?:\\\\s\\\\S+)*(?=\\\\s+;(?:\\\\s|$))/,\\n        lookbehind: true,\\n        alias: 'function',\\n        inside: {\\n          // this is essentially a regex for vocab names, which i don't want to specify\\n          // but the USING: gets picked up as a vocab name\\n          string: {\\n            pattern: /(\\\\s)[^:\\\\s]+/,\\n            lookbehind: true\\n          }\\n        }\\n      },\\n\\n      /* this description of stack effect literal syntax is not complete and not as specific as theoretically possible\\n      trying to do better is more work and regex-computation-time than it's worth though.\\n      - we'd like to have the \\\"delimiter\\\" parts of the stack effect [ (, --, and ) ] be a different (less-important or comment-like) colour to the stack effect contents\\n      - we'd like if nested stack effects were treated as such rather than just appearing flat (with `inside`)\\n      - we'd like if the following variable name conventions were recognised specifically:\\n      special row variables = ..a b..\\n      type and stack effect annotations end with a colon = ( quot: ( a: ( -- ) -- b ) -- x ), ( x: number -- )\\n      word throws unconditional error = *\\n      any other word-like variable name = a ? q' etc\\n      https://docs.factorcode.org/content/article-effects.html\\n      these are pretty complicated to highlight properly without a real parser, and therefore out of scope\\n      the old pattern, which may be later useful, was: (^|\\\\s)(?:call|execute|eval)?\\\\((?:\\\\s+[^\\\"\\\\r\\\\n\\\\t ]\\\\S*)*?\\\\s+--(?:\\\\s+[^\\\"\\\\n\\\\t ]\\\\S*)*?\\\\s+\\\\)(?=\\\\s|$)\\n      */\\n      // current solution is not great\\n      'stack-effect-delimiter': [{\\n        // opening parenthesis\\n        pattern: /(^|\\\\s)(?:call|eval|execute)?\\\\((?=\\\\s)/,\\n        lookbehind: true,\\n        alias: 'operator'\\n      }, {\\n        // middle --\\n        pattern: /(\\\\s)--(?=\\\\s)/,\\n        lookbehind: true,\\n        alias: 'operator'\\n      }, {\\n        // closing parenthesis\\n        pattern: /(\\\\s)\\\\)(?=\\\\s|$)/,\\n        lookbehind: true,\\n        alias: 'operator'\\n      }],\\n      combinators: {\\n        pattern: null,\\n        lookbehind: true,\\n        alias: 'keyword'\\n      },\\n      'kernel-builtin': {\\n        pattern: null,\\n        lookbehind: true,\\n        alias: 'variable'\\n      },\\n      'sequences-builtin': {\\n        pattern: null,\\n        lookbehind: true,\\n        alias: 'variable'\\n      },\\n      'math-builtin': {\\n        pattern: null,\\n        lookbehind: true,\\n        alias: 'variable'\\n      },\\n      'constructor-word': {\\n        // <array> but not <=>\\n        pattern: /(^|\\\\s)<(?!=+>|-+>)\\\\S+>(?=\\\\s|$)/,\\n        lookbehind: true,\\n        alias: 'keyword'\\n      },\\n      'other-builtin-syntax': {\\n        pattern: null,\\n        lookbehind: true,\\n        alias: 'operator'\\n      },\\n\\n      /*\\n      full list of supported word naming conventions: (the convention appears outside of the [brackets])\\n      set-[x]\\n      change-[x]\\n      with-[x]\\n      new-[x]\\n      >[string]\\n      [base]>\\n      [string]>[number]\\n      +[symbol]+\\n      [boolean-word]?\\n      ?[of]\\n      [slot-reader]>>\\n      >>[slot-setter]\\n      [slot-writer]<<\\n      ([implementation-detail])\\n      [mutater]!\\n      [variant]*\\n      [prettyprint].\\n      $[help-markup]\\n      <constructors>, SYNTAX:, etc are supported by their own patterns.\\n      `with` and `new` from `kernel` are their own builtins.\\n      see <https://docs.factorcode.org/content/article-conventions.html>\\n      */\\n      'conventionally-named-word': {\\n        pattern: /(^|\\\\s)(?!\\\")(?:(?:change|new|set|with)-\\\\S+|\\\\$\\\\S+|>[^>\\\\s]+|[^:>\\\\s]+>|[^>\\\\s]+>[^>\\\\s]+|\\\\+[^+\\\\s]+\\\\+|[^?\\\\s]+\\\\?|\\\\?[^?\\\\s]+|[^>\\\\s]+>>|>>[^>\\\\s]+|[^<\\\\s]+<<|\\\\([^()\\\\s]+\\\\)|[^!\\\\s]+!|[^*\\\\s]\\\\S*\\\\*|[^.\\\\s]\\\\S*\\\\.)(?=\\\\s|$)/,\\n        lookbehind: true,\\n        alias: 'keyword'\\n      },\\n      'colon-syntax': {\\n        pattern: /(^|\\\\s)(?:[A-Z0-9\\\\-]+#?)?:{1,2}\\\\s+(?:;\\\\S+|(?!;)\\\\S+)(?=\\\\s|$)/,\\n        lookbehind: true,\\n        greedy: true,\\n        alias: 'function'\\n      },\\n      'semicolon-or-setlocal': {\\n        pattern: /(\\\\s)(?:;|:>)(?=\\\\s|$)/,\\n        lookbehind: true,\\n        alias: 'function'\\n      },\\n      // do not highlight leading } or trailing X{ at the begin/end of the file as it's invalid syntax\\n      'curly-brace-literal-delimiter': [{\\n        // opening\\n        pattern: /(^|\\\\s)[a-z]*\\\\{(?=\\\\s)/i,\\n        lookbehind: true,\\n        alias: 'operator'\\n      }, {\\n        // closing\\n        pattern: /(\\\\s)\\\\}(?=\\\\s|$)/,\\n        lookbehind: true,\\n        alias: 'operator'\\n      }],\\n      // do not highlight leading ] or trailing [ at the begin/end of the file as it's invalid syntax\\n      'quotation-delimiter': [{\\n        // opening\\n        pattern: /(^|\\\\s)\\\\[(?=\\\\s)/,\\n        lookbehind: true,\\n        alias: 'operator'\\n      }, {\\n        // closing\\n        pattern: /(\\\\s)\\\\](?=\\\\s|$)/,\\n        lookbehind: true,\\n        alias: 'operator'\\n      }],\\n      'normal-word': {\\n        pattern: /(^|\\\\s)[^\\\"\\\\s]\\\\S*(?=\\\\s|$)/,\\n        lookbehind: true\\n      },\\n\\n      /*\\n      basic first-class string \\\"a\\\"\\n      with escaped double-quote \\\"a\\\\\\\"\\\"\\n      escaped backslash \\\"\\\\\\\\\\\"\\n      and general escapes since Factor has so many \\\"\\\\N\\\"\\n      syntax that works in the reference implementation that isn't fully\\n      supported because it's an implementation detail:\\n      \\\"string 1\\\"\\\"string 2\\\" -> 2 strings (works anyway)\\n      \\\"string\\\"5 -> string, 5\\n      \\\"string\\\"[ ] -> string, quotation\\n      { \\\"a\\\"} -> array<string>\\n      the rest of those examples all properly recognise the string, but not\\n      the other object (number, quotation, etc)\\n      this is fine for a regex-only implementation.\\n      */\\n      string: {\\n        pattern: /\\\"(?:\\\\\\\\\\\\S|[^\\\"\\\\\\\\])*\\\"/,\\n        greedy: true,\\n        inside: string_inside\\n      }\\n    };\\n\\n    var escape = function (str) {\\n      return (str + '').replace(/([.?*+\\\\^$\\\\[\\\\]\\\\\\\\(){}|\\\\-])/g, '\\\\\\\\$1');\\n    };\\n\\n    var arrToWordsRegExp = function (arr) {\\n      return new RegExp('(^|\\\\\\\\s)(?:' + arr.map(escape).join('|') + ')(?=\\\\\\\\s|$)');\\n    };\\n\\n    var builtins = {\\n      'kernel-builtin': ['or', '2nipd', '4drop', 'tuck', 'wrapper', 'nip', 'wrapper?', 'callstack>array', 'die', 'dupd', 'callstack', 'callstack?', '3dup', 'hashcode', 'pick', '4nip', 'build', '>boolean', 'nipd', 'clone', '5nip', 'eq?', '?', '=', 'swapd', '2over', 'clear', '2dup', 'get-retainstack', 'not', 'tuple?', 'dup', '3nipd', 'call', '-rotd', 'object', 'drop', 'assert=', 'assert?', '-rot', 'execute', 'boa', 'get-callstack', 'curried?', '3drop', 'pickd', 'overd', 'over', 'roll', '3nip', 'swap', 'and', '2nip', 'rotd', 'throw', '(clone)', 'hashcode*', 'spin', 'reach', '4dup', 'equal?', 'get-datastack', 'assert', '2drop', '<wrapper>', 'boolean?', 'identity-hashcode', 'identity-tuple?', 'null', 'composed?', 'new', '5drop', 'rot', '-roll', 'xor', 'identity-tuple', 'boolean'],\\n      'other-builtin-syntax': [// syntax\\n      '=======', 'recursive', 'flushable', '>>', '<<<<<<', 'M\\\\\\\\', 'B', 'PRIVATE>', '\\\\\\\\', '======', 'final', 'inline', 'delimiter', 'deprecated', '<PRIVATE', '>>>>>>', '<<<<<<<', 'parse-complex', 'malformed-complex', 'read-only', '>>>>>>>', 'call-next-method', '<<', 'foldable', // literals\\n      '$', '$[', '${'],\\n      'sequences-builtin': ['member-eq?', 'mismatch', 'append', 'assert-sequence=', 'longer', 'repetition', 'clone-like', '3sequence', 'assert-sequence?', 'last-index-from', 'reversed', 'index-from', 'cut*', 'pad-tail', 'join-as', 'remove-eq!', 'concat-as', 'but-last', 'snip', 'nths', 'nth', 'sequence', 'longest', 'slice?', '<slice>', 'remove-nth', 'tail-slice', 'empty?', 'tail*', 'member?', 'virtual-sequence?', 'set-length', 'drop-prefix', 'iota', 'unclip', 'bounds-error?', 'unclip-last-slice', 'non-negative-integer-expected', 'non-negative-integer-expected?', 'midpoint@', 'longer?', '?set-nth', '?first', 'rest-slice', 'prepend-as', 'prepend', 'fourth', 'sift', 'subseq-start', 'new-sequence', '?last', 'like', 'first4', '1sequence', 'reverse', 'slice', 'virtual@', 'repetition?', 'set-last', 'index', '4sequence', 'max-length', 'set-second', 'immutable-sequence', 'first2', 'first3', 'supremum', 'unclip-slice', 'suffix!', 'insert-nth', 'tail', '3append', 'short', 'suffix', 'concat', 'flip', 'immutable?', 'reverse!', '2sequence', 'sum', 'delete-all', 'indices', 'snip-slice', '<iota>', 'check-slice', 'sequence?', 'head', 'append-as', 'halves', 'sequence=', 'collapse-slice', '?second', 'slice-error?', 'product', 'bounds-check?', 'bounds-check', 'immutable', 'virtual-exemplar', 'harvest', 'remove', 'pad-head', 'last', 'set-fourth', 'cartesian-product', 'remove-eq', 'shorten', 'shorter', 'reversed?', 'shorter?', 'shortest', 'head-slice', 'pop*', 'tail-slice*', 'but-last-slice', 'iota?', 'append!', 'cut-slice', 'new-resizable', 'head-slice*', 'sequence-hashcode', 'pop', 'set-nth', '?nth', 'second', 'join', 'immutable-sequence?', '<reversed>', '3append-as', 'virtual-sequence', 'subseq?', 'remove-nth!', 'length', 'last-index', 'lengthen', 'assert-sequence', 'copy', 'move', 'third', 'first', 'tail?', 'set-first', 'prefix', 'bounds-error', '<repetition>', 'exchange', 'surround', 'cut', 'min-length', 'set-third', 'push-all', 'head?', 'subseq-start-from', 'delete-slice', 'rest', 'sum-lengths', 'head*', 'infimum', 'remove!', 'glue', 'slice-error', 'subseq', 'push', 'replace-slice', 'subseq-as', 'unclip-last'],\\n      'math-builtin': ['number=', 'next-power-of-2', '?1+', 'fp-special?', 'imaginary-part', 'float>bits', 'number?', 'fp-infinity?', 'bignum?', 'fp-snan?', 'denominator', 'gcd', '*', '+', 'fp-bitwise=', '-', 'u>=', '/', '>=', 'bitand', 'power-of-2?', 'log2-expects-positive', 'neg?', '<', 'log2', '>', 'integer?', 'number', 'bits>double', '2/', 'zero?', 'bits>float', 'float?', 'shift', 'ratio?', 'rect>', 'even?', 'ratio', 'fp-sign', 'bitnot', '>fixnum', 'complex?', '/i', 'integer>fixnum', '/f', 'sgn', '>bignum', 'next-float', 'u<', 'u>', 'mod', 'recip', 'rational', '>float', '2^', 'integer', 'fixnum?', 'neg', 'fixnum', 'sq', 'bignum', '>rect', 'bit?', 'fp-qnan?', 'simple-gcd', 'complex', '<fp-nan>', 'real', '>fraction', 'double>bits', 'bitor', 'rem', 'fp-nan-payload', 'real-part', 'log2-expects-positive?', 'prev-float', 'align', 'unordered?', 'float', 'fp-nan?', 'abs', 'bitxor', 'integer>fixnum-strict', 'u<=', 'odd?', '<=', '/mod', '>integer', 'real?', 'rational?', 'numerator'] // that's all for now\\n\\n    };\\n    Object.keys(builtins).forEach(function (k) {\\n      factor[k].pattern = arrToWordsRegExp(builtins[k]);\\n    });\\n    var combinators = [// kernel\\n    '2bi', 'while', '2tri', 'bi*', '4dip', 'both?', 'same?', 'tri@', 'curry', 'prepose', '3bi', '?if', 'tri*', '2keep', '3keep', 'curried', '2keepd', 'when', '2bi*', '2tri*', '4keep', 'bi@', 'keepdd', 'do', 'unless*', 'tri-curry', 'if*', 'loop', 'bi-curry*', 'when*', '2bi@', '2tri@', 'with', '2with', 'either?', 'bi', 'until', '3dip', '3curry', 'tri-curry*', 'tri-curry@', 'bi-curry', 'keepd', 'compose', '2dip', 'if', '3tri', 'unless', 'tuple', 'keep', '2curry', 'tri', 'most', 'while*', 'dip', 'composed', 'bi-curry@', // sequences\\n    'find-last-from', 'trim-head-slice', 'map-as', 'each-from', 'none?', 'trim-tail', 'partition', 'if-empty', 'accumulate*', 'reject!', 'find-from', 'accumulate-as', 'collector-for-as', 'reject', 'map', 'map-sum', 'accumulate!', '2each-from', 'follow', 'supremum-by', 'map!', 'unless-empty', 'collector', 'padding', 'reduce-index', 'replicate-as', 'infimum-by', 'trim-tail-slice', 'count', 'find-index', 'filter', 'accumulate*!', 'reject-as', 'map-integers', 'map-find', 'reduce', 'selector', 'interleave', '2map', 'filter-as', 'binary-reduce', 'map-index-as', 'find', 'produce', 'filter!', 'replicate', 'cartesian-map', 'cartesian-each', 'find-index-from', 'map-find-last', '3map-as', '3map', 'find-last', 'selector-as', '2map-as', '2map-reduce', 'accumulate', 'each', 'each-index', 'accumulate*-as', 'when-empty', 'all?', 'collector-as', 'push-either', 'new-like', 'collector-for', '2selector', 'push-if', '2all?', 'map-reduce', '3each', 'any?', 'trim-slice', '2reduce', 'change-nth', 'produce-as', '2each', 'trim', 'trim-head', 'cartesian-find', 'map-index', // math\\n    'if-zero', 'each-integer', 'unless-zero', '(find-integer)', 'when-zero', 'find-last-integer', '(all-integers?)', 'times', '(each-integer)', 'find-integer', 'all-integers?', // math.combinators\\n    'unless-negative', 'if-positive', 'when-positive', 'when-negative', 'unless-positive', 'if-negative', // combinators\\n    'case', '2cleave', 'cond>quot', 'case>quot', '3cleave', 'wrong-values', 'to-fixed-point', 'alist>quot', 'cond', 'cleave', 'call-effect', 'recursive-hashcode', 'spread', 'deep-spread>quot', // combinators.short-circuit\\n    '2||', '0||', 'n||', '0&&', '2&&', '3||', '1||', '1&&', 'n&&', '3&&', // combinators.smart\\n    'smart-unless*', 'keep-inputs', 'reduce-outputs', 'smart-when*', 'cleave>array', 'smart-with', 'smart-apply', 'smart-if', 'inputs/outputs', 'output>sequence-n', 'map-outputs', 'map-reduce-outputs', 'dropping', 'output>array', 'smart-map-reduce', 'smart-2map-reduce', 'output>array-n', 'nullary', 'input<sequence', 'append-outputs', 'drop-inputs', 'inputs', 'smart-2reduce', 'drop-outputs', 'smart-reduce', 'preserving', 'smart-when', 'outputs', 'append-outputs-as', 'smart-unless', 'smart-if*', 'sum-outputs', 'input<sequence-unsafe', 'output>sequence' // tafn\\n    ];\\n    factor.combinators.pattern = arrToWordsRegExp(combinators);\\n    Prism.languages.factor = factor;\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factor\",\"Prism\",\"comment_inside\",\"function\",\"string_inside\",\"number\",\"comment\",\"pattern\",\"lookbehind\",\"inside\",\"greedy\",\"regexp\",\"alias\",\"variable\",\"keyword\",\"operator\",\"boolean\",\"string\",\"combinators\",\"escape\",\"str\",\"replace\",\"arrToWordsRegExp\",\"arr\",\"RegExp\",\"map\",\"join\",\"builtins\",\"Object\",\"keys\",\"forEach\",\"k\",\"languages\",\"defineProperty\",\"value\",\"default\",\"displayName\",\"aliases\"]\n}\n"]