["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/tsx.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$tsx=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function tsx(Prism){Prism.register(_jsx.default);Prism.register(_typescript.default);var typescript=Prism.util.clone(Prism.languages.typescript);Prism.languages.tsx=Prism.languages.extend(\"jsx\",typescript);delete Prism.languages.tsx.parameter;delete Prism.languages.tsx[\"literal-property\"];Prism=Prism.languages.tsx.tag;Prism.pattern=\nRegExp(/(^|[^\\w$]|(?=<\\/))/.source+\"(?:\"+Prism.pattern.source+\")\",Prism.pattern.flags);Prism.lookbehind=!0}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=tsx;var _jsx=_interopRequireDefault(require(\"module$node_modules$refractor$lang$jsx\")),_typescript=_interopRequireDefault(require(\"module$node_modules$refractor$lang$typescript\"));tsx.displayName=\"tsx\";tsx.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$tsx\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = tsx;\n\nvar _jsx = _interopRequireDefault(require(\"./jsx.js\"));\n\nvar _typescript = _interopRequireDefault(require(\"./typescript.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// @ts-nocheck\ntsx.displayName = 'tsx';\ntsx.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction tsx(Prism) {\n  Prism.register(_jsx.default);\n  Prism.register(_typescript.default);\n\n  (function (Prism) {\n    var typescript = Prism.util.clone(Prism.languages.typescript);\n    Prism.languages.tsx = Prism.languages.extend('jsx', typescript); // doesn't work with TS because TS is too complex\n\n    delete Prism.languages.tsx['parameter'];\n    delete Prism.languages.tsx['literal-property']; // This will prevent collisions between TSX tags and TS generic types.\n    // Idea by https://github.com/karlhorky\n    // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928\n\n    var tag = Prism.languages.tsx.tag;\n    tag.pattern = RegExp(/(^|[^\\w$]|(?=<\\/))/.source + '(?:' + tag.pattern.source + ')', tag.pattern.flags);\n    tag.lookbehind = true;\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$refractor$lang$typescript","~$module$node_modules$refractor$lang$jsx","~$shadow.js"]],"~:properties",["^5",["aliases","displayName","__esModule","lookbehind","value","pattern","tsx","default"]],"~:compiled-at",1676841365455,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$tsx.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,sCAAA,CAA2D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAYnGC,QAASA,uBAAsB,CAACC,GAAD,CAAM,CAAE,MAAOA,IAAA,EAAOA,GAAIC,CAAAA,UAAX,CAAwBD,GAAxB,CAA8B,CAAEE,QAASF,GAAX,CAAvC,CAOrCG,QAASA,IAAG,CAACC,KAAD,CAAQ,CAClBA,KAAMC,CAAAA,QAAN,CAAeC,IAAKJ,CAAAA,OAApB,CACAE,MAAMC,CAAAA,QAAN,CAAeE,WAAYL,CAAAA,OAA3B,CAGE,KAAIM,WAWHJ,KAXsBK,CAAAA,IAAKC,CAAAA,KAAX,CAWhBN,KAXuCO,CAAAA,SAAUH,CAAAA,UAAjC,CAWhBJ,MAVKO,CAAAA,SAAUR,CAAAA,GAAhB,CAUCC,KAV2BO,CAAAA,SAAUC,CAAAA,MAAhB,CAAuB,KAAvB,CAA8BJ,UAA9B,CAEtB,QAQCJ,KARYO,CAAAA,SAAUR,CAAAA,GAAhB,CAAA,SACP,QAOCC,KAPYO,CAAAA,SAAUR,CAAAA,GAAhB,CAAoB,kBAApB,CAIHU,MAAAA,CAGHT,KAHeO,CAAAA,SAAUR,CAAAA,GAAIU,CAAAA,GAC9BA,MAAIC,CAAAA,OAAJ;AAAcC,MAAA,CAAO,oBAAqBC,CAAAA,MAA5B,CAAqC,KAArC,CAA6CH,KAAIC,CAAAA,OAAQE,CAAAA,MAAzD,CAAkE,GAAlE,CAAuEH,KAAIC,CAAAA,OAAQG,CAAAA,KAAnF,CACdJ,MAAIK,CAAAA,UAAJ,CAAiB,CAAA,CAfD,CAhBpBC,MAAOC,CAAAA,cAAP,CAAsBtB,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CuB,MAAO,CAAA,CADoC,CAA7C,CAGAvB,QAAQI,CAAAA,OAAR,CAAkBC,GAElB,KAAIG,KAAOP,sBAAA,CAAuBH,OAAA,CAAQ,wCAAR,CAAvB,CAAX,CAEIW,YAAcR,sBAAA,CAAuBH,OAAA,CAAQ,+CAAR,CAAvB,CAKlBO,IAAImB,CAAAA,WAAJ,CAAkB,KAClBnB,IAAIoB,CAAAA,OAAJ,CAAc,EAhBqF;\",\n\"sources\":[\"node_modules/refractor/lang/tsx.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$tsx\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = tsx;\\n\\nvar _jsx = _interopRequireDefault(require(\\\"./jsx.js\\\"));\\n\\nvar _typescript = _interopRequireDefault(require(\\\"./typescript.js\\\"));\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n// @ts-nocheck\\ntsx.displayName = 'tsx';\\ntsx.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction tsx(Prism) {\\n  Prism.register(_jsx.default);\\n  Prism.register(_typescript.default);\\n\\n  (function (Prism) {\\n    var typescript = Prism.util.clone(Prism.languages.typescript);\\n    Prism.languages.tsx = Prism.languages.extend('jsx', typescript); // doesn't work with TS because TS is too complex\\n\\n    delete Prism.languages.tsx['parameter'];\\n    delete Prism.languages.tsx['literal-property']; // This will prevent collisions between TSX tags and TS generic types.\\n    // Idea by https://github.com/karlhorky\\n    // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928\\n\\n    var tag = Prism.languages.tsx.tag;\\n    tag.pattern = RegExp(/(^|[^\\\\w$]|(?=<\\\\/))/.source + '(?:' + tag.pattern.source + ')', tag.pattern.flags);\\n    tag.lookbehind = true;\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"default\",\"tsx\",\"Prism\",\"register\",\"_jsx\",\"_typescript\",\"typescript\",\"util\",\"clone\",\"languages\",\"extend\",\"tag\",\"pattern\",\"RegExp\",\"source\",\"flags\",\"lookbehind\",\"Object\",\"defineProperty\",\"value\",\"displayName\",\"aliases\"]\n}\n"]