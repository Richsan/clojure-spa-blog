["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js"],"~:js","shadow$provide.module$node_modules$micromark_extension_gfm_strikethrough$lib$syntax=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.gfmStrikethrough=function(options={}){let single=options.singleTilde;options={tokenize:function(effects,ok,nok){function more(code){const before=(0,_micromarkUtilClassifyCharacter.classifyCharacter)(previous);if(126===code){if(1<size)return nok(code);effects.consume(code);size++;return more}if(2>size&&!single)return nok(code);\nconst token=effects.exit(\"strikethroughSequenceTemporary\"),after=(0,_micromarkUtilClassifyCharacter.classifyCharacter)(code);token._open=!after||2===after&&!!before;token._close=!before||2===before&&!!after;return ok(code)}const previous=this.previous,events=this.events;let size=0;return function(code){if(126===previous&&\"characterEscape\"!==events[events.length-1][1].type)return nok(code);effects.enter(\"strikethroughSequenceTemporary\");return more(code)}},resolveAll:function(events,context){let index=\n-1;for(;++index<events.length;)if(\"enter\"===events[index][0]&&\"strikethroughSequenceTemporary\"===events[index][1].type&&events[index][1]._close){let open=index;for(;open--;)if(\"exit\"===events[open][0]&&\"strikethroughSequenceTemporary\"===events[open][1].type&&events[open][1]._open&&events[index][1].end.offset-events[index][1].start.offset===events[open][1].end.offset-events[open][1].start.offset){events[index][1].type=\"strikethroughSequence\";events[open][1].type=\"strikethroughSequence\";const strikethrough=\n{type:\"strikethrough\",start:Object.assign({},events[open][1].start),end:Object.assign({},events[index][1].end)},text={type:\"strikethroughText\",start:Object.assign({},events[open][1].end),end:Object.assign({},events[index][1].start)},nextEvents=[[\"enter\",strikethrough,context],[\"enter\",events[open][1],context],[\"exit\",events[open][1],context],[\"enter\",text,context]];(0,_micromarkUtilChunked.splice)(nextEvents,nextEvents.length,0,(0,_micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan.null,\nevents.slice(open+1,index),context));(0,_micromarkUtilChunked.splice)(nextEvents,nextEvents.length,0,[[\"exit\",text,context],[\"enter\",events[index][1],context],[\"exit\",events[index][1],context],[\"exit\",strikethrough,context]]);(0,_micromarkUtilChunked.splice)(events,open-1,index-open+3,nextEvents);index=open+nextEvents.length-2;break}}for(index=-1;++index<events.length;)\"strikethroughSequenceTemporary\"===events[index][1].type&&(events[index][1].type=\"data\");return events}};if(null===single||void 0===\nsingle)single=!0;return{text:{[126]:options},insideSpan:{null:[options]},attentionMarkers:{null:[126]}}};var _micromarkUtilChunked=require(\"module$node_modules$micromark_util_chunked$index\"),_micromarkUtilClassifyCharacter=require(\"module$node_modules$micromark_util_classify_character$index\"),_micromarkUtilResolveAll=require(\"module$node_modules$micromark_util_resolve_all$index\")}","~:source","shadow$provide[\"module$node_modules$micromark_extension_gfm_strikethrough$lib$syntax\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gfmStrikethrough = gfmStrikethrough;\n\nvar _micromarkUtilChunked = require(\"micromark-util-chunked\");\n\nvar _micromarkUtilClassifyCharacter = require(\"micromark-util-classify-character\");\n\nvar _micromarkUtilResolveAll = require(\"micromark-util-resolve-all\");\n\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde (`boolean`, default:\n *   `true`).\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\n\n/**\n * @param {Options} [options]\n * @returns {Extension}\n */\nfunction gfmStrikethrough(options = {}) {\n  let single = options.singleTilde;\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n\n  if (single === null || single === undefined) {\n    single = true;\n  }\n\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  };\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n\n  function resolveAllStrikethrough(events, context) {\n    let index = -1; // Walk through all events.\n\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\n        let open = index; // Now walk back to find an opener.\n\n        while (open--) {\n          // Find a token that can open the closer.\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open && // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = 'strikethroughSequence';\n            events[open][1].type = 'strikethroughSequence';\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            };\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }; // Opening.\n\n            const nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]]; // Between.\n\n            (0, _micromarkUtilChunked.splice)(nextEvents, nextEvents.length, 0, (0, _micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context)); // Closing.\n\n            (0, _micromarkUtilChunked.splice)(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\n            (0, _micromarkUtilChunked.splice)(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n\n    index = -1;\n\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data';\n      }\n    }\n\n    return events;\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous;\n    const events = this.events;\n    let size = 0;\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      if (previous === 126 && events[events.length - 1][1].type !== 'characterEscape') {\n        return nok(code);\n      }\n\n      effects.enter('strikethroughSequenceTemporary');\n      return more(code);\n    }\n    /** @type {State} */\n\n\n    function more(code) {\n      const before = (0, _micromarkUtilClassifyCharacter.classifyCharacter)(previous);\n\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code);\n        effects.consume(code);\n        size++;\n        return more;\n      }\n\n      if (size < 2 && !single) return nok(code);\n      const token = effects.exit('strikethroughSequenceTemporary');\n      const after = (0, _micromarkUtilClassifyCharacter.classifyCharacter)(code);\n      token._open = !after || after === 2 && Boolean(before);\n      token._close = !before || before === 2 && Boolean(after);\n      return ok(code);\n    }\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_classify_character$index","~$module$node_modules$micromark_util_resolve_all$index","~$shadow.js","~$module$node_modules$micromark_util_chunked$index"]],"~:properties",["^5",["resolveAll","tokenize","_open","insideSpan","null","__esModule","attentionMarkers","value","start","text","type","_close","end","gfmStrikethrough"]],"~:compiled-at",1676841365323,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_extension_gfm_strikethrough$lib$syntax.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_extension_gfm_strikethrough$lib$syntax\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.gfmStrikethrough = gfmStrikethrough;\\n\\nvar _micromarkUtilChunked = require(\\\"micromark-util-chunked\\\");\\n\\nvar _micromarkUtilClassifyCharacter = require(\\\"micromark-util-classify-character\\\");\\n\\nvar _micromarkUtilResolveAll = require(\\\"micromark-util-resolve-all\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Extension} Extension\\n * @typedef {import('micromark-util-types').Resolver} Resolver\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').State} State\\n * @typedef {import('micromark-util-types').Token} Token\\n * @typedef {import('micromark-util-types').Event} Event\\n */\\n\\n/**\\n * @typedef Options\\n *   Configuration (optional).\\n * @property {boolean} [singleTilde=true]\\n *   Whether to support strikethrough with a single tilde (`boolean`, default:\\n *   `true`).\\n *   Single tildes work on github.com, but are technically prohibited by the\\n *   GFM spec.\\n */\\n\\n/**\\n * @param {Options} [options]\\n * @returns {Extension}\\n */\\nfunction gfmStrikethrough(options = {}) {\\n  let single = options.singleTilde;\\n  const tokenizer = {\\n    tokenize: tokenizeStrikethrough,\\n    resolveAll: resolveAllStrikethrough\\n  };\\n\\n  if (single === null || single === undefined) {\\n    single = true;\\n  }\\n\\n  return {\\n    text: {\\n      [126]: tokenizer\\n    },\\n    insideSpan: {\\n      null: [tokenizer]\\n    },\\n    attentionMarkers: {\\n      null: [126]\\n    }\\n  };\\n  /**\\n   * Take events and resolve strikethrough.\\n   *\\n   * @type {Resolver}\\n   */\\n\\n  function resolveAllStrikethrough(events, context) {\\n    let index = -1; // Walk through all events.\\n\\n    while (++index < events.length) {\\n      // Find a token that can close.\\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\\n        let open = index; // Now walk back to find an opener.\\n\\n        while (open--) {\\n          // Find a token that can open the closer.\\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open && // If the sizes are the same:\\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\\n            events[index][1].type = 'strikethroughSequence';\\n            events[open][1].type = 'strikethroughSequence';\\n            const strikethrough = {\\n              type: 'strikethrough',\\n              start: Object.assign({}, events[open][1].start),\\n              end: Object.assign({}, events[index][1].end)\\n            };\\n            const text = {\\n              type: 'strikethroughText',\\n              start: Object.assign({}, events[open][1].end),\\n              end: Object.assign({}, events[index][1].start)\\n            }; // Opening.\\n\\n            const nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]]; // Between.\\n\\n            (0, _micromarkUtilChunked.splice)(nextEvents, nextEvents.length, 0, (0, _micromarkUtilResolveAll.resolveAll)(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context)); // Closing.\\n\\n            (0, _micromarkUtilChunked.splice)(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\\n            (0, _micromarkUtilChunked.splice)(events, open - 1, index - open + 3, nextEvents);\\n            index = open + nextEvents.length - 2;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n\\n    index = -1;\\n\\n    while (++index < events.length) {\\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\\n        events[index][1].type = 'data';\\n      }\\n    }\\n\\n    return events;\\n  }\\n  /** @type {Tokenizer} */\\n\\n\\n  function tokenizeStrikethrough(effects, ok, nok) {\\n    const previous = this.previous;\\n    const events = this.events;\\n    let size = 0;\\n    return start;\\n    /** @type {State} */\\n\\n    function start(code) {\\n      if (previous === 126 && events[events.length - 1][1].type !== 'characterEscape') {\\n        return nok(code);\\n      }\\n\\n      effects.enter('strikethroughSequenceTemporary');\\n      return more(code);\\n    }\\n    /** @type {State} */\\n\\n\\n    function more(code) {\\n      const before = (0, _micromarkUtilClassifyCharacter.classifyCharacter)(previous);\\n\\n      if (code === 126) {\\n        // If this is the third marker, exit.\\n        if (size > 1) return nok(code);\\n        effects.consume(code);\\n        size++;\\n        return more;\\n      }\\n\\n      if (size < 2 && !single) return nok(code);\\n      const token = effects.exit('strikethroughSequenceTemporary');\\n      const after = (0, _micromarkUtilClassifyCharacter.classifyCharacter)(code);\\n      token._open = !after || after === 2 && Boolean(before);\\n      token._close = !before || before === 2 && Boolean(after);\\n      return ok(code);\\n    }\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"gfmStrikethrough\",\"options\",\"single\",\"singleTilde\",\"tokenizer\",\"tokenize\",\"tokenizeStrikethrough\",\"effects\",\"ok\",\"nok\",\"more\",\"code\",\"before\",\"_micromarkUtilClassifyCharacter\",\"classifyCharacter\",\"previous\",\"size\",\"consume\",\"token\",\"exit\",\"after\",\"_open\",\"_close\",\"events\",\"start\",\"length\",\"type\",\"enter\",\"resolveAll\",\"resolveAllStrikethrough\",\"context\",\"index\",\"open\",\"end\",\"offset\",\"strikethrough\",\"assign\",\"text\",\"nextEvents\",\"_micromarkUtilChunked\",\"splice\",\"_micromarkUtilResolveAll\",\"parser\",\"constructs\",\"insideSpan\",\"null\",\"slice\",\"undefined\",\"attentionMarkers\"]\n}\n"]