["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-util-classify-character/index.js"],"~:js","shadow$provide.module$node_modules$micromark_util_classify_character$index=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.classifyCharacter=function(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEndingOrSpace)(code)||(0,_micromarkUtilCharacter.unicodeWhitespace)(code))return 1;if((0,_micromarkUtilCharacter.unicodePunctuation)(code))return 2};var _micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\")}","~:source","shadow$provide[\"module$node_modules$micromark_util_classify_character$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classifyCharacter = classifyCharacter;\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\n/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * Classify whether a character code represents whitespace, punctuation, or\n * something else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * Note that eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n * @returns {number|undefined}\n */\nfunction classifyCharacter(code) {\n  if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code) || (0, _micromarkUtilCharacter.unicodeWhitespace)(code)) {\n    return 1;\n  }\n\n  if ((0, _micromarkUtilCharacter.unicodePunctuation)(code)) {\n    return 2;\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js"]],"~:properties",["^5",["__esModule","value","classifyCharacter"]],"~:compiled-at",1676665867262,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_util_classify_character$index.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,CAAA,2DAAA,CAAgF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGxHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,iBAAR,CAoBAA,QAA0B,CAACC,IAAD,CAAO,CAC/B,GAAa,IAAb,GAAIA,IAAJ,EAAqB,GAAIC,uBAAwBC,CAAAA,yBAA5B,EAAuDF,IAAvD,CAArB,EAAqF,GAAIC,uBAAwBE,CAAAA,iBAA5B,EAA+CH,IAA/C,CAArF,CACE,MAAO,EAGT,IAAI,GAAIC,uBAAwBG,CAAAA,kBAA5B,EAAgDJ,IAAhD,CAAJ,CACE,MAAO,EANsB,CAlBjC,KAAIC,wBAA0BR,OAAA,CAAQ,oDAAR,CAR0F;\",\n\"sources\":[\"node_modules/micromark-util-classify-character/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_util_classify_character$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.classifyCharacter = classifyCharacter;\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Code} Code\\n */\\n\\n/**\\n * Classify whether a character code represents whitespace, punctuation, or\\n * something else.\\n *\\n * Used for attention (emphasis, strong), whose sequences can open or close\\n * based on the class of surrounding characters.\\n *\\n * Note that eof (`null`) is seen as whitespace.\\n *\\n * @param {Code} code\\n * @returns {number|undefined}\\n */\\nfunction classifyCharacter(code) {\\n  if (code === null || (0, _micromarkUtilCharacter.markdownLineEndingOrSpace)(code) || (0, _micromarkUtilCharacter.unicodeWhitespace)(code)) {\\n    return 1;\\n  }\\n\\n  if ((0, _micromarkUtilCharacter.unicodePunctuation)(code)) {\\n    return 2;\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"classifyCharacter\",\"code\",\"_micromarkUtilCharacter\",\"markdownLineEndingOrSpace\",\"unicodeWhitespace\",\"unicodePunctuation\"]\n}\n"]