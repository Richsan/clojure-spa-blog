["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-core-commonmark/lib/list.js"],"~:js","shadow$provide.module$node_modules$micromark_core_commonmark$lib$list=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.list=void 0;var _micromarkFactorySpace=require(\"module$node_modules$micromark_factory_space$index\"),_micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\"),_blankLine=require(\"module$node_modules$micromark_core_commonmark$lib$blank_line\"),_thematicBreak=require(\"module$node_modules$micromark_core_commonmark$lib$thematic_break\");\nconst list={name:\"list\",tokenize:function(effects,ok,nok){function inside(code){return(0,_micromarkUtilCharacter.asciiDigit)(code)&&10>++size?(effects.consume(code),inside):(!self.interrupt||2>size)&&(self.containerState.marker?code===self.containerState.marker:41===code||46===code)?(effects.exit(\"listItemValue\"),atMarker(code)):nok(code)}function atMarker(code){effects.enter(\"listItemMarker\");effects.consume(code);effects.exit(\"listItemMarker\");self.containerState.marker=self.containerState.marker||\ncode;return effects.check(_blankLine.blankLine,self.interrupt?nok:onBlank,effects.attempt(listItemPrefixWhitespaceConstruct,endOfPrefix,otherPrefix))}function onBlank(code){self.containerState.initialBlankLine=!0;initialSize++;return endOfPrefix(code)}function otherPrefix(code){return(0,_micromarkUtilCharacter.markdownSpace)(code)?(effects.enter(\"listItemPrefixWhitespace\"),effects.consume(code),effects.exit(\"listItemPrefixWhitespace\"),endOfPrefix):nok(code)}function endOfPrefix(code){self.containerState.size=\ninitialSize+self.sliceSerialize(effects.exit(\"listItemPrefix\"),!0).length;return ok(code)}const self=this,tail=self.events[self.events.length-1];let initialSize=tail&&\"linePrefix\"===tail[1].type?tail[2].sliceSerialize(tail[1],!0).length:0,size=0;return function(code){const kind=self.containerState.type||(42===code||43===code||45===code?\"listUnordered\":\"listOrdered\");if(\"listUnordered\"===kind?!self.containerState.marker||code===self.containerState.marker:(0,_micromarkUtilCharacter.asciiDigit)(code)){self.containerState.type||\n(self.containerState.type=kind,effects.enter(kind,{_container:!0}));if(\"listUnordered\"===kind)return effects.enter(\"listItemPrefix\"),42===code||45===code?effects.check(_thematicBreak.thematicBreak,nok,atMarker)(code):atMarker(code);if(!self.interrupt||49===code)return effects.enter(\"listItemPrefix\"),effects.enter(\"listItemValue\"),inside(code)}return nok(code)}},continuation:{tokenize:function(effects,ok,nok){function notInCurrentItem(code){self.containerState._closeFlow=!0;self.interrupt=void 0;return(0,_micromarkFactorySpace.factorySpace)(effects,\neffects.attempt(list,ok,nok),\"linePrefix\",self.parser.constructs.disable.null.includes(\"codeIndented\")?void 0:4)(code)}const self=this;self.containerState._closeFlow=void 0;return effects.check(_blankLine.blankLine,function(code){self.containerState.furtherBlankLines=self.containerState.furtherBlankLines||self.containerState.initialBlankLine;return(0,_micromarkFactorySpace.factorySpace)(effects,ok,\"listItemIndent\",self.containerState.size+1)(code)},function(code){if(self.containerState.furtherBlankLines||\n!(0,_micromarkUtilCharacter.markdownSpace)(code))return self.containerState.furtherBlankLines=void 0,self.containerState.initialBlankLine=void 0,notInCurrentItem(code);self.containerState.furtherBlankLines=void 0;self.containerState.initialBlankLine=void 0;return effects.attempt(indentConstruct,ok,notInCurrentItem)(code)})}},exit:function(effects){effects.exit(this.containerState.type)}};exports.list=list;const listItemPrefixWhitespaceConstruct={tokenize:function(effects,ok,nok){const self=this;return(0,_micromarkFactorySpace.factorySpace)(effects,\nfunction(code){const tail=self.events[self.events.length-1];return!(0,_micromarkUtilCharacter.markdownSpace)(code)&&tail&&\"listItemPrefixWhitespace\"===tail[1].type?ok(code):nok(code)},\"listItemPrefixWhitespace\",self.parser.constructs.disable.null.includes(\"codeIndented\")?void 0:5)},partial:!0},indentConstruct={tokenize:function(effects,ok,nok){const self=this;return(0,_micromarkFactorySpace.factorySpace)(effects,function(code){const tail=self.events[self.events.length-1];return tail&&\"listItemIndent\"===\ntail[1].type&&tail[2].sliceSerialize(tail[1],!0).length===self.containerState.size?ok(code):nok(code)},\"listItemIndent\",self.containerState.size+1)},partial:!0}}","~:source","shadow$provide[\"module$node_modules$micromark_core_commonmark$lib$list\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.list = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _blankLine = require(\"./blank-line.js\");\n\nvar _thematicBreak = require(\"./thematic-break.js\");\n\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * @typedef {Record<string, unknown> & {marker: Code, type: string, size: number}} ListContainerState\n * @typedef {TokenizeContext & {containerState: ListContainerState}} TokenizeContextWithState\n */\n\n/** @type {Construct} */\nconst list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n};\n/** @type {Construct} */\n\nexports.list = list;\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n};\n/** @type {Construct} */\n\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  let initialSize = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    const kind = self.containerState.type || (code === 42 || code === 43 || code === 45 ? 'listUnordered' : 'listOrdered');\n\n    if (kind === 'listUnordered' ? !self.containerState.marker || code === self.containerState.marker : (0, _micromarkUtilCharacter.asciiDigit)(code)) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind;\n        effects.enter(kind, {\n          _container: true\n        });\n      }\n\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix');\n        return code === 42 || code === 45 ? effects.check(_thematicBreak.thematicBreak, nok, atMarker)(code) : atMarker(code);\n      }\n\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix');\n        effects.enter('listItemValue');\n        return inside(code);\n      }\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function inside(code) {\n    if ((0, _micromarkUtilCharacter.asciiDigit)(code) && ++size < 10) {\n      effects.consume(code);\n      return inside;\n    }\n\n    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code === self.containerState.marker : code === 41 || code === 46)) {\n      effects.exit('listItemValue');\n      return atMarker(code);\n    }\n\n    return nok(code);\n  }\n  /**\n   * @type {State}\n   **/\n\n\n  function atMarker(code) {\n    effects.enter('listItemMarker');\n    effects.consume(code);\n    effects.exit('listItemMarker');\n    self.containerState.marker = self.containerState.marker || code;\n    return effects.check(_blankLine.blankLine, // Can’t be empty when interrupting.\n    self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));\n  }\n  /** @type {State} */\n\n\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true;\n    initialSize++;\n    return endOfPrefix(code);\n  }\n  /** @type {State} */\n\n\n  function otherPrefix(code) {\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      effects.enter('listItemPrefixWhitespace');\n      effects.consume(code);\n      effects.exit('listItemPrefixWhitespace');\n      return endOfPrefix;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function endOfPrefix(code) {\n    self.containerState.size = initialSize + self.sliceSerialize(effects.exit('listItemPrefix'), true).length;\n    return ok(code);\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\n\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this;\n  self.containerState._closeFlow = undefined;\n  return effects.check(_blankLine.blankLine, onBlank, notBlank);\n  /** @type {State} */\n\n  function onBlank(code) {\n    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine; // We have a blank line.\n    // Still, try to consume at most the items size.\n\n    return (0, _micromarkFactorySpace.factorySpace)(effects, ok, 'listItemIndent', self.containerState.size + 1)(code);\n  }\n  /** @type {State} */\n\n\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !(0, _micromarkUtilCharacter.markdownSpace)(code)) {\n      self.containerState.furtherBlankLines = undefined;\n      self.containerState.initialBlankLine = undefined;\n      return notInCurrentItem(code);\n    }\n\n    self.containerState.furtherBlankLines = undefined;\n    self.containerState.initialBlankLine = undefined;\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);\n  }\n  /** @type {State} */\n\n\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true; // As we’re closing flow, we’re no longer interrupting.\n\n    self.interrupt = undefined;\n    return (0, _micromarkFactorySpace.factorySpace)(effects, effects.attempt(list, ok, nok), 'linePrefix', self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code);\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\n\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this;\n  return (0, _micromarkFactorySpace.factorySpace)(effects, afterPrefix, 'listItemIndent', self.containerState.size + 1);\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'listItemIndent' && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok(code) : nok(code);\n  }\n}\n/**\n * @type {Exiter}\n * @this {TokenizeContextWithState}\n */\n\n\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type);\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\n\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this;\n  return (0, _micromarkFactorySpace.factorySpace)(effects, afterPrefix, 'listItemPrefixWhitespace', self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4 + 1);\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return !(0, _micromarkUtilCharacter.markdownSpace)(code) && tail && tail[1].type === 'listItemPrefixWhitespace' ? ok(code) : nok(code);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$shadow.js","~$module$node_modules$micromark_core_commonmark$lib$blank_line","~$module$node_modules$micromark_factory_space$index","~$module$node_modules$micromark_core_commonmark$lib$thematic_break"]],"~:properties",["^5",["partial","list","tokenize","continuation","__esModule","name","value","interrupt","type","_container","exit","furtherBlankLines","_closeFlow","size","marker","initialBlankLine"]],"~:compiled-at",1676665867296,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_core_commonmark$lib$list.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-core-commonmark/lib/list.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_core_commonmark$lib$list\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.list = void 0;\\n\\nvar _micromarkFactorySpace = require(\\\"micromark-factory-space\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\nvar _blankLine = require(\\\"./blank-line.js\\\");\\n\\nvar _thematicBreak = require(\\\"./thematic-break.js\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\\n * @typedef {import('micromark-util-types').Exiter} Exiter\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').State} State\\n * @typedef {import('micromark-util-types').Code} Code\\n */\\n\\n/**\\n * @typedef {Record<string, unknown> & {marker: Code, type: string, size: number}} ListContainerState\\n * @typedef {TokenizeContext & {containerState: ListContainerState}} TokenizeContextWithState\\n */\\n\\n/** @type {Construct} */\\nconst list = {\\n  name: 'list',\\n  tokenize: tokenizeListStart,\\n  continuation: {\\n    tokenize: tokenizeListContinuation\\n  },\\n  exit: tokenizeListEnd\\n};\\n/** @type {Construct} */\\n\\nexports.list = list;\\nconst listItemPrefixWhitespaceConstruct = {\\n  tokenize: tokenizeListItemPrefixWhitespace,\\n  partial: true\\n};\\n/** @type {Construct} */\\n\\nconst indentConstruct = {\\n  tokenize: tokenizeIndent,\\n  partial: true\\n};\\n/**\\n * @type {Tokenizer}\\n * @this {TokenizeContextWithState}\\n */\\n\\nfunction tokenizeListStart(effects, ok, nok) {\\n  const self = this;\\n  const tail = self.events[self.events.length - 1];\\n  let initialSize = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\\n  let size = 0;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    const kind = self.containerState.type || (code === 42 || code === 43 || code === 45 ? 'listUnordered' : 'listOrdered');\\n\\n    if (kind === 'listUnordered' ? !self.containerState.marker || code === self.containerState.marker : (0, _micromarkUtilCharacter.asciiDigit)(code)) {\\n      if (!self.containerState.type) {\\n        self.containerState.type = kind;\\n        effects.enter(kind, {\\n          _container: true\\n        });\\n      }\\n\\n      if (kind === 'listUnordered') {\\n        effects.enter('listItemPrefix');\\n        return code === 42 || code === 45 ? effects.check(_thematicBreak.thematicBreak, nok, atMarker)(code) : atMarker(code);\\n      }\\n\\n      if (!self.interrupt || code === 49) {\\n        effects.enter('listItemPrefix');\\n        effects.enter('listItemValue');\\n        return inside(code);\\n      }\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function inside(code) {\\n    if ((0, _micromarkUtilCharacter.asciiDigit)(code) && ++size < 10) {\\n      effects.consume(code);\\n      return inside;\\n    }\\n\\n    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code === self.containerState.marker : code === 41 || code === 46)) {\\n      effects.exit('listItemValue');\\n      return atMarker(code);\\n    }\\n\\n    return nok(code);\\n  }\\n  /**\\n   * @type {State}\\n   **/\\n\\n\\n  function atMarker(code) {\\n    effects.enter('listItemMarker');\\n    effects.consume(code);\\n    effects.exit('listItemMarker');\\n    self.containerState.marker = self.containerState.marker || code;\\n    return effects.check(_blankLine.blankLine, // Can\\u2019t be empty when interrupting.\\n    self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));\\n  }\\n  /** @type {State} */\\n\\n\\n  function onBlank(code) {\\n    self.containerState.initialBlankLine = true;\\n    initialSize++;\\n    return endOfPrefix(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function otherPrefix(code) {\\n    if ((0, _micromarkUtilCharacter.markdownSpace)(code)) {\\n      effects.enter('listItemPrefixWhitespace');\\n      effects.consume(code);\\n      effects.exit('listItemPrefixWhitespace');\\n      return endOfPrefix;\\n    }\\n\\n    return nok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function endOfPrefix(code) {\\n    self.containerState.size = initialSize + self.sliceSerialize(effects.exit('listItemPrefix'), true).length;\\n    return ok(code);\\n  }\\n}\\n/**\\n * @type {Tokenizer}\\n * @this {TokenizeContextWithState}\\n */\\n\\n\\nfunction tokenizeListContinuation(effects, ok, nok) {\\n  const self = this;\\n  self.containerState._closeFlow = undefined;\\n  return effects.check(_blankLine.blankLine, onBlank, notBlank);\\n  /** @type {State} */\\n\\n  function onBlank(code) {\\n    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine; // We have a blank line.\\n    // Still, try to consume at most the items size.\\n\\n    return (0, _micromarkFactorySpace.factorySpace)(effects, ok, 'listItemIndent', self.containerState.size + 1)(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function notBlank(code) {\\n    if (self.containerState.furtherBlankLines || !(0, _micromarkUtilCharacter.markdownSpace)(code)) {\\n      self.containerState.furtherBlankLines = undefined;\\n      self.containerState.initialBlankLine = undefined;\\n      return notInCurrentItem(code);\\n    }\\n\\n    self.containerState.furtherBlankLines = undefined;\\n    self.containerState.initialBlankLine = undefined;\\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function notInCurrentItem(code) {\\n    // While we do continue, we signal that the flow should be closed.\\n    self.containerState._closeFlow = true; // As we\\u2019re closing flow, we\\u2019re no longer interrupting.\\n\\n    self.interrupt = undefined;\\n    return (0, _micromarkFactorySpace.factorySpace)(effects, effects.attempt(list, ok, nok), 'linePrefix', self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code);\\n  }\\n}\\n/**\\n * @type {Tokenizer}\\n * @this {TokenizeContextWithState}\\n */\\n\\n\\nfunction tokenizeIndent(effects, ok, nok) {\\n  const self = this;\\n  return (0, _micromarkFactorySpace.factorySpace)(effects, afterPrefix, 'listItemIndent', self.containerState.size + 1);\\n  /** @type {State} */\\n\\n  function afterPrefix(code) {\\n    const tail = self.events[self.events.length - 1];\\n    return tail && tail[1].type === 'listItemIndent' && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok(code) : nok(code);\\n  }\\n}\\n/**\\n * @type {Exiter}\\n * @this {TokenizeContextWithState}\\n */\\n\\n\\nfunction tokenizeListEnd(effects) {\\n  effects.exit(this.containerState.type);\\n}\\n/**\\n * @type {Tokenizer}\\n * @this {TokenizeContextWithState}\\n */\\n\\n\\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\\n  const self = this;\\n  return (0, _micromarkFactorySpace.factorySpace)(effects, afterPrefix, 'listItemPrefixWhitespace', self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4 + 1);\\n  /** @type {State} */\\n\\n  function afterPrefix(code) {\\n    const tail = self.events[self.events.length - 1];\\n    return !(0, _micromarkUtilCharacter.markdownSpace)(code) && tail && tail[1].type === 'listItemPrefixWhitespace' ? ok(code) : nok(code);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"list\",\"_micromarkFactorySpace\",\"_micromarkUtilCharacter\",\"_blankLine\",\"_thematicBreak\",\"name\",\"tokenize\",\"tokenizeListStart\",\"effects\",\"ok\",\"nok\",\"inside\",\"code\",\"asciiDigit\",\"size\",\"consume\",\"self\",\"interrupt\",\"containerState\",\"marker\",\"exit\",\"atMarker\",\"enter\",\"check\",\"blankLine\",\"onBlank\",\"attempt\",\"listItemPrefixWhitespaceConstruct\",\"endOfPrefix\",\"otherPrefix\",\"initialBlankLine\",\"initialSize\",\"markdownSpace\",\"sliceSerialize\",\"length\",\"tail\",\"events\",\"type\",\"start\",\"kind\",\"_container\",\"thematicBreak\",\"continuation\",\"tokenizeListContinuation\",\"notInCurrentItem\",\"_closeFlow\",\"undefined\",\"factorySpace\",\"parser\",\"constructs\",\"disable\",\"null\",\"includes\",\"furtherBlankLines\",\"notBlank\",\"indentConstruct\",\"tokenizeListEnd\",\"tokenizeListItemPrefixWhitespace\",\"afterPrefix\",\"partial\",\"tokenizeIndent\"]\n}\n"]