["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hast-util-to-html/lib/omission/opening.js"],"~:js","shadow$provide.module$node_modules$hast_util_to_html$lib$omission$opening=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.opening=void 0;var _hastUtilWhitespace=require(\"module$node_modules$hast_util_whitespace$index\"),_siblings=require(\"module$node_modules$hast_util_to_html$lib$omission$util$siblings\"),_closing=require(\"module$node_modules$hast_util_to_html$lib$omission$closing\");global=(0,require(\"module$node_modules$hast_util_to_html$lib$omission$omission\").omission)({html:function(node){node=\n(0,_siblings.siblingAfter)(node,-1);return!node||\"comment\"!==node.type},head:function(node){node=node.children;const seen=[];let index=-1;for(;++index<node.length;){const child=node[index];if(\"element\"===child.type&&(\"title\"===child.tagName||\"base\"===child.tagName)){if(seen.includes(child.tagName))return!1;seen.push(child.tagName)}}return 0<node.length},body:function(node){node=(0,_siblings.siblingAfter)(node,-1,!0);return!node||\"comment\"!==node.type&&!(\"text\"===node.type&&(0,_hastUtilWhitespace.whitespace)(node.value.charAt(0)))&&\n!(\"element\"===node.type&&(\"meta\"===node.tagName||\"link\"===node.tagName||\"script\"===node.tagName||\"style\"===node.tagName||\"template\"===node.tagName))},colgroup:function(node,index,parent){index=(0,_siblings.siblingBefore)(parent,index);node=(0,_siblings.siblingAfter)(node,-1,!0);return parent&&index&&\"element\"===index.type&&\"colgroup\"===index.tagName&&(0,_closing.closing)(index,parent.children.indexOf(index),parent)?!1:node&&\"element\"===node.type&&\"col\"===node.tagName},tbody:function(node,index,parent){index=\n(0,_siblings.siblingBefore)(parent,index);node=(0,_siblings.siblingAfter)(node,-1);return parent&&index&&\"element\"===index.type&&(\"thead\"===index.tagName||\"tbody\"===index.tagName)&&(0,_closing.closing)(index,parent.children.indexOf(index),parent)?!1:node&&\"element\"===node.type&&\"tr\"===node.tagName}});exports.opening=global}","~:source","shadow$provide[\"module$node_modules$hast_util_to_html$lib$omission$opening\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.opening = void 0;\n\nvar _hastUtilWhitespace = require(\"hast-util-whitespace\");\n\nvar _siblings = require(\"./util/siblings.js\");\n\nvar _closing = require(\"./closing.js\");\n\nvar _omission = require(\"./omission.js\");\n\n/**\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Content} Content\n */\nconst opening = (0, _omission.omission)({\n  html,\n  head,\n  body,\n  colgroup,\n  tbody\n});\n/**\n * Whether to omit `<html>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\n\nexports.opening = opening;\n\nfunction html(node) {\n  const head = (0, _siblings.siblingAfter)(node, -1);\n  return !head || head.type !== 'comment';\n}\n/**\n * Whether to omit `<head>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\n\n\nfunction head(node) {\n  const children = node.children;\n  /** @type {Array<string>} */\n\n  const seen = [];\n  let index = -1;\n\n  while (++index < children.length) {\n    const child = children[index];\n\n    if (child.type === 'element' && (child.tagName === 'title' || child.tagName === 'base')) {\n      if (seen.includes(child.tagName)) return false;\n      seen.push(child.tagName);\n    }\n  }\n\n  return children.length > 0;\n}\n/**\n * Whether to omit `<body>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\n\n\nfunction body(node) {\n  const head = (0, _siblings.siblingAfter)(node, -1, true);\n  return !head || head.type !== 'comment' && !(head.type === 'text' && (0, _hastUtilWhitespace.whitespace)(head.value.charAt(0))) && !(head.type === 'element' && (head.tagName === 'meta' || head.tagName === 'link' || head.tagName === 'script' || head.tagName === 'style' || head.tagName === 'template'));\n}\n/**\n * Whether to omit `<colgroup>`.\n * The spec describes some logic for the opening tag, but itâ€™s easier to\n * implement in the closing tag, to the same effect, so we handle it there\n * instead.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\n\n\nfunction colgroup(node, index, parent) {\n  const previous = (0, _siblings.siblingBefore)(parent, index);\n  const head = (0, _siblings.siblingAfter)(node, -1, true); // Previous colgroup was already omitted.\n\n  if (parent && previous && previous.type === 'element' && previous.tagName === 'colgroup' && (0, _closing.closing)(previous, parent.children.indexOf(previous), parent)) {\n    return false;\n  }\n\n  return head && head.type === 'element' && head.tagName === 'col';\n}\n/**\n * Whether to omit `<tbody>`.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\n\n\nfunction tbody(node, index, parent) {\n  const previous = (0, _siblings.siblingBefore)(parent, index);\n  const head = (0, _siblings.siblingAfter)(node, -1); // Previous table section was already omitted.\n\n  if (parent && previous && previous.type === 'element' && (previous.tagName === 'thead' || previous.tagName === 'tbody') && (0, _closing.closing)(previous, parent.children.indexOf(previous), parent)) {\n    return false;\n  }\n\n  return head && head.type === 'element' && head.tagName === 'tr';\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$hast_util_whitespace$index","~$module$node_modules$hast_util_to_html$lib$omission$util$siblings","~$shadow.js","~$module$node_modules$hast_util_to_html$lib$omission$closing","~$module$node_modules$hast_util_to_html$lib$omission$omission"]],"~:properties",["^5",["body","__esModule","opening","value","head","html","colgroup","tbody"]],"~:compiled-at",1676686799606,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hast_util_to_html$lib$omission$opening.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/hast-util-to-html/lib/omission/opening.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hast_util_to_html$lib$omission$opening\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.opening = void 0;\\n\\nvar _hastUtilWhitespace = require(\\\"hast-util-whitespace\\\");\\n\\nvar _siblings = require(\\\"./util/siblings.js\\\");\\n\\nvar _closing = require(\\\"./closing.js\\\");\\n\\nvar _omission = require(\\\"./omission.js\\\");\\n\\n/**\\n * @typedef {import('../types.js').Element} Element\\n * @typedef {import('../types.js').Parent} Parent\\n * @typedef {import('../types.js').Content} Content\\n */\\nconst opening = (0, _omission.omission)({\\n  html,\\n  head,\\n  body,\\n  colgroup,\\n  tbody\\n});\\n/**\\n * Whether to omit `<html>`.\\n *\\n * @param {Element} node\\n *   Element.\\n * @returns {boolean}\\n *   Whether the opening tag can be omitted.\\n */\\n\\nexports.opening = opening;\\n\\nfunction html(node) {\\n  const head = (0, _siblings.siblingAfter)(node, -1);\\n  return !head || head.type !== 'comment';\\n}\\n/**\\n * Whether to omit `<head>`.\\n *\\n * @param {Element} node\\n *   Element.\\n * @returns {boolean}\\n *   Whether the opening tag can be omitted.\\n */\\n\\n\\nfunction head(node) {\\n  const children = node.children;\\n  /** @type {Array<string>} */\\n\\n  const seen = [];\\n  let index = -1;\\n\\n  while (++index < children.length) {\\n    const child = children[index];\\n\\n    if (child.type === 'element' && (child.tagName === 'title' || child.tagName === 'base')) {\\n      if (seen.includes(child.tagName)) return false;\\n      seen.push(child.tagName);\\n    }\\n  }\\n\\n  return children.length > 0;\\n}\\n/**\\n * Whether to omit `<body>`.\\n *\\n * @param {Element} node\\n *   Element.\\n * @returns {boolean}\\n *   Whether the opening tag can be omitted.\\n */\\n\\n\\nfunction body(node) {\\n  const head = (0, _siblings.siblingAfter)(node, -1, true);\\n  return !head || head.type !== 'comment' && !(head.type === 'text' && (0, _hastUtilWhitespace.whitespace)(head.value.charAt(0))) && !(head.type === 'element' && (head.tagName === 'meta' || head.tagName === 'link' || head.tagName === 'script' || head.tagName === 'style' || head.tagName === 'template'));\\n}\\n/**\\n * Whether to omit `<colgroup>`.\\n * The spec describes some logic for the opening tag, but it\\u2019s easier to\\n * implement in the closing tag, to the same effect, so we handle it there\\n * instead.\\n *\\n * @param {Element} node\\n *   Element.\\n * @param {number | undefined} index\\n *   Index of element in parent.\\n * @param {Parent | undefined} parent\\n *   Parent of element.\\n * @returns {boolean}\\n *   Whether the opening tag can be omitted.\\n */\\n\\n\\nfunction colgroup(node, index, parent) {\\n  const previous = (0, _siblings.siblingBefore)(parent, index);\\n  const head = (0, _siblings.siblingAfter)(node, -1, true); // Previous colgroup was already omitted.\\n\\n  if (parent && previous && previous.type === 'element' && previous.tagName === 'colgroup' && (0, _closing.closing)(previous, parent.children.indexOf(previous), parent)) {\\n    return false;\\n  }\\n\\n  return head && head.type === 'element' && head.tagName === 'col';\\n}\\n/**\\n * Whether to omit `<tbody>`.\\n *\\n * @param {Element} node\\n *   Element.\\n * @param {number | undefined} index\\n *   Index of element in parent.\\n * @param {Parent | undefined} parent\\n *   Parent of element.\\n * @returns {boolean}\\n *   Whether the opening tag can be omitted.\\n */\\n\\n\\nfunction tbody(node, index, parent) {\\n  const previous = (0, _siblings.siblingBefore)(parent, index);\\n  const head = (0, _siblings.siblingAfter)(node, -1); // Previous table section was already omitted.\\n\\n  if (parent && previous && previous.type === 'element' && (previous.tagName === 'thead' || previous.tagName === 'tbody') && (0, _closing.closing)(previous, parent.children.indexOf(previous), parent)) {\\n    return false;\\n  }\\n\\n  return head && head.type === 'element' && head.tagName === 'tr';\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"opening\",\"_hastUtilWhitespace\",\"_siblings\",\"_closing\",\"_omission\",\"omission\",\"html\",\"node\",\"head\",\"siblingAfter\",\"type\",\"children\",\"seen\",\"index\",\"length\",\"child\",\"tagName\",\"includes\",\"push\",\"body\",\"whitespace\",\"charAt\",\"colgroup\",\"parent\",\"previous\",\"siblingBefore\",\"closing\",\"indexOf\",\"tbody\"]\n}\n"]