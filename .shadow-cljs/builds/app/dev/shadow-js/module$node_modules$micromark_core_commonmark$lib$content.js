["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/micromark-core-commonmark/lib/content.js"],"~:js","shadow$provide.module$node_modules$micromark_core_commonmark$lib$content=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.content=void 0;var _micromarkFactorySpace=require(\"module$node_modules$micromark_factory_space$index\"),_micromarkUtilCharacter=require(\"module$node_modules$micromark_util_character$index\"),_micromarkUtilSubtokenize=require(\"module$node_modules$micromark_util_subtokenize$index\");exports.content={tokenize:function(effects,ok){function data(code){if(null===\ncode)return contentEnd(code);if((0,_micromarkUtilCharacter.markdownLineEnding)(code))return effects.check(continuationConstruct,contentContinue,contentEnd)(code);effects.consume(code);return data}function contentEnd(code){effects.exit(\"chunkContent\");effects.exit(\"content\");return ok(code)}function contentContinue(code){effects.consume(code);effects.exit(\"chunkContent\");previous.next=effects.enter(\"chunkContent\",{contentType:\"content\",previous});previous=previous.next;return data}let previous;return function(code){effects.enter(\"content\");\nprevious=effects.enter(\"chunkContent\",{contentType:\"content\"});return data(code)}},resolve:function(events){(0,_micromarkUtilSubtokenize.subtokenize)(events);return events}};const continuationConstruct={tokenize:function(effects,ok,nok){function prefixed(code){if(null===code||(0,_micromarkUtilCharacter.markdownLineEnding)(code))return nok(code);const tail=self.events[self.events.length-1];return!self.parser.constructs.disable.null.includes(\"codeIndented\")&&tail&&\"linePrefix\"===tail[1].type&&4<=tail[2].sliceSerialize(tail[1],\n!0).length?ok(code):effects.interrupt(self.parser.constructs.flow,nok,ok)(code)}const self=this;return function(code){effects.exit(\"chunkContent\");effects.enter(\"lineEnding\");effects.consume(code);effects.exit(\"lineEnding\");return(0,_micromarkFactorySpace.factorySpace)(effects,prefixed,\"linePrefix\")}},partial:!0}}","~:source","shadow$provide[\"module$node_modules$micromark_core_commonmark$lib$content\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.content = void 0;\n\nvar _micromarkFactorySpace = require(\"micromark-factory-space\");\n\nvar _micromarkUtilCharacter = require(\"micromark-util-character\");\n\nvar _micromarkUtilSubtokenize = require(\"micromark-util-subtokenize\");\n\n/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\n\n/**\n * No name because it must not be turned off.\n * @type {Construct}\n */\nconst content = {\n  tokenize: tokenizeContent,\n  resolve: resolveContent\n};\n/** @type {Construct} */\n\nexports.content = content;\nconst continuationConstruct = {\n  tokenize: tokenizeContinuation,\n  partial: true\n};\n/**\n * Content is transparent: itâ€™s parsed right now. That way, definitions are also\n * parsed right now: before text in paragraphs (specifically, media) are parsed.\n *\n * @type {Resolver}\n */\n\nfunction resolveContent(events) {\n  (0, _micromarkUtilSubtokenize.subtokenize)(events);\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeContent(effects, ok) {\n  /** @type {Token} */\n  let previous;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('content');\n    previous = effects.enter('chunkContent', {\n      contentType: 'content'\n    });\n    return data(code);\n  }\n  /** @type {State} */\n\n\n  function data(code) {\n    if (code === null) {\n      return contentEnd(code);\n    }\n\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return effects.check(continuationConstruct, contentContinue, contentEnd)(code);\n    } // Data.\n\n\n    effects.consume(code);\n    return data;\n  }\n  /** @type {State} */\n\n\n  function contentEnd(code) {\n    effects.exit('chunkContent');\n    effects.exit('content');\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function contentContinue(code) {\n    effects.consume(code);\n    effects.exit('chunkContent');\n    previous.next = effects.enter('chunkContent', {\n      contentType: 'content',\n      previous\n    });\n    previous = previous.next;\n    return data;\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeContinuation(effects, ok, nok) {\n  const self = this;\n  return startLookahead;\n  /** @type {State} */\n\n  function startLookahead(code) {\n    effects.exit('chunkContent');\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    return (0, _micromarkFactorySpace.factorySpace)(effects, prefixed, 'linePrefix');\n  }\n  /** @type {State} */\n\n\n  function prefixed(code) {\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\n      return nok(code);\n    }\n\n    const tail = self.events[self.events.length - 1];\n\n    if (!self.parser.constructs.disable.null.includes('codeIndented') && tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4) {\n      return ok(code);\n    }\n\n    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$micromark_util_character$index","~$module$node_modules$micromark_util_subtokenize$index","~$shadow.js","~$module$node_modules$micromark_factory_space$index"]],"~:properties",["^5",["partial","next","resolve","tokenize","__esModule","value","previous","content","contentType"]],"~:compiled-at",1676665867284,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$micromark_core_commonmark$lib$content.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/micromark-core-commonmark/lib/content.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$micromark_core_commonmark$lib$content\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.content = void 0;\\n\\nvar _micromarkFactorySpace = require(\\\"micromark-factory-space\\\");\\n\\nvar _micromarkUtilCharacter = require(\\\"micromark-util-character\\\");\\n\\nvar _micromarkUtilSubtokenize = require(\\\"micromark-util-subtokenize\\\");\\n\\n/**\\n * @typedef {import('micromark-util-types').Construct} Construct\\n * @typedef {import('micromark-util-types').Resolver} Resolver\\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\\n * @typedef {import('micromark-util-types').Token} Token\\n * @typedef {import('micromark-util-types').State} State\\n */\\n\\n/**\\n * No name because it must not be turned off.\\n * @type {Construct}\\n */\\nconst content = {\\n  tokenize: tokenizeContent,\\n  resolve: resolveContent\\n};\\n/** @type {Construct} */\\n\\nexports.content = content;\\nconst continuationConstruct = {\\n  tokenize: tokenizeContinuation,\\n  partial: true\\n};\\n/**\\n * Content is transparent: it\\u2019s parsed right now. That way, definitions are also\\n * parsed right now: before text in paragraphs (specifically, media) are parsed.\\n *\\n * @type {Resolver}\\n */\\n\\nfunction resolveContent(events) {\\n  (0, _micromarkUtilSubtokenize.subtokenize)(events);\\n  return events;\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeContent(effects, ok) {\\n  /** @type {Token} */\\n  let previous;\\n  return start;\\n  /** @type {State} */\\n\\n  function start(code) {\\n    effects.enter('content');\\n    previous = effects.enter('chunkContent', {\\n      contentType: 'content'\\n    });\\n    return data(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function data(code) {\\n    if (code === null) {\\n      return contentEnd(code);\\n    }\\n\\n    if ((0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      return effects.check(continuationConstruct, contentContinue, contentEnd)(code);\\n    } // Data.\\n\\n\\n    effects.consume(code);\\n    return data;\\n  }\\n  /** @type {State} */\\n\\n\\n  function contentEnd(code) {\\n    effects.exit('chunkContent');\\n    effects.exit('content');\\n    return ok(code);\\n  }\\n  /** @type {State} */\\n\\n\\n  function contentContinue(code) {\\n    effects.consume(code);\\n    effects.exit('chunkContent');\\n    previous.next = effects.enter('chunkContent', {\\n      contentType: 'content',\\n      previous\\n    });\\n    previous = previous.next;\\n    return data;\\n  }\\n}\\n/** @type {Tokenizer} */\\n\\n\\nfunction tokenizeContinuation(effects, ok, nok) {\\n  const self = this;\\n  return startLookahead;\\n  /** @type {State} */\\n\\n  function startLookahead(code) {\\n    effects.exit('chunkContent');\\n    effects.enter('lineEnding');\\n    effects.consume(code);\\n    effects.exit('lineEnding');\\n    return (0, _micromarkFactorySpace.factorySpace)(effects, prefixed, 'linePrefix');\\n  }\\n  /** @type {State} */\\n\\n\\n  function prefixed(code) {\\n    if (code === null || (0, _micromarkUtilCharacter.markdownLineEnding)(code)) {\\n      return nok(code);\\n    }\\n\\n    const tail = self.events[self.events.length - 1];\\n\\n    if (!self.parser.constructs.disable.null.includes('codeIndented') && tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4) {\\n      return ok(code);\\n    }\\n\\n    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"content\",\"_micromarkFactorySpace\",\"_micromarkUtilCharacter\",\"_micromarkUtilSubtokenize\",\"tokenize\",\"tokenizeContent\",\"effects\",\"ok\",\"data\",\"code\",\"contentEnd\",\"markdownLineEnding\",\"check\",\"continuationConstruct\",\"contentContinue\",\"consume\",\"exit\",\"previous\",\"next\",\"enter\",\"contentType\",\"start\",\"resolve\",\"resolveContent\",\"events\",\"subtokenize\",\"tokenizeContinuation\",\"nok\",\"prefixed\",\"tail\",\"self\",\"length\",\"parser\",\"constructs\",\"disable\",\"null\",\"includes\",\"type\",\"sliceSerialize\",\"interrupt\",\"flow\",\"startLookahead\",\"factorySpace\",\"partial\"]\n}\n"]