["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vfile-location/lib/index.js"],"~:js","shadow$provide.module$node_modules$vfile_location$lib$index=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.location=function(file){file=String(file);const indices=[],search=/\\r?\\n|\\r/g;for(;search.test(file);)indices.push(search.lastIndex);indices.push(file.length+1);return{toPoint:function(offset){let index=-1;if(\"number\"===typeof offset&&-1<offset&&offset<indices[indices.length-1])for(;++index<indices.length;)if(indices[index]>offset)return{line:index+\n1,column:offset-(0<index?indices[index-1]:0)+1,offset};return{line:void 0,column:void 0,offset:void 0}},toOffset:function(point){var line=point&&point.line;point=point&&point.column;return\"number\"===typeof line&&\"number\"===typeof point&&!Number.isNaN(line)&&!Number.isNaN(point)&&line-1 in indices&&(line=(indices[line-2]||0)+point-1||0,-1<line&&line<indices[indices.length-1])?line:-1}}}}","~:source","shadow$provide[\"module$node_modules$vfile_location$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.location = location;\n\n/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('vfile').Value} Value\n */\n\n/**\n * @typedef Point\n *   unist point, where `line` and `column` can be `undefined`.\n * @property {number | undefined} line\n *   Line.\n * @property {number | undefined} column\n *   Column.\n * @property {number | undefined} [offset]\n *   Offset.\n *\n * @typedef PointLike\n *   unist point, allowed as input.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @callback ToPoint\n *   Get a line/column-based `point` from `offset`.\n * @param {number | null | undefined} [offset]\n *   Something that should be an `offset.\n * @returns {Point}\n *   Point, line/column are undefined for invalid or out of bounds input.\n *\n * @callback ToOffset\n *   Get an offset from a line/column-based `point`.\n * @param {Point | null | undefined} [point]\n *   Something that should be a `point.\n * @returns {number}\n *   Offset or `-1` for invalid or out of bounds input.\n *\n * @typedef Location\n *   Accessors for index.\n * @property {ToPoint} toPoint\n *   Get a line/column-based `point` from `offset`.\n * @property {ToOffset} toOffset\n *   Get an offset from a line/column-based `point`.\n */\n\n/**\n * Index the given document so you can translate between line/column and offset\n * based positional info.\n *\n * @param {VFile | Value} file\n *   File to index.\n * @returns {Location}\n *   Accessors for index.\n */\nfunction location(file) {\n  const value = String(file);\n  /** @type {Array<number>} */\n\n  const indices = [];\n  const search = /\\r?\\n|\\r/g;\n\n  while (search.test(value)) {\n    indices.push(search.lastIndex);\n  }\n\n  indices.push(value.length + 1);\n  return {\n    toPoint,\n    toOffset\n  };\n  /** @type {ToPoint} */\n\n  function toPoint(offset) {\n    let index = -1;\n\n    if (typeof offset === 'number' && offset > -1 && offset < indices[indices.length - 1]) {\n      while (++index < indices.length) {\n        if (indices[index] > offset) {\n          return {\n            line: index + 1,\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n            offset\n          };\n        }\n      }\n    }\n\n    return {\n      line: undefined,\n      column: undefined,\n      offset: undefined\n    };\n  }\n  /** @type {ToOffset} */\n\n\n  function toOffset(point) {\n    const line = point && point.line;\n    const column = point && point.column;\n\n    if (typeof line === 'number' && typeof column === 'number' && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices) {\n      const offset = (indices[line - 2] || 0) + column - 1 || 0;\n\n      if (offset > -1 && offset < indices[indices.length - 1]) {\n        return offset;\n      }\n    }\n\n    return -1;\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["toOffset","offset","__esModule","toPoint","value","location","line","column"]],"~:compiled-at",1676667638429,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vfile_location$lib$index.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,4CAAA,CAAiE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGzGC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,QAAR,CAyDAA,QAAiB,CAACC,IAAD,CAAO,CAChBF,IAAAA,CAAQG,MAAA,CAAOD,IAAP,CAGd,OAAME,QAAU,EAAhB,CACMC,OAAS,WAEf,KAAA,CAAOA,MAAOC,CAAAA,IAAP,CAAYN,IAAZ,CAAP,CAAA,CACEI,OAAQG,CAAAA,IAAR,CAAaF,MAAOG,CAAAA,SAApB,CAGFJ,QAAQG,CAAAA,IAAR,CAAaP,IAAMS,CAAAA,MAAnB,CAA4B,CAA5B,CACA,OAAO,CACLC,QAKFA,QAAgB,CAACC,MAAD,CAAS,CACvB,IAAIC,MAAQ,CAAC,CAEb,IAAsB,QAAtB,GAAI,MAAOD,OAAX,EAA2C,CAAC,CAA5C,CAAkCA,MAAlC,EAAiDA,MAAjD,CAA0DP,OAAA,CAAQA,OAAQK,CAAAA,MAAhB,CAAyB,CAAzB,CAA1D,CACE,IAAA,CAAO,EAAEG,KAAT,CAAiBR,OAAQK,CAAAA,MAAzB,CAAA,CACE,GAAIL,OAAA,CAAQQ,KAAR,CAAJ,CAAqBD,MAArB,CACE,MAAO,CACLE,KAAMD,KAANC;AAAc,CADT,CAELC,OAAQH,MAARG,EAA0B,CAAR,CAAAF,KAAA,CAAYR,OAAA,CAAQQ,KAAR,CAAgB,CAAhB,CAAZ,CAAiC,CAAnDE,EAAwD,CAFnD,CAGLH,MAHK,CASb,OAAO,CACLE,KAAME,IAAAA,EADD,CAELD,OAAQC,IAAAA,EAFH,CAGLJ,OAAQI,IAAAA,EAHH,CAfgB,CANlB,CAELC,SA4BFA,QAAiB,CAACC,KAAD,CAAQ,CACvB,IAAMJ,KAAOI,KAAPJ,EAAgBI,KAAMJ,CAAAA,IACtBC,MAAAA,CAASG,KAATH,EAAkBG,KAAMH,CAAAA,MAE9B,OAAoB,QAApB,GAAI,MAAOD,KAAX,EAAkD,QAAlD,GAAgC,MAAOC,MAAvC,EAA8D,CAACI,MAAOC,CAAAA,KAAP,CAAaN,IAAb,CAA/D,EAAqF,CAACK,MAAOC,CAAAA,KAAP,CAAaL,KAAb,CAAtF,EAA8GD,IAA9G,CAAqH,CAArH,GAA0HT,QAA1H,GACQO,IAEF,EAFYP,OAAA,CAAQS,IAAR,CAAe,CAAf,CAEZ,EAFiC,CAEjC,EAFsCC,KAEtC,CAF+C,CAE/C,EAFoD,CAEpD,CAAS,CAAC,CAAV,CAAAH,IAAA,EAAeA,IAAf,CAAwBP,OAAA,CAAQA,OAAQK,CAAAA,MAAhB,CAAyB,CAAzB,CAH9B,EAIWE,IAJX,CAQO,CAAC,CAZe,CA9BlB,CAZe,CA/DiF;\",\n\"sources\":[\"node_modules/vfile-location/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vfile_location$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.location = location;\\n\\n/**\\n * @typedef {import('vfile').VFile} VFile\\n * @typedef {import('vfile').Value} Value\\n */\\n\\n/**\\n * @typedef Point\\n *   unist point, where `line` and `column` can be `undefined`.\\n * @property {number | undefined} line\\n *   Line.\\n * @property {number | undefined} column\\n *   Column.\\n * @property {number | undefined} [offset]\\n *   Offset.\\n *\\n * @typedef PointLike\\n *   unist point, allowed as input.\\n * @property {number | null | undefined} [line]\\n *   Line.\\n * @property {number | null | undefined} [column]\\n *   Column.\\n * @property {number | null | undefined} [offset]\\n *   Offset.\\n *\\n * @callback ToPoint\\n *   Get a line/column-based `point` from `offset`.\\n * @param {number | null | undefined} [offset]\\n *   Something that should be an `offset.\\n * @returns {Point}\\n *   Point, line/column are undefined for invalid or out of bounds input.\\n *\\n * @callback ToOffset\\n *   Get an offset from a line/column-based `point`.\\n * @param {Point | null | undefined} [point]\\n *   Something that should be a `point.\\n * @returns {number}\\n *   Offset or `-1` for invalid or out of bounds input.\\n *\\n * @typedef Location\\n *   Accessors for index.\\n * @property {ToPoint} toPoint\\n *   Get a line/column-based `point` from `offset`.\\n * @property {ToOffset} toOffset\\n *   Get an offset from a line/column-based `point`.\\n */\\n\\n/**\\n * Index the given document so you can translate between line/column and offset\\n * based positional info.\\n *\\n * @param {VFile | Value} file\\n *   File to index.\\n * @returns {Location}\\n *   Accessors for index.\\n */\\nfunction location(file) {\\n  const value = String(file);\\n  /** @type {Array<number>} */\\n\\n  const indices = [];\\n  const search = /\\\\r?\\\\n|\\\\r/g;\\n\\n  while (search.test(value)) {\\n    indices.push(search.lastIndex);\\n  }\\n\\n  indices.push(value.length + 1);\\n  return {\\n    toPoint,\\n    toOffset\\n  };\\n  /** @type {ToPoint} */\\n\\n  function toPoint(offset) {\\n    let index = -1;\\n\\n    if (typeof offset === 'number' && offset > -1 && offset < indices[indices.length - 1]) {\\n      while (++index < indices.length) {\\n        if (indices[index] > offset) {\\n          return {\\n            line: index + 1,\\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\\n            offset\\n          };\\n        }\\n      }\\n    }\\n\\n    return {\\n      line: undefined,\\n      column: undefined,\\n      offset: undefined\\n    };\\n  }\\n  /** @type {ToOffset} */\\n\\n\\n  function toOffset(point) {\\n    const line = point && point.line;\\n    const column = point && point.column;\\n\\n    if (typeof line === 'number' && typeof column === 'number' && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices) {\\n      const offset = (indices[line - 2] || 0) + column - 1 || 0;\\n\\n      if (offset > -1 && offset < indices[indices.length - 1]) {\\n        return offset;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"location\",\"file\",\"String\",\"indices\",\"search\",\"test\",\"push\",\"lastIndex\",\"length\",\"toPoint\",\"offset\",\"index\",\"line\",\"column\",\"undefined\",\"toOffset\",\"point\",\"Number\",\"isNaN\"]\n}\n"]