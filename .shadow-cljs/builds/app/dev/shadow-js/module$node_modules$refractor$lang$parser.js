["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/refractor/lang/parser.js"],"~:js","shadow$provide.module$node_modules$refractor$lang$parser=function(global,require,module,exports){function parser$jscomp$0(Prism){Prism.register(_markup.default);var parser=Prism.languages.parser=Prism.languages.extend(\"markup\",{keyword:{pattern:/(^|[^^])(?:\\^(?:case|eval|for|if|switch|throw)\\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\\b)/,lookbehind:!0},variable:{pattern:/(^|[^^])\\B\\$(?:\\w+|(?=[.{]))(?:(?:\\.|::?)\\w+)*(?:\\.|::?)?/,lookbehind:!0,inside:{punctuation:/\\.|:+/}},function:{pattern:/(^|[^^])\\B[@^]\\w+(?:(?:\\.|::?)\\w+)*(?:\\.|::?)?/,\nlookbehind:!0,inside:{keyword:{pattern:/(^@)(?:GET_|SET_)/,lookbehind:!0},punctuation:/\\.|:+/}},escape:{pattern:/\\^(?:[$^;@()\\[\\]{}\"':]|#[a-f\\d]*)/i,alias:\"builtin\"},punctuation:/[\\[\\](){};]/});parser=Prism.languages.insertBefore(\"parser\",\"keyword\",{\"parser-comment\":{pattern:/(\\s)#.*/,lookbehind:!0,alias:\"comment\"},expression:{pattern:/(^|[^^])\\((?:[^()]|\\((?:[^()]|\\((?:[^()])*\\))*\\))*\\)/,greedy:!0,lookbehind:!0,inside:{string:{pattern:/(^|[^^])([\"'])(?:(?!\\2)[^^]|\\^[\\s\\S])*\\2/,lookbehind:!0},keyword:parser.keyword,\nvariable:parser.variable,function:parser.function,boolean:/\\b(?:false|true)\\b/,number:/\\b(?:0x[a-f\\d]+|\\d+(?:\\.\\d*)?(?:e[+-]?\\d+)?)\\b/i,escape:parser.escape,operator:/[~+*\\/\\\\%]|!(?:\\|\\|?|=)?|&&?|\\|\\|?|==|<[<=]?|>[>=]?|-[fd]?|\\b(?:def|eq|ge|gt|in|is|le|lt|ne)\\b/,punctuation:parser.punctuation}}});Prism.languages.insertBefore(\"inside\",\"punctuation\",{expression:parser.expression,keyword:parser.keyword,variable:parser.variable,function:parser.function,escape:parser.escape,\"parser-punctuation\":{pattern:parser.punctuation,\nalias:\"punctuation\"}},parser.tag.inside[\"attr-value\"])}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=parser$jscomp$0;var _markup=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(require(\"module$node_modules$refractor$lang$markup\"));parser$jscomp$0.displayName=\"parser\";parser$jscomp$0.aliases=[]}","~:source","shadow$provide[\"module$node_modules$refractor$lang$parser\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parser;\n\nvar _markup = _interopRequireDefault(require(\"./markup.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// @ts-nocheck\nparser.displayName = 'parser';\nparser.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nfunction parser(Prism) {\n  Prism.register(_markup.default);\n\n  (function (Prism) {\n    var parser = Prism.languages.parser = Prism.languages.extend('markup', {\n      keyword: {\n        pattern: /(^|[^^])(?:\\^(?:case|eval|for|if|switch|throw)\\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\\b)/,\n        lookbehind: true\n      },\n      variable: {\n        pattern: /(^|[^^])\\B\\$(?:\\w+|(?=[.{]))(?:(?:\\.|::?)\\w+)*(?:\\.|::?)?/,\n        lookbehind: true,\n        inside: {\n          punctuation: /\\.|:+/\n        }\n      },\n      function: {\n        pattern: /(^|[^^])\\B[@^]\\w+(?:(?:\\.|::?)\\w+)*(?:\\.|::?)?/,\n        lookbehind: true,\n        inside: {\n          keyword: {\n            pattern: /(^@)(?:GET_|SET_)/,\n            lookbehind: true\n          },\n          punctuation: /\\.|:+/\n        }\n      },\n      escape: {\n        pattern: /\\^(?:[$^;@()\\[\\]{}\"':]|#[a-f\\d]*)/i,\n        alias: 'builtin'\n      },\n      punctuation: /[\\[\\](){};]/\n    });\n    parser = Prism.languages.insertBefore('parser', 'keyword', {\n      'parser-comment': {\n        pattern: /(\\s)#.*/,\n        lookbehind: true,\n        alias: 'comment'\n      },\n      expression: {\n        // Allow for 3 levels of depth\n        pattern: /(^|[^^])\\((?:[^()]|\\((?:[^()]|\\((?:[^()])*\\))*\\))*\\)/,\n        greedy: true,\n        lookbehind: true,\n        inside: {\n          string: {\n            pattern: /(^|[^^])([\"'])(?:(?!\\2)[^^]|\\^[\\s\\S])*\\2/,\n            lookbehind: true\n          },\n          keyword: parser.keyword,\n          variable: parser.variable,\n          function: parser.function,\n          boolean: /\\b(?:false|true)\\b/,\n          number: /\\b(?:0x[a-f\\d]+|\\d+(?:\\.\\d*)?(?:e[+-]?\\d+)?)\\b/i,\n          escape: parser.escape,\n          operator: /[~+*\\/\\\\%]|!(?:\\|\\|?|=)?|&&?|\\|\\|?|==|<[<=]?|>[>=]?|-[fd]?|\\b(?:def|eq|ge|gt|in|is|le|lt|ne)\\b/,\n          punctuation: parser.punctuation\n        }\n      }\n    });\n    Prism.languages.insertBefore('inside', 'punctuation', {\n      expression: parser.expression,\n      keyword: parser.keyword,\n      variable: parser.variable,\n      function: parser.function,\n      escape: parser.escape,\n      'parser-punctuation': {\n        pattern: parser.punctuation,\n        alias: 'punctuation'\n      }\n    }, parser['tag'].inside['attr-value']);\n  })(Prism);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$refractor$lang$markup","~$shadow.js"]],"~:properties",["^5",["boolean","parser","punctuation","string","aliases","operator","displayName","__esModule","expression","lookbehind","escape","value","variable","keyword","number","greedy","function","pattern","inside","alias","default"]],"~:compiled-at",1676841365443,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$refractor$lang$parser.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAA,yCAAA,CAA8D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAiBtGC,QAASA,gBAAM,CAACC,KAAD,CAAQ,CACrBA,KAAMC,CAAAA,QAAN,CAAeC,OAAQC,CAAAA,OAAvB,CAGE,KAAIJ,OAmEHC,KAnEkBI,CAAAA,SAAUL,CAAAA,MAAzBA,CAmEHC,KAnE2CI,CAAAA,SAAUC,CAAAA,MAAhB,CAAuB,QAAvB,CAAiC,CACrEC,QAAS,CACPC,QAAS,8GADF,CAEPC,WAAY,CAAA,CAFL,CAD4D,CAKrEC,SAAU,CACRF,QAAS,2DADD,CAERC,WAAY,CAAA,CAFJ,CAGRE,OAAQ,CACNC,YAAa,OADP,CAHA,CAL2D,CAYrEC,SAAU,CACRL,QAAS,gDADD;AAERC,WAAY,CAAA,CAFJ,CAGRE,OAAQ,CACNJ,QAAS,CACPC,QAAS,mBADF,CAEPC,WAAY,CAAA,CAFL,CADH,CAKNG,YAAa,OALP,CAHA,CAZ2D,CAuBrEE,OAAQ,CACNN,QAAS,oCADH,CAENO,MAAO,SAFD,CAvB6D,CA2BrEH,YAAa,aA3BwD,CAAjC,CA6BtCZ,OAAA,CAsCCC,KAtCcI,CAAAA,SAAUW,CAAAA,YAAhB,CAA6B,QAA7B,CAAuC,SAAvC,CAAkD,CACzD,iBAAkB,CAChBR,QAAS,SADO,CAEhBC,WAAY,CAAA,CAFI,CAGhBM,MAAO,SAHS,CADuC,CAMzDE,WAAY,CAEVT,QAAS,sDAFC,CAGVU,OAAQ,CAAA,CAHE,CAIVT,WAAY,CAAA,CAJF,CAKVE,OAAQ,CACNQ,OAAQ,CACNX,QAAS,0CADH,CAENC,WAAY,CAAA,CAFN,CADF,CAKNF,QAASP,MAAOO,CAAAA,OALV;AAMNG,SAAUV,MAAOU,CAAAA,QANX,CAONG,SAAUb,MAAOa,CAAAA,QAPX,CAQNO,QAAS,oBARH,CASNC,OAAQ,iDATF,CAUNP,OAAQd,MAAOc,CAAAA,MAVT,CAWNQ,SAAU,gGAXJ,CAYNV,YAAaZ,MAAOY,CAAAA,WAZd,CALE,CAN6C,CAAlD,CAsCRX,MAXKI,CAAAA,SAAUW,CAAAA,YAAhB,CAA6B,QAA7B,CAAuC,aAAvC,CAAsD,CACpDC,WAAYjB,MAAOiB,CAAAA,UADiC,CAEpDV,QAASP,MAAOO,CAAAA,OAFoC,CAGpDG,SAAUV,MAAOU,CAAAA,QAHmC,CAIpDG,SAAUb,MAAOa,CAAAA,QAJmC,CAKpDC,OAAQd,MAAOc,CAAAA,MALqC,CAMpD,qBAAsB,CACpBN,QAASR,MAAOY,CAAAA,WADI;AAEpBG,MAAO,aAFa,CAN8B,CAAtD,CAUGf,MAAA,CAAA,GAAcW,CAAAA,MAAd,CAAqB,YAArB,CAVH,CA5DmB,CAdvBY,MAAOC,CAAAA,cAAP,CAAsBzB,OAAtB,CAA+B,YAA/B,CAA6C,CAC3C0B,MAAO,CAAA,CADoC,CAA7C,CAGA1B,QAAQK,CAAAA,OAAR,CAAkBJ,eAElB,KAAIG,QAEJuB,QAA+B,CAACC,GAAD,CAAM,CAAE,MAAOA,IAAA,EAAOA,GAAIC,CAAAA,UAAX,CAAwBD,GAAxB,CAA8B,CAAEvB,QAASuB,GAAX,CAAvC,CAFvB,CAAuB9B,OAAA,CAAQ,2CAAR,CAAvB,CAKdG,gBAAO6B,CAAAA,WAAP,CAAqB,QACrB7B,gBAAO8B,CAAAA,OAAP,CAAiB,EAdqF;\",\n\"sources\":[\"node_modules/refractor/lang/parser.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$refractor$lang$parser\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = parser;\\n\\nvar _markup = _interopRequireDefault(require(\\\"./markup.js\\\"));\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n// @ts-nocheck\\nparser.displayName = 'parser';\\nparser.aliases = [];\\n/** @type {import('../core.js').Syntax} */\\n\\nfunction parser(Prism) {\\n  Prism.register(_markup.default);\\n\\n  (function (Prism) {\\n    var parser = Prism.languages.parser = Prism.languages.extend('markup', {\\n      keyword: {\\n        pattern: /(^|[^^])(?:\\\\^(?:case|eval|for|if|switch|throw)\\\\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\\\\b)/,\\n        lookbehind: true\\n      },\\n      variable: {\\n        pattern: /(^|[^^])\\\\B\\\\$(?:\\\\w+|(?=[.{]))(?:(?:\\\\.|::?)\\\\w+)*(?:\\\\.|::?)?/,\\n        lookbehind: true,\\n        inside: {\\n          punctuation: /\\\\.|:+/\\n        }\\n      },\\n      function: {\\n        pattern: /(^|[^^])\\\\B[@^]\\\\w+(?:(?:\\\\.|::?)\\\\w+)*(?:\\\\.|::?)?/,\\n        lookbehind: true,\\n        inside: {\\n          keyword: {\\n            pattern: /(^@)(?:GET_|SET_)/,\\n            lookbehind: true\\n          },\\n          punctuation: /\\\\.|:+/\\n        }\\n      },\\n      escape: {\\n        pattern: /\\\\^(?:[$^;@()\\\\[\\\\]{}\\\"':]|#[a-f\\\\d]*)/i,\\n        alias: 'builtin'\\n      },\\n      punctuation: /[\\\\[\\\\](){};]/\\n    });\\n    parser = Prism.languages.insertBefore('parser', 'keyword', {\\n      'parser-comment': {\\n        pattern: /(\\\\s)#.*/,\\n        lookbehind: true,\\n        alias: 'comment'\\n      },\\n      expression: {\\n        // Allow for 3 levels of depth\\n        pattern: /(^|[^^])\\\\((?:[^()]|\\\\((?:[^()]|\\\\((?:[^()])*\\\\))*\\\\))*\\\\)/,\\n        greedy: true,\\n        lookbehind: true,\\n        inside: {\\n          string: {\\n            pattern: /(^|[^^])([\\\"'])(?:(?!\\\\2)[^^]|\\\\^[\\\\s\\\\S])*\\\\2/,\\n            lookbehind: true\\n          },\\n          keyword: parser.keyword,\\n          variable: parser.variable,\\n          function: parser.function,\\n          boolean: /\\\\b(?:false|true)\\\\b/,\\n          number: /\\\\b(?:0x[a-f\\\\d]+|\\\\d+(?:\\\\.\\\\d*)?(?:e[+-]?\\\\d+)?)\\\\b/i,\\n          escape: parser.escape,\\n          operator: /[~+*\\\\/\\\\\\\\%]|!(?:\\\\|\\\\|?|=)?|&&?|\\\\|\\\\|?|==|<[<=]?|>[>=]?|-[fd]?|\\\\b(?:def|eq|ge|gt|in|is|le|lt|ne)\\\\b/,\\n          punctuation: parser.punctuation\\n        }\\n      }\\n    });\\n    Prism.languages.insertBefore('inside', 'punctuation', {\\n      expression: parser.expression,\\n      keyword: parser.keyword,\\n      variable: parser.variable,\\n      function: parser.function,\\n      escape: parser.escape,\\n      'parser-punctuation': {\\n        pattern: parser.punctuation,\\n        alias: 'punctuation'\\n      }\\n    }, parser['tag'].inside['attr-value']);\\n  })(Prism);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"parser\",\"Prism\",\"register\",\"_markup\",\"default\",\"languages\",\"extend\",\"keyword\",\"pattern\",\"lookbehind\",\"variable\",\"inside\",\"punctuation\",\"function\",\"escape\",\"alias\",\"insertBefore\",\"expression\",\"greedy\",\"string\",\"boolean\",\"number\",\"operator\",\"Object\",\"defineProperty\",\"value\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"displayName\",\"aliases\"]\n}\n"]