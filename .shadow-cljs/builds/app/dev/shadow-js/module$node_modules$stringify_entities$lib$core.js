["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/stringify-entities/lib/core.js"],"~:js","shadow$provide.module$node_modules$stringify_entities$lib$core=function(global,require,module,exports){function charactersToExpression(subset){const groups=[];let index=-1;for(;++index<subset.length;)groups.push(subset[index].replace(/[|\\\\{}()[\\]^$+*?.]/g,\"\\\\$\\x26\"));return new RegExp(\"(?:\"+groups.join(\"|\")+\")\",\"g\")}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.core=function(value,options){function basic(character,index,all){return options.format(character.charCodeAt(0),all.charCodeAt(index+\n1),options)}value=value.replace(options.subset?charactersToExpression(options.subset):/[\"&'<>`]/g,basic);return options.subset||options.escapeOnly?value:value.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,function(pair,index,all){return options.format(1024*(pair.charCodeAt(0)-55296)+pair.charCodeAt(1)-56320+65536,all.charCodeAt(index+2),options)}).replace(/[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g,basic)}}","~:source","shadow$provide[\"module$node_modules$stringify_entities$lib$core\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.core = core;\n\n/**\n * @typedef CoreOptions\n * @property {Array<string>} [subset=[]]\n *   Whether to only escape the given subset of characters.\n * @property {boolean} [escapeOnly=false]\n *   Whether to only escape possibly dangerous characters.\n *   Those characters are `\"`, `&`, `'`, `<`, `>`, and `` ` ``.\n *\n * @typedef FormatOptions\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\n *   Format strategy.\n *\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\n */\n\n/**\n * Encode certain characters in `value`.\n *\n * @param {string} value\n * @param {CoreWithFormatOptions} options\n * @returns {string}\n */\nfunction core(value, options) {\n  value = value.replace(options.subset ? charactersToExpression(options.subset) : /[\"&'<>`]/g, basic);\n\n  if (options.subset || options.escapeOnly) {\n    return value;\n  }\n\n  return value // Surrogate pairs.\n  .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, surrogate) // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\n  // non-ASCII ones).\n  .replace( // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n  /[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g, basic);\n  /**\n   * @param {string} pair\n   * @param {number} index\n   * @param {string} all\n   */\n\n  function surrogate(pair, index, all) {\n    return options.format((pair.charCodeAt(0) - 0xd800) * 0x400 + pair.charCodeAt(1) - 0xdc00 + 0x10000, all.charCodeAt(index + 2), options);\n  }\n  /**\n   * @param {string} character\n   * @param {number} index\n   * @param {string} all\n   */\n\n\n  function basic(character, index, all) {\n    return options.format(character.charCodeAt(0), all.charCodeAt(index + 1), options);\n  }\n}\n/**\n * @param {Array<string>} subset\n * @returns {RegExp}\n */\n\n\nfunction charactersToExpression(subset) {\n  /** @type {Array<string>} */\n  const groups = [];\n  let index = -1;\n\n  while (++index < subset.length) {\n    groups.push(subset[index].replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&'));\n  }\n\n  return new RegExp('(?:' + groups.join('|') + ')', 'g');\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["__esModule","value","core"]],"~:compiled-at",1676686799589,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$stringify_entities$lib$core.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,+CAAA,CAAoE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAoE5GC,QAASA,uBAAsB,CAACC,MAAD,CAAS,CAEtC,MAAMC,OAAS,EACf,KAAIC,MAAQ,CAAC,CAEb,KAAA,CAAO,EAAEA,KAAT,CAAiBF,MAAOG,CAAAA,MAAxB,CAAA,CACEF,MAAOG,CAAAA,IAAP,CAAYJ,MAAA,CAAOE,KAAP,CAAcG,CAAAA,OAAd,CAAsB,qBAAtB,CAA6C,SAA7C,CAAZ,CAGF,OAAO,KAAIC,MAAJ,CAAW,KAAX,CAAmBL,MAAOM,CAAAA,IAAP,CAAY,GAAZ,CAAnB,CAAsC,GAAtC,CAA2C,GAA3C,CAT+B,CAjExCC,MAAOC,CAAAA,cAAP,CAAsBX,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CY,MAAO,CAAA,CADoC,CAA7C,CAGAZ,QAAQa,CAAAA,IAAR,CAwBAA,QAAa,CAACD,KAAD,CAAQE,OAAR,CAAiB,CA4B5BC,QAASA,MAAK,CAACC,SAAD,CAAYZ,KAAZ,CAAmBa,GAAnB,CAAwB,CACpC,MAAOH,QAAQI,CAAAA,MAAR,CAAeF,SAAUG,CAAAA,UAAV,CAAqB,CAArB,CAAf,CAAwCF,GAAIE,CAAAA,UAAJ,CAAef,KAAf;AAAuB,CAAvB,CAAxC,CAAmEU,OAAnE,CAD6B,CA3BtCF,KAAA,CAAQA,KAAML,CAAAA,OAAN,CAAcO,OAAQZ,CAAAA,MAAR,CAAiBD,sBAAA,CAAuBa,OAAQZ,CAAAA,MAA/B,CAAjB,CAA0D,WAAxE,CAAqFa,KAArF,CAER,OAAID,QAAQZ,CAAAA,MAAZ,EAAsBY,OAAQM,CAAAA,UAA9B,CACSR,KADT,CAIOA,KACNL,CAAAA,OADM,CACE,iCADF,CAWPc,QAAkB,CAACC,IAAD,CAAOlB,KAAP,CAAca,GAAd,CAAmB,CACnC,MAAOH,QAAQI,CAAAA,MAAR,CAA+C,IAA/C,EAAgBI,IAAKH,CAAAA,UAAL,CAAgB,CAAhB,CAAhB,CAAqC,KAArC,EAAuDG,IAAKH,CAAAA,UAAL,CAAgB,CAAhB,CAAvD,CAA4E,KAA5E,CAAqF,KAArF,CAA8FF,GAAIE,CAAAA,UAAJ,CAAef,KAAf,CAAuB,CAAvB,CAA9F,CAAyHU,OAAzH,CAD4B,CAX9B,CAGNP,CAAAA,OAHM,CAIP,4DAJO,CAIuDQ,KAJvD,CAPqB,CA9B8E;\",\n\"sources\":[\"node_modules/stringify-entities/lib/core.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$stringify_entities$lib$core\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.core = core;\\n\\n/**\\n * @typedef CoreOptions\\n * @property {Array<string>} [subset=[]]\\n *   Whether to only escape the given subset of characters.\\n * @property {boolean} [escapeOnly=false]\\n *   Whether to only escape possibly dangerous characters.\\n *   Those characters are `\\\"`, `&`, `'`, `<`, `>`, and `` ` ``.\\n *\\n * @typedef FormatOptions\\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\\n *   Format strategy.\\n *\\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\\n */\\n\\n/**\\n * Encode certain characters in `value`.\\n *\\n * @param {string} value\\n * @param {CoreWithFormatOptions} options\\n * @returns {string}\\n */\\nfunction core(value, options) {\\n  value = value.replace(options.subset ? charactersToExpression(options.subset) : /[\\\"&'<>`]/g, basic);\\n\\n  if (options.subset || options.escapeOnly) {\\n    return value;\\n  }\\n\\n  return value // Surrogate pairs.\\n  .replace(/[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]/g, surrogate) // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\\n  // non-ASCII ones).\\n  .replace( // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\\n  /[\\\\x01-\\\\t\\\\v\\\\f\\\\x0E-\\\\x1F\\\\x7F\\\\x81\\\\x8D\\\\x8F\\\\x90\\\\x9D\\\\xA0-\\\\uFFFF]/g, basic);\\n  /**\\n   * @param {string} pair\\n   * @param {number} index\\n   * @param {string} all\\n   */\\n\\n  function surrogate(pair, index, all) {\\n    return options.format((pair.charCodeAt(0) - 0xd800) * 0x400 + pair.charCodeAt(1) - 0xdc00 + 0x10000, all.charCodeAt(index + 2), options);\\n  }\\n  /**\\n   * @param {string} character\\n   * @param {number} index\\n   * @param {string} all\\n   */\\n\\n\\n  function basic(character, index, all) {\\n    return options.format(character.charCodeAt(0), all.charCodeAt(index + 1), options);\\n  }\\n}\\n/**\\n * @param {Array<string>} subset\\n * @returns {RegExp}\\n */\\n\\n\\nfunction charactersToExpression(subset) {\\n  /** @type {Array<string>} */\\n  const groups = [];\\n  let index = -1;\\n\\n  while (++index < subset.length) {\\n    groups.push(subset[index].replace(/[|\\\\\\\\{}()[\\\\]^$+*?.]/g, '\\\\\\\\$&'));\\n  }\\n\\n  return new RegExp('(?:' + groups.join('|') + ')', 'g');\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"charactersToExpression\",\"subset\",\"groups\",\"index\",\"length\",\"push\",\"replace\",\"RegExp\",\"join\",\"Object\",\"defineProperty\",\"value\",\"core\",\"options\",\"basic\",\"character\",\"all\",\"format\",\"charCodeAt\",\"escapeOnly\",\"surrogate\",\"pair\"]\n}\n"]